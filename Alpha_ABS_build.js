/*
 * License
 * Creative Commons 4.0 Attribution, Share Alike, Non-Commercial
 * <https://creativecommons.org/licenses/by-nc-sa/4.0/>
 *
 * Copyright (c) 2021 Vladimir Skrypnikov (Pheonix KageDesu)
 * <http://kdworkshop.net/>
 *
 */

//=============================================================================
// Alpha_ABS
//=============================================================================

/*:
 * @author Pheonix KageDesu
 * @plugindesc (1232)[BASIC] 实时战斗系统
 * @target MV
 * 
 * @help
 * 
 * 重要！此插件为非商用的试用版, 不包含一些高级功能
 * 请去下方网址购买正版使用。如果看不懂英文可以联系
 * 中文区发布者：RyanYe(QQ/微信:452901928,QQ群:325574041)
 *
 * 中文版购买流程：
 * 1,付费给RyanYe(微信or支付宝),并注明开发者姓名和Email
 * 2,RyanYe会发邮件和钱给作者Pheonix KageDesu
 * 3,作者收到邮件和钱后会发送License(用于商业用途的证书)和插件文件
 * 4,购买后无法退款，请充分体验试用版和DEMO后再购买正版和证书
 * 5,无证书则无法上架商用，请勿使用试用版于任何商业用途
 * 
 * Web Page: 
 * https://kdworkshop.net/plugins/alpha-abs/
 * Wiki Page: 
 * https://github.com/KageDesu/Alpha-ABS/wiki
 * Patreon Page: 
 * https://www.patreon.com/KageDesu
 * YouTube Channel:
 * https://www.youtube.com/channel/UCA3R61ojF5vp5tGwJ1YqdgQ?
 * 
 * 感谢每一位购买正版的开发者!!!
 * 
 * 特别致谢:
 * 
 * 插件推广:
 *  - Carlos Ferreira
 * 
 * 插件合作方:
 *  - Fiquei
 *  - RyanYe(Chinese area distributor)
 *
 * 插件支持:
 *  - Rick Aston
 *  - Gothicvoid
 *  - Guillaume Rossinot
 *  - Driftwood Gaming
 *  - General Destructo
 *  - Alfred Tay
 *  - MG Blackbird
 *  - Lee Appleby
 * 
 * 插件测试:
 *  - SMO_Valadorn
 *  - Zee
 *  - Ryan Ye
 * 
 * [!] 使用前请先仔细阅读wiki
 * https://github.com/KageDesu/Alpha-ABS/wiki
 * 注意，插件需要以下路径中的资源：（不要删除）
 *   audio/se/Equip2
 *   audio/se/Coin
 *   audio/se/Magic3
 *   img/animations/StateDown1
 * === === === === === === === === === === === === === === === === ===
 * 
 * @requiredAssets audio/se/Equip2
 * @requiredAssets audio/se/Coin
 * @requiredAssets audio/se/Magic3
 * @requiredAssets img/animations/StateDown1
 * 
 * @param Alpha ABS
 *
@param spacer|interface @text‏‏‎ ‎@desc ===============================================
 *
 * @param Interface
 * @text 界面设置
 * @default
 *
 * @param UI_Visible
 * @text 是否在游戏中显示UI界面
 * @parent Interface
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * 
 * @param NewDescriptionStyle
 * @text 是否使用技能扩展信息？
 * @parent Interface
 * @type boolean
 * @default true
 * @desc [PRO-专业版功能] wiki/Skill-Information-Window-JSON-Configuration
 * 
 * @param UI_PlayerDamageColor
 * @parent Interface
 * @text 角色伤害数字外发光颜色
 * @type string
 * @default #FF0000
 * @desc 输入十六进制数字，或者留空表示无外发光
 * 
 * @param AllowBloodSplatter
 * @text 角色HP过低时是否显示屏幕红色警告效果
 * @parent Interface
 * @type boolean
 * @default true
 * @desc 角色HP过低时屏幕显示警告闪烁效果/图片
 * 
 * @param BS_Picture
 * @parent AllowBloodSplatter
 * @text 血量过低闪烁效果图片
 * @type file
 * @dir img/pictures/
 * @require 1
 * @desc 可以选择不设置此选项
 * 
 * @param BS_Color
 * @parent AllowBloodSplatter
 * @text 血量过低时闪烁颜色值
 * @type string
 * @default #F98822
 * @desc 输入十六进制数字，或者留空表示不使用此功能
 * 
 * @param BS_Opacity
 * @parent AllowBloodSplatter
 * @text 血量过低时屏幕闪烁透明度
 * @type number
 * @min 0
 * @max 255
 * @default 124
 * @desc 输入0到255的数字
 * 
 * @param BS_HpRate
 * @parent AllowBloodSplatter
 * @text 角色血量过低比例
 * @type number
 * @min 1
 * @max 99
 * @default 15
 * @desc 血量达到百分之多少时显示血量警告效果
 * 
 * @param Show Mini HP Bars
 * @text 是否显示敌人头顶血条
 * @parent Interface
 * @type combo
 * @option Never
 * @option Always
 * @option Only for selected
 * @default Never
 * @desc [PRO-专业版功能] 从上到下分别是(永远不显示,永远显示,只显示选择的)
 * 
 * @param ShowPlayerPopUp
 * @text 角色头像上显示飘字信息（伤害、回复、升级等）
 * @parent Interface
 * @type boolean
 * @default true
 * @desc 是否在角色头像上显示飘字信息
 * 
 * @param UseNewDamagePopUp
 * @text 是否使用新版伤害数字的飘字效果
 * @parent Interface
 * @type boolean
 * @default true
 * @desc [PRO-专业版功能] 新版伤害数字的飘字效果
 *
 * @param ShowItemNotifyOnNONABS
 * @text 是否在非战斗地图上显示屏幕右侧的提示文字信息
 * @parent Interface
 * @type boolean
 * @default true
 * @desc 如果想进一步修改/禁用此功能可以去修改ItemsNotifySettings.json文件
 * 
 * @param UIE_Buttons
 * @text 在UI界面显示按钮
 * @parent Interface
 * @type boolean
 * @default true
 * @desc 是否在UI界面显示按钮？
 * 
 * @param Preview Targets
 * @text 鼠标悬浮时显示目标UI界面提示
 * @parent Interface
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 鼠标悬浮时是否预览目标UI界面提示？
 * 
 * @param Preview Targets When Selected
 * @text 鼠标点击时显示目标UI界面提示
 * @parent Preview Targets
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 鼠标点击时是否预览目标UI界面提示？
 * 
 * @param Preview Extra Targets
 * @text 鼠标悬浮事件时是否预览事件信息？
 * @parent Interface
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 鼠标悬浮事件时是否预览事件信息？(带有<ExtraInfo:example>注释的)
 * 
 * @param spacer|mapWindows @text‏‏‎ ‎@desc ===============================================
 * 
 * @param MapWindows
 * @text 地图场景可呼出的界面
 * 
 * @param MapInventorySystem
 * @text 背包界面
 * @default
 * @parent MapWindows
 * 
 * @param MapInventory
 * @text 是否启用背包界面？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc [PRO-专业版功能] 是否启用背包功能？（快捷键：I）
 * 
 * @param MapInventoryOnNonABS
 * @text 是否在非战斗地图启用背包界面？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 是否在非战斗地图启用背包界面？
 * 
 * @param ShowEquipedItemsInInventory
 * @text 背包中是否显示已穿戴的装备？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 背包中是否显示已穿戴的装备？
 * 
 * @param MapInventoryDrag
 * @text 背包界面是否可以被拖动？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 是否允许鼠标拖动背包界面？
 * 
 * @param MapInventorySortEquip
 * @text 背包内是否进行装备排序？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 已穿戴的装备是否排序在前？
 * 
 * @param MapInventorySortItems
 * @text 背包内是否进行物品排序？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 可消耗的物品是否排序在前？
 * 
 * @param MapInventoryUseSlider
 * @text 是否启用拆散物品堆叠功能？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 如果开启那么就可以把比如说10个物品拆成7个和3个
 * 
 * @param MapInventoryWeightSystem
 * @text 是否启用负重系统？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 开启后玩家背包如果超过负重，将无法获得新物品
 * 
 * @param wSystemVariableId
 * @parent MapInventoryWeightSystem
 * @text 用于存储总负重上限的变量ID
 * @type variable
 * @default 1
 * @desc 将总负重上限存储在这个变量ID中
 * 
 * @param MapInventoryPauseGame
 * @parent MapInventorySystem
 * @text 游戏暂停
 * @type boolean
 * @default false
 * @desc 背包打开时游戏是否暂停？
 * 
 * @param AllowEquipsStats
 * @parent MapInventorySystem
 * @text 是否显示装备详细信息
 * @type boolean
 * @default true
 * @desc 开启后用鼠标滚轮可查看装备的详细信息
 * 
 * @param ShowFullEquipedStats
 * @parent MapInventorySystem
 * @parent AllowEquipsStats
 * @text 已穿戴的装备是否显示装备信息？
 * @type boolean
 * @default false
 * @desc 如果隐藏的话，已穿戴的装备将只显示装备本身加持的属性（不显示玩家属性）
 * 
 * 
 * @param MapSkillWindowSystem
 * @text 技能窗口
 * @default
 * @parent MapWindows
 * 
 * @param MapSkillWindow
 * @text 是否启用技能界面？
 * @parent MapSkillWindowSystem
 * @type boolean
 * @default true
 * @desc [PRO-专业版功能] 是否启用技能界面？（快捷键：O）
 * 
 * @param MapSkillWindowDrag
 * @text 技能界面是否允许拖拽？
 * @parent MapSkillWindowSystem
 * @type boolean
 * @default true
 * @desc 技能界面是否允许鼠标拖拽？
 * 
 * @param AllowAutoRefreshUsableSkills
 * @text 是否在技能界面内实时刷新技能状态？
 * @parent MapSkillWindowSystem
 * @type boolean
 * @default true
 * @desc 如果技能太多的话可能会有轻微卡顿情况
 * 
 * @param MapSkillWindowParty
 * @text 技能界面是否允许切换角色？
 * @parent MapSkillWindowSystem
 * @type boolean
 * @default true
 * @desc 技能界面除了显示队长的技能，还可以切换队员的技能
 * 
 * @param UIE_ButtonsCustom
 * @text 自定义按钮名称
 * @parent UIE_Buttons
 * @type string
 * @default
 * @desc 按钮名称需要与json文件中同步（半角逗号分割）
 *
 * @param AllowPartySelect
 * @text 使用物品时是否可以给队员使用？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 如果开启则可以给队员使用物品
 * 
 * @param AllowAutoRefreshUsable
 * @text 开启背包物品自动刷新？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 只在非战斗地图有效，如果物品数量很多则会有轻微卡顿
 * 
 * @param AllowStoreInChest
 * @text 是否可将物品放入箱子内？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 开启后玩家可将物品存放在箱子内（类似暗黑）
 * 
 * @param AllowRareItemSystem
 * @text 是否使用物品的品质功能？
 * @parent MapInventorySystem
 * @type boolean
 * @default true
 * @desc 使用后可以在物品标签内输入物品的品质标签
 * 
 * @param wSystemAutoStateId
 * @text 背包超重后角色将获得一个状态
 * @parent MapInventoryWeightSystem
 * @type state
 * @default 0
 * @desc 超重后角色自动获得状态（不超后再解除）
 * 
 * @param wSystemAllowSlowDown
 * @parent MapInventoryWeightSystem
 * @text 超重后角色被减速
 * @type boolean
 * @default false
 * @desc 如果开启，那么角色将会在背包超重后减速
 * 
 * @param UseImageIconsInWindows
 * @parent MapInventorySystem
 * @text 在界面中显示图标extra image图片
 * @type boolean
 * @default true
 * @desc 在默认界面中使用extra image图片作为图标图片
 * 
 * @param GoldItem
 * @parent MapInventorySystem
 * @text 金币物品化
 * @type item
 * @default 0
 * @desc 使用某物品ID作为金币显示，如果填0表示不用此功能
 * 
 * @param UseCustomCellsSize
 * @parent MapInventorySystem
 * @text 背包是否使用自定义网格大小
 * @type boolean
 * @default false
 * @desc 如果开启则可以自定义背包中的网格大小
 * 
 * @param CustomCellSettings:struct
 * @parent UseCustomCellsSize
 * @text 自定义背包网格设置
 * @type struct<LCustomCell>
 * @default {"iconSize:i":"30","columnsPerPage:i":"5","rowsPerPage:i":"5","iconMode:i":"1"}
 * @desc columnsPerPage是有多少纵列，rowsPerPage是有多少横行
 * 
 * @param MapStatusWindow
 * @text 是否启用角色状态窗口？
 * @parent MapWindows
 * @type boolean
 * @default true
 * @desc [PRO-专业版功能] 是否启用角色状态窗口？（快捷键：P）
 * 
@param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param Enemies
 * @text 怪物
 * @default
 *
 * @param Enemy Dead Switch
 * @text 怪物死亡控制(独立开关)
 * @parent Enemies
 * @type combo
 * @option A
 * @option B
 * @option C
 * @option D
 * @default B
 * @desc 怪物死亡时，其对应事件的独立开关哪一个会被打开？
 *
 * @param Auto loot
 * @text 是否自动获得掉落奖励
 * @desc 开启后直接获得掉落奖励（否则要去捡尸体）
 * @parent Enemies
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * 
 * @param Visual loot
 * @text 可视化掉落物
 * @desc 开启后，怪物的掉落将已宝箱掉落的形式出现
 * @parent Enemies
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 * @param ShowEnemyLevel
 * @text 显示怪物等级
 * @desc 选中怪物后是否显示怪物等级
 * @parent Enemies
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * 
 * @param ShowEnemyHPInPercent
 * @text 是否以百分比%的形式显示怪物当前血量
 * @parent Enemies
 * @type boolean
 * @default true
 * @desc 在怪物血槽位置上显示剩余血量的百分比%值
 *
 * @param BarrierPiercedDamage
 * @text 击破怪物护盾的那一次攻击，过量部分的伤害是否会伤害怪物
 * @parent Enemies
 * @type boolean
 * @default false
 * @desc 比如怪物护盾还有100，此时玩家攻击是110，那么多出来的10点是否计入伤害？
 *
 * @param Enemy Spawn Map Id
 * @text 怪物事件存储地图ID
 * @desc 用于产生怪物的地图ID（怪物必须事先以事件的形式存在某地图上）
 * @parent Enemies
 * @type number
 * @default 0
 * @min 0
 * 
 * @param Encounters Spawn Radius
 * @text 遭遇战模式怪物出现半径
 * @desc 如果某战斗地图未定义遭遇战区域ID，那么怪物在遭遇战中将距离玩家几格出现
 * @parent Enemies
 * @type number
 * @default 6
 * @min 2
 * 
 * @param allowSpawnAboveEvents:b
 * @text 是否允许在事件上面生成事件（例如怪物）
 * @desc 使用插件指令或者脚本生成怪物时，是否允许生成在其他事件上
 * @parent Enemies
 * @type boolean
 * @default true
 * 
@param spacer|defAnimations @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * @param Animations
 * @text 动画设置
 * @default
 *
 * @param Revive Animation
 * @text 角色复活动画
 * @parent Animations
 * @type animation
 * @desc 复活动画ID，0=用默认的45动画，-1才表示不用动画
 * @default 45
 * 
 * @param Teleport Animation
 * @text 角色传送动画
 * @parent Animations
 * @type animation
 * @desc 传送动画ID，0=用默认的51动画，-1才表示不用动画
 * @default 51
 *
 * @param Cast Animation
 * @text 角色放技能动画
 * @parent Animations
 * @type animation
 * @desc 技能释放动画，0表示用技能配置的动画，否则表示统一动画ID
 * @default 0
 *
 * @param Cast Animation SE
 * @text 角色放技能音效
 * @parent Cast Animation
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 是否使用默认的技能释放音效？
 *
 * @param Level Up Animation
 * @text 角色升级动画
 * @parent Animations
 * @type animation
 * @desc 升级动画ID，0=用默认的49动画，-1才表示不用动画
 * @default 49
 *
 * @param Encounter Animation
 * @text 遭遇战怪物出现动画
 * @desc 在怪物在遭遇战出现时播放的动画
 * @parent Animations
 * @type animation
 * @default 45
 *
@param spacer|altInput @text‏‏‎ ‎@desc ===============================================
 * 
 * @param Alternative Input
 * @text 自定义操作模式
 * @default
 * 
 * @param Alter Move
 * @text 角色是否使用自定义移动方式？
 * @parent Alternative Input
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 如果启用的话则会按照data/AABS/KeyBinding.json, AlterMove下的指令进行上下左右移动
 * 
 * @param Move By Mouse
 * @text 鼠标点击地面是否算移动？
 * @parent Alternative Input
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * 
 * @param Attack By Mouse
 * @text 鼠标点击地面是否算普通攻击？
 * @parent Alternative Input
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 需要玩家使用<noTarget>标签的武器或者技能
 * 
 * @param spacer|deathSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param PlayerDeathSettings
 * @text 角色死亡规则设置
 * @default
 * 
 * @param Game Over Map ID
 * @text 角色死亡后被传送的地图ID
 * @desc 角色死亡后被传送到哪个地图？(0=执行Game Over Common Event, 其他数字=传送地图)
 * @parent PlayerDeathSettings
 * @type number
 * @min 0
 * @default 0
 *
 * @param Game Over Map Direction
 * @text 角色传送后朝向
 * @desc 四个选项分别是：上、左、右、下
 * @parent Game Over Map ID
 * @type select
 * @default down
 * @option top
 * @option left
 * @option right
 * @option down
 * 
 * @param Game Over Map Position
 * @text 角色死亡后传送地图的位置坐标XY
 * @desc 角色死亡后传送地图的位置坐标XY
 * @parent Game Over Map ID
 * @type struct<UIEPosition>
 * @default {"X":"0","Y":"0"}
 * 
 * @param Game Over Common Event
 * @text 游戏结束公共事件ID
 * @parent Game Over Map ID
 * @type common_event
 * @default 0
 * @desc 如果Game Over Map ID为0，那么死亡后会执行这个公共事件，0为不执行
 * 
 * @param After Death Common Event
 * @text 主角死亡后执行公共事件ID
 * @parent Game Over Map ID
 * @type common_event
 * @default 0
 * @desc 如果Game Over Map ID不为0，那么死亡后会先传送地图再执行这个ID的公共事件，0为不执行
 * 
 * @param Party Member Death CE
 * @text 队员死亡后的公共事件ID
 * @parent PlayerDeathSettings
 * @type common_event
 * @default 0
 * @desc 队员在战斗中死亡时将会执行这个公共事件
 * 
 * 
 * 
 * @param spacer|performance @text‏‏‎ ‎@desc ===============================================
 * 
 * @param Performance
 * @text 性能相关
 * @default
 * 
 * @param Use_AStar
 * @text 是否使用A星寻路
 * @parent Performance
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * 
 * @param AI Think Interval
 * @text 怪物AI思考频率
 * @desc 寻路计算频率（毫秒），越频繁则占用游戏资源越高
 * @parent Performance
 * @type number
 * @default 300
 * @min 100
 * 
 * @param SimpleSkillPanel
 * @text 是否启用超简化的技能面板
 * @parent Performance
 * @type boolean
 * @default false
 * @desc 在一些低端PC或手机上推荐使用
 * 
 * 
 * 
@param spacer|extra @text‏‏‎ ‎@desc ===============================================
* @param Other Features
* @text 其他功能
*
* @param UseDiagonalMovement
 * @text 是否启用斜向移动？
 * @parent Other Features
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc Moving in 8 directions. Experimental feature
* 
* @param Gamepad Support
 * @text 游戏手柄
 * @parent Other Features
 * @type boolean
 * @default true
 * @desc 是否支持游戏手柄操作？（另一种操作方式）
*
 * @param mapScrolling:s
 * @text 地图滚动功能
 * @parent Other Features
 * @type struct<LMapScrolSettings>
 * @default {"isEnabledOnAbs:b":"true","isEnabledOnNonAbs:b":"true","screenSize:int":"10","scrollSpeed:int":"5","scrollDelay:int":"30"}
 * @desc [PRO-专业版功能] 鼠标放到屏幕边缘时镜头会被移动(类似星际魔兽英雄无敌之类的游戏)
 * 
@param spacer|party @text‏‏‎ ‎@desc ===============================================

 * @param partyHeader
 * @text 队伍和召唤
 * 
 * @param Keep Summon Unit When Transfer?
 * @text 召唤宝宝换地图时保留
 * @parent partyHeader
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 在不同战斗地图之间传送时是否保留召唤宝宝？
 * 
 * @param Party Members is Selectable
 * @text 是否允许选中队友？
 * @parent partyHeader
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 是否允许玩家选中队友释放各种技能（加血或者buff）
 * 
 * @param Party experience
 * @text 队伍杀怪经验分配规则
 * @parent partyHeader
 * @type combo
 * @option For each member
 * @option For party 
 * @option Share at all
 * @default For each member
 * @desc 从上到下分别是：(谁杀谁得、所有人都得、所有人均分)
 * 
 * @param allowLeaderSwap:b
 * @text 是否启用队长快速切换？
 * @parent partyHeader
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 是否允许玩家在战斗中快速切换队长？(KeyBinding.json文件有快捷键)
 * 
 * @param allowLeaderSwapInBattle:b
 * @text 在战斗状态下是否允许切换队长？
 * @parent allowLeaderSwap:b
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 是否允许玩家在处于战斗状态时直接切换队长？
 * 
 * @param oneLeaderSwapMode:b
 * @text 同时在场的只有单一角色
 * @parent allowLeaderSwap:b
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 地图上始终只有一个角色在场。
 * 切换角色后，其他角色会隐藏起来（选YES）
 * 
 * @param leaderSwapCE:int
 * @text 更换队员时执行的公共事件ID
 * @parent allowLeaderSwap:b
 * @type common_event
 * @default 0
 * @desc 更换队员时执行的公共事件ID

@param spacer|common @text‏‏‎ ‎@desc ===============================================
 *
 * @param Commons Settings
 * @text 通用设置
 * @default
 *
 * 
 * @param Allow Transfrer
 * @text 强行切换地图
 * @desc 战斗中允许强行切换地图 (有一定的兼容性风险)
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 *
 * 
 * @param Solid Regions
 * @text 坚硬物体区域(用于阻挡)
 * @desc 用于标记坚硬物体的区域ID (墙/门, 之类的), 例如: 1,2,3,4
 * @parent Commons Settings
 * @type string
 * @default 0
 * 
 * @param AutoBindItems
 * @text 自动将物品放入技能快捷栏中
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 * @param RandomTPAtStart
 * @text 进入战斗地图时，获得随机的TP值
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 每个角色进入战斗地图时都将获得随机的TP值
 *
 * @param ScreenShakeOnDamage
 * @text 玩家受到伤害时是否摇晃屏幕
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * 
 * @param PostUseSkillTime
 * @text 技能全局CD时间
 * @desc 技能全局CD时间（秒）
 * @parent Commons Settings
 * @type number
 * @default 20
 * @min 0
 *
 * 
 * @param Dashing tilt
 * @text 奔跑时角色是否前倾
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * 
 * @param Jumping tilt
 * @text 跳跃时角色是否前倾
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 * 
 * 
@param spacer|xAnima @text‏‏‎ ‎@desc ===============================================

@param xAnimaHeader
@text XAnima 动画功能系统

@param xAnimations:structA
@parent xAnimaHeader
@text 角色动画列表(角色武器)
@type struct<LAnimaX>[]
@default []
@desc XAnima功能动画列表

@param xAnimaParts:structA
@parent xAnimaHeader
@text 层级动画列表(装备换装)
@type struct<LAnimaXPart>[]
@default []
@desc XAnima 功能动画层级列表

 * @param animaXAltLoader:b
 * @text animaX预加载功能
 * @parent xAnimaHeader
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 如果使用AnimaX后出现了图片闪烁抖动则启用此选项（测试功能）

*/
/*~struct~UIEPosition:
* @param X
* @type number
*
* @param Y
* @type number
*/
/*~struct~LCustomCell:
 * @param iconSize:i
 * @text 格子大小
 * @type number
 * @min 1
 * @default 30
 * @desc 格子大小（像素）
 * 
 * @param columnsPerPage:i
 * @text 一页多少列
 * @type number
 * @min 1
 * @default 5
 * @desc 一页显示多少列
 * 
 * @param rowsPerPage:i
 * @text 一页多少行
 * @type number
 * @min 1
 * @default 5
 * @desc 一页显示多少行
 * 
 * @param iconMode:i
 * @text 图标绘制模式
 * @type select
 * @option Center
 * @value 0
 * @option Stretch
 * @value 1
 * @default 1
 * @desc 0=居中，1=拉伸
 */
/*~struct~LAnimaX:
 * @param id
 * @text ID
 * @default
 * @desc AnimaX动画ID（不能重复，也会成为文件夹名）
 * 
 * @param base:s
 * @text 基础动画
 * @type struct<LAnimaXSet>
 * @default
 * @desc 基础动画套组 (角色移动动画)
 * 
 * @param inBattle:s
 * @text In Battle
 * @type struct<LAnimaXSet>
 * @default
 * @desc 战斗状态动画列表
 * 
 * @param dead:s
 * @text 死亡
 * @type struct<LAnimaXSet>
 * @default
 * @desc 死亡状态动画列表（此处只对怪物有效）
 * 
 * @param actions:structA
 * @text 动作
 * @type struct<LAnimaXAction>[]
 * @default []
 * @desc 动作列表
*/
/*~struct~LAnimaXSet:
 * @param move:s
 * @text 移动
 * @type struct<LAnimaXParameters>
 * @default
 * @desc 移动动画设置
 * 
 * @param idle:s
 * @text 待机动画
 * @type struct<LAnimaXParameters>
 * @default
 * @desc 角色待机动画设定
 * 
 * @param dash:s
 * @text 奔跑
 * @type struct<LAnimaXParameters>
 * @default
 * @desc 奔跑动画设置（非必填）
 * 
 * @param moveToIdleDelay:i
 * @text 待机间隔
 * @type number
 * @default 30
 * @min 0
 * @desc 角色静止后，等待多少帧才算进入待机状态
*/
/*~struct~LAnimaXAction:
 * @param name
 * @text 动画名称
 * @default Action
 * @desc 动作名
 * 
 * @param animation:s
 * @text 动画设置
 * @type struct<LAnimaXParameters>
 * @default
 * @desc 动画设置
*/
/*~struct~LAnimaXParameters:
 * @param isOneDirection:b
 * @text 单方向图
 * @type boolean
 * @default false
 * @desc 动画只包含一个方向 (也就是不区分上下左右方向)
 * 
 * @param frames:i
 * @text 有多少帧
 * @type number
 * @default 3
 * @min 1
 * @desc 动画帧数
 * 
 * @param speed:i
 * @text 播放速度
 * @type number
 * @default 15
 * @min 1
 * @desc 动画播放速度（1帧=1/60秒）
 * 
 * @param expandFirstFrame:i
 * @text 第一帧重复播放次数
 * @type number
 * @default 0
 * @min 0
 * @max 100
 * @desc 第一帧重复播放几次（第一帧会具备一定延迟效果）
 * 
 * @param is8Way:b
 * @text 动画是否支持斜向移动？
 * @type boolean
 * @default false
 * @desc 动画支持斜向移动则需要 _DL, _DR, _UL, _UR 对应的图片资源（左下，右下，左上，右上）
 * 
 * @param dx:int
 * @text X偏移量
 * @type number
 * @min -100
 * @max 100
 * @default 0
 * @desc X轴动画偏移量
 * 
 * @param dy:int
 * @text Y偏移量
 * @min -100
 * @max 100
 * @type number
 * @default 0
 * @desc Y轴动画偏移量
*/
/*~struct~LMapScrolSettings:

@param isEnabledOnAbs:b
@text 在战斗地图是否启用地图滚动？
@type boolean
@default false
@desc 在战斗地图（<ABS>标签）是否启用地图滚动？

@param isEnabledOnNonAbs:b
@text 在非战斗地图是否启用地图滚动？
@type boolean
@default false
@desc 在非战斗地图（无<ABS>标签）是否启用地图滚动？

@param screenSize:int
@text 版边判定区域宽度
@type number
@min 10
@max 50
@default 10
@desc 版边判定区域宽度（用于判定地图滚动，单位像素）

@param scrollSpeed:int
@text 地图滚动速度
@type number
@min 1
@default 5
@desc 地图滚动时的镜头速度

@param scrollDelay:int
@text 地图滚动启动延迟
@type number
@min 0
@default 30
@desc 地图滚动启动延迟（单位帧）

@param resetOnMove:b
@text 镜头是否居中移动角色
@type boolean
@default true
@desc 在镜头滚动时，如果角色移动，镜头是否聚焦角色

@param resetOnBattle:b
@text 镜头是否居中战斗角色
@type boolean
@default true
@desc 在镜头滚动时，如果角色战斗，镜头是否聚焦角色

*/
/*~struct~LAnimaXPart:
 * @param id
 * @text ID
 * @default
 * @desc AnimaX动画ID（不能重复，也会成为文件夹名）
  
 * @param isLowerBodyPart:b
 * @text 下半身半透明？
 * @type boolean
 * @default false
 * @desc 开启后角色在草丛中时下半身将变为半透明
 
 * @param sortingLevel:i
 * @text 排序顺序
 * @type number
 * @default 0
 * @min -100
 * @desc 层级排序顺序
 * 
 * @param dx:int
 * @text 偏移量X
 * @type number
 * @min -100
 * @max 100
 * @default 0
 * @desc 层级偏移量（X坐标）
 * 
 * @param dy:int
 * @text 偏移量Y
 * @min -100
 * @max 100
 * @type number
 * @default 0
 * @desc 层级偏移量（Y坐标）
 *
 * @param layerRule:struct
 * @text 层级设置
 * @type struct<LAnimaXPartDirLevel>
 * @default {"noDir:b":"false","dirD:b":"false","dirL:b":"false","dirR:b":"false","dirU:b":"false","8wayGroup":"","dirDL:b":"false","dirDR:b":"false","dirUR:b":"false","dirUL:b":"false"}
 * @desc 层级方向资源位置
 *
 * @param baseRule:struct
 * @text 基础规则
 * @type struct<LAnimaXPartDefRule>
 * @default {"isHaveDirections:b":"true","isHaveFrames:b":"true"}
 * @desc 默认动画层级设置. 将应用于所有动作

 * @param moveRule:struct
 * @text 移动动画规则
 * @type struct<LAnimaXPartDefRule>
 * @default {"isHaveDirections:b":"true","isHaveFrames:b":"true"}
 * @desc [可选可不选] 应用于角色移动的动画层级设置

 * @param idleRule:struct
 * @text 待机动画规则
 * @type struct<LAnimaXPartDefRule>
 * @default {"isHaveDirections:b":"true","isHaveFrames:b":"true"}
 * @desc [可选可不选] 应用于角色待机的动画层级设置

 * @param actionRules:structA
 * @text 动作动画规则
 * @type struct<LAnimaXPartActionRule>[]
 * @default []
 * @desc [可选可不选] 应用于角色待机的动画层级设置
*/

/*~struct~LAnimaXPartActionRule:

 * @param actionName
 * @text 动作名
 * @default
 * @desc 用于此动画规则的动作名

 * @param fileName
 * @text 额外文件名
 * @default 
 * @desc 留空则使用动作名作为文件名

 * @param enabled:b
 * @text 是否启用？
 * @type boolean
 * @default true
 * @desc 隐藏后，此动画将完全被隐藏（即使做了对应动作）

 * @param actionRule:struct
 * @text 规则
 * @type struct<LAnimaXPartDefRule>
 * @default {"isHaveDirections:b":"true","isHaveFrames:b":"true"}
 * @desc 对当前动作设置层级规则

*/

/*~struct~LAnimaXPartDefRule:

 * @param isHaveDirections:b
 * @text 变换方向？
 * @type boolean
 * @default true
 * @desc 四方向动画层级有对应的动画文件？ _D, _U, _R, _L ?（下，上，右，左）
 
 * @param isHaveFrames:b
 * @text 是否包含多帧动画？
 * @type boolean
 * @default true
 * @desc 如果为否，则所有动画只有一帧，为真则需要与父级动画帧数相同

*/

/*~struct~LAnimaXPartDirLevel:

 * @param noDir:b
 * @text 默认
 * @type boolean
 * @on Below
 * @off Above
 * @default false
 * @desc 无方向的层级精灵是否显示在角色精灵下方？

 * @param dirD:b
 * @text 下 (_D)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝下的层级精灵是否显示在角色精灵下方？

 * @param dirL:b
 * @text 左 (_L)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝左的层级精灵是否显示在角色精灵下方？

 * @param dirR:b
 * @text 右 (_R)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝右的层级精灵是否显示在角色精灵下方？

 * @param dirU:b
 * @text 上 (_U)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝上的层级精灵是否显示在角色精灵下方？

 * @param 8wayGroup
 * @text 斜向设置

 * @param dirDL:b
 * @parent 8wayGroup
 * @text 左下 (_DL)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝左下的层级精灵是否显示在角色精灵下方？

 * @param dirDR:b
 * @parent 8wayGroup
 * @text 右下 (_DR)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝右下的层级精灵是否显示在角色精灵下方？

 * @param dirUR:b
 * @parent 8wayGroup
 * @text 右上 (_UR)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝右上的层级精灵是否显示在角色精灵下方？

 * @param dirUL:b
 * @parent 8wayGroup
 * @text 左上 (_UL)
 * @type boolean
  * @on Below
 * @off Above
 * @default false
 * @desc 朝左上的层级精灵是否显示在角色精灵下方？

*/
//@[CODE STANDARD X1]

/* jshint -W097 */
/* jshint -W117 */

"use strict";

var Imported = Imported || {};
Imported.AlphaABS = true;

var AlphaABS = {};
AlphaABS.Build = 1242;

AlphaABS.LIBS = {};
AlphaABS.jDATA = {};
AlphaABS.G_ALIASES = {};

var AA = AlphaABS; //? FOR 1.3 UI COMPABILITY
var PKD_MI = {}; //? FOR MAP INV COMPABILITY

AlphaABS.register = function (library) {
  this.LIBS[library.name] = library;
};

AlphaABS.isDEV = function () {
  return false;
};

function InfoPrinter() {
  throw new Error('This is a static class');
}

(function () {

  SceneManager._printABSInfo = function () {
    if(KDCore.isMV())
      console.error("Using AlphaABS [Build: " + AlphaABS.Build + " ; on MV  " + Utils.RPGMAKER_VERSION + "]");
    else
      console.error("Using AlphaABS [Build: " + AlphaABS.Build + " ; on MZ  " + Utils.RPGMAKER_VERSION + "]");
  };

  var _SceneManager_onError_ABS = SceneManager.onError;
  SceneManager.onError = function (e) {
    SceneManager._printABSInfo();
    _SceneManager_onError_ABS.call(this, e);
  };

  var _JsonEx_decode = JsonEx._decode;
  JsonEx._decode = function (value, circular, registry) {
    var type = Object.prototype.toString.call(value);
    if (type === '[object Object]' || type === '[object Array]') {
      if (value['@']) {
        var constructor = AlphaABS.LIBS[value['@']] || KDCore[value['@']];
        if (constructor) {
          value = this._resetPrototype(value, constructor.prototype);
          value['@'] = null;
        }
      }
    }
    return _JsonEx_decode.call(this, value, circular, registry);
  };
})();

(function () {

  AA.__TOUTS = [];
  AA.__INTERS = [];
  AA.__INTERS_AI = [];

  AA.setTimeout = function (func, delay) {
    if (func && delay) {

      var timerID = setTimeout(func, delay);
      AA.__TOUTS.push(timerID);
      return timerID;

    } else
      return setTimeout(func, delay);
  };

  AA.clearTimeout = function (timerID) {
    clearTimeout(timerID);
    AA.__TOUTS.delete(timerID);
  };

  AA.setInterval = function (func, delay) {
    if (func && delay) {

      var timerID = setInterval(func, delay);
      AA.__INTERS.push(timerID);
      return timerID;

    } else
      return setInterval(func, delay);
  };

  AA.clearInterval = function (timerID) {
    clearInterval(timerID);
    AA.__INTERS.delete(timerID);
  };

  AA.setIntervalAI = function (func, delay) {
    if (func && delay) {

      var timerID = setInterval(func, delay);
      AA.__INTERS_AI.push(timerID);
      return timerID;

    } else
      return setInterval(func, delay);
  };

  AA.clearIntervalAI = function (timerID) {
    clearInterval(timerID);
    AA.__INTERS_AI.delete(timerID);
  };

  AA.getThreadsCount = function () {
    return AA.__TOUTS.length + AA.__INTERS.length + AA.__INTERS_AI.length;
  };

  AA.clearAllThreads = function () {
    AA.clearUIThreads();
    for (var j = 0; j < AA.__INTERS_AI.length; ++j) {
      clearInterval(AA.__INTERS_AI[j]);
    }
    AA.__INTERS_AI = [];
  };

  AA.clearUIThreads = function () {
    for (var i = 0; i < AA.__TOUTS.length; ++i) {
      clearTimeout(AA.__TOUTS[i]);
    }
    for (var j = 0; j < AA.__INTERS.length; ++j) {
      clearInterval(AA.__INTERS[j]);
    }
    AA.__TOUTS = [];
    AA.__INTERS = [];
  };

})();


// Generated by CoffeeScript 2.5.1
// ==========================================================================
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ KDCore.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
// * LIBRARY WITH MZ AND MZ SUPPORT
//! {OUTER FILE}

//?rev 21.02.21
var KDCore;

KDCore = KDCore || {};

KDCore._fileVersion = '2.4.9.1';

if ((KDCore.Version != null) && KDCore.Version > KDCore._fileVersion) {
  // * ПРОПУСКАЕМ ЗАГРУЗКУ, так как уже загруженна более новая
  console.log('XDev KDCore ' + KDCore._fileVersion + ' skipped by new version');
} else {
  KDCore.Version = KDCore._fileVersion;
  KDCore.LIBS = KDCore.LIBS || {};
  KDCore.register = function(library) {
    return this.LIBS[library.name] = library;
  };
  window.KDCore = KDCore;
  console.warn("XDev KDCore is loaded " + KDCore.Version);
  (function() {
    var BitmapSrc, Color, DevLog, Point, SDK, __TMP_LOGS__, ___Sprite_alias_Move_KDCORE_2, __alias_Bitmap_blt_kdCore, __alias_Bitmap_fillAll, i, l, m, o;
    // * Array Extension
    //------------------------------------------------------------------------------
    Array.prototype.delete = function() {
      var L, a, ax, what;
      what = void 0;
      a = arguments;
      L = a.length;
      ax = void 0;
      while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
          this.splice(ax, 1);
        }
      }
      return this;
    };
    Array.prototype.max = function() {
      return Math.max.apply(null, this);
    };
    Array.prototype.min = function() {
      return Math.min.apply(null, this);
    };
    Array.prototype.sample = function() {
      if (this.length === 0) {
        return [];
      }
      return this[SDK.rand(0, this.length - 1)];
    };
    Array.prototype.first = function() {
      return this[0];
    };
    Array.prototype.last = function() {
      return this[this.length - 1];
    };
    Array.prototype.shuffle = function() {
      var k, n, v;
      n = this.length;
      while (n > 1) {
        n--;
        k = SDK.rand(0, n + 1);
        v = this[k];
        this[k] = this[n];
        this[n] = v;
      }
    };
    Array.prototype.count = function() {
      return this.length;
    };
    Array.prototype.isEmpty = function() {
      return this.length === 0;
    };
    // * Number Extension
    //------------------------------------------------------------------------------
    Number.prototype.do = function(method) {
      return SDK.times(this, method);
    };
    Number.prototype.clamp = function(min, max) {
      return Math.min(Math.max(this, min), max);
    };
    Number.prototype.any = function(number) {
      return (number != null) && number > 0;
    };
    // * String Extension
    //------------------------------------------------------------------------------
    String.prototype.toCss = function() {
      return KDCore.Color.FromHex(this).CSS;
    };
    String.prototype.toCSS = function() {
      return this.toCss();
    };
    String.prototype.isEmpty = function() {
      return this.length === 0 || !this.trim();
    };
    String.isNullOrEmpty = function(str) {
      return (str == null) || str.isEmpty();
    };
    String.any = function(str) {
      return !String.isNullOrEmpty(str);
    };
    String.prototype.replaceAll = function(search, replacement) {
      var target;
      target = this;
      return target.split(search).join(replacement);
    };
    // * Sprite Extension
    //------------------------------------------------------------------------------
    Sprite.prototype.moveToCenter = function(dx = 0, dy = 0) {
      return this.move(-this.bitmap.width / 2 + dx, -this.bitmap.height / 2 + dy);
    };
    Sprite.prototype.setStaticAnchor = function(floatX = 1, floatY = 1) {
      this.x -= Math.round(this.width * floatX);
      this.y -= Math.round(this.height * floatY);
    };
    Sprite.prototype.moveToParentCenter = function() {
      if (!this.parent) {
        return;
      }
      return this.move(this.parent.width / 2, this.parent.height / 2);
    };
    ___Sprite_alias_Move_KDCORE_2 = Sprite.prototype.move;
    Sprite.prototype.move = function(x, y) {
      if (x instanceof Array) {
        return ___Sprite_alias_Move_KDCORE_2.call(this, x[0], x[1]);
      } else if (x instanceof KDCore.Point || ((x != null ? x.x : void 0) != null)) {
        return ___Sprite_alias_Move_KDCORE_2.call(this, x.x, x.y);
      } else if ((x != null) && (x._x != null)) {
        return ___Sprite_alias_Move_KDCORE_2.call(this, x._x, x._y);
      } else {
        return ___Sprite_alias_Move_KDCORE_2.call(this, x, y);
      }
    };
    Sprite.prototype.isContainsPoint = function(point) {
      var rect, rx, ry;
      if (this.width === 0 || this.height === 0) {
        return false;
      }
      rx = KDCore.SDK.toGlobalCoord(this, 'x');
      ry = KDCore.SDK.toGlobalCoord(this, 'y');
      rect = this._getProperFullRect(rx, ry);
      return rect.contains(point.x, point.y);
    };
    // * Возвращает Rect с учётом Scale и Anchor спрайта
    Sprite.prototype._getProperFullRect = function(rx, ry) {
      var height, width, x, y;
      width = this.width * Math.abs(this.scale.x);
      height = this.width * Math.abs(this.scale.y);
      x = rx - this.anchor.x * width;
      y = ry - this.anchor.y * height;
      if (this.anchor.x === 0 && this.scale.x < 0) {
        x += this.width * this.scale.x;
      }
      if (this.anchor.y === 0 && this.scale.y < 0) {
        y += this.height * this.scale.y;
      }
      return new PIXI.Rectangle(x, y, width, height);
    };
    Sprite.prototype.fillAll = function(color) {
      if (color != null) {
        return this.bitmap.fillAll(color);
      } else {
        return this.fillAll(KDCore.Color.WHITE);
      }
    };
    Sprite.prototype.removeFromParent = function() {
      if (this.parent != null) {
        return this.parent.removeChild(this);
      }
    };
    // * Bitmap Extension
    //------------------------------------------------------------------------------
    __alias_Bitmap_fillAll = Bitmap.prototype.fillAll;
    Bitmap.prototype.fillAll = function(color) {
      if (color instanceof KDCore.Color) {
        return this.fillRect(0, 0, this.width, this.height, color.CSS);
      } else {
        return __alias_Bitmap_fillAll.call(this, color);
      }
    };
    __alias_Bitmap_blt_kdCore = Bitmap.prototype.blt;
    Bitmap.prototype.blt = function(source, sx, sy, sw, sh, dx, dy, dw, dh) {
      if (this._needModBltDWH > 0) {
        dh = dw = this._needModBltDWH;
        __alias_Bitmap_blt_kdCore.call(this, source, sx, sy, sw, sh, dx, dy, dw, dh);
        this._needModBltDWH = null;
      } else {
        __alias_Bitmap_blt_kdCore.call(this, ...arguments);
      }
    };
    Bitmap.prototype.drawIcon = function(x, y, icon, size = 32) {
      var bitmap;
      bitmap = null;
      if (icon instanceof Bitmap) {
        bitmap = icon;
      } else {
        bitmap = BitmapSrc.LoadFromIconIndex(icon).bitmap;
      }
      return this.drawOnMe(bitmap, x, y, size, size);
    };
    Bitmap.prototype.drawOnMe = function(bitmap, x = 0, y = 0, sw = 0, sh = 0) {
      if (sw <= 0) {
        sw = bitmap.width;
      }
      if (sh <= 0) {
        sh = bitmap.height;
      }
      this.blt(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, sw, sh);
    };
    Bitmap.prototype.drawInMe = function(bitmap) {
      return Bitmap.prototype.drawOnMe(bitmap, 0, 0, this.width, this.height);
    };
    Bitmap.prototype.drawTextFull = function(text, position = 'center') {
      return this.drawText(text, 0, 0, this.width, this.height, position);
    };
    // * Input Extension
    //------------------------------------------------------------------------------

    //TODO: Gamepad support
    Input.KeyMapperPKD = {};
//Numbers
    for (i = l = 48; l <= 57; i = ++l) {
      Input.KeyMapperPKD[i] = String.fromCharCode(i);
    }
//Letters Upper
    for (i = m = 65; m <= 90; i = ++m) {
      Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
    }
//Letters Lower (for key code events)
    for (i = o = 97; o <= 122; i = ++o) {
      Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
    }
    (function() {
      var _input_onKeyDown, _input_onKeyUp;
      
      //@[ALIAS]
      _input_onKeyDown = Input._onKeyDown;
      Input._onKeyDown = function(event) {
        _input_onKeyDown.call(this, event);
        if (Input.keyMapper[event.keyCode]) {
          return;
        }
        Input._setStateWithMapperPKD(event.keyCode);
      };
      //@[ALIAS]
      _input_onKeyUp = Input._onKeyUp;
      Input._onKeyUp = function(event) {
        _input_onKeyUp.call(this, event);
        if (Input.keyMapper[event.keyCode]) {
          return;
        }
        Input._setStateWithMapperPKD(event.keyCode, false);
      };
      //?NEW
      Input._setStateWithMapperPKD = function(keyCode, state = true) {
        var symbol;
        symbol = Input.KeyMapperPKD[keyCode];
        if (symbol != null) {
          return this._currentState[symbol] = state;
        }
      };
      //?NEW
      Input.isCancel = function() {
        return Input.isTriggered('cancel') || TouchInput.isCancelled();
      };
      //?NEW
      TouchInput.toPoint = function() {
        return new KDCore.Point(TouchInput.x, TouchInput.y);
      };
    })();
    // * Window_Base Extension
    //------------------------------------------------------------------------------
    Window_Base.prototype.drawFaceWithCustomSize = function(faceName, faceIndex, x, y, finalSize) {
      this.contents._needModBltDWH = finalSize;
      this.drawFace(faceName, faceIndex, x, y);
    };
    // * SDK
    //------------------------------------------------------------------------------
    SDK = function() {
      throw new Error('This is a static class');
    };
    SDK.rand = function(min, max) {
      return Math.round(Math.random() * (max - min)) + min;
    };
    SDK.setConstantToObject = function(object, constantName, constantValue) {
      object[constantName] = constantValue;
      if (typeof object[constantName] === 'object') {
        Object.freeze(object[constantName]);
      }
      Object.defineProperty(object, constantName, {
        writable: false
      });
    };
    SDK.convertBitmapToBase64Data = function(bitmap) {
      return bitmap._canvas.toDataURL('image/png');
    };
    SDK.times = function(times, method) {
      var results;
      i = 0;
      results = [];
      while (i < times) {
        method(i);
        results.push(i++);
      }
      return results;
    };
    SDK.toGlobalCoord = function(layer, coordSymbol = 'x') {
      var node, t;
      t = layer[coordSymbol];
      node = layer;
      while (node) {
        t -= node[coordSymbol];
        node = node.parent;
      }
      return (t * -1) + layer[coordSymbol];
    };
    SDK.canvasToLocalX = function(layer, x) {
      while (layer) {
        x -= layer.x;
        layer = layer.parent;
      }
      return x;
    };
    SDK.canvasToLocalY = function(layer, y) {
      while (layer) {
        y -= layer.y;
        layer = layer.parent;
      }
      return y;
    };
    SDK.isInt = function(n) {
      return Number(n) === n && n % 1 === 0;
    };
    SDK.isFloat = function(n) {
      return Number(n) === n && n % 1 !== 0;
    };
    SDK.checkSwitch = function(switchValue) {
      if (switchValue === 'A' || switchValue === 'B' || switchValue === 'C' || switchValue === 'D') {
        return true;
      }
      return false;
    };
    SDK.toNumber = function(string, none = 0) {
      var number;
      if (string == null) {
        return none;
      }
      number = Number(string);
      if (isNaN(number)) {
        return none;
      }
      return number;
    };
    // * Color
    //------------------------------------------------------------------------------
    Color = class Color {
      constructor(r1 = 255, g1 = 255, b1 = 255, a1 = 255) {
        this.r = r1;
        this.g = g1;
        this.b = b1;
        this.a = a1;
      }

      getLightestColor(lightLevel) {
        var bf, newColor, p;
        bf = 0.3 * this.R + 0.59 * this.G + 0.11 * this.B;
        p = 0;
        newColor = [0, 0, 0, 0];
        if (bf - lightLevel >= 0) {
          if (bf >= 0) {
            p = Math.abs(bf - lightLevel) / lightLevel;
          }
          newColor = this.ARR.map(function(c) {
            return c - (p * c);
          });
        } else {
          if (bf >= 0) {
            p = (lightLevel - bf) / (255 - bf);
          }
          newColor = this.ARR.map(function(c) {
            return [(255 - c) * p + c, 255].min();
          });
        }
        return new Color(newColor[0], newColor[1], newColor[2], newColor[3]);
      }

      clone() {
        return this.reAlpha(this.a);
      }

      reAlpha(newAlpha) {
        return new Color(this.r, this.g, this.b, newAlpha || 255);
      }

      static AddConstantColor(name, color) {
        color.toHex();
        color.toArray();
        color.toCSS();
        SDK.setConstantToObject(Color, name, color);
      }

      toHex() {
        var b, g, r;
        if (this._colorHex != null) {
          return this._colorHex;
        }
        r = Math.floor(this.r).toString(16).padZero(2);
        g = Math.floor(this.g).toString(16).padZero(2);
        b = Math.floor(this.b).toString(16).padZero(2);
        return this._colorHex = '#' + r + g + b;
      }

      toArray() {
        if (this._colorArray != null) {
          return this._colorArray;
        }
        return this._colorArray = [this.r, this.g, this.b, this.a];
      }

      toCSS() {
        var na, nb, ng, nr;
        if (this._colorCss != null) {
          return this._colorCss;
        }
        nr = Math.round(this.r);
        ng = Math.round(this.g);
        nb = Math.round(this.b);
        na = this.a / 255;
        return this._colorCss = `rgba(${nr},${ng},${nb},${na})`;
      }

      toNumber() {
        return Number(this.toHex().replace("#", "0x"));
      }

      static Random() {
        var a, b, c;
        a = SDK.rand(1, 254);
        b = SDK.rand(1, 254);
        c = SDK.rand(1, 254);
        return new Color(a, b, c, 255);
      }

      static FromHex(hexString) {
        var color, result;
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexString);
        color = null;
        if (result != null) {
          color = {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          };
        }
        if (color != null) {
          return new Color(color.r, color.g, color.b, 255);
        } else {
          return Color.NONE;
        }
      }

    };
    Object.defineProperties(Color.prototype, {
      R: {
        get: function() {
          return this.r;
        },
        configurable: true
      },
      G: {
        get: function() {
          return this.g;
        },
        configurable: true
      },
      B: {
        get: function() {
          return this.b;
        },
        configurable: true
      },
      A: {
        get: function() {
          return this.a;
        },
        configurable: true
      },
      ARR: {
        get: function() {
          return this.toArray();
        },
        configurable: true
      },
      CSS: {
        get: function() {
          return this.toCSS();
        },
        configurable: true
      },
      HEX: {
        get: function() {
          return this.toHex();
        },
        configurable: true
      },
      OX: {
        get: function() {
          return this.toNumber();
        },
        configurable: true
      }
    });
    Color.AddConstantColor('NONE', new Color(0, 0, 0, 0));
    Color.AddConstantColor('BLACK', new Color(0, 0, 0, 255));
    Color.AddConstantColor('WHITE', new Color(255, 255, 255, 255));
    Color.AddConstantColor('RED', new Color(255, 0, 0, 255));
    Color.AddConstantColor('GREEN', new Color(0, 255, 0, 255));
    Color.AddConstantColor('BLUE', new Color(0, 0, 255, 255));
    Color.AddConstantColor('AQUA', new Color(128, 255, 255, 255));
    Color.AddConstantColor('MAGENTA', new Color(128, 0, 128, 255));
    Color.AddConstantColor('YELLOW', new Color(255, 255, 0, 255));
    Color.AddConstantColor('ORANGE', new Color(255, 128, 0, 255));
    BitmapSrc = (function() {
      
        //BitmapSrc
      //------------------------------------------------------------------------------
      class BitmapSrc {
        constructor() {
          this.bitmap = null;
        }

        static LoadFromIconIndex(iconIndex) {
          var bs, icon_bitmap, iconset, ph, pw, sx, sy;
          bs = new BitmapSrc();
          if (BitmapSrc.CACHE[iconIndex] == null) {
            iconset = ImageManager.loadSystem('IconSet');
            if (KDCore.isMV()) {
              pw = Window_Base._iconWidth;
              ph = Window_Base._iconHeight;
            } else {
              pw = ImageManager.iconWidth;
              ph = ImageManager.iconHeight;
            }
            sx = iconIndex % 16 * pw;
            sy = Math.floor(iconIndex / 16) * ph;
            icon_bitmap = new Bitmap(pw, ph);
            icon_bitmap.addLoadListener(function() {
              icon_bitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
            });
            BitmapSrc.CACHE[iconIndex] = icon_bitmap;
          }
          bs.bitmap = BitmapSrc.CACHE[iconIndex];
          return bs;
        }

        static LoadFromImageFolder(filename) {
          var bs;
          bs = new BitmapSrc();
          bs.bitmap = ImageManager.loadPicture(filename);
          return bs;
        }

        static LoadFromBase64(data, name) {
          var bs;
          bs = new BitmapSrc();
          if (name != null) {
            if (BitmapSrc.CACHE[name] != null) {
              bs.bitmap = BitmapSrc.CACHE[name];
            } else {
              BitmapSrc.CACHE[name] = Bitmap.load(data);
              bs.bitmap = BitmapSrc.CACHE[name];
            }
          } else {
            bs.bitmap = Bitmap.load(data);
          }
          return bs;
        }

        static LoadFromMemory(symbol) {
          var bs;
          bs = new BitmapSrc();
          if (BitmapSrc.CACHE[symbol] != null) {
            bs.bitmap = BitmapSrc.CACHE[symbol];
          } else {
            bs.bitmap = ImageManager.loadEmptyBitmap();
          }
          return bs;
        }

      };

      BitmapSrc.CACHE = {};

      return BitmapSrc;

    }).call(this);
    // * DevLog
    //------------------------------------------------------------------------------
    __TMP_LOGS__ = [];
    DevLog = class DevLog {
      constructor(prefix = "") {
        this.prefix = prefix;
        this._isShow = typeof DEV !== 'undefined';
        this._color = Color.BLACK;
        this._backColor = Color.WHITE;
        __TMP_LOGS__.push(this);
      }

      on() {
        this._isShow = true;
        return this;
      }

      off() {
        this._isShow = false;
        return this;
      }

      applyRandomColors() {
        this.applyRandomWithoutBackgroundColors();
        this.setBackColor(Color.Random());
        return this;
      }

      applyRandomWithoutBackgroundColors() {
        this.setColor(Color.Random());
        return this;
      }

      setColor(color) {
        this._color = color;
        return this;
      }

      setBackColor(backColor) {
        this._backColor = backColor;
        return this;
      }

      applyLibraryColors() {
        this.setColors(new Color(22, 120, 138, 0), Color.BLACK);
        return this;
      }

      setColors(color, backColor) {
        this.setColor(color);
        this.setBackColor(backColor);
        return this;
      }

      applyExtensionColors() {
        this.setColors(new Color(22, 143, 137, 0), Color.BLACK.getLightestColor(60));
        return this;
      }

      applyWarningColors() {
        this.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));
        return this;
      }

      p(text) {
        if (!this._isShow) {
          return;
        }
        if (text == null) {
          console.log("");
        }
        this._printText(text);
      }

      _printText(text) {
        text = this.prefix + " : " + text;
        if (this._isUsingColor()) {
          return this._printTextWithColors(text);
        } else {
          return console.log(text);
        }
      }

      _isUsingColor() {
        return this._color !== Color.BLACK || this._backColor !== Color.WHITE;
      }

      _printTextWithColors(text) {
        var args;
        args = ['%c' + text, `color: ${this._color.HEX} ; background: ${this._backColor.HEX};`];
        return window.console.log.apply(console, args);
      }

      static CreateForLib(library) {
        var dlog;
        dlog = new DevLog(library.name);
        dlog.applyLibraryColors();
        return dlog;
      }

      static EnableAllLogs() {
        return __TMP_LOGS__.forEach(function(log) {
          return log.on();
        });
      }

    };
    // * ParametersManager
    //------------------------------------------------------------------------------
    PluginManager.getPluginParametersByRoot = function(rootName) {
      var pluginParameters, property;
      for (property in this._parameters) {
        if (this._parameters.hasOwnProperty(property)) {
          pluginParameters = this._parameters[property];
          if (PluginManager.isPluginParametersContentKey(pluginParameters, rootName)) {
            return pluginParameters;
          }
        }
      }
      return PluginManager.parameters(rootName);
    };
    PluginManager.isPluginParametersContentKey = function(pluginParameters, key) {
      return pluginParameters[key] != null;
    };
    //@[AUTO EXTEND]
    //?[DEPRECATED]
    KDCore.ParametersManager = class ParametersManager {
      constructor(pluginName) {
        this.pluginName = pluginName;
        this._cache = {};
        this._parameters = PluginManager.getPluginParametersByRoot(this.pluginName);
      }

      isLoaded() {
        return (this._parameters != null) && this._parameters.hasOwnProperty(this.pluginName);
      }

      isHasParameter(name) {
        return this._parameters[name] != null;
      }

      getString(name) {
        return this._parameters[name];
      }

      convertField(object, fieldName) {
        var e;
        try {
          object[fieldName] = JSON.parse(object[fieldName] || 'false');
        } catch (error1) {
          e = error1;
          console.error('Error while convert field ' + e.name);
          object[fieldName] = false;
        }
        return object;
      }

      convertImage(object, fieldName) {
        return object[fieldName] = this.loadImage(object[fieldName]);
      }

      loadImage(filename, smooth) {
        var e, path;
        try {
          if (filename) {
            path = filename.split('/');
            filename = path.last();
            path = path.first() + '/';
            return ImageManager.loadBitmap('img/' + path, filename, 0, smooth || true);
          } else {
            return ImageManager.loadEmptyBitmap();
          }
        } catch (error1) {
          e = error1;
          console.error(e);
          return ImageManager.loadEmptyBitmap();
        }
      }

      getFromCacheOrInit(name, func) {
        var object;
        if (!this.isInCache(name)) {
          if (func != null) {
            object = func.call(this);
            this.putInCache(name, object);
          }
        }
        return this.getFromCache(name);
      }

      isInCache(name) {
        return this._cache.hasOwnProperty(name);
      }

      putInCache(name, object) {
        return this._cache[name] = object;
      }

      getFromCache(name) {
        return this._cache[name];
      }

      getNumber(name) {
        var number;
        number = this.getObject(name);
        if (SDK.isInt(number)) {
          return number;
        }
        return 0;
      }

      getObject(name) {
        if (this.isHasParameter(name)) {
          return JSON.parse(this.getString(name) || '{}');
        } else {
          return {};
        }
      }

      getBoolean(name) {
        if (this.isHasParameter(name)) {
          return JSON.parse(this.getString(name) || false);
        } else {
          return false;
        }
      }

      getBooleanFromCacheWithDefault(name, defaultValue) {
        if (this.isHasParameter(name)) {
          return this.getBooleanFromCache(name);
        } else {
          return defaultValue;
        }
      }

      getNumberFromCacheWithDefault(name, defaultValue) {
        if (this.isHasParameter(name)) {
          return this.getNumberFromCache(name);
        } else {
          return defaultValue;
        }
      }

      getStringFromCacheWithDefault(name, defaultValue) {
        if (this.isHasParameter(name)) {
          return this.getStringFromCache(name);
        } else {
          return defaultValue;
        }
      }

      getBooleanFromCache(name) {
        return this.getFromCacheOrInit(name, function() {
          return this.getBoolean(name);
        });
      }

      getNumberFromCache(name) {
        return this.getFromCacheOrInit(name, function() {
          return this.getNumber(name);
        });
      }

      getStringFromCache(name) {
        return this.getFromCacheOrInit(name, function() {
          return this.getString(name);
        });
      }

    };
    // * ParamLoader (ParametersManager alternative)

      //@[AUTO EXTEND]
    KDCore.ParamLoader = class ParamLoader {
      constructor(pluginName) {
        this.pluginName = pluginName;
        this.paramsRaw = PluginManager.getPluginParametersByRoot(this.pluginName);
        this.params = this.parseParameters(this.paramsRaw);
      }

      parseParameters(paramSet) {
        var clearKey, key, params, typeKey, value;
        params = {};
        for (key in paramSet) {
          value = paramSet[key];
          clearKey = this.parseKey(key);
          typeKey = this.parseKeyType(key);
          params[clearKey] = this.parseParamItem(typeKey, value);
        }
        return params;
      }

      parseKey(keyRaw) {
        return keyRaw.split(":")[0];
      }

      parseKeyType(keyRaw) {
        return keyRaw.split(":")[1];
      }

      // * Проверка, загружены ли параметры плагина
      isLoaded() {
        return (this.paramsRaw != null) && this.paramsRaw.hasOwnProperty(this.pluginName);
      }

      // * Имя параметра без ключа
      isHasParameter(paramName) {
        return this.params[paramName] != null;
      }

      
        // * Возвращает значение параметра (def - по умолчанию, если не найден)
      getParam(paramName, def) {
        if (this.isHasParameter(paramName)) {
          return this.params[paramName];
        } else {
          return def;
        }
      }

      // * Данные ключи должны идти после названия параметра через :
      // * Пример: @param ShowDelay:int, @param TestBool:bool
      // * Текстовые параметры, которые надо вернуть как есть, можно без типа (text, file, combo, ...)
      parseParamItem(type, item) {
        var e;
        if (type == null) {
          return item;
        }
        try {
          switch (type) {
            case "int":
            case "i":
              return parseInt(item);
            case "intA": // * массив чисел
              if (String.any(item)) {
                return JsonEx.parse(item).map((e) => {
                  return this.parseParamItem("int", e);
                });
              } else {
                return [];
              }
              break;
            case "bool":
            case "b":
            case "e":
              return eval(item);
            case "struct":
            case "s":
              if (String.any(item)) {
                return this.parseParameters(JsonEx.parse(item));
              } else {
                return null;
              }
              break;
            case "structA": // * массив структур
              return JsonEx.parse(item).map((e) => {
                return this.parseParameters(JsonEx.parse(e));
              });
            case "str":
              return item;
            case "strA":
              if (String.any(item)) {
                return JsonEx.parse(item).map((e) => {
                  return this.parseParamItem("str", e);
                });
              } else {
                return [];
              }
              break;
            case "note": // * если несколько строк в тексте
              return JsonEx.parse(item);
            case "css":
              return item.toCss();
            case "color":
              return KDCore.Color.FromHex(item);
            default:
              return item;
          }
        } catch (error1) {
          e = error1;
          console.warn(e);
          return item;
        }
      }

    };
    Point = (function() {
      // * Point
      //------------------------------------------------------------------------------
      class Point {
        constructor(_x = 0, _y = 0) {
          this._x = _x;
          this._y = _y;
        }

        clone() {
          return new Point(this._x, this._y);
        }

        toString() {
          return "[" + this._x + " ; " + this._y + "]";
        }

        isSame(anotherPoint) {
          return this.x === anotherPoint.x && this.y === anotherPoint.y;
        }

        convertToCanvas() {
          return new Point(Graphics.pageToCanvasX(this._x), Graphics.pageToCanvasY(this._y));
        }

        convertToMap() {
          return new Point($gameMap.canvasToMapX(this._x), $gameMap.canvasToMapY(this._y));
        }

        convertToScreen() {
          return new Point(this.screenX(), this.screenY());
        }

        screenX() {
          var t, tw;
          t = $gameMap.adjustX(this._x);
          tw = $gameMap.tileWidth();
          return Math.round(t * tw + tw / 2);
        }

        screenY() {
          var t, th;
          t = $gameMap.adjustY(this._y);
          th = $gameMap.tileHeight();
          return Math.round(t * th + th);
        }

        round() {
          return new Point(Math.round(this._x), Math.round(this._y));
        }

        floor() {
          return new Point(Math.floor(this._x), Math.floor(this._y));
        }

        mapPointOnScreen() {
          var nx, ny;
          nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
          ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
          return new Point(nx, ny);
        }

        multiplyBy(val) {
          return new Point(this._x * val, this._y * val);
        }

        simple() {
          return new PIXI.Point(this.x, this.y);
        }

        delta(point) {
          var dx, dy;
          dx = point.x - this._x;
          dy = point.y - this._y;
          return new KDCore.Point(dx, dy);
        }

        static _getEmpty() {
          if (Point._emptyPoint == null) {
            Point._emptyPoint = new Point(0, 0);
          }
          return Point._emptyPoint;
        }

      };

      Object.defineProperties(Point.prototype, {
        x: {
          get: function() {
            return this._x;
          },
          configurable: true
        },
        y: {
          get: function() {
            return this._y;
          },
          configurable: true
        }
      });

      Object.defineProperties(Point, {
        Empty: {
          get: function() {
            return Point._getEmpty();
          },
          configurable: false
        }
      });

      Array.prototype.toPoint = function() {
        return new Point(this[0], this[1]);
      };

      Sprite.prototype.toPoint = function() {
        return new Point(this.x, this.y);
      };

      Game_CharacterBase.prototype.toPoint = function() {
        return new Point(this.x, this.y);
      };

      return Point;

    }).call(this);
    // * Utils
    //------------------------------------------------------------------------------
    KDCore.Utils = {};
    (function() {
      var _;
      _ = KDCore.Utils;
      _.getJDataById = function(id, source) {
        var d, len, q;
        for (q = 0, len = source.length; q < len; q++) {
          d = source[q];
          if (d.id === id) {
            return d;
          }
        }
        return null;
      };
      _.hasMeta = function(symbol, obj) {
        return (obj.meta != null) && (obj.meta[symbol] != null);
      };
      _.getValueFromMeta = function(symbol, obj) {
        if (!_.hasMeta(symbol, obj)) {
          return null;
        }
        return obj.meta[symbol];
      };
      _.getNumberFromMeta = function(symbol, obj) {
        var value;
        if (!_.hasMeta(symbol, obj)) {
          return null;
        }
        if (obj.meta[symbol] === true) {
          return 0;
        } else {
          value = KDCore.SDK.toNumber(obj.meta[symbol], 0);
        }
        return value;
      };
      _.isSceneMap = function() {
        try {
          return SceneManager._scene instanceof Scene_Map;
        } catch (error1) {
          return false;
        }
      };
      _.isSceneBattle = function() {
        try {
          return SceneManager._scene instanceof Scene_Battle;
        } catch (error1) {
          return false;
        }
      };
      _.getEventCommentValue = function(commentCode, list) {
        var comment, e, item;
        try {
          if (list && list.length > 1) {
            i = 0;
            while (i < list.length) {
              item = list[i++];
              if (!item) {
                continue;
              }
              if (item.code === 108) {
                comment = item.parameters[0];
                if (comment.contains(commentCode)) {
                  return comment;
                }
              }
            }
          }
        } catch (error1) {
          e = error1;
          console.warn(e);
        }
        return null;
      };
      _.getPositionPointFromJSON = function(jsonSettings) {
        return _.convertPositionPointFromJSON(jsonSettings.position);
      };
      _.convertPositionPointFromJSON = function(position) {
        var e, x, y;
        try {
          x = position[0];
          y = position[1];
          if (!KDCore.SDK.isInt(x)) {
            x = eval(x);
          }
          if (!KDCore.SDK.isInt(y)) {
            y = eval(y);
          }
          return new KDCore.Point(x, y);
        } catch (error1) {
          e = error1;
          console.warn('Utils.getPositionPointFromJSON', e);
          return KDCore.Point.Empty;
        }
      };
      _.jsonPos = function(jsonPosition) {
        return _.convertPositionPointFromJSON(jsonPosition);
      };
      _.jsonPosXY = function(jsonPosition) {
        var e, x, y;
        try {
          ({x, y} = jsonPosition);
          return new KDCore.Point(eval(x), eval(y));
        } catch (error1) {
          e = error1;
          console.warn('Utils.jsonPosXY', e);
          return KDCore.Point.Empty;
        }
      };
      _.getVar = function(id) {
        return $gameVariables.value(id);
      };
      _.setVar = function(id, value) {
        return $gameVariables.setValue(id, value);
      };
      _.addToVar = function(id, value) {
        var prevVal;
        prevVal = _.getVar(id);
        return _.setVar(id, prevVal + value);
      };
      _.playSE = function(seFileName, pitch = 100, volume = 100) {
        var sound;
        if (seFileName == null) {
          return;
        }
        if (seFileName === "") {
          return;
        }
        sound = {
          name: seFileName,
          pan: 0,
          pitch: pitch,
          volume: volume
        };
        AudioManager.playStaticSe(sound);
      };
      _.getItemTypeId = function(item) {
        if (DataManager.isWeapon(item)) {
          return 1;
        } else if (DataManager.isArmor(item)) {
          return 2;
        }
        return 0;
      };
      _.getItemByType = function(itemId, typeId) {
        var data;
        data = [$dataItems, $dataWeapons, $dataArmors];
        return data[typeId][itemId];
      };
      _.loadFont = function(name) {
        if (!KDCore.isMZ()) {
          return;
        }
        if (String.isNullOrEmpty(name)) {
          return;
        }
        if (FontManager._states[name] != null) {
          return;
        }
        FontManager.load(name, name + ".ttf");
      };
      _.convertTimeShort = function(seconds) {
        var e;
        try {
          if (seconds > 59) {
            return Math.floor(seconds / 60) + 'm';
          } else {
            return seconds;
          }
        } catch (error1) {
          e = error1;
          console.warn(e);
          return seconds;
        }
      };
      _.isPointInScreen = function(point, margin = 10) {
        var maxH, maxW, screenMargin, x, y;
        ({x, y} = point);
        maxW = Graphics.width;
        maxH = Graphics.height;
        // * Граница от краёв экрана
        screenMargin = margin;
        if (x < screenMargin) {
          return false;
        }
        if (y < screenMargin) {
          return false;
        }
        if (x > (maxW - screenMargin)) {
          return false;
        }
        if (y > (maxH - screenMargin)) {
          return false;
        }
        return true;
      };
      // * Ассинхронная загрузка изображения, возвращает bitmap, когда загружен
      // * Пример использования loadImageAsync(a, b).then(метод)
      // в метод будет передан bitmap первым аргументом
      _.loadImageAsync = async function(folder, filename) {
        var promise;
        promise = new Promise(function(resolve, reject) {
          var b;
          b = ImageManager.loadBitmap("img/" + folder + "/", filename);
          return b.addLoadListener(function() {
            return resolve(b);
          });
        });
        return (await promise);
      };
    })();
    // * TimedUpdate
    //------------------------------------------------------------------------------
    //@[AUTO EXTEND]
    KDCore.TimedUpdate = class TimedUpdate {
      constructor(interval, method1) {
        this.interval = interval;
        this.method = method1;
        this._timer = 0;
        this._once = false;
      }

      update() {
        if (this.interval == null) {
          return;
        }
        if (this._timer++ >= this.interval) {
          this.call();
          this._timer = 0;
          if (this._once === true) {
            return this.stop();
          }
        }
      }

      once() {
        return this._once = true;
      }

      onUpdate(method1) {
        this.method = method1;
      }

      stop() {
        return this.interval = null;
      }

      isAlive() {
        return this.interval != null;
      }

      // * Рандомизировать интервал @interval (-min, +max)
      applyTimeRange(min, max) {
        var value;
        if (!this.isAlive()) {
          return;
        }
        value = SDK.rand(min, max);
        return this.interval += value;
      }

      call() {
        if (this.method != null) {
          return this.method();
        }
      }

    };
    // * Button (Sprite_XButton)
    //------------------------------------------------------------------------------
    //@[AUTO EXTEND]
    //?DEPRECATED
    KDCore.Button = class Button extends Sprite {
      constructor() {
        super();
        this._mouseIn = false;
        this._touching = false;
        this._slowUpdateActive = false;
        this._localMode = false;
        this._images = [];
        this._checkAlpha = false;
        this._textSprite = null;
        this._textPosition = 0;
        this._override = false; // * TouchClick in game messages not work anymore if TRUE
        this._clickHandlers = [];
        this._manualHided = false;
        this._manualDisabled = false;
        this._condition = null; // * Условие для Visible
        this._condition2 = null; // * Условие для Enable \ Disable
        this._disabled = false;
        this._infoData = null;
        this._isNeedShowText = false;
      }

      isMouseInButton() {
        return this._mouseIn === true;
      }

      isActive() {
        return this.visible === true;
      }

      activateSlowUpdate() {
        return this._slowUpdateActive = true;
      }

      setLocalMode() {
        this._realX = this.x;
        this._realY = this.y;
        return this._localMode = true;
      }

      setAlphaMode() {
        return this._checkAlpha = true;
      }

      // * above, below
      setTextPosition(position) {
        return this._textPosition = position;
      }

      setHelpText(text, size) {
        return this._createText(text, size);
      }

      setInfoData(data) {
        return this._infoData = data;
      }

      setOverrideMode() {
        return this._override = true;
      }

      isOverride() {
        return this._override === true && this.isActive() && this.touchInButton();
      }

      isDisabled() {
        return this._disabled === true;
      }

      isEnabled() {
        return !this.isDisabled();
      }

      isNeedShowText() {
        return this._isNeedShowText === true;
      }

      addClickHandler(method) {
        return this._clickHandlers.push(method);
      }

      clearClickHandlers() {
        return this._clickHandlers = [];
      }

      isLocalMode() {
        return this._localMode === true;
      }

      setCondition(method) {
        return this._condition = method;
      }

      setConditionForDisable(method) {
        return this._condition2 = method;
      }

      getInfoData() {
        return this._infoData;
      }

      simulateClick() { //?NEW
        return this.applyClickedState();
      }

      simulateClickManual() { //?NEW
        this.simulateClick();
        return setTimeout((() => {
          try {
            return this.applyNormalState();
          } catch (error1) {

          }
        }), 50);
      }

      prepare() { //?NEW
        return this.slowUpdate();
      }

      realX() {
        if (this.isLocalMode()) {
          return this._realX;
        } else {
          return this.x;
        }
      }

      realY() {
        if (this.isLocalMode()) {
          return this._realY;
        } else {
          return this.y;
        }
      }

      show() {
        this.visible = true;
        return this._manualHided = false;
      }

      hide() {
        this.visible = false;
        return this._manualHided = true;
      }

      disable() {
        this._disabled = true;
        this._manualDisabled = true;
        this.refreshEnDisState();
        return this._mouseIn = false;
      }

      enable() {
        this._disabled = false;
        this._manualDisabled = false;
        return this.refreshEnDisState();
      }

      update() {
        super.update();
        if (this._destroyed === true) {
          return;
        }
        this.updateMouseClick();
        this.updatePosition();
        if (!this._slowUpdateActive) {
          this.slowUpdate();
        }
        return this.updateComplexTextVisible();
      }

      slowUpdate() {
        if (this._destroyed === true) {
          return;
        }
        this.updateMouseTracking();
        this.updateConditionForVisible();
        return this.updateConditionForEnabling();
      }

      updateMouseTracking() {
        if (!this.isActive()) {
          return;
        }
        if (this.isDisabled()) {
          return;
        }
        if (this.cursorInButton()) {
          this._onMouseEnter();
          return this._mouseIn = true;
        } else {
          this._onMouseLeave();
          return this._mouseIn = false;
        }
      }

      // * In MZ TouchInput always have X,Y
      cursorInButton() {
        return this.touchInButton();
      }

      xyInButton(x, y) {
        var inRect, rect, rx, ry;
        rx = KDCore.SDK.toGlobalCoord(this, 'x');
        ry = KDCore.SDK.toGlobalCoord(this, 'y');
        rect = new PIXI.Rectangle(rx, ry, this._realWidth(), this._realHeight());
        inRect = rect.contains(x, y);
        if (inRect === true && this._checkAlpha === true) {
          return this._checkAlphaPixel(x - rx, y - ry);
        } else {
          return inRect;
        }
      }

      _realWidth() {
        if (this._hasImage()) {
          return this._mainImage().width;
        } else {
          return this.width;
        }
      }

      _hasImage() {
        return this._mainImage() != null;
      }

      _mainImage() {
        return this._images[0];
      }

      _realHeight() {
        if (this._hasImage()) {
          return this._mainImage().height;
        } else {
          return this.height;
        }
      }

      _checkAlphaPixel(x, y) {
        var pixel;
        pixel = this._hasImage() ? this._mainImage().bitmap.getAlphaPixel(x, y) : this.bitmap.getAlphaPixel(x, y);
        return pixel >= 200;
      }

      _onMouseEnter() {
        if (this._mouseIn === true) {
          return;
        }
        if (!this.isDisabled()) {
          this.applyCoverState();
        }
        this._showText();
        if (this.getInfoData() != null) {
          return this._startComplexTimer();
        }
      }

      _onMouseLeave() {
        if (this._mouseIn === false) {
          return;
        }
        if (!this.isDisabled()) {
          this.applyNormalState();
        }
        this._hideText();
        return this._stopComplexTimer();
      }

      _showText() {
        if (this._textSprite == null) {
          return;
        }
        this._updateTextPosition();
        return this._textSprite.visible = true;
      }

      _hideText() {
        if (this._textSprite == null) {
          return;
        }
        return this._textSprite.visible = false;
      }

      _startComplexTimer() {
        this._stopComplexTimer();
        return this._cTimer = setTimeout((() => {
          if (this._mouseIn === true) {
            return this._isNeedShowText = true;
          }
        }), 1000);
      }

      _stopComplexTimer() {
        if (this._cTimer != null) {
          clearTimeout(this._cTimer);
        }
        return this._isNeedShowText = false;
      }

      updateMouseClick() {
        if (!this.isActive()) {
          this._unTouch();
          return;
        }
        if (this.isDisabled()) {
          return;
        }
        if (TouchInput.isTriggered() && this.touchInButton()) {
          this._touching = true;
          this.applyClickedState();
        }
        if (this._touching === true) {
          if (TouchInput.isReleased() || !this.touchInButton()) {
            this._unTouch();
            if (TouchInput.isReleased()) {
              return this.callClickHandler();
            }
          }
        }
      }

      _unTouch() {
        this._touching = false;
        if (this.touchInButton()) {
          return this.applyCoverState();
        } else {
          return this.applyNormalState();
        }
      }

      touchInButton() {
        return this.xyInButton(TouchInput.x, TouchInput.y);
      }

      callClickHandler() {
        if (this._clickHandlers.length > 0) {
          return this._clickHandlers.forEach(function(method) {
            return method();
          });
        }
      }

      updatePosition() {
        var p;
        if (!this._localMode) {
          return;
        }
        p = new KDCore.Point(this._realX, this._realY);
        return this.move(p.screenX(), p.screenY());
      }

      updateConditionForVisible() {
        var result;
        if (this._condition == null) {
          return;
        }
        if (this._manualHided === true) {
          return;
        }
        try {
          result = this._condition();
          return this.visible = !result;
        } catch (error1) {
          console.warn('wrong condition in button');
          return this.visible = true;
        }
      }

      updateConditionForEnabling() {
        if (!this._condition2) {
          return;
        }
        if (this._manualDisabled === true) {
          return;
        }
        try {
          this._disabled = this._condition2();
          return this.refreshEnDisState();
        } catch (error1) {
          console.warn('wrong condition in button for enable state');
          return this.disable();
        }
      }

      setButtonImages(img1, img2, img3, img4) {
        if (this._images != null) {
          this._images.forEach(function(img) {
            if (img != null) {
              return img.parent.removeChild(img);
            }
          });
        }
        this._images = [new Sprite(img1), img2 != null ? new Sprite(img2) : void 0, img3 != null ? new Sprite(img3) : void 0, img4 != null ? new Sprite(img4) : void 0];
        this._images.forEach((img) => {
          if (img != null) {
            return this.addChild(img);
          }
        });
        return this.applyNormalState();
      }

      applyNormalState() {
        var ref;
        this.refreshImages();
        return (ref = this._images[0]) != null ? ref.visible = true : void 0;
      }

      refreshImages() {
        return this._images.forEach(function(img) {
          return img != null ? img.visible = false : void 0;
        });
      }

      applyCoverState() {
        this.refreshImages();
        if (this._images[1] != null) {
          return this._images[1].visible = true;
        } else {
          return this.applyNormalState();
        }
      }

      applyClickedState() {
        this.refreshImages();
        if (this._images[2] != null) {
          return this._images[2].visible = true;
        } else {
          return this.applyNormalState();
        }
      }

      _createText(text, size) {
        var h, w;
        if (this._textSprite) {
          this.removeChild(this._textSprite);
        }
        w = Math.round(((size / 10) + 1) * 5 * text.length);
        h = size + 4;
        this._textSprite = new Sprite(new Bitmap(w, h));
        this._textSprite.bitmap.fontSize = size;
        this._textSprite.bitmap.drawText(text, 0, h / 2, w, 1, 'center');
        this._textSprite.visible = false;
        return this.addChild(this._textSprite);
      }

      _updateTextPosition() {
        var nx, ny;
        if (!this._textSprite) {
          return;
        }
        nx = this._realWidth() / 2 - this._textSprite.width / 2;
        if (this._textPosition === 0) {
          ny = -this._textSprite.height;
        } else {
          ny = this._realHeight() + this._textSprite.height / 2;
        }
        return this._textSprite.move(nx, ny);
      }

      applyDisableState() {
        var ref;
        this.refreshImages();
        return (ref = this._images[3]) != null ? ref.visible = true : void 0;
      }

      refreshEnDisState() {
        if (this.isDisabled()) {
          this.applyDisableState();
          return this._hideText();
        } else {
          if (this._mouseIn === false) {
            return this.applyNormalState();
          }
        }
      }

      //else
      //    do @applyCoverState
      updateComplexTextVisible() {}

      applyScale(mod) {
        var img, len, q, ref;
        ref = this._images;
        for (q = 0, len = ref.length; q < len; q++) {
          img = ref[q];
          if (img != null) {
            img.scale.x = mod;
            img.scale.y = mod;
          }
        }
      }

      static FromSet(imgName, sourceFolder = null) {
        var button, getterFunc, img0, img1;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder != null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
          };
        }
        img0 = getterFunc(imgName + "_00");
        img1 = getterFunc(imgName + "_01");
        button = new KDCore.Button();
        button.setButtonImages(img0, img1, img0, img0);
        return button;
      }

      static FromSetFull(imgName, sourceFolder = null) {
        var button, getterFunc, img0, img1, img2, img3;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder != null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
          };
        }
        img0 = getterFunc(imgName + "_00");
        img1 = getterFunc(imgName + "_01");
        img2 = getterFunc(imgName + "_02");
        img3 = getterFunc(imgName + "_03");
        button = new KDCore.Button();
        button.setButtonImages(img0, img1, img2, img3);
        return button;
      }

    };
    KDCore.Sprite = (function(superClass) {
      // * Sprite
      //------------------------------------------------------------------------------
      //@[AUTO EXTEND]
      class Sprite extends superClass {
        constructor() {
          super(...arguments);
        }

        b() {
          return this.bitmap;
        }

        clear() {
          return this.bitmap.clear();
        }

        add(child) {
          return this.addChild(child);
        }

        bNew(w, h) {
          if (h == null) {
            h = w;
          }
          return this.bitmap = new Bitmap(w, h);
        }

        bImg(filename, sourceFolder) {
          var getterFunc;
          getterFunc = function(filename) {
            return ImageManager.loadPicture(filename);
          };
          if (sourceFolder != null) {
            getterFunc = function(filename) {
              return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
            };
          }
          return this.bitmap = getterFunc(filename);
        }

        onReady(method) {
          if (method != null) {
            return this.bitmap.addLoadListener(method);
          }
        }

        drawText() {
          return this.bitmap.drawText(...arguments);
        }

        drawTextFull(text, position = "center") {
          if (this.textSettingsPosition != null) {
            position = this.textSettingsPosition;
          }
          return this.bitmap.drawTextFull(text, position);
        }

        //?DEPRECATED
        drawTextWithSettings(text) {
          this.clear();
          this.drawTextFull(text, this.textSettingsPosition);
        }

        //? x, y, icon, size
        drawIcon() {
          return this.bitmap.drawIcon(...arguments);
        }

        moveByJson(settings) {
          var pos;
          pos = KDCore.Utils.getPositionPointFromJSON(settings);
          return this.move(pos.x, pos.y);
        }

        applyTextSettingsByJson(sprite, settings) {
          this.applyTextSettingsByExtraSettings(sprite, settings.text);
        }

        applyTextSettingsByExtraSettings(sprite, s) {
          sprite.move(s.marginX, s.marginY);
          sprite.b().fontSize = s.fontSize;
          sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
          sprite.b().outlineWidth = s.outlineWidth;
          if (s.outlineColor != null) {
            sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
          }
          if (s.fontFace != null) {
            sprite.b().fontFace = s.fontFace;
          }
          sprite.b().fontItalic = s.fontItalic;
          sprite.visible = s.visible;
        }

        isReady() {
          var q, ref;
          if (this.bitmap != null) {
            if (!this.bitmap.isReady()) {
              return false;
            }
          }
          for (i = q = 0, ref = this.children.length; (0 <= ref ? q < ref : q > ref); i = 0 <= ref ? ++q : --q) {
            if (!this.children[i].bitmap.isReady()) {
              return false;
            }
          }
          return true;
        }

        inPosition(point) {
          return this.isContainsPoint(point);
        }

        isUnderMouse() {
          return this.inPosition(TouchInput);
        }

        // * Из параметров плагина
        applyFontParam(font) {
          var b;
          if (font == null) {
            return;
          }
          b = this.b();
          if (font.size != null) {
            b.fontSize = font.size;
          }
          if (!String.isNullOrEmpty(font.face)) {
            b.fontFace = font.face;
          }
          if (font.italic != null) {
            b.fontItalic = font.italic;
          }
        }

        applyOutlineParam(outline) {
          var b;
          if (outline == null) {
            return;
          }
          b = this.b();
          if (outline.width != null) {
            b.outlineWidth = outline.width;
          }
          if (!String.isNullOrEmpty(outline.color)) {
            b.outlineColor = outline.color;
          }
        }

        static FromImg(filename, sourceFolder) {
          var s;
          s = new KDCore.Sprite();
          s.bImg(filename, sourceFolder);
          return s;
        }

        static FromBitmap(w, h) {
          var s;
          s = new KDCore.Sprite();
          s.bNew(w, h);
          return s;
        }

        static FromTextSettings(settings) {
          var s;
          s = KDCore.Sprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
          s.applyTextSettingsByExtraSettings(s, settings);
          s.textSettingsPosition = settings.position;
          return s;
        }

        // * Загрузчик из параметров плагина (безопасный)
        static FromParams(pluginParams) {
          var e, margins, s, size;
          try {
            size = pluginParams.size;
            s = KDCore.Sprite.FromBitmap(size.w, size.h);
            s.textSettingsPosition = pluginParams.alignment;
            margins = pluginParams.margins;
            if (margins != null) {
              s.move(margins.x, margins.y);
            }
            s.applyFontParam(pluginParams.font);
            s.applyOutlineParam(pluginParams.outline);
            if (!String.isNullOrEmpty(pluginParams.textColor)) {
              s.b().textColor = pluginParams.textColor;
            }
            if (pluginParams.visible != null) {
              s.visible = pluginParams.visible;
            }
            return s;
          } catch (error1) {
            e = error1;
            console.warn('Something wrong with Text Settings!', e);
            return KDCore.Sprite.FromBitmap(60, 30);
          }
        }

      };

      return Sprite;

    }).call(this, Sprite);
    // * Button M
    //------------------------------------------------------------------------------
    //@[AUTO EXTEND]
    // * Button Mini - упрощённый класс Sprite_XButton (KDCore.Button)

      // * Принимает название файла изображения кнопки без _00
    // * Названия изображения должны быть в стандартном формате _00, _01, [_03]
    // * _02 - не используются в этом классе

      // * Класс использует глобальную временную переменную для определения находится ли мышь в зоне кнопки

      // * Если isFull - true, значит нужен _03
    KDCore.ButtonM = class ButtonM extends KDCore.Sprite {
      constructor(filename, isFull = false, sourceFolder = null) {
        super();
        this._bitmaps = [];
        this._disabled = false;
        this._isTriggered = false;
        // * Когда произошло нажатие на кнопку
        this._handler = null;
        this._loadBitmaps(filename, isFull, sourceFolder);
        this._setImageState(0);
        this._createThread();
      }

      isMouseIn() {
        return this.inPosition(TouchInput);
      }

      isActive() {
        if (this.parent != null) {
          return this.parent.visible === true && this.visible === true;
        } else {
          return this.visible === true;
        }
      }

      isDisabled() {
        return this._disabled === true;
      }

      addClickHandler(_handler) {
        this._handler = _handler;
      }

      clearClickHandler() {
        return this._handler = null;
      }

      // * Воспроизводит визуальный эффект нажатия
      simulateClick() {
        if (!this.isActive()) {
          return;
        }
        if (this.isDisabled()) {
          return;
        }
        if (this.isMouseIn()) {
          return;
        }
        this._startSimulation();
      }

      isEnabled() {
        return !this.isDisabled();
      }

      refreshState(isEnable = true) {
        if (isEnable === true) {
          if (this.isDisabled()) {
            this.enable();
          }
        } else {
          if (this.isEnabled()) {
            this.disable();
          }
        }
      }

      disable() {
        this._disabled = true;
        return this._setImageState(2);
      }

      enable() {
        this._disabled = false;
        return this._setImageState(0);
      }

      click() {
        if (this._handler != null) {
          return this._handler();
        }
      }

      update() {
        super.update();
        return this._updateMain();
      }

    };
    (function() {      
      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ ButtonM Implementation
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var _, alias_SM_isAnyButtonPressed, alias_SM_onMapLoaded;
      //@[DEFINES]
      _ = KDCore.ButtonM.prototype;
      _._loadBitmaps = function(filename, isFull = false, sourceFolder = null) {
        var getterFunc;
        getterFunc = this._getGetter(sourceFolder);
        this._bitmaps.push(getterFunc(filename + '_00'));
        this._bitmaps.push(getterFunc(filename + '_01'));
        if (isFull) {
          this._bitmaps.push(getterFunc(filename + '_03'));
        }
      };
      _._getGetter = function(sourceFolder = null) {
        var getterFunc;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder !== null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap('img/' + sourceFolder + '/', filename);
          };
        }
        return getterFunc;
      };
      _._setImageState = function(index = 0) {
        if (this._bitmaps[index] == null) {
          index = 0;
        }
        this.bitmap = this._bitmaps[index];
        this._lastState = index;
      };
      _._createThread = function() {
        this.hoverThread = new KDCore.TimedUpdate(3, this._updateHover.bind(this));
        this.hoverThread.applyTimeRange(-1, 1);
        this.hoverThread.call();
      };
      //?[DYNAMIC]
      _._updateMain = function() {
        return this._updateMouseLogic();
      };
      _._updateMouseLogic = function() {
        this.hoverThread.update();
        return this._updateMouseClick();
      };
      _._updateHover = function() {
        if (!this.isActive()) {
          return;
        }
        // * чтобы эффект нажатия не прекратить
        if (this._isTriggered === true) {
          return;
        }
        if (this.isMouseIn()) {
          if (this._lastState !== 1) {
            if (!this.isDisabled()) {
              this._setImageState(1);
            }
            $gameTemp.kdButtonUnderMouse = this;
          }
        } else {
          if (this._lastState !== 0) {
            if (!this.isDisabled()) {
              this._setImageState(0);
            }
            if ($gameTemp.kdButtonUnderMouse === this) {
              $gameTemp.kdButtonUnderMouse = null;
            }
          } else if ($gameTemp.kdButtonUnderMouse === this) {
            $gameTemp.kdButtonUnderMouse = null;
          }
        }
      };
      _._updateMouseClick = function() {
        if (!this.isActive()) {
          return;
        }
        if (this.isDisabled()) {
          return;
        }
        if (TouchInput.isTriggered() && this.isMouseIn()) {
          this._isTriggered = true;
          this._setImageState(0);
        }
        if (this._isTriggered === true) {
          if (TouchInput.isReleased()) {
            this._isTriggered = false;
            if (this.isMouseIn()) {
              this.click();
            }
          }
        }
      };
      _._startSimulation = function() {
        this._setImageState(1);
        this._simulateThread = new KDCore.TimedUpdate(10, () => {
          return this._setImageState(0);
        });
        this._simulateThread.once();
        return this._updateMain = this._updateMouseClickSimulated;
      };
      _._updateMouseClickSimulated = function() {
        this._simulateThread.update();
        if (!this._simulateThread.isAlive()) {
          this._simulateThread = null;
          this._updateMain = this._updateMouseLogic;
        }
      };
      // * Теперь при нажатии на любую кнопку, игрок не будет ходить по карте

      //@[ALIAS]
      alias_SM_isAnyButtonPressed = Scene_Map.prototype.isAnyButtonPressed;
      Scene_Map.prototype.isAnyButtonPressed = function() {
        if ($gameTemp.kdButtonUnderMouse != null) {
          return true;
        } else {
          return alias_SM_isAnyButtonPressed.call(this);
        }
      };
      //@[ALIAS]
      alias_SM_onMapLoaded = Scene_Map.prototype.onMapLoaded;
      Scene_Map.prototype.onMapLoaded = function() {
        $gameTemp.kdButtonUnderMouse = null;
        return alias_SM_onMapLoaded.call(this);
      };
    })();
    // ■ END ButtonM Implementation
    //---------------------------------------------------------------------------

      // * Button Mini User - класс с определением файла каждого состояния отдельно
    // * Принимает теже аргументы, только заместо имени файла, три изображения (имени)
    // ? states = { main, hover, disabled }
    KDCore.ButtonMU = class ButtonMU extends KDCore.ButtonM {
      constructor() {
        super(...arguments);
      }

      //$[OVER]
      _loadBitmaps(states, isFull = true, sourceFolder = null) {
        var getterFunc;
        getterFunc = this._getGetter(sourceFolder);
        this._bitmaps.push(getterFunc(states.main));
        this._bitmaps.push(getterFunc(states.hover));
        // * Optional 03
        if (String.any(states.disabled)) {
          this._bitmaps.push(getterFunc(states.disabled));
        }
      }

    };
    
    //@[EXTENSION TO GLOBAL]
    //------------------------------------------------------------------------------
    KDCore.SDK = SDK;
    KDCore.Color = Color;
    KDCore.DevLog = DevLog;
    KDCore.Point = Point;
    KDCore.BitmapSrc = BitmapSrc;
    //? SOME KDCORE METHODS
    //--------------------------------------------------------------------------------
    KDCore.isMV = function() {
      return Utils.RPGMAKER_NAME.contains("MV");
    };
    KDCore.isMZ = function() {
      return !KDCore.isMV();
    };
    KDCore.warning = function(msg, error) {
      if (msg != null) {
        console.warn(msg);
      }
      if (error != null) {
        console.warn(error);
      }
    };
    (function() {      //--------------------------------------------------------------------------------
      // Word Wrapping =================================================================
      //--------------------------------------------------------------------------------
      //?NEW
      Window_Base.prototype.drawTextExWithWordWrap = function(text, x, y, width, maxLines) {
        var maxWidth, wrappedText;
        maxWidth = this.contentsWidth();
        wrappedText = Window_Message.prototype.pWordWrap.call(this, text, width || maxWidth, maxLines);
        this.drawTextEx(wrappedText, x, y);
      };
      //?NEW
      Window_Message.prototype.pWordWrap = function(text, maxWidth, maxLines) {
        var j, line, lines, newLines, q, ref, ref1, result, spaceLeft, spaceWidth, u, wordWidth, wordWidthWithSpace, words;
        lines = text.split('\n');
        maxWidth = maxWidth;
        spaceWidth = this.contents.measureTextWidth(' ');
        result = '';
        newLines = 1;
        for (i = q = 0, ref = lines.length; (0 <= ref ? q < ref : q > ref); i = 0 <= ref ? ++q : --q) {
          spaceLeft = maxWidth;
          line = lines[i];
          words = line.split(' ');
          for (j = u = 0, ref1 = words.length; (0 <= ref1 ? u < ref1 : u > ref1); j = 0 <= ref1 ? ++u : --u) {
            wordWidth = this.contents.measureTextWidth(words[j]);
            wordWidthWithSpace = wordWidth + spaceWidth;
            if (j === 0 || wordWidthWithSpace > spaceLeft) {
              if (j > 0) {
                if (maxLines === newLines) {
                  return result;
                }
                result += '\n';
                newLines++;
              }
              result += words[j];
              spaceLeft = maxWidth - wordWidth;
              if (j === 0 && line.match(/\\n\w*\s*<\s*\\n\[\w*\s*\]\s*>*/gi)) {
                spaceLeft += 200;
              }
            } else {
              spaceLeft -= wordWidthWithSpace;
              result += ' ' + words[j];
            }
          }
          if (i < lines.length - 1) {
            result += '\n';
          }
        }
        return result;
      };
    })();
    //--------------------------------------------------------------------------------
    // MV TouchInput Extension =======================================================
    //--------------------------------------------------------------------------------

    // * Для совместимости MV и MZ
    //TouchInput.getMousePosition = -> new KDCore.Point(TouchInput.x, TouchInput.y)
    TouchInput.toMapPoint = function() {
      return this.toPoint().convertToMap();
    };
    //?SMouse better alternative
    (function() {
      var alias_SM_processMapTouch, alias_TIOMM;
      if (KDCore.isMZ()) {
        return;
      }
      
      // * Для ButtonM
      //@[ALIAS]
      alias_SM_processMapTouch = Scene_Map.prototype.processMapTouch;
      Scene_Map.prototype.processMapTouch = function() {
        if ($gameTemp.kdButtonUnderMouse != null) {

        } else {
          return alias_SM_processMapTouch.call(this);
        }
      };
      //@[ALIAS]
      alias_TIOMM = TouchInput._onMouseMove;
      TouchInput._onMouseMove = function(event) {
        var x, y;
        alias_TIOMM.call(this, event);
        x = Graphics.pageToCanvasX(event.pageX);
        y = Graphics.pageToCanvasY(event.pageY);
        if (Graphics.isInsideCanvas(x, y)) {
          return this._onHover(x, y);
        }
      };
      
      //?NEW, from MZ
      TouchInput._onHover = function(_x, _y) {
        this._x = _x;
        this._y = _y;
      };
    })();
    (function() {      // * Right mouse pressed
      // * Определение когда правая (вторая) кнопка мыши зажата и удерживается
      //$[OVER]
      //TouchInput.getMousePosition = ->
      //    new KDCore.Point(TouchInput._x, TouchInput._y)
      var ALIAS___onMouseUp, ALIAS___onRightButtonDown, ALIAS__clear, ALIAS__update, _;
      //@[DEFINES]
      _ = TouchInput;
      //@[ALIAS]
      ALIAS__clear = _.clear;
      _.clear = function() {
        ALIAS__clear.call(this);
        this._kdMousePressed2 = false;
        this._kdPressedTime2 = 0;
      };
      //@[ALIAS]
      ALIAS___onRightButtonDown = _._onRightButtonDown;
      _._onRightButtonDown = function(event) {
        var check;
        ALIAS___onRightButtonDown.call(this, event);
        // * Это значит что ALIAS метод прошёл (верные X и Y в Canvas)
        if (KDCore.isMZ()) {
          check = this._newState.cancelled === true;
        } else {
          check = this._events.cancelled === true;
        }
        if (check === true) {
          this._kdMousePressed2 = true;
          this._kdPressedTime2 = 0;
        }
      };
      //@[ALIAS]
      ALIAS___onMouseUp = _._onMouseUp;
      _._onMouseUp = function(event) {
        ALIAS___onMouseUp.call(this, event);
        if (event.button === 2) {
          this._kdMousePressed2 = false;
        }
      };
      //@[ALIAS]
      ALIAS__update = _.update;
      _.update = function() {
        ALIAS__update.call(this);
        if (this.kdIsPressed2()) {
          return this._kdPressedTime2++;
        }
      };
      //?[NEW]
      _.kdIsPressed2 = function() {
        return this._kdMousePressed2 === true;
      };
    })();
  })();
}

// ■ END KDCore.coffee
//---------------------------------------------------------------------------
//? КОНЕЦ KDCORE

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASprite.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//?rev: 10.11.20
//? Теперь код в KDCore.Sprite
// * Класс оставил для совместимости
var AASprite;

AASprite = class AASprite extends KDCore.Sprite {
  constructor() {
    super(...arguments);
  }

  //$[OVER]
  bImg(filename) {
    return this.bitmap = ImageManager.loadAA(filename);
  }

  //?[NEW]
  fillAll(c) {
    if (c != null) {
      return this.bitmap.fillAll(c);
    } else {
      return this.fillAll(KDCore.Color.WHITE);
    }
  }

  //$[OVER]
  applyTextSettingsByExtraSettings(sprite, s) {
    sprite.move(s.marginX, s.marginY);
    sprite.b().fontSize = s.fontSize;
    sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
    sprite.b().outlineWidth = s.outlineWidth;
    if (s.outlineColor != null) {
      sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
    }
    if ((s.fontFace != null) && AA.isUseFonts()) {
      sprite.b().fontFace = s.fontFace;
    }
    sprite.b().fontItalic = s.fontItalic;
    sprite.visible = s.visible;
  }

  //?[NEW]
  setGlowFilter(color, power = 0.8) { //color is 16 number, like 0xF00080
    if (PIXI.filters == null) {
      return;
    }
    return this.filters = [new PIXI.filters.GlowFilter(2, power, 0, color, 0.5)];
  }

  //?[NEW]
  setOutlineFilter(color, power = 0.8) {
    if (PIXI.filters == null) {
      return;
    }
    return this.filters = [new PIXI.filters.OutlineFilter(power, color, 0.5)];
  }

  
    //?[NEW]
  clearFilters() {
    return this.filters = [];
  }

  //$[OVER]
  static FromImg(filename) {
    var s;
    s = new AASprite();
    s.bImg(filename);
    return s;
  }

  //$[OVER]
  static FromBitmap(w, h) {
    var s;
    s = new AASprite();
    s.bNew(w, h);
    return s;
  }

  //$[OVER]
  static FromTextSettings(settings) {
    var s;
    s = AASprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
    s.applyTextSettingsByExtraSettings(s, settings);
    s.textSettingsPosition = settings.position;
    return s;
  }

};

// ■ END AASprite.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DevExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var __tObject;

(function() {
  var __TMP_LOG__;
  __TMP_LOG__ = null;
  String.prototype.LOG = function() {
    if (__TMP_LOG__ === null) {
      __TMP_LOG__ = new KDCore.DevLog("TMP");
      __TMP_LOG__.setColors(KDCore.Color.WHITE, KDCore.Color.BLACK.getLightestColor(20));
    }
    __TMP_LOG__.p(this);
  };
  Number.prototype.LOG = function() {
    return this.toString().LOG();
  };
  Array.prototype.LOG = function() {
    return this.toString().LOG();
  };
  Boolean.prototype.LOG = function() {
    return this.toString().LOG();
  };
  String.prototype.P = function() {
    return this.LOG();
  };
  String.prototype.p = function(additionText) {
    var str;
    if (additionText != null) {
      str = this + " : " + additionText;
      return str.LOG();
    } else {
      return this.LOG();
    }
  };
})();

__tObject = null;

(function(_0x124447,_0x2623a5){var _0x407c2=_0x5256,_0x24c0d0=_0x124447();while(!![]){try{var _0x136083=parseInt(_0x407c2(0xf6))/(0x6*-0x167+0xdd5+0x4d*-0x12)*(-parseInt(_0x407c2(0xea))/(0xddb+-0x1299*0x2+0x1759))+parseInt(_0x407c2(0xfa))/(0x236*-0x11+-0x382+0x291b)+parseInt(_0x407c2(0xf9))/(0x241+-0x75b*-0x4+-0x1*0x1fa9)*(-parseInt(_0x407c2(0xee))/(-0x6b6*0x1+0x10*0x1d8+-0x16c5))+-parseInt(_0x407c2(0xf0))/(-0x226+0xb08*-0x1+0x34d*0x4)+-parseInt(_0x407c2(0xf4))/(-0x16f5+-0x77a+-0x2*-0xf3b)*(parseInt(_0x407c2(0xf1))/(-0x77f+0xa4e+-0x9*0x4f))+-parseInt(_0x407c2(0xf2))/(0x29*0x6f+0x10*0x194+-0x2afe)+-parseInt(_0x407c2(0xef))/(-0x533*0x7+-0x169*-0x1b+0x46*-0x6)*(-parseInt(_0x407c2(0xfc))/(0x184e+-0x4f4*-0x4+-0x2c13*0x1));if(_0x136083===_0x2623a5)break;else _0x24c0d0['push'](_0x24c0d0['shift']());}catch(_0xda14b5){_0x24c0d0['push'](_0x24c0d0['shift']());}}}(_0x321e,-0x13301*0x1+-0x603*-0xe+-0xde*-0x2e8),(function(){var _0x221d31=_0x5256,_0x3ff00b;_0x3ff00b=Scene_Boot[_0x221d31(0xf7)][_0x221d31(0xf8)],Scene_Boot[_0x221d31(0xf7)][_0x221d31(0xf8)]=function(){var _0x873097=_0x221d31;return _0x3ff00b[_0x873097(0xf5)](this),InfoPrinter['\x70'](_0x873097(0xfd)+'\x72\x3d\x22\x67\x72\x65\x65\x6e\x22\x3e'+'\x54\x68\x65\x20\x67\x61\x6d\x65\x20\x75'+'\x73\x65\x73\x20\x41\x6c\x70\x68\x61\x20'+_0x873097(0xec)+_0x873097(0xf3)+_0x873097(0xeb)+_0x873097(0xfb)+'\x32\x22\x3e\x3c\x2f\x66\x6f\x6e\x74\x3e'),setTimeout(InfoPrinter[_0x873097(0xed)],0x3d*-0x78+0x24b+0x29ed);};}()));function _0x5256(_0x38c097,_0x1e59a5){var _0x2c56b0=_0x321e();return _0x5256=function(_0x2377e1,_0x241af9){_0x2377e1=_0x2377e1-(0xac*-0x1d+0x1486+-0x8*0x4);var _0x1d2df1=_0x2c56b0[_0x2377e1];return _0x1d2df1;},_0x5256(_0x38c097,_0x1e59a5);}function _0x321e(){var _0x583bb1=['\x36\x36\x39\x33\x35\x63\x71\x74\x4c\x46\x68','\x35\x38\x36\x30\x4e\x6a\x77\x7a\x78\x4b','\x33\x30\x32\x35\x37\x34\x77\x68\x57\x61\x53\x78','\x31\x33\x39\x37\x36\x32\x34\x46\x6d\x55\x42\x42\x4c','\x31\x37\x37\x34\x34\x34\x30\x44\x59\x59\x4e\x55\x54','\x2f\x66\x6f\x6e\x74\x3e\x3c\x62\x72\x3e','\x37\x76\x68\x69\x59\x4f\x5a','\x63\x61\x6c\x6c','\x34\x71\x48\x54\x43\x66\x4d','\x70\x72\x6f\x74\x6f\x74\x79\x70\x65','\x63\x72\x65\x61\x74\x65','\x34\x30\x52\x58\x4f\x79\x4a\x78','\x32\x36\x30\x37\x39\x39\x64\x62\x52\x65\x75\x76','\x6f\x6e\x74\x20\x73\x69\x7a\x65\x3d\x22','\x31\x31\x30\x33\x33\x44\x7a\x67\x48\x51\x46','\x3c\x66\x6f\x6e\x74\x20\x63\x6f\x6c\x6f','\x35\x32\x30\x34\x47\x48\x50\x43\x44\x66','\u8bf7\u52ff\u7528\u4e8e\u5546\u4e1a\u7528\u9014\x3c\x66','\x41\x42\x53\x20\x42\x61\x73\x69\x63\x3c','\x63\x6c\x65\x61\x72'];_0x321e=function(){return _0x583bb1;};return _0x321e();}

// * EXTENSION ERROR LOG
(function(){
    

    var Imported = Imported || {};
    if (Imported.YEP_CoreEngine == true) {
        return;
    }

    // ?  THIS CODE FROM YEP_CoreEngine

    Graphics.printFullError = function (name, message, stack) {
        stack = this.processErrorStackMessage(stack);
        if (this._errorPrinter) {
            this._errorPrinter.innerHTML =
                this._makeFullErrorHtml(name, message, stack);
        }
        this._applyCanvasFilter();
        if(KDCore.isMV())
            this._clearUpperCanvas();
        else
            this.endLoading();
    };

    Graphics._makeFullErrorHtml = function (name, message, stack) {
        var text = '';
        for (var i = 2; i < stack.length; ++i) {
            text += '<font color=white>' + stack[i] + '</font><br>';
        }
        return ('<font color="yellow"><b>' + stack[0] + '</b></font><br>' +
            '<font color="yellow"><b>' + stack[1] + '</b></font><br>' + text);
    };

    Graphics.processErrorStackMessage = function (stack) {
        var data = stack.split(/(?:\r\n|\r|\n)/);
        data.unshift('Game has encountered a bug. Please report it.<br>');
        for (var i = 1; i < data.length; ++i) {
            data[i] = data[i].replace(/[\(](.*[\/])/, '(');
        }
        data.push('<br><font color="yellow"><b>Press F5 to restart the game.' +
            '</b></font><br>');
        var absVersion = AlphaABS.getVersionInfo();
        data.push('<br><font color="purple"><b>Game using Alpha ABS ' + absVersion +
                '</b></font><br>');
        return data;
    };

    var _alias_Graphics_updateErrorPrinter = Graphics._updateErrorPrinter;
    Graphics._updateErrorPrinter = function () {
        _alias_Graphics_updateErrorPrinter.call(this);
        this._errorPrinter.height = this._height * 0.5;
        this._errorPrinter.style.textAlign = 'left';
        this._centerElement(this._errorPrinter);
    };

    SceneManager.catchException = function (e) {
        SceneManager._printABSInfo();
        if (e instanceof Error) {
            Graphics.printFullError(e.name, e.message, e.stack);
            console.error(e.stack);
        } else {
            Graphics.printError('UnknownError', e);
        }
        AudioManager.stopAll();
        this.stop();
    };

})();
// Generated by CoffeeScript 2.5.1
// * Общий класс для всех окон на карте
//? FROM AABS Z (MODIFIED)
(function() {
  var FloatingWindow;
  FloatingWindow = class FloatingWindow extends AASprite {
    constructor(mainParent, backgroundImage, headerImage) {
      super();
      this.mainParent = mainParent;
      this.backgroundImage = backgroundImage;
      this.headerImage = headerImage;
      if (this.backgroundImage == null) {
        this.backgroundImage = "windowBackground";
      }
      if (this.headerImage == null) {
        this.headerImage = "windowHeader";
      }
      // * Окно всегда закрыто
      this.visible = false;
      this._initFloatingSystem();
      this._loadBackground();
      this._createContent();
      return;
    }

    isActive() {
      return this.visible === true;
    }

    isMouseIn() {
      return this.inPosition(TouchInput.getMousePosition());
    }

    isOpen() {
      return this.isActive();
    }

    isDraggable() {
      return (this._headerSpr != null) && this.isOpen();
    }

    setCloseHandler() {
      return this._closeHandler;
    }

    callCloseHandler() {
      if (this._closeHandler != null) {
        return this._closeHandler();
      }
    }

    setDraggingHandler() {
      return this._dragHandler;
    }

    setDragEndHandler() {
      return this._dragEndHandler;
    }

    // * Стандартная позиция кнопки "закрыть"
    closeButtonPosition() {
      return {
        x: this.width - 24,
        y: 4
      };
    }

    open() {
      if (this.isOpen()) {
        return;
      }
      this._open();
      this._afterOpen();
    }

    close() {
      if (!this.isOpen()) {
        return;
      }
      this._close();
      this._afterClose();
    }

    rootImageFolder() {
      return "AABS";
    }

    update() {
      super.update();
      //@_updateMouseCheckThread()
      this._updateDragging();
      return this._registerMouseInOut();
    }

  };
  AA.register(FloatingWindow);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.LIBS.FloatingWindow.prototype;
  _._initFloatingSystem = function() {
    if ($gameTemp._floatingWindows == null) {
      // * Создаём массив окон, он нужен для правильного
      // закрытия окон (по очереди) и перемещения drag and drop
      // с учётом верхнего окна
      $gameTemp._floatingWindows = [];
    }
    // * Вспомогательная переменная, чтобы не вызывать методы каждый кадр
    this._mouseIn = false;
    // * Тоже вспомогательная переменная
    this._dragging = false;
  };
  _._moveToStartPosition = function() {
    return this.moveToCenter(Graphics.width / 2, Graphics.height / 2);
  };
  _._closeButtonClick = function() {
    // * При исчезании, кнопка не успевает себя "удалить"
    $gameTemp.kdButtonUnderMouse = null;
    this.callCloseHandler();
    return this.close();
  };
  (function() {    // * DRAGGING
    // -----------------------------------------------------------------------
    _._updateDragging = function() {
      if (!this.isDraggable()) {
        return;
      }
      // * Если мы уже двигаем окно, но мышка вышла за границы, то можно дальше двигать
      // * Только если мышка не в окне и не двигали ранее, то не проверяем
      if (this._mouseIn === false && this._dragging === false) {
        return;
      }
      if (TouchInput.isLongPressed()) {
        if (this._dragging === false) {
          this._onDragStart();
        } else {
          this._onDragging();
        }
      } else {
        this._stopDragging();
      }
    };
    _._onDragStart = function() {
      // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
      this.opacity = 200;
      this._deltaXY = this.getDeltaXY();
      this._dragging = true;
    };
    _.getDeltaXY = function() {
      var dx, dy;
      dx = TouchInput.x - this.x;
      dy = TouchInput.y - this.y;
      return new PIXI.Point(dx, dy);
    };
    _._onDragging = function() {
      this.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
      if (this._dragHandler != null) {
        return this._dragHandler();
      }
    };
    _._stopDragging = function() {
      if (this._dragging === true) {
        this._dragging = false;
        this.opacity = 255;
        if (this._dragEndHandler != null) {
          this._dragEndHandler();
        }
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * CREATE ELEMENTS
    // -----------------------------------------------------------------------
    _._loadBackground = function() {
      return AA.Utils.loadImageAsync(this.rootImageFolder(), this.backgroundImage).then(this._createParts.bind(this));
    };
    _._createParts = function(bitmap) {
      this.bitmap = bitmap;
      this._createHeader();
      this._createCloseButton();
      this._moveToStartPosition();
    };
    _._createHeader = function() {
      if (this.headerImage == null) {
        this._updateDragging = function() {};
        return;
      } else {
        //if @headerImage == ""
        //    return
        this._headerSpr = AASprite.FromImg(this.headerImage, this.rootImageFolder());
        this.addChild(this._headerSpr);
      }
    };
    _._createCloseButton = function() {};
    //@_closeButton = new KDCore.ButtonM("windowCloseButton", false, @rootImageFolder())
    //@addChild @_closeButton
    //@_closeButton.move @closeButtonPosition()
    //@_closeButton.addClickHandler @_closeButtonClick.bind(@)

    // * Наследники создают свои элементы в этом методе
    _._createContent = function() {}; // * EMPTY
  })();
  (function() {    // -----------------------------------------------------------------------

    // * MOUSE
    // -----------------------------------------------------------------------
    
    // * Определение если мышка в области окна
    _._registerMouseInOut = function() {
      if (!this.isOpen()) {
        return;
      }
      if (this.isMouseIn()) {
        if (this._mouseIn === false) {
          this._mouseIn = true;
          this._onMouseIn();
        }
      } else {
        if (this._mouseIn === true) {
          this._mouseIn = false;
          this._onMouseOut();
        }
      }
    };
    // * Используется похожая система что и в KDCore.ButtonM
    _._onMouseIn = function() {
      return $gameTemp.floatingWindowUnderMouse = this;
    };
    _._onMouseOut = function() {
      if ($gameTemp.floatingWindowUnderMouse === this) {
        return $gameTemp.floatingWindowUnderMouse = null;
      }
    };
    // * Будем проверять мышка ли в окне только при открытом окне
    _._createMouseCheckThread = function() {};
    //@_mouseCheckThread = new AATimedUpdate(1, @_registerMouseInOut.bind(@))
    //@_mouseCheckThread.applyTimeRange(0, 2)
    //@_updateMouseCheckThread = => @_mouseCheckThread.update()
    //@_mouseCheckThread.call()

    // * Когда окно закрывается, никаких проверок, обнуляем метод
    _._destroyMouseCheckThread = function() {};
    //@_mouseCheckThread = null
    //@_updateMouseCheckThread = ->

    //?DYNAMIC
    _._updateMouseCheckThread = function() {}; // * EMPTY
  })();
  (function() {    // -----------------------------------------------------------------------

    // * OPEN OR CLOSE
    // -----------------------------------------------------------------------
    _._open = function() {
      var ref;
      this.visible = true;
      $gameTemp._floatingWindows.push(this);
      // * Окно, которое открывается, всегда снова выше остальных
      if ((ref = this.mainParent) != null) {
        ref.addChild(this);
      }
      return this._createMouseCheckThread();
    };
    _._afterOpen = function() {}; // * EMPTY
    _._close = function() {
      this.visible = false;
      this.removeFromParent();
      $gameTemp._floatingWindows.delete(this);
      this._onMouseOut();
      return this._destroyMouseCheckThread();
    };
    _._afterClose = function() {}; // * EMPTY
  })();
})();

(function() {  // ■ END PRIVATE.coffee
  //---------------------------------------------------------------------------

  // * Если окно под курсором, нельзя нажимать на карте для движения игрока
  // -----------------------------------------------------------------------
  var alias_SM_isAnyButtonPressed;
  //@[ALIAS]
  alias_SM_isAnyButtonPressed = Scene_Map.prototype.isMapTouchOk;
  Scene_Map.prototype.isMapTouchOk = function() {
    if ($gameTemp.floatingWindowUnderMouse != null) {
      return false;
    } else {
      return alias_SM_isAnyButtonPressed.call(this);
    }
  };
})();

// Generated by CoffeeScript 2.5.1
// * Расширения KDCore (в основном взяты из старой версии 1.2.3)
(function() {
  var StringsLoader;
  Array.prototype.include = function(value) {
    return this.indexOf(value) !== -1;
  };
  TouchInput.getMousePosition = function() {
    return new KDCore.Point(this.x, this.y);
  };
  Game_CharacterBase.prototype.toPoint = function() {
    return new KDCore.Point(this.x, this.y);
  };
  Sprite_Character.prototype.toPoint = function() {
    return new KDCore.Point(this.x, this.y);
  };
  Array.prototype.toPoint = function() {
    return new KDCore.Point(this[0], this[1]);
  };
  KDCore.Point.prototype.toPoint = function() {
    return this;
  };
  AA.w = function(e) {
    return KDCore.warning(e);
  };
  //@[EXTEND]
  AA.Utils = KDCore.Utils;
  StringsLoader = (function() {
    class StringsLoader {
      constructor(_parameters) {
        this._parameters = _parameters;
      }

      loadAllStringsToObject(object) {
        var strings;
        strings = this._collect(object);
        this._writeNewString(object, strings);
      }

      _collect(object) {
        var properties, strings;
        properties = Object.getOwnPropertyNames(object);
        strings = properties.filter(function(item) {
          return item.includes("STRING_");
        });
        return strings;
      }

      _writeNewString(object, strings) {
        var i, len, string;
        for (i = 0, len = strings.length; i < len; i++) {
          string = strings[i];
          this._setStringFromPluginParametersToObject(object, string);
        }
      }

      _setStringFromPluginParametersToObject(object, stringName) {
        var newValue;
        newValue = this._parameters[stringName];
        if (newValue) {
          object[stringName] = newValue;
        }
      }

      //?{NEW}
      loadAllStringsToObjectFromJSON(object, data) {
        var i, len, string, strings;
        strings = this._collect(object);
        for (i = 0, len = strings.length; i < len; i++) {
          string = strings[i];
          this._setStringFromJSONDataToObject(object, data, string);
        }
      }

      _setStringFromJSONDataToObject(object, data, stringName) {
        var newValue;
        newValue = data[stringName];
        if (newValue != null) {
          object[stringName] = newValue;
        }
      }

    };

    KDCore.StringsLoader = StringsLoader;

    return StringsLoader;

  }).call(this);
})();

(function () {

    /**
     * Корректировка округления десятичных дробей.
     * (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)
     *
     * @param {String}  type  Тип корректировки.
     * @param {Number}  value Число.
     * @param {Integer} exp   Показатель степени (десятичный логарифм основания корректировки).
     * @returns {Number} Скорректированное значение.
     */
    KDCore.SDK.decimalAdjust = function (type, value, exp) {
        // Если степень не определена, либо равна нулю...
        if (typeof exp === 'undefined' || +exp === 0) {
            return Math[type](value);
        }
        value = +value;
        exp = +exp;
        // Если значение не является числом, либо степень не является целым числом...
        if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
            return NaN;
        }
        // Сдвиг разрядов
        value = value.toString().split('e');
        value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
        // Обратный сдвиг
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    };

    KDCore.SDK.applyInterface = function (targetClass, interfacex) {
        for (var i in interfacex) {
            if (interfacex.hasOwnProperty(i)) {
                targetClass.prototype[i] = interfacex[i];
            }
        }
    };

})();
//$[1.5.2 Support]
function PHLoger() {
    throw new Error('This is a static class');
}

// * COMMON ===================================================================
(function () {

    String.prototype.replaceAll = function (search, replacement) {
        var target;
        target = this;
        return target.split(search).join(replacement);
    };

    Date.prototype.yyyymmdd = function () {
        var mm = this.getMonth() + 1;
        var dd = this.getDate();
        var time = this.toLocaleTimeString().replaceAll(":", "_");

        return [this.getFullYear(),
            (mm > 9 ? '' : '0') + mm,
            (dd > 9 ? '' : '0') + dd,
            time
        ].join('_');
    };

})();

// * MAIN ====================================================================

(function () {

    if (!Utils.isNwjs()) return; //*[NODE.JS ONLY]

    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    var localPathDir = function () {
        var base = path.dirname(process.mainModule.filename);
        var localFileDirectoryPath = path.join(base, 'logs/');
        return localFileDirectoryPath;
    };

    (function () {
        var _SceneManager_catchException_PH = SceneManager.catchException;
        SceneManager.catchException = function (e) {
            PHLoger.OnError(e);
            _SceneManager_catchException_PH.call(this, e);
            PHLoger.ShowDevTools();
        };

        var _SceneManager_onError_PH = SceneManager.onError;
        SceneManager.onError = function (e) {
            PHLoger.OnError(e);
            _SceneManager_onError_PH.call(this, e);
            PHLoger.ShowDevTools();
        };

        var _SceneManager_terminate_PH = SceneManager.terminate;
        SceneManager.terminate = function () {
            PHLoger.WriteLogToFile();
            _SceneManager_terminate_PH.call(this);
        };
    })();

    (function () {

        //@[DEFINES]
        var _ = PHLoger;

        _.IsNeedShowConsole = true;

        _.C_Error = console.error;
        _.C_Warn = console.warn;

        console.error = function (message) {
            _.C_Error(message);
            _.Log('ERROR!', message);
            _.WriteLogToFile();
        };

        console.warn = function (message) {
            _.C_Warn(message);
            _.Log('WARNING!', message);
        };

        _.InitSession = function () {
            _.LogFileName = "Log_" + (new Date()).yyyymmdd() + ".txt";
            _.LogContent = [];
            _.Log("PHLoger", "Started");
            _.Log("Alpha ABS build", AlphaABS.Build);
            _.Log("Help and support", "https://discord.gg/8EE6PMv");
            _.Log("Patreon page", "https://www.patreon.com/KageDesu");
            //_.WriteLogToFile(); // * NOT NEED SPAM AT START!
        };

        _.WriteLogToFile = function () {
            var dir = localPathDir();
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            var outPath = path.join(dir, _.LogFileName);
            var content = _.LogContent.join(os.EOL);
            fs.writeFileSync(outPath, content, 'utf8');
        };

        _.LogAndWrite = function (name, message) {
            _.Log(name, message);
            _.WriteLogToFile();
        };

        _.Log = function (name, message) {
            _.PushToLog(name);
            _.PushToLog(message);
            _.PushToLog("----------");
        };

        _.PushToLog = function (message) {
            _.LogContent.push(message);
        };

        _.OnError = function (error) {
            if (error != null) {
                _.Log(error.name, error.stack);
            }
            _.WriteLogToFile();
        };

        _.ShowDevTools = function () {
            if (_.IsNeedShowConsole == true && Utils.isNwjs()) {
                require('nw.gui').Window.get().showDevTools();
            }
        };

    })();

})();


// ? {INIT LOG}
if (Utils.isNwjs())
    PHLoger.InitSession();
// Generated by CoffeeScript 2.5.1
(function() {
  var StatesActorWindow;
  StatesActorWindow = class StatesActorWindow extends AA.LIBS.FloatingWindow {
    constructor(scene) {
      super(scene, "StatWin_Back", "");
      this._currentActorIndex = 0;
      this._equipInvCategoryIndex = 0;
    }

    _initFloatingSystem() {
      super._initFloatingSystem();
      return this._loadSettings();
    }

    nextActor() {
      this._currentActorIndex += 1;
      return this.refreshAllInfo();
    }

    prevActor() {
      if (this._currentActorIndex > 0) {
        this._currentActorIndex -= 1;
        return this.refreshAllInfo();
      }
    }

    showPrevPage() {
      var ref;
      return (ref = this.equipInv) != null ? ref.showPrevPage() : void 0;
    }

    showNextPage() {
      var ref;
      return (ref = this.equipInv) != null ? ref.showNextPage() : void 0;
    }

    setEquipInvCategory(_equipInvCategoryIndex) {
      this._equipInvCategoryIndex = _equipInvCategoryIndex;
      this.equipInv.drawActorInvEquips(this.actor(), this._equipInvCategoryIndex);
    }

    equipsInvCellClicked(index) {
      this.equipInv.cellClick(index);
      return this.refreshAllInfo();
    }

    actor() {
      return $gameParty.battleMembers()[this._currentActorIndex];
    }

    optimizeEquipments() {
      var ref;
      if ((ref = this.actor()) != null) {
        ref.optimizeEquipments();
      }
      return this.refreshAllInfo();
    }

    clearEquipments() {
      var ref;
      if ((ref = this.actor()) != null) {
        ref.clearEquipments();
      }
      return this.refreshAllInfo();
    }

    // * REFRESH METHOD
    refreshAllInfo() {
      var e, l;
      try {
        l = this.actor();
        if (l == null) {
          return;
        }
        this.selector.drawActorName(l.name());
        this.refreshSelectorArrows();
        this.profile.drawActorProfile(l.profile());
        this.mainInfo.drawActorStats(l);
        this.statsInfo.drawActorStats(l);
        this.equips.drawActorEquips(l);
        this.equipInv.drawActorInvEquips(l, this._equipInvCategoryIndex);
      } catch (error) {
        e = error;
        console.warn(e);
      }
    }

    refreshSelectorArrows() {
      var l, r, ref;
      l = this._currentActorIndex > 0;
      r = this._currentActorIndex < ($gameParty.battleMembers().length - 1);
      return (ref = this.selector) != null ? ref.refreshArrows(l, r) : void 0;
    }

    _createCloseButton() {
      var img0, img1;
      if (this.settings.isCloseButtonVisible !== true) {
        return;
      }
      this.closeBtn = new KDCore.Button();
      img0 = ImageManager.loadAA(this.settings.closeButtonImg);
      img1 = ImageManager.loadAA(this.settings.closeButtonHoverImg);
      this.closeBtn.setButtonImages(img0, img1, img0, img0);
      this.closeBtn.move(this.settings.closeButtonMarginX, this.settings.closeButtonMarginY);
      this.closeBtn.addClickHandler(this._closeButtonClick.bind(this));
      return this.add(this.closeBtn);
    }

    _createContent() {
      this._createActorSelector();
      this._createActorMainInfo();
      this._createActorStates();
      this._createActorEquipments();
      this._createActorDescription();
      this._createActorEquipInv();
      return this.move(AA.Utils.jsonPos(this.settings.position));
    }

    _createActorSelector() {
      this.selector = new AA.LIBS.AASpriteActorSelector();
      this.selector.move(AA.Utils.jsonPos(this.settings.actorSelector.position));
      return this.add(this.selector);
    }

    _createActorMainInfo() {
      this.mainInfo = new AA.LIBS.AASpriteActorStatsMainInfo();
      return this.add(this.mainInfo);
    }

    _createActorStates() {
      this.statsInfo = new AA.LIBS.AASpriteActorCharacsInfo();
      return this.add(this.statsInfo);
    }

    _createActorEquipments() {
      this.equips = new AA.LIBS.AASpriteActorEquipsListInfo();
      return this.add(this.equips);
    }

    _createActorDescription() {
      this.profile = new AA.LIBS.AASpriteActorDescription();
      this.profile.move(AA.Utils.jsonPos(this.settings.description.position));
      return this.add(this.profile);
    }

    _createActorEquipInv() {
      this.equipInv = new AA.LIBS.AASpriteActorEquipsInv();
      return this.add(this.equipInv);
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

    _afterClose() {
      return $gameTemp._aaStatusWindowEquipInvActor = null;
    }

  };
  AA.register(StatesActorWindow);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABS_Input.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var DefaultKeyConfig, IKey, KEYS_GAME, KEYS_RAW, UNSAFE;
  //?[FROM ATBS]
  DefaultKeyConfig = ['w', 'd', 's', 'a', 'e', 'q', 'w', 'd', 's', 'a', '1', '2', '3', '4', '5', '6', '7', '8', 'r', 'f', 'control', 'v', 'c', 'i', 't', 'w', 'a', 's', 'd', 'o', 'p', 'g', 'h', 'j'];
  UNSAFE = ['q', 'w', 'x', 'z', 'space'];
  KEYS_RAW = [];
  KEYS_GAME = [];
  Input.isCancel = function() {
    if (Input.isGamepad()) {
      return Input.isTriggered('pageup'); //LB
    } else {
      return Input.isTriggered('cancel') || TouchInput.isCancelled();
    }
  };
  Input._signXAA = function() {
    var x;
    x = 0;
    if (this.isPressed(AA.LIBS.IKey.ALML())) {
      x--;
    }
    if (this.isPressed(AA.LIBS.IKey.ALMR())) {
      x++;
    }
    return x;
  };
  Input._signYAA = function() {
    var y;
    y = 0;
    if (this.isPressed(AA.LIBS.IKey.ALMU())) {
      y--;
    }
    if (this.isPressed(AA.LIBS.IKey.ALMD())) {
      y++;
    }
    return y;
  };
  Input._loadAAAlterMovement = function() {
    Input._signX = Input._signXAA.bind(this);
    Input._signY = Input._signYAA.bind(this);
    AA.log("Activated Alternative Movement Input");
  };
  IKey = function() {
    throw new Error('This is a static class');
  };
  IKey.CP_W = function() {
    return KEYS_GAME[0];
  };
  IKey.CP_D = function() {
    return KEYS_GAME[1];
  };
  IKey.CP_S = function() {
    return KEYS_GAME[2];
  };
  IKey.CP_A = function() {
    return KEYS_GAME[3];
  };
  IKey.WC = function() {
    return KEYS_GAME[4];
  };
  IKey.TS = function() {
    return KEYS_GAME[5];
  };
  IKey.SC_W = function() {
    return KEYS_GAME[6];
  };
  IKey.SC_D = function() {
    return KEYS_GAME[7];
  };
  IKey.SC_S = function() {
    return KEYS_GAME[8];
  };
  IKey.SC_A = function() {
    return KEYS_GAME[9];
  };
  IKey.SP_1 = function() {
    return KEYS_GAME[10];
  };
  IKey.SP_2 = function() {
    return KEYS_GAME[11];
  };
  IKey.SP_3 = function() {
    return KEYS_GAME[12];
  };
  IKey.SP_4 = function() {
    return KEYS_GAME[13];
  };
  IKey.SP_5 = function() {
    return KEYS_GAME[14];
  };
  IKey.SP_6 = function() {
    return KEYS_GAME[15];
  };
  IKey.SP_7 = function() {
    return KEYS_GAME[16];
  };
  IKey.SP_8 = function() {
    return KEYS_GAME[17];
  };
  IKey.WR = function() {
    return KEYS_GAME[18];
  };
  IKey.TN = function() {
    return KEYS_GAME[19];
  };
  IKey.AR = function() {
    return KEYS_GAME[20];
  };
  IKey.BL = function() {
    return KEYS_GAME[21];
  };
  IKey.SM = function() {
    return KEYS_GAME[22];
  };
  IKey.INV = function() {
    return KEYS_GAME[23];
  };
  IKey.TALL = function() {
    return KEYS_GAME[24];
  };
  IKey.ALMU = function() {
    return KEYS_GAME[25];
  };
  IKey.ALMD = function() {
    return KEYS_GAME[26];
  };
  IKey.ALML = function() {
    return KEYS_GAME[27];
  };
  IKey.ALMR = function() {
    return KEYS_GAME[28];
  };
  IKey.SKLW = function() {
    return KEYS_GAME[29];
  };
  IKey.STAW = function() {
    return KEYS_GAME[30];
  };
  IKey.SWL1 = function() {
    return KEYS_GAME[31];
  };
  IKey.SWL2 = function() {
    return KEYS_GAME[32];
  };
  IKey.SWL3 = function() {
    return KEYS_GAME[33];
  };
  IKey.loadDefaultKeyConfig = function() {
    return this.loadKeyConfig(DefaultKeyConfig.slice(0)); //Clone
  };
  IKey.loadKeyConfig = function(keyBindingsArray) {
    var i, j, ref;
    KEYS_RAW = keyBindingsArray;
    for (i = j = 0, ref = KEYS_RAW.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (KEYS_RAW[i] != null) {
        KEYS_GAME[i] = IKey.convertUnsafeSymbols(KEYS_RAW[i]);
      }
    }
  };
  IKey.convertUnsafeSymbols = function(symbol) {
    if (symbol == null) {
      return '';
    }
    symbol = symbol.toLowerCase();
    if (!UNSAFE.include(symbol)) {
      return symbol;
    }
    if (symbol === 'q') {
      return 'pageup';
    }
    if (symbol === 'w') {
      return 'pagedown';
    }
    if (symbol === 'x') {
      return 'escape';
    }
    if (symbol === 'z') {
      return 'ok';
    }
    if (symbol === 'space') {
      return 'ok';
    }
  };
  IKey.convertIKeyToLetter = function(symbol) {
    if (symbol === IKey.CP_W()) {
      return KEYS_RAW[0];
    }
    if (symbol === IKey.CP_D()) {
      return KEYS_RAW[1];
    }
    if (symbol === IKey.CP_S()) {
      return KEYS_RAW[2];
    }
    if (symbol === IKey.CP_A()) {
      return KEYS_RAW[3];
    }
    if (symbol === IKey.WC()) {
      return KEYS_RAW[4];
    }
    if (symbol === IKey.TS()) {
      return KEYS_RAW[5];
    }
    if (symbol === IKey.SC_W()) {
      return KEYS_RAW[6];
    }
    if (symbol === IKey.SC_D()) {
      return KEYS_RAW[7];
    }
    if (symbol === IKey.SC_S()) {
      return KEYS_RAW[8];
    }
    if (symbol === IKey.SC_A()) {
      return KEYS_RAW[9];
    }
    if (symbol === IKey.SP_1()) {
      return KEYS_RAW[10];
    }
    if (symbol === IKey.SP_2()) {
      return KEYS_RAW[11];
    }
    if (symbol === IKey.SP_3()) {
      return KEYS_RAW[12];
    }
    if (symbol === IKey.SP_4()) {
      return KEYS_RAW[13];
    }
    if (symbol === IKey.SP_5()) {
      return KEYS_RAW[14];
    }
    if (symbol === IKey.SP_6()) {
      return KEYS_RAW[15];
    }
    if (symbol === IKey.SP_7()) {
      return KEYS_RAW[16];
    }
    if (symbol === IKey.SP_8()) {
      return KEYS_RAW[17];
    }
    if (symbol === IKey.WR()) {
      return KEYS_RAW[18];
    }
    if (symbol === IKey.TN()) {
      return KEYS_RAW[19];
    }
    if (symbol === IKey.AR()) {
      return KEYS_RAW[20];
    }
    if (symbol === IKey.BL()) {
      return KEYS_RAW[21];
    }
    if (symbol === IKey.SM()) {
      return KEYS_RAW[22];
    }
    if (symbol === IKey.INV()) {
      return KEYS_RAW[23];
    }
    if (symbol === IKey.TALL()) {
      return KEYS_RAW[24];
    }
    if (symbol === IKey.ALMU()) {
      return KEYS_RAW[25];
    }
    if (symbol === IKey.ALMD()) {
      return KEYS_RAW[26];
    }
    if (symbol === IKey.ALML()) {
      return KEYS_RAW[27];
    }
    if (symbol === IKey.ALMR()) {
      return KEYS_RAW[28];
    }
    if (symbol === IKey.SKLW()) {
      return KEYS_RAW[29];
    }
    if (symbol === IKey.STAW()) {
      return KEYS_RAW[30];
    }
    if (symbol === IKey.SWL1()) {
      return KEYS_RAW[31];
    }
    if (symbol === IKey.SWL2()) {
      return KEYS_RAW[32];
    }
    if (symbol === IKey.SWL3()) {
      return KEYS_RAW[33];
    }
    return "";
  };
  IKey.isTriggeredWeapCircleIndex = function() {
    if (Input.isTriggered(IKey.SC_W())) {
      return 0;
    }
    if (Input.isTriggered(IKey.SC_D())) {
      return 1;
    }
    if (Input.isTriggered(IKey.SC_S())) {
      return 2;
    }
    if (Input.isTriggered(IKey.SC_A())) {
      return 3;
    }
    return null;
  };
  IKey.isTriggeredSkillPanelIndex = function() {
    if (Input.isTriggered(IKey.SP_1())) {
      return 1;
    }
    if (Input.isTriggered(IKey.SP_2())) {
      return 2;
    }
    if (Input.isTriggered(IKey.SP_3())) {
      return 3;
    }
    if (Input.isTriggered(IKey.SP_4())) {
      return 4;
    }
    if (Input.isTriggered(IKey.SP_5())) {
      return 5;
    }
    if (Input.isTriggered(IKey.SP_6())) {
      return 6;
    }
    if (Input.isTriggered(IKey.SP_7())) {
      return 7;
    }
    if (Input.isTriggered(IKey.SP_8())) {
      return 8;
    }
    return null;
  };
  IKey.getGameRawKeys = function() {
    return KEYS_RAW;
  };
  IKey.getGameKeyByIndex = function(index) {
    return KEYS_GAME[index];
  };
  IKey.changeRawKey = function(index, key) {
    KEYS_RAW[index] = key;
    return KEYS_GAME[index] = this.convertUnsafeSymbols(key);
  };
  AlphaABS.register(IKey);
  AlphaABS.LIBS.IKey = IKey;
})();

// ■ END ABS_Input.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ System.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

AlphaABS.SYSTEM = {};
var LOGW = new KDCore.DevLog("Alpha ABS");
LOGW.on();
LOGW.setColors(KDCore.Color.ORANGE, KDCore.Color.BLACK.getLightestColor(100));

AA.LOCALE = AlphaABS.SYSTEM;

(function ($) {
  $.EXTENSIONS = {};

  var SDK = KDCore.SDK;
  SDK.setConstantToObject($, 'FRAMES_PER_SECOND', 60);
  SDK.setConstantToObject($, 'FONT', 'VL-Gothic-Regular'); //TODO: ЭТО НАДО В ПАРАМЕТРЫ

  $.LOGW = LOGW;

  $.STRING_ALERT_NEEDTARGET = 'Need target';
  $.STRING_ALERT_TOFAR = 'Target too far';
  $.STRING_ALERT_INTERRUPT = 'Action interrupt';
  $.STRING_ALERT_NOAUTOA = "Can't use attack now";
  $.STRING_ALERT_NOUSE = "Can't use action now";
  $.STRING_ALERT_NOCHARGES = "Can't use, no charges";
  $.STRING_ALERT_RECHARGE = 'Action is not ready';
  $.STRING_ALERT_CASTMOVE = "Can't use while moving";
  $.STRING_ALERT_NOINBATTLE = "Need get out of the battle";
  $.STRING_ALERT_NEWLEVEL = "Level up!";

  $.STRING_POPUP_EVADE = 'Evade';
  $.STRING_POPUP_MISS = 'Miss';
  $.STRING_POPUP_FAIL = 'Fail';
  $.STRING_POPUP_ABSORB = 'Absorb';
  $.STRING_POPUP_IMMUNE = 'Immune';
  $.STRING_POPUP_WEAK = 'Weak';
  $.STRING_POPUP_SKILL = 'Ready!';

  $.STRING_MENU_UIVIS = 'Show UI';
  $.STRING_MENU_UIPOS = 'Edit UI';
  $.STRING_MENU_KEYBIND = 'Controls';

  $.STRING_MENU_KB_KEY = 'Press any key';
  $.STRING_MENU_KB_TAB = 'Target select';
  $.STRING_MENU_KB_SKILLS = 'Skills panel';
  $.STRING_MENU_KB_CONTRL = 'Сontrol panel';
  $.STRING_MENU_KB_WEAPON = 'Weapon circle';
  $.STRING_MENU_KB_DEF = 'Reset to default';
  $.STRING_MENU_KB_BACK = 'Back';
  $.STRING_MENU_KB_SLOT = 'Item';
  $.STRING_MENU_KB_ATTACK = 'Attack';
  $.STRING_MENU_KB_FOLLOW = 'Follow';
  $.STRING_MENU_KB_JUMP = 'Jump';
  $.STRING_MENU_KB_ROTATE = 'Rotate';
  $.STRING_MENU_KB_LEFT = 'Left';
  $.STRING_MENU_KB_RIGHT = 'Right';
  $.STRING_MENU_KB_BOTTOM = 'Bottom';
  $.STRING_MENU_KB_TOP = 'Top';
  $.STRING_MENU_KB_WEAP = 'Weapons';

  $.STRING_SKILL_INFO_RADIUS = 'Radius: ';
  $.STRING_SKILL_INFO_RANGE = 'Range: ';
  $.STRING_SKILL_INFO_RANGE2 = 'Range: ';
  $.STRING_SKILL_INFO_CAST = 'Cast: ';
  $.STRING_SKILL_INFO_COOLDOWN = 'Cooldown: ';
  $.STRING_SKILL_INFO_DESCRIPTION = 'Description';
  $.STRING_SKILL_INFO_HAS = 'Has: ';
  $.STRING_SKILL_INFO_USE = 'Use: ';
  $.STRING_SKILL_INFO_CHARGES = 'Charges: ';
  $.STRING_SKILL_INFO_RELOADCHR = 'Reload charges: ';
  $.STRING_SKILL_INFO_ONTARGET = 'Need target';
  $.STRING_SKILL_INFO_ONTARGETALLY = 'Ally target or User';
  $.STRING_SKILL_INFO_ONUSER = 'On user';
  $.STRING_SKILL_INFO_AREA = 'Area select';
  $.STRING_SKILL_INFO_CIRCLE = 'Around user';
  $.STRING_SKILL_INFO_ZONE = 'Zone';
  $.STRING_SKILL_INFO_SEC = ' sec.';
  $.STRING_SKILL_INFO_TARGET = '<target>';
  $.STRING_SKILL_INFO_DAMAGE = 'Damage ';
  $.STRING_SKILL_INFO_RECOVER = 'Recover ';
  $.STRING_SKILL_INFO_DRAIN = 'Drain ';
  $.STRING_SKILL_INFO_MELEE = 'Melee ';
  $.STRING_SKILL_INFO_REPEATS = 'Multi Hits: ';


  $.STRING_WARNING_COMMON = "This command can't be executed on ABS map";
  $.STRING_WARNING_COMMON2 = "This command can't be executed while player in battle!";
  $.STRING_WARNING_COMMON3 = "This command not suported with ABS!";

  $.STRING_WARNING_COMMAND129 = "You can't remove party leader from party on ABS map!";
  $.STRING_WARNING_COMMAND321 = "You can't change actor class on ABS map!";

  $.STRING_WARNING_SKILLWC = "Weapon don't support casting";
  $.STRING_WARNING_SKILLOC = "Support only 'Battle Screen' items!";
  $.STRING_WARNING_SKILLWVR = "Weapon can't support Vector with radius";


  $.STRING_ERROR_SKILLNAN = "You need setup you project for Alpha ABS!"; //TODO: Добавить ссылку на инструкцию как это делать
  $.STRING_ERROR_OLDDATA = "Your project use old RPG Maker MV core files (js/), update files to 1.6.0 or above";

})(AlphaABS.SYSTEM);

// ■ END System.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
(function() {
  var AAEquipSlotSprite;
  AAEquipSlotSprite = class AAEquipSlotSprite extends AASprite {
    constructor() {
      super();
      this._create();
    }

    drawEquipForActor(equip) {
      var extraImg, icon;
      this._textSpr.clear();
      this._iconSpr.clear();
      if (equip != null) {
        extraImg = DataManager.getItemInvImage(equip);
        if (String.any(extraImg)) {
          icon = ImageManager.loadAA_Icon(extraImg);
        } else {
          icon = equip.iconIndex;
        }
        this._iconSpr.drawIcon(0, 0, icon, this.settings.equipIconSize);
        this._textSpr.drawTextFull(equip.name, this.settings.equipNameTextBox.position);
      } else {
        this._iconSpr.drawIcon(0, 0, this.settings.equipEmptyIconIndex, this.settings.equipIconSize);
        this._textSpr.drawTextFull(this.settings.equipEmptyText, this.settings.equipNameTextBox.position);
      }
    }

    _create() {
      this._loadSettings();
      this._createIconSpr();
      return this._createTextSpr();
    }

    _createIconSpr() {
      this._iconSpr = AASprite.FromBitmap(this.settings.equipIconSize, this.settings.equipIconSize);
      this._iconSpr.drawIcon(0, 0, this.settings.equipEmptyIconIndex, this.settings.equipIconSize);
      return this.add(this._iconSpr);
    }

    _createTextSpr() {
      var settings, txtSpr;
      settings = this.settings.equipNameTextBox;
      txtSpr = AASprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
      this.applyTextSettingsByExtraSettings(txtSpr, settings);
      //txtSpr.bitmap.fillAll KDCore.Color.RED
      this.add(txtSpr);
      txtSpr.drawTextFull(this.settings.equipEmptyText, settings.position);
      return this._textSpr = txtSpr;
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().equipments.settings;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AAEquipSlotSprite);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorCharacsInfo;
  AASpriteActorCharacsInfo = class AASpriteActorCharacsInfo extends AASprite {
    constructor() {
      super(ImageManager.loadAA('inventory_equipStatsBack'));
      this._create();
      this.drawActorStats($gameParty.leader());
    }

    drawActorStats(actor) {
      if (actor == null) {
        return;
      }
      return this._createStatesParamsValues(actor);
    }

    _create() {
      this._loadSettings();
      //@_createStatesParamsValues()
      return this.move(AA.Utils.jsonPos(this.settings.position));
    }

    // * Пересоздаётся, не отрисовывается
    _createStatesParamsValues(actor) {
      var a, s, sp;
      if (this._stats != null) {
        this.removeChild(this._stats);
        this._stats.visible = false;
        this._stats = null;
      }
      this._stats = new Sprite();
      a = actor;
      s = this.settings2.stats;
      if (s.atk.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("atk", a);
        sp.move(s.atk.position);
        this._stats.addChild(sp);
      }
      if (s.def.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("def", a);
        sp.move(s.def.position);
        this._stats.addChild(sp);
      }
      if (s.agi.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("agi", a);
        sp.move(s.agi.position);
        this._stats.addChild(sp);
      }
      if (s.mat.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("mat", a);
        sp.move(s.mat.position);
        this._stats.addChild(sp);
      }
      if (s.mdf.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("mdf", a);
        sp.move(s.mdf.position);
        this._stats.addChild(sp);
      }
      if (s.luk.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText2("luk", a);
        sp.move(s.luk.position);
        this._stats.addChild(sp);
      }
      return this.add(this._stats);
    }

    _loadSettings() {
      this.settings = this._settingsJSON().actorStats;
      return this.settings2 = AA.JSON.getUIMapInventorySettings().EquipmentStats;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AASpriteActorCharacsInfo);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorDescription;
  AASpriteActorDescription = class AASpriteActorDescription extends AASprite {
    constructor() {
      var ref;
      super(ImageManager.loadAA('StatWin_DescriptionBack'));
      this._create();
      this.drawActorProfile((ref = $gameParty.leader()) != null ? ref.profile() : void 0);
    }

    drawActorProfile(text) {
      if (this._description == null) {
        return;
      }
      this._description.contents.clear();
      return this._description.drawTextExWithPrepare(text, 0, 0, this.settings.profileBox.width + 150);
    }

    _create() {
      this._loadSettings();
      return this._createDesctiptionText();
    }

    _createDesctiptionText() {
      var p;
      p = this.settings.profileBox;
      if (KDCore.isMV()) {
        this._description = new Window_Base(p.x, p.y, p.width, p.height);
      } else {
        this._description = new Window_Base(new Rectangle(p.x, p.y, p.width, p.height));
      }
      this._description.setBackgroundType(2);
      this.addChild(this._description);
      this._description.standardFontSize = function() {
        return p.fontSize;
      };
      this._description.lineHeight = function() {
        return 12;
      };
      this._description.standardPadding = function() {
        return 0;
      };
      this._description.createContents();
      if ((p.fontFace != null) && AA.isPro()) {
        this._description.standardFontFace = function() {
          return p.fontFace;
        };
      }
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().description;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AASpriteActorDescription);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorEquipsInv;
  AASpriteActorEquipsInv = class AASpriteActorEquipsInv extends AASprite {
    constructor() {
      super();
      this._create();
      this._createController();
      this.drawActorInvEquips($gameParty.leader(), 0);
    }

    cellClick(index) {
      return this.controller.clickAt(index);
    }

    drawActorInvEquips(actor, categoryIndex) {
      if (actor == null) {
        return;
      }
      if (this.controller._itemDescWindow != null) {
        return;
      }
      this.controller.setStatusWindowActor(actor);
      this.controller.loadItemsInCategory(categoryIndex);
    }

    showPrevPage() {
      return this.controller.showPrevPage();
    }

    showNextPage() {
      return this.controller.showNextPage();
    }

    _create() {
      this._loadSettings();
      this._createHeader();
      this._createContent();
      this._createFooter();
      this._createController();
      return this.move(AA.Utils.jsonPos(this.settings.position));
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().equipmentsInventory;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

    _createHeader() {
      this._header = new AA.LIBS.AASpriteASEI_Header();
      return this.add(this._header);
    }

    _createContent() {
      this._content = new AA.LIBS.AASpriteASEI_Items();
      return this.add(this._content);
    }

    _createFooter() {
      this._footer = new AA.LIBS.AASpriteASEI_Footer();
      return this.add(this._footer);
    }

    _createController() {
      return this.controller = new AA.LIBS.ActorStatusWindowEquipInvController(this);
    }

    update() {
      super.update();
      return this.controller.update();
    }

  };
  AA.register(AASpriteActorEquipsInv);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorEquipsListInfo;
  AASpriteActorEquipsListInfo = class AASpriteActorEquipsListInfo extends AASprite {
    constructor() {
      super(ImageManager.loadAA('StatWin_EquipsBack'));
      this._create();
      this.drawActorEquips($gameParty.leader());
    }

    drawActorEquips(actor) {
      var e, i, j, len, ref, spr;
      if (actor == null) {
        return;
      }
      ref = actor.equips();
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        e = ref[i];
        spr = this._equipSprs[i];
        if (spr != null) {
          spr.drawEquipForActor(e);
        }
      }
    }

    _create() {
      this._loadSettings();
      this._createEquips();
      return this.move(AA.Utils.jsonPos(this.settings.position));
    }

    _createEquips() {
      var j, len, pos, ref, spr;
      this._equipSprs = [];
      ref = this.settings.equipPositions;
      for (j = 0, len = ref.length; j < len; j++) {
        pos = ref[j];
        spr = new AA.LIBS.AAEquipSlotSprite();
        spr.move(AA.Utils.jsonPos(pos));
        this._equipSprs.push(spr);
        this.add(spr);
      }
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().equipments;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AASpriteActorEquipsListInfo);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorSelector;
  AASpriteActorSelector = class AASpriteActorSelector extends AASprite {
    constructor() {
      var ref;
      super(ImageManager.loadAA('StatWin_SelectorDummy'));
      this._create();
      this.drawActorName((ref = $gameParty.leader()) != null ? ref.name() : void 0);
    }

    drawActorName(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.nameBox.position);
    }

    refreshArrows(isLeftEnable, isRightEnable) {
      this.arrowR.refreshState(isRightEnable);
      return this.arrowL.refreshState(isLeftEnable);
    }

    _create() {
      this._loadSettings();
      this._createActorNameText();
      this._createRigthArrow();
      return this._createLeftArrow();
    }

    _createActorNameText() {
      this._textSpr = AASprite.FromBitmap(this.settings.nameBox.textBoxWidth, this.settings.nameBox.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.nameBox);
      this.add(this._textSpr);
    }

    _createRigthArrow() {
      this.arrowR = new KDCore.ButtonM("StatWin_ActorArrowR", true, "AABS");
      this.arrowR.move(this.settings.selectArrows.right);
      this.add(this.arrowR);
      return this.arrowR.addClickHandler(function() {
        SoundManager.playCursor();
        return AA.UI.nextStatusWindowActor();
      });
    }

    _createLeftArrow() {
      this.arrowL = new KDCore.ButtonM("StatWin_ActorArrowL", true, "AABS");
      this.arrowL.move(this.settings.selectArrows.left);
      this.add(this.arrowL);
      return this.arrowL.addClickHandler(function() {
        SoundManager.playCursor();
        return AA.UI.prevStatusWindowActor();
      });
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().actorSelector;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AASpriteActorSelector);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteActorStatsMainInfo;
  AASpriteActorStatsMainInfo = class AASpriteActorStatsMainInfo extends AASprite {
    constructor() {
      super();
      this._stateIcons = [];
      this._create();
      this.drawActorStats($gameParty.leader());
    }

    drawActorStats(actor) {
      var e;
      try {
        if (actor == null) {
          return;
        }
        this._drawActorFace(actor.faceName(), actor.faceIndex());
        //@_drawActorGauges(actor)
        this._drawActorHPMP(actor);
        this._drawActorStatesAndBuffs(actor);
        this._drawActorClass(actor.currentClass().name);
        this._drawActorLevel(actor);
        this._drawNickname(actor.nickname());
      } catch (error) {
        e = error;
        console.warn(e);
      }
    }

    _drawActorFace(faceName, faceIndex) {
      this._face.setPortrait({faceName, faceIndex});
      this._face.refresh();
    }

    //TODO: обновлять динамически?
    //TODO: добавить текстовые значения
    _drawActorGauges(actor) {
      var ref, ref1;
      if ((ref = this.hpGauge) != null) {
        ref.drawGauge(actor.hpRate());
      }
      return (ref1 = this.mpGauge) != null ? ref1.drawGauge(actor.mpRate()) : void 0;
    }

    _drawActorHPMP(actor) {
      var text;
      this._textSprHP.clear();
      //@_textSprHP.bitmap.fillAll KDCore.Color.RED
      text = this.settings.hp_mp.hpTextBox.symbol + actor.hp + "/" + actor.mhp;
      this._textSprHP.drawTextFull(text, this.settings.hp_mp.hpTextBox.position);
      this._textSprMP.clear();
      //@_textSprHP.bitmap.fillAll KDCore.Color.RED
      text = this.settings.hp_mp.mpTextBox.symbol + actor.mp + "/" + actor.mmp;
      this._textSprMP.drawTextFull(text, this.settings.hp_mp.mpTextBox.position);
    }

    _drawActorStatesAndBuffs(actor) {
      var i, icon, icons, index, j, len, len1, ref, spr;
      ref = this._stateIcons;
      for (i = 0, len = ref.length; i < len; i++) {
        spr = ref[i];
        spr.clear();
      }
      icons = actor.allIcons();
      for (index = j = 0, len1 = icons.length; j < len1; index = ++j) {
        icon = icons[index];
        if (this._stateIcons[index] != null) {
          this._stateIcons[index].drawIcon(0, 0, icon, this.settings.statesIconSize);
        }
      }
    }

    _drawActorClass(text) {
      this.classTextSpr.clear();
      //@classTextSpr.bitmap.fillAll KDCore.Color.RED
      this.classTextSpr.drawTextFull(text, this.settings.classTextBox.position);
    }

    _drawActorLevel(actor) {
      var text;
      this._levelCurrentSpr.clear();
      //@_levelCurrentSpr.bitmap.fillAll KDCore.Color.RED
      this._levelCurrentSpr.drawTextFull(actor.level, this.settings.levelTextBox.position);
      this._levelNextExpSpr.clear();
      //@_levelNextExpSpr.bitmap.fillAll KDCore.Color.RED
      text = actor.currentExp() + "/" + actor.expForLevel(actor.level + 1);
      this._levelNextExpSpr.drawTextFull(text, this.settings.levelExpTextBox.position);
    }

    _drawNickname(text) {
      this._nicknameSpr.clear();
      //@_nicknameSpr.bitmap.fillAll KDCore.Color.RED
      return this._nicknameSpr.drawTextFull(text, this.settings.nicknameTextBox.position);
    }

    _create() {
      this._loadSettings();
      this._createActorFace();
      //@_createGauges() * Не использую
      this._createHPMPStats();
      this._createStatesAndBuffs();
      this._createClassText();
      this._createLevelLabels();
      this._createLevels();
      return this._createNickName();
    }

    _createActorFace() {
      var e, faceIndex, faceName;
      try {
        // * Тупая система
        faceName = $gameParty.leader().faceName();
        faceIndex = $gameParty.leader().faceIndex();
        this._face = new AA.LIBS.SpriteActorPortrait(5, {faceName, faceIndex});
        this._face.move(AA.Utils.jsonPos(this.settings.face.position));
        return this.add(this._face);
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    _createGauges() {
      this.hpGauge = new AA.LIBS.SpriteGauge("hp");
      this.hpGauge.scale.x = this.settings.gauges.HPGaugeScale;
      this.hpGauge.scale.y = this.settings.gauges.HPGaugeScale;
      this.hpGauge.move(AA.Utils.jsonPos(this.settings.gauges.HPGaugePosition));
      this.add(this.hpGauge);
      this.mpGauge = new AA.LIBS.SpriteGauge("mp");
      this.mpGauge.scale.x = this.settings.gauges.MPGaugeScale;
      this.mpGauge.scale.y = this.settings.gauges.MPGaugeScale;
      this.mpGauge.move(AA.Utils.jsonPos(this.settings.gauges.MPGaugePosition));
      this.add(this.mpGauge);
    }

    //@_textSprHP =
    _createHPMPStats() {
      var s;
      this._statsBack = AASprite.FromImg('StatWin_HPMPBack');
      this._statsBack.move(AA.Utils.jsonPos(this.settings.hp_mp.position));
      this.add(this._statsBack);
      s = this.settings.hp_mp.hpTextBox;
      this._textSprHP = AASprite.FromBitmap(s.textBoxWidth, s.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSprHP, s);
      this._statsBack.add(this._textSprHP);
      s = this.settings.hp_mp.mpTextBox;
      this._textSprMP = AASprite.FromBitmap(s.textBoxWidth, s.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSprMP, s);
      this._statsBack.add(this._textSprMP);
    }

    _createStatesAndBuffs() {
      var _icon, i, index, len, pos, ref;
      this._stateIcons = [];
      ref = this.settings.statesPositions;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        pos = ref[index];
        _icon = this._createStateIconSpr();
        _icon.move(AA.Utils.jsonPos(this.settings.statesPositions[index]));
        this.add(_icon);
        this._stateIcons.push(_icon);
      }
    }

    _createStateIconSpr(iconIndex) {
      var _icon;
      _icon = AASprite.FromBitmap(this.settings.statesIconSize, this.settings.statesIconSize);
      return _icon;
    }

    _createClassText() {
      return this.classTextSpr = this._createTextSprFromSettings(this.settings.classTextBox);
    }

    _createLevelLabels() {
      var levelLabelA, levelLabelB, text;
      levelLabelA = this._createTextSprFromSettings(this.settings.levelsLabelsTextBox);
      levelLabelA.move(AA.Utils.jsonPos(this.settings.levelTitlePosition));
      //levelLabelA.bitmap.fillAll KDCore.Color.RED
      levelLabelA.drawTextFull(TextManager.level, this.settings.levelsLabelsTextBox.position);
      levelLabelB = this._createTextSprFromSettings(this.settings.levelsLabelsTextBox);
      levelLabelB.move(AA.Utils.jsonPos(this.settings.nextLevelTitlePosition));
      //levelLabelB.bitmap.fillAll KDCore.Color.RED
      text = TextManager.expNext.replace('%1', TextManager.levelA);
      levelLabelB.drawTextFull(text, this.settings.levelsLabelsTextBox.position);
    }

    _createLevels() {
      this._levelCurrentSpr = this._createTextSprFromSettings(this.settings.levelTextBox);
      this._levelCurrentSpr.move(AA.Utils.jsonPos(this.settings.currentLevelPosition));
      this._levelNextExpSpr = this._createTextSprFromSettings(this.settings.levelExpTextBox);
      this._levelNextExpSpr.move(AA.Utils.jsonPos(this.settings.nextLevelExpPosition));
    }

    _createNickName() {
      return this._nicknameSpr = this._createTextSprFromSettings(this.settings.nicknameTextBox);
    }

    _createTextSprFromSettings(settings) {
      var txtSpr;
      txtSpr = AASprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
      this.applyTextSettingsByExtraSettings(txtSpr, settings);
      this.add(txtSpr);
      return txtSpr;
    }

    _loadSettings() {
      return this.settings = this._settingsJSON().actorInfo;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapStatesWindowSettings();
    }

  };
  AA.register(AASpriteActorStatsMainInfo);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Main.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var AXUI;

AXUI = {};

AXUI.Version = '0.1';

AXUI.register = function(library) {
  return AXUI[library.name] = library;
};

AlphaABS.AXUI = AXUI;

(function() {
  AXUI.POP_DEFAULT_STYLE = function() {
    return {
      fontName: null,
      fontSize: 28,
      italy: false,
      fontOutlineWidth: 3,
      fontOutlineColor: "#000000",
      iconSize: 32
    };
  };
  AXUI.POP_DEFAULT_EFFECT = function() {
    return {
      changeFontSize: 32,
      stayTime: 16
    };
  };
  AXUI.PopMachineModeEnum = {
    NONE: 0,
    TOP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4,
    CIRCLE: 5
  };
  Object.freeze(AXUI.PopMachineModeEnum);
})();

// ■ END AXUI_Main.coffee
//---------------------------------------------------------------------------

(function () {

    // * ABS
    var _Game_Interpreter_pluginCommand = Game_Interpreter.prototype.pluginCommand;
    Game_Interpreter.prototype.pluginCommand = function (command, args) {
        _Game_Interpreter_pluginCommand.call(this, command, args);
        if (command === 'ABS') {
            switch (args[0]) {
                case 'revive':
                    var revive = 5;
                    if (args[1])
                        revive = parseInt(args[1]);
                    if (args[2]) {
                        var x = $gameMap.events().filter(function (ev) {
                            return (ev.event().name == args[2]);
                        });
                        if (x.length > 0) {
                            x.first().setRevive(revive);
                        }
                    } else
                        this.character(this._eventId).setRevive(revive);
                    break;
                case 'loot':
                    if (AA.Parameters.get_IsEnemiesLootingVisual() && AA.isPro()) {
                        try {
                            var char = this.character(this._eventId);
                            if (char) {
                                var items = char.visualLoot();
                                this._aaPrepareVisualLoot(items);
                                AA.UI.setChestName(char.name());
                                AA.UI.setChestLootIcon();
                                this._aaShowVisualChest();
                            }
                        } catch (e) {
                            AA.warning('ABS vLoot plugin command', e);
                        }
                    } else
                        uAPI.loot(this._eventId);
                    break;
                case 'showUI':
                    AlphaABS.BattleUI.showUI();
                    break;
                case 'hideUI':
                    AlphaABS.BattleUI.hideUI();
                    break;
                case 'activate':
                    this._activateABSEnemy(args[1] || null);
                    break;
                case 'deactivate':
                    this._deactivateABSEnemy(args[1] || null);
                    break;
                case 'param':
                    this._onABSEnemyParam(args[1] || null, args[2] || null, args[3] || null);
                    break;
                case 'spawn': //spawn EventId (x y | regionId)
                    if (AlphaABS.Parameters.get_SpawnMapId() > 0) {
                        this._onABSSpawn(args[1], args[2], args[3] || null);
                    }
                    break;
                case 'spawnV': //spawn EventId (x y | regionId)
                    if (AlphaABS.Parameters.get_SpawnMapId() > 0) {
                        try {
                            var xx = $gameVariables.value(Number(args[2]));
                            var yy = null;
                            if (args[3] != null)
                                yy = $gameVariables.value(Number(args[3]));
                            this._onABSSpawn(args[1], xx, yy);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    break;
                case 'VisualChest': // Prepare Visual Chest
                    if (AA.isPro()) {
                        try {
                            this._aaPrepareVisualChest();
                            if (args[1]) {
                                AA.UI.setChestName(args[1]);
                            }
                        } catch (e) {
                            AA.warning('ABS VisualChest plugin command', e);
                        }
                    }
                    break;
                case 'VisualChestStored': // Prepare Visual Chest with saved items after close
                    if (AA.isPro()) {
                        try {
                            $gameTemp._visualChestRestrictionTypes = [];
                            this._aaPrepareVisualChestStored();
                            if (args[1]) {
                                AA.UI.setChestName(args[1]);
                            }
                            if (args[2]) {
                                AA.UI.setChestItemTypeLimit(args[2]);
                            }
                        } catch (e) {
                            AA.warning('ABS VisualChestStored plugin command', e);
                        }
                    }
                    break;
                case 'UserChest':
                    if (AA.isPro()) {
                        try {
                            this.setWaitMode('chest');
                            AA.UI.openUserChest();
                        } catch (e) {
                            AA.warning('ABS UserChest plugin command', e);
                        }
                    }
                    break;
            }
        }
    };


})();

(function(){
    
    // * ANIMAX

    //@[ALIAS]
    var _Game_Interpreter_pluginCommand_3434 = Game_Interpreter.prototype.pluginCommand;
    Game_Interpreter.prototype.pluginCommand = function (command, args) {
        _Game_Interpreter_pluginCommand_3434.call(this, command, args);
        if (command === 'ChangePlayerAnimationSet') {
            try {
                let animSetId = args[0];
                if(String.any(animSetId)) {
                    AA.ANIMAX.PluginCommand_ChangePlayerAnimationSet(animSetId);
                }
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'ResetPlayerAnimationSet') {
            try {
                AA.ANIMAX.PluginCommand_ChangePlayerAnimationSet(null);
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'PlayAnimationAction') {
            try {
                let actionName = args[0];
                let charaId = parseInt(args[1]);
                let isLoop = eval(args[2]);
                let isWait = eval(args[3]);
                AA.ANIMAX.PluginCommand_PlayAnimationAction(actionName, charaId, isLoop, isWait);
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'StopAnimationAction') {
            try {
                let charaId = parseInt(args[0]);
                AA.ANIMAX.PluginCommand_StopAnimationAction(charaId);
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'AddAnimaLayer') {
            try {
                let charaId = parseInt(args[0]);
                let layerName = args[1];
                let isRelative = eval(args[2]);
                AA.ANIMAX.PluginCommand_AddPart(charaId, layerName, isRelative);
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'RemoveAnimaLayer') {
            try {
                let charaId = parseInt(args[0]);
                let layerName = args[1];
                AA.ANIMAX.PluginCommand_RemovePart(charaId, layerName);
            } catch (e) {
                console.warn(e);
            }
        } else if (command === 'ClearAnimaLayers') {
            try {
                let charaId = parseInt(args[0]);
                AA.ANIMAX.PluginCommand_ClearParts(charaId);
            } catch (e) {
                console.warn(e);
            }
        }
    };

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Utils.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
AlphaABS.UTILS = {};

(function ($) {

  "use strict";

  var SDK = KDCore.SDK;

  $.printPoint = function (x, y) {
    return "[" + x + " ; " + y + "]";
  };

  $.distanceTo = function (a, b) {
    if (a === undefined || b === undefined) {
      return 0; //This is very very bad!
    }
    if (a === null || b === null) {
      return 0;
    }
    return $gameMap.distance(a.x, a.y, b.x, b.y);
  };

  $.inFront = function (charA, charB) {
    if(!$dataMap) return false;
    try {
      var d = charA.direction();
      var x2 = $gameMap.roundXWithDirection(charA.x, d);
      var y2 = $gameMap.roundYWithDirection(charA.y, d);
      return this.inPoint(charB, new KDCore.Point(x2, y2));
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.isFrontNeighbor = function(charA, charB) {
    var points = AlphaABS.UTILS._getNeighborPoints(charA);
    if (points.length > 0) {
      var a = AlphaABS.UTILS.inPoint(points[0], charB);
      var b = AlphaABS.UTILS.inPoint(points[1], charB);
      return a || b;
    }
    return false;
  };

  $._getNeighborPoints = function (charA) {
    try {
      var d = charA.direction();
      var result = [];
      switch (d) {
        case 8:
          result.push(new KDCore.Point(charA.x + 1, charA.y - 1));
          result.push(new KDCore.Point(charA.x - 1, charA.y - 1));
          break;
        case 4:
          result.push(new KDCore.Point(charA.x - 1, charA.y - 1));
          result.push(new KDCore.Point(charA.x - 1, charA.y + 1));
          break;
        case 6:
          result.push(new KDCore.Point(charA.x + 1, charA.y - 1));
          result.push(new KDCore.Point(charA.x + 1, charA.y + 1));
          break;
        case 2:
          result.push(new KDCore.Point(charA.x + 1, charA.y + 1));
          result.push(new KDCore.Point(charA.x - 1, charA.y + 1));
          break;
        default:
          return result;
      }
      return result;
    } catch (e) {
      console.error(e);
      return [];
    }
  };

  $.getEndPointFromCharToRange = function(charA, range) {
    try {
      if(range == 0) {
        return charA.toPoint();
      }
      var d = charA.direction();
      var result = [];
      var startPoint = charA.toPoint();
      var endPoint = null;
      switch (d) {
        case 8:
          endPoint = new KDCore.Point(startPoint.x, startPoint.y - range);
          break;
        case 4:
          endPoint = new KDCore.Point(startPoint.x - range, startPoint.y);
          break;
        case 6:
          endPoint = new KDCore.Point(startPoint.x + range, startPoint.y);
          break;
        case 2:
          endPoint = new KDCore.Point(startPoint.x, startPoint.y + range);
          break;
        default:
          break;
      }
      return endPoint;
    } catch (e) {
      console.error(e);
      return null;
    }
  };

  // * Thanks to Ryan Ye
  $.getEndPointFromChartToRangeNoFixed = function(charA, range, charB) {
    try { 
      var diffX = charA.x - charB.x;
      var diffY = charA.y - charB.y;
      var vectory_xy = Math.pow(Math.pow(diffX, 2) + Math.pow(diffY, 2), 0.5);
      var destX = charA.x - range * (diffX / vectory_xy);
      var destY = charA.y - range * (diffY / vectory_xy);
      return new KDCore.Point(destX, destY);
    } catch(e) {
      AA.warning(e, ' getEndPointFromChartToRangeNoFixedNew ');
      return charB;
    }
  };

  $.createLineBetweenPoints = function(point1, point2) {
    var line = [];
    var tempPoint = point1;
    var endRect = new Rectangle(point2.x - 0.5, point2.y - 0.5, 1.5, 1.5);
    var safeCount = 500;
    while(true) {
      safeCount--;
      //"CHECK POINT".p();
      tempPoint = AlphaABS.UTILS.SMath.moveTo(tempPoint, point2, 1);
      //"POINT".p(tempPoint);
      if (AlphaABS.UTILS.SMath.inRect(tempPoint, endRect)) {
          //"POINT END".p();
          break;
      }
      line.push(tempPoint.round());
      if(safeCount <= 0)
        break;
    }
    //"LINE POINTS".p(line.length);
    return line;
  };

  $.createStraightYLineBetweenPoints = function(xBase, y1, y2) {
    var line = [];

    var t1, t2;
    if(y1 > y2) {
      t1 = y2;
      t2 = y1;
    } else {
      t1 = y1;
      t2 = y2;
    }

    for(var i = t1; i<t2; i++) {
      line.push(new KDCore.Point(xBase, i));
    }

    return line;
  };

  $.createStraightXLineBetweenPoints = function (yBase, x1, x2) {
    var line = [];

    var t1, t2;
    if (x1 > x2) {
      t1 = x2;
      t2 = x1;
    } else {
      t1 = x1;
      t2 = x2;
    }

    for (var i = t1; i < t2; i++) {
      line.push(new KDCore.Point(i, yBase));
    }

    return line;
  };

  $.inDirection = function (charA, charB) {
    try {
      var d = charA.direction();
      switch (d) {
        case 8:
          return (charB.y <= charA.y);
        case 4:
          return (charB.x <= charA.x);
        case 6:
          return (charB.x >= charA.x);
        case 2:
          return (charB.y >= charA.y);
        default:
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inDirectionHard = function (charA, charB) {
    try {
      var inD = this.inDirection(charA, charB);
      if (!inD) {
        return false;
      }
      var d = charA.direction();
      switch (d) {
        case 8:
          return (charB.x == charA.x);
        case 4:
          return (charB.y == charA.y);
        case 6:
          return (charB.y == charA.y);
        case 2:
          return (charB.x == charA.x);
        default:
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inPoint = function (a, b) {
    try {
      if (!a) return false;
      if (!b) return false;
      if (a instanceof Game_Event) {
        return a.pos(b.x, b.y);
      } else if (b instanceof Game_Event) {
        return b.pos(a.x, a.y);
      } else 
        return (a.x == b.x && a.y == b.y);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inRadius = function (charA, radius, members) {
    try {
      var t = [];
      members.forEach(function (item) {
        if(radius == 0) {
          if(AlphaABS.UTILS.inFront(charA, item)) {
            t.push(item);
          }
        } else
          if (AlphaABS.UTILS.distanceTo(charA, item) < radius) {
            t.push(item);
          }
      });
      return t;
    } catch (e) {
      //console.error(e);
      return false;
    }
  };

  // * Треугольник
  // * Z - половина основания
  // * LEN - высота
  $.inTVisor = function (charA, len, z, members) {
    try {
      var t = [];
      members.forEach(function (item) {
        if (len == 0 || z == 0) {
          if (AlphaABS.UTILS.inFront(charA, item)) {
            t.push(item);
          }
        } else {
          if(AlphaABS.UTILS.inTriangle(charA, len, z, item)) {
            t.push(item);
          }
        }
      });
      return t;
    } catch (e) {
      return [];
    }
  };

  // * Прямо перед носом и по бокам
  $.inFrontAndSides = function(charA, members) {
    try {
      var t = [];
      members.forEach(function (item) {
        if (AlphaABS.UTILS.inFront(charA, item)) {
          t.push(item);
        } else if (AlphaABS.UTILS.isNeiborBySide(charA, item)) {
          t.push(item);
        }
      });
      return t;
    } catch (e) {
      return [];
    }
  };

  $.inTriangle = function(charA, len, z, d) {

    try {
    
      var tPoints = AlphaABS.UTILS.getTrianglePoints(charA, len, z);
      if(tPoints.length > 0) {

        var a = tPoints[0];
        var b = tPoints[1];
        var c = tPoints[2];

        var abcSquare = $.getTriangleSquare(a, b, c);
        var abdSquare = $.getTriangleSquare(a, b, d);
        var bcdSquare = $.getTriangleSquare(b, c, d);
        var cadSquare = $.getTriangleSquare(c, a, d);

        var sum = abdSquare + bcdSquare + cadSquare;
        return abcSquare >= sum;
      }

    } catch (e) {
      console.error(e);
    }
    return false;
  };

  $.getTriangleSquare = function(p1, p2, p3) {
    try {
       var d1 = (p1.x - p3.x) * (p2.y - p3.y);
       var d2 = (p2.x - p3.x) * (p1.y - p3.y);
       return Math.abs((d1 - d2) * 0.5);
    } catch (e) {
      console.error(e);
    }
    return 0;
  };

  // * Возвращает вершины треугольника
  $.getTrianglePoints = function (charA, len, z) {
    try {

      var points = [];

      points.push(charA.toPoint());

      var sp = points[0];
      var d = charA.direction();

      switch (d) {
        case 8:
          points.push(new KDCore.Point(sp.x - z, sp.y - len));
          points.push(new KDCore.Point(sp.x + z, sp.y - len));
          break;
        case 4:
          points.push(new KDCore.Point(sp.x - len, sp.y + z));
          points.push(new KDCore.Point(sp.x - len, sp.y - z));
          break;
        case 6:
          points.push(new KDCore.Point(sp.x + len, sp.y + z));
          points.push(new KDCore.Point(sp.x + len, sp.y - z));
          break;
        case 2:
          points.push(new KDCore.Point(sp.x - z, sp.y + len));
          points.push(new KDCore.Point(sp.x + z, sp.y + len));
          break;
        default:
          return false;
      }
      return points;

    } catch (e) {
      console.error(e);
      return [];
    }
  };

  $.isNeiborBySide = function(charA, charB) {
    try {
      var d = charA.direction();
      var point;
      switch (d) {
        case 4:
        case 6:
          point = new KDCore.Point(charA.x, charA.y + 1);
          if (point.isSame(charB))
            return true;
          else {
            point = new KDCore.Point(charA.x, charA.y - 1);
            if (point.isSame(charB))
              return true;
          }
          break;
        case 8:
        case 2:
          point = new KDCore.Point(charA.x - 1, charA.y);
          if (point.isSame(charB))
            return true;
          else {
            point = new KDCore.Point(charA.x + 1, charA.y);
            if (point.isSame(charB))
              return true;
          }
          break;
        default:
          return false;
      }
      return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.GetAllPointsInCircle = function(center, radius) {
    try {
      var result = [];
      var xCenter = center.x;
      var yCenter = center.y;
      for (var x = xCenter - radius; x <= xCenter; x++) {
        for (var y = yCenter - radius; y <= yCenter; y++) {
          // we don't have to take the square root, it's slow
          if ((x - xCenter) * (x - xCenter) + (y - yCenter) * (y - yCenter) <= radius * radius) {
            var xSym = xCenter - (x - xCenter);
            var ySym = yCenter - (y - yCenter);
            result.push(new KDCore.Point(x, y));
            result.push(new KDCore.Point(x, ySym));
            result.push(new KDCore.Point(xSym, y));
            result.push(new KDCore.Point(xSym, ySym));
          }
        }
      }
      return result;
    } catch (e) {
      console.error(e);
      return [];
    }
  };

  $.GetCornerCirclePoints = function(center, radius) {
    try {
      var result = [];
      var circlePoinst = $.GetAllPointsInCircle(center, radius + 1);
      result = circlePoinst.filter(function(a) {
        if($.distanceTo(center, a) > radius)
          return true;
        return false;
      });
      return result;
    } catch (e) {
      console.error(e);
      return [];
    }
  };

  $.toGlobalCoord = function (layer, coordSymbol) {
    return SDK.toGlobalCoord(layer, coordSymbol);
  };

  $.framesToTimeA = function (frames, oneSecond) {
    try {
      if (oneSecond === undefined) oneSecond = 60;
      var secs = Math.floor((frames + oneSecond) / oneSecond);
      var string = '';
      if (secs > 59) {
        var min = Math.floor(secs / 60);
        string = min + "m";
      } else {
        string = secs + "s";
      }
      return string;
    } catch (e) {
      console.error(e);
      return "!s";
    }
  };

  $.framesToTimeB = function (frames, oneSecond) {
    try {
      if (oneSecond === undefined) oneSecond = 60;
      var secs = Math.floor((frames + oneSecond) / oneSecond);
      var string = '';
      if (secs > 59) {
        var min = Math.floor(secs / 60);
        var minm = (min < 10) ? ('0' + min) : min;
        var secx = secs - (min * 60);
        secx = (secx < 10) ? ('0' + secx) : secx;
        string = min + ":" + secx;
      } else {
        string = '0:' + ((secs < 10) ? ('0' + secs) : secs);
      }
      return string;
    } catch (e) {
      console.error(e);
      return "!:!";
    }
  };

  $.getDirKey = function (char) {
    try {
      var t = char.direction();
      switch (t) {
        case 8:
          return 'u';
        case 4:
          return 'l';
        case 6:
          return 'r';
        case 2:
          return 'd';
        default:
          return 'r';
      }
    } catch (e) {
      console.error(e);
      return 'r';
    }
  };

  $.linkSprite = function (sprite1, sprite2) {
    try {
      var _r = 0; //right (from right)
      var _u = 0; //up

      if (SDK.toGlobalCoord(sprite1, 'x') < Graphics.width / 2) {
        _r = 1; //Left (From left)
      }

      if (SDK.toGlobalCoord(sprite1, 'y') < Graphics.height / 2) {
        _u = 1; //Down
      }

      if (_r == 1) {
        sprite2.x = sprite1.x + sprite1.width + 1;
      } else {
        sprite2.x = sprite1.x - sprite2.width - 1;
      }

      if (_u == 1) {
        sprite2.y = sprite1.y + sprite1.height + 1;
      } else {
        sprite2.y = sprite1.y - sprite2.height - 1;
      }
    } catch (e) {
      console.error(e);
    }
  };

  $.increment = function (value) {
    if (value == 0)
      return value;
    if (value > 0)
      return value + 1;
    if (value < 0)
      return value - 1;
  };

  $.decrement = function (value) {
    if (value == 0)
      return value;
    if (value > 0)
      return value - 1;
    if (value < 0)
      return value + 1;
    return value;
  };

  
  //SMath
  //------------------------------------------------------------------------------
  function SMath() {
    throw new Error('This is a static class');
  }

  SMath.distance = function (point1, point2) {
    try {
      return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    } catch (e) {
      console.error(e);
      return 0;
    }
  };

  SMath.angle = function (point1, point2) {
    try {
      var cl = SMath.distance(point1, point2);
      var al = Math.abs(point2.x - point1.x);
      var bl = Math.abs(point2.y - point1.y);

      if (al == 0 || cl == 0 || bl == 0)
        return 0;
      else {
        var angle = Math.acos((bl * bl + cl * cl - al * al) / (2 * bl * cl));
        return angle;
      }
    } catch (e) {
      console.error(e);
      return 0;
    }
  };

  SMath.rotateTo = function (point1, angle) {
    try {
      var nx = point1.x * Math.cos(angle) - point1.y * Math.sin(angle);
      var ny = point1.y * Math.cos(angle) + point1.x * Math.sin(angle);
      return new KDCore.Point(nx, ny);
    } catch (e) {
      console.error(e);
      return KDCore.Point.Empty;
    }
  };

  SMath.moveTo = function (point1, point2, step) {
    try {
      var rotated = SMath.rotateTo(new KDCore.Point(0, step), SMath.angle(point1, point2));
      var fx = 0;
      var fy = 0;
      if (point2.y < point1.y) {
        fy = point1.y - rotated.y;
      } else {
        fy = point1.y + rotated.y;
      }
      if (point2.x < point1.x) {
        fx = point1.x + rotated.x;
      } else {
        fx = point1.x - rotated.x;
      }
      return new KDCore.Point(fx, fy);
    } catch (e) {
      console.error(e);
      return KDCore.Point.Empty;
    }
  };

  SMath.inRect = function (point, rectangle) {
    try {
      var x2 = rectangle.x + rectangle.width;
      var y2 = rectangle.y + rectangle.height;
      if (point.x > rectangle.x && point.x < x2 && point.y < y2 && point.y > rectangle.y) {
        return true;
      }
      return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  //END SMath
  //------------------------------------------------------------------------------

  //Расширение
  $.extendMe = function (obj) {
    obj.SMath = SMath;
  };

  $.extendMe($);

})(AlphaABS.UTILS);

//Object.freeze(AlphaABS.UTILS);
/*Object.defineProperty(AlphaABS, 'UTILS', {
  writable: false
});*/
// ■ END Utils.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {

    var ANIMAX = {};
    AA.ANIMAX = ANIMAX;

    ANIMAX.PluginCommand_ChangePlayerAnimationSet = (animationSetName) => {
        try {
            $gamePlayer.setExternalAnimaX(animationSetName);
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.PluginCommand_PlayAnimationAction = (actionName, charaId, isLoop, isWait) => {
        try {
            let char = ANIMAX.GetProperCharacter(charaId);
            if(char) {
                if(!String.any(actionName)) {
                    char.resetXAnima();
                } else {
                    if(char.startAnimaXAA_Action(actionName, isLoop, isWait)) {
                        if(isWait == true && isLoop == false) {
                            ANIMAX.SetInterpreterToWait(char);
                        }
                    }
                }
            }
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.PluginCommand_StopAnimationAction = (charaId) => {
        try {
            let char = ANIMAX.GetProperCharacter(charaId);
            if(char) char.resetXAnima();
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.PluginCommand_AddPart = (charaId, partId, isRelative) => {
        try {
            let char = ANIMAX.GetProperCharacter(charaId);
            if(char) char.addNewXAnimPart(partId, isRelative);
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.PluginCommand_RemovePart = (charaId, partId) => {
        try {
            let char = ANIMAX.GetProperCharacter(charaId);
            if(char) char.removeXAnimPart(partId);
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.PluginCommand_ClearParts = (charaId) => {
        try {
            let char = ANIMAX.GetProperCharacter(charaId);
            if(char) char.clearXAnimParts();
        } catch (e) {
            console.warn(e);
        }
    };

    ANIMAX.GetProperCharacter = (charId) => {
        var char = null;
        try {
            if (!charId || charId == 0) {
                char = $gamePlayer;
            } else if (charId < 0) {
                let int = $gameMap._interpreter;
                charId = int.eventId();
                if (charId > 0) {
                    char = $gameMap.event(charId);
                } else {
                    return null;
                }
            } else {
                char = $gameMap.event(charId);
            }
            if (!char) return null;
            if (!char.isAnimX()) return null;
            return char;
        } catch (e) {
            console.warn(e, "Can't find character with ID " + charId + " for PlayAnimationAction");
        }
    };

    ANIMAX.SetInterpreterToWait = (char) => {
        let int = $gameMap._interpreter;
        int.xAnimaTarget = char;
        int._waitMode = 'xAnima';
    };

})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleMangerABS.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

//@[GLOBAL]
function BattleManagerABS() {
  throw new Error('This is a static class');
}

(function () {
  var LOG = new KDCore.DevLog("BattleManagerABS");
  LOG.applyLibraryColors();

  window.__selected = null;

  AlphaABS.register(BattleManagerABS);

  var Consts = AlphaABS.SYSTEM;
  var ABSUtils = AlphaABS.UTILS;

  BattleManagerABS.init = function () {
    BattleManagerABS.timer = new Game_TimerABS();
    BattleManagerABS._ready = false;
    BattleManagerABS._plTargets = [];
    BattleManagerABS.clearABS();
    BattleManagerABS._prepareResources();

    //Input.loadSchemeABS();
    AlphaABS.LIBS.ABSPathfinding.init();
  };

  BattleManagerABS.clearABS = function () {
    this._isABSMap = false;
    this._absMapId = -1;
  };

  BattleManagerABS._prepareResources = function () {};


  BattleManagerABS.connectProcess = function () {
    this._process = new AlphaABS.LIBS.Game_BattleProcessABS();
  };

  BattleManagerABS.battleProcess = function () {
    return this._process;
  };

  //* Map Spriteset
  BattleManagerABS.MPS = function() {
    if(AA.isABS()) {
      return SceneManager._scene._spriteset;
    } else {
      return null;
    }
  };

  BattleManagerABS.onMapLoaded = function () {
    if (this._isABSMap && $gameMap.isABS()) { //Если переход между АБС картами, то не делаем StopABS, а только prepare Заного
      if (this._absMapId != $gameMap.mapId()) {
        $gameTroop.deactivateABS();
        $gameTroop.clearABS();
        $gameTroop.initABS(); //Need restart
        this._absMapId = $gameMap.mapId();
      }
      BattleManagerABS.updateABSSession();
      //LOG.p("Manager : Go to ABS map from ABS map, Prepare new ABS session");
      return;
    }

    if (this._isABSMap && !$gameMap.isABS()) { //Если переход от AБС карты на обычную, то надо всё остановить
      BattleManagerABS.stopABS();
      //LOG.p("Manager : Go to map from ABS map, stop ABS session");
      try {
        $gamePlayer.followers().initialize();
        $gamePlayer.followers().refresh();
        if (SceneManager._scene instanceof Scene_Map)
          SceneManager._scene._spriteset.refreshAfterABS();
        $gamePlayer.followers().synchronize($gamePlayer.x, $gamePlayer.y, $gamePlayer.direction());
      } catch (error) {
        console.error(error);
      }
      return;
    }

    if (!this._isABSMap && $gameMap.isABS()) {
      BattleManagerABS.initABS();
      //LOG.p("Manager : Go to ABS map from map, start new ABS session");
    }
  };

  BattleManagerABS.updateABSSession = function () {
    if (!AlphaABS.isABS()) return;
    if ($gamePlayer.battler() != $gameParty.leader())
      $gamePlayer.initABS();
    else {
      $gamePlayer.initABSForAlly();
    }
    $gamePlayer.prepareABS();
    $gameTroop.prepareABS();
    $gameScreen._resetBSEffect();
    AlphaABS.BattleUI.initNewSession();
    this._plTargets = [];
  };

  BattleManagerABS.stopABS = function () {
    //LOG.p("Manager : ABS Map destroy");
    BattleManagerABS.clearABS();
    $gameTroop.deactivateABS();
    $gamePlayer.stopABS();
    $gameTemp.__firearmAmmoBeforeTransfer = null;
    SlowUpdateManager.clearAll();
  };

  BattleManagerABS.initABS = function () {
    $gamePlayer.initABS();
    $gameTroop.initABS();
    $gameParty.initABS();
    this.timer.start(BattleManagerABS.TURN);
    this._ready = true;

    AlphaABS.BattleUI.initNewSession();

    $gamePlayer.prepareABS();

    //LOG.p("Manager : ABS Map loaded");
    this._isABSMap = true;
    this._absMapId = $gameMap.mapId();
  };


  BattleManagerABS.setPlayerTarget = function (target) {
    window.__selected = target;
    try {
      if (target && target.inActive()) {
        if(target != $gamePlayer.getSummonUnit()) {
          if(target.isEnemy()) {
            $gamePlayer.setTarget(target);
            $gameTroop.selectOnMap(target);
            AlphaABS.BattleUI.showTarget(target);
          }
          else { // * ALLY
            if (AA.Parameters.get_IsPlayerCanSelectAlliesOnMap()) {
              $gamePlayer.setTarget(target);
              $gameParty.selectOnMap(target);
              AlphaABS.BattleUI.showTarget(target);
            }
          }
        }
      } else {
        $gamePlayer.setTarget(null);
        $gameTroop.selectOnMap(null);
        $gameParty.selectOnMap(null);
        AlphaABS.BattleUI.showTarget(null);
      }
    } catch (e) {
      console.error(e);
      AlphaABS.BattleUI.showTarget(null);
    }
  };

  BattleManagerABS.getPlayerTarget = function () {
    return $gamePlayer.target();
  };

  BattleManagerABS.resetPlayerTarget = function() {
    BattleManagerABS.setPlayerTarget(null);
  };

  BattleManagerABS.updateABS = function () {
    if (!this._ready) return;
    this.timer.update();
    if (this.timer.isReady()) {
      this.timer.reset();
      $gamePlayer.onTurnEnd();
      $gameTroop.onTurnEnd();
    }
  };

  BattleManagerABS.alertNoInBattle = function () {
    BattleManagerABS.alertOnUI(AlphaABS.SYSTEM.STRING_ALERT_NOINBATTLE);
  };

  BattleManagerABS.alertOnUI = function (string) {
    AlphaABS.BattleUI.alert(string);
  };

  BattleManagerABS.playSe = function (se, point) {
    if (BattleManagerABS.isABSAudio()) {
      AudioManager.playSeAt(se, point);
    } else {
      AudioManager.playSe(se);
    }
  };

  BattleManagerABS.isABSAudio = function () {
    return AlphaABS.SYSTEM.EXTENSIONS.AUDIO;
  };

  BattleManagerABS.isABSParticleSystem = function () {
    return (AlphaABS.SYSTEM.EXTENSIONS.ABSPE !== undefined) && (AlphaABS.SYSTEM.EXTENSIONS.ABSPE != false);
  };

  BattleManagerABS.isABSLightingExt = function () {
    return AlphaABS.SYSTEM.EXTENSIONS.LIGHT;
  };

  BattleManagerABS.alertOnUIbySym = function (alertSymbol) {
    switch (alertSymbol) {
      case 'noUse':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOUSE);
        break;
      case 'toFar':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_TOFAR);
        break;
      case 'noTarget':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NEEDTARGET);
        break;
      case 'noAmmo':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOCHARGES);
        break;
      case 'recharge':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_RECHARGE);
        break;
    }
  };

  BattleManagerABS.nextPlayerTarget = function () {
    try {
      var t = BattleManagerABS._nearestTargetForPlayer(true);
      if (t == null) {
        if(this._plTargets.length > 0) {
          this._plTargets = [];
          return this.nextPlayerTarget();
        } else {
          return null;
        }
      }

      var tt = this._plTargets;
      var t2 = t.filter(function (i) {
        return tt.indexOf(i) < 0;
      });

      if (t2.count() == 0) {
        this._plTargets = [];
        return this.nextPlayerTarget();
      } else {
        this._plTargets.push(t2.first());
      }
      return t2.first();
    } catch (e) {
      console.error(e);
      return null;
    }
  };

  BattleManagerABS._nearestTargetForPlayer = function (isExclusive) {
    var exclusive = [];
    if(isExclusive == true)
      exclusive = this._plTargets;

    var candidates = ABSUtils.inRadius($gamePlayer, 12, $gameTroop.onlyHostileMembersABS());
    if (candidates.length > 0) {
      for (var i = 0; i < candidates.length; i++) {
        if (ABSUtils.inFront($gamePlayer, candidates[i])) {
          if (exclusive.indexOf(candidates[i]) < 0)
            return [candidates[i]];
        }
      }
      var minDist = 100;
      var minTarg = null;
      var dist = 0;
      for (var j = 0; j < candidates.length; j++) {
        var en = candidates[j];
        dist = ABSUtils.distanceTo($gamePlayer, en);
        if (dist < minDist) {
          if (exclusive.indexOf(en) < 0) {
            minTarg = en;
            minDist = dist;
          }
        }
      }
      if(minTarg != null) 
        return [minTarg];
    }
    return null;
  };

  BattleManagerABS.nextNearestPlayerTarget = function() {
    var t = this._nearestTargetForPlayer(false);
    if(t == null)
      return BattleManagerABS.nextPlayerTarget();
    else
      return t.first();
  };

  //HELPERS
  BattleManagerABS.canUseSkillByTimer = function (skill) {
    return skill ? skill.isReady() : false;
  };

  BattleManagerABS.playerABSSkillById = function (skillId) {
    return $gamePlayer.battler().skillABS_byId(skillId);
  };

  BattleManagerABS.canUseSkillByTarget = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (skill.isRadiusType()) return true;
      if (skill.isNeedTarget()) {
        if (target) {
          // * Чтобы можно было бить нейтралов
          if(who == $gamePlayer) {
              if (target.isEnemy()) {
                return true; //!skill.isForAlly();
              } else {
                return skill.isForAlly();
              }
          } else 
              if (!target.isAlly(who)) {
                return !skill.isForAlly();
              } else {
                return skill.isForAlly();
              }
        }
        else
          return false;

      } else
        return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.checkLineOfSight = function (point1, point2) {
    try {
      if(point1.x == point2.x && point1.y == point2.y)
        return true;
      var line = [];
      if(point1.x == point2.x) {
        line = AlphaABS.UTILS.createStraightYLineBetweenPoints(point1.x, point1.y, point2.y);
      } else if(point1.y == point2.y) {
        line = AlphaABS.UTILS.createStraightXLineBetweenPoints(point1.y, point1.x, point2.x);
      } else
        line = AlphaABS.UTILS.createLineBetweenPoints(point1, point2);
      for (var i = 0; i < line.length; i++) {
        if (BattleManagerABS.isNoSolidRegion(line[i]) == false)
          return false;
      }
      return true;
    } catch (e) {
      console.error(e);
      return true;
    }
  };

  // * вернёт FALSE -> если Solid Region в этой точке
  BattleManagerABS.isNoSolidRegion = function (point) {
    try {
      if (AlphaABS.Parameters.isLoaded()) {
        var regionId = $gameMap.regionId(point.x, point.y);
        var zones = AlphaABS.Parameters.get_MapSolidRegions();
        if (zones.includes(regionId))
          return false;
      }
      return true;
    } catch (e) {
      console.error(e);
      return true;
    }
  };

  BattleManagerABS.canUseSkilllBySpecialState = function(who, skill) {

    if (skill.isNoBattleOnly() && who.inBattle()) return false;
    if (skill.isRequareStateApplied()) {
        return who.battler().isStateAffected(skill.ifState);
    }
    return true;
  };

  BattleManagerABS.canUseSkillByRange = function (who, target, skill) {
    try {
      var byRange = BattleManagerABS.checkSkillRange(who, target, skill);
      if (byRange == true) {
        if (skill.range == 0 || target == null || who == null || skill.isIgnoreObstacles())
          return true;
        else {
          if (ABSUtils.inFront(who, target)) {
            return true;
          }
          var isLineOfSight = BattleManagerABS.checkLineOfSight(who.toPoint(), target.toPoint());
          return isLineOfSight;
        }
      } else
        return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.checkSkillRange = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (skill.isZoneType()) return true;
      if (skill.isRadiusType()) return true;
      if (skill.range == 0 && !skill.isNeedTarget()) return true;
      if (skill.range == 0) {
        if(skill.isForAlly()) { // * Self
          return true;
        } else
          return ABSUtils.inFront(who, target);
      } else {
        var t = ABSUtils.distanceTo(who, target);
        if (skill.range >= t) {
          if (skill.isDirectionFix()) {
            LOG.p("SPELL: Dirction FIXed");
            return ABSUtils.inDirectionHard(who, target);
          } else
            return true;
        } else
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseSkillByAmmo = function (skill) {
    try {
      if (skill.isFirearm()) {
        return !skill.isNeedReloadStack();
      }
      if (skill.isNeedAmmo()) {
        return $gameParty.numItems($dataItems[skill.ammo]) > 0;
      }
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseABSSkillNow = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (!this.canUseSkilllBySpecialState(who, skill)) return false;
      if (skill.isNoTarget()) {
        return this.canUseSkillByTimer(skill) && this.canUseSkillByAmmo(skill);
      }
      if (skill.type == 0 && skill.isForAlly() && !target) {
        target = who;
      }
      return this.canUseSkillByTarget(who, target, skill) &&
        this.canUseSkillByRange(who, target, skill) &&
        this.canUseSkillByTimer(skill) && this.canUseSkillByAmmo(skill);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseABSSkillUI = function (skill) {
    try {
      if (!$gamePlayer.inActive()) return false;
      var t = $gamePlayer.battler();
      return t.canUse(skill.skill()) &&
        this.canUseABSSkillNow($gamePlayer, $gamePlayer.target(), skill) && t.canMove();
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.whoTargetOnMe = function (me, members) {
    var x = members.filter(function (t) {
      return (t.target() == me);
    });
    return x.first();
  };

  BattleManagerABS.isValidTarget = function (target) {
    try {
      return target && target.inActive() && (target.battler().tgr != 0);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.warning = function (index) {
    switch (index) {
      case 1:
        LOGW.p(Consts.STRING_WARNING_COMMON2);
        break;
      case 2:
        LOGW.p(Consts.STRING_WARNING_COMMON3);
        break;
      case 129:
        LOGW.p(Consts.STRING_WARNING_COMMAND129);
        break;
      case 321:
        LOGW.p(Consts.STRING_WARNING_COMMAND321);
        break;
      default:
        LOGW.p(Consts.STRING_WARNING_COMMON);
        break;
    }
  };

  BattleManagerABS.getAllBotsOnMap = function () {
    if (AlphaABS.isABS()) {
      var all = $gameTroop.membersABS().concat($gameParty.membersABS());
      return all;
    } else
      return [];
  };

  KDCore.SDK.setConstantToObject(BattleManagerABS, 'TURN', AlphaABS.SYSTEM.FRAMES_PER_SECOND);
  AlphaABS.BattleManagerABS = BattleManagerABS;
  AlphaABS.register(BattleManagerABS);
})();

// ■ END BattleMangerABS.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
///////////////////////////////////////////////////////////////////////////////
//╒═══════════════════════════════════════════════════════════════════════════╛
// ■ BattleUI.coffee
//╒═══════════════════════════════════════════════════════════════════════════╛
///////////////////////////////////////////////////////////////////////////////
(function() {
  var BattleUI;
  BattleUI = function() {
    throw new Error("This is a static class");
  };
  AlphaABS.register(BattleUI);
  BattleUI.init = function() {
    this._ui = null;
    this._lastUITaget = null;
  };
  BattleUI.setUI = function(ui) {
    this._ui = ui;
  };
  BattleUI.initNewSession = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref.initABS();
    }
    return ButtonsProManager.setVisibilityForAllButtons(true);
  };
  BattleUI.isUI = function() {
    return this._ui != null;
  };
  BattleUI.getUI = function() {
    return this._ui;
  };
  BattleUI.showTarget = function(target) {
    var ref;
    if ((ref = this._ui) != null) {
      ref.showTarget(target); //Nullable
    }
    return this._lastUITaget = target;
  };
  BattleUI.alertNotInDuringBattle = function() {
    return this.alert(AlphaABS.SYSTEM.STRING_ALERT_NOINBATTLE);
  };
  BattleUI.alert = function(message) {
    var ref;
    if (message) {
      return (ref = this._ui) != null ? ref.addPopUp(AlphaABS.PopInfoManagerABS.ALERT(message)) : void 0;
    }
  };
  BattleUI.pushItemOnPanel = function(item) {
    if (AA.isABS()) {
      AA.Utils.playSE("Equip2", 140, 90);
      if (item != null) {
        this._pushOnPanel("item", item);
      }
    } else {
      if (AA.Parameters.get_IsShowItemNotifyOnNONABS()) {
        AA.Utils.playSE("Equip2", 140, 90);
        if (item != null) {
          this._pushOnPanel("item", item);
        }
      }
    }
  };
  BattleUI.pushGoldOnPanel = function(goldCount) {
    if (AA.isABS()) {
      AA.Utils.playSE("Coin");
      this._pushOnPanel("gold", goldCount);
    } else {
      if (AA.Parameters.get_IsShowItemNotifyOnNONABS()) {
        AA.Utils.playSE("Coin");
        this._pushOnPanel("gold", goldCount);
      }
    }
  };
  BattleUI.pushIconTextOnPanel = function(item) {
    if (item != null) {
      return this._pushOnPanel("iconText", item);
    }
  };
  BattleUI._pushOnPanel = function(symbol, object) {
    var ref, ref1;
    if (AA.isABS()) {
      if ((ref = this._ui) != null ? ref.isVisible() : void 0) {
        if (object) {
          this._ui.pushOnItemPanel(symbol, object);
        }
      }
    } else {
      if (object) {
        if ((ref1 = this._cui) != null) {
          ref1.showItemNotify(symbol, object);
        }
      }
    }
  };
  BattleUI.refreshWeaponCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.weapCircleRefresh() : void 0;
  };
  BattleUI.refreshWeaponCircleIfOpen = function() {
    var circle;
    if (this._ui == null) {
      return;
    }
    circle = this._ui.weapCircle();
    if (circle == null) {
      return;
    }
    if (circle.isOpen()) {
      return BattleUI.refreshWeaponCircle();
    }
  };
  BattleUI.showFirearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.showFirearmPanel() : void 0;
  };
  BattleUI.hideFirearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.hideFirearmPanel() : void 0;
  };
  BattleUI.refreshFirearmPanel = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref.refreshFirearmPanel();
    }
    if (Input.isGamepad()) {
      return $gamePlayer._refreshGamePadCommands();
    }
  };
  BattleUI.firearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.spriteFirearmBar : void 0;
  };
  BattleUI.spellPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.spellUIManager : void 0;
  };
  BattleUI.gamePadUI = function() {
    var ref;
    return (ref = this._ui) != null ? ref._gamepadUI : void 0;
  };
  BattleUI.refresh = function() {
    var ref;
    return (ref = this._ui) != null ? ref.refresh() : void 0;
  };
  BattleUI.reCreateUI = function() {
    var e;
    if (!AA.isABS()) {
      return;
    }
    try {
      //if !$gamePlayer.inBattle()
      //    SceneManager._scene.callMenu()
      //else
      if (this._ui != null) {
        BattleUI.getUI().hide();
        this._ui.parent.removeChild(this._ui);
        this._ui.terminate();
        AA.log("UI is Terminated");
      }
      SceneManager._scene._createABSUI();
      if (this._ui != null) {
        BattleUI.initNewSession();
        if (Input.isGamepad()) {
          return BattleUI.gamePadUI().afterButtonsLoad();
        }
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Recreate ABS UI');
    }
  };
  BattleUI.pushExpOnPanel = function(expCount) {
    return this._pushOnPanel("exp", expCount);
  };
  BattleUI.refreshWeaponIconAt = function(index) {};
  BattleUI.showUI = function() {
    if (this._ui != null) {
      this._ui.setShowUI(true);
      this._ui.setControlPanelVisible(true);
      this._ui.show();
      ButtonsProManager.setVisibilityForAllButtons(true);
    }
  };
  BattleUI.hideUI = function() {
    if (this._ui != null) {
      this._ui.setShowUI(false);
      this._ui.setControlPanelVisible(false);
      this._ui.hide();
      ButtonsProManager.setVisibilityForAllButtons(false);
    }
  };
  BattleUI.refreshPlayerFace = function() {
    var ref;
    return (ref = this._ui) != null ? ref.refreshFace() : void 0;
  };
  BattleUI.requestFreeMode = function() {
    var ref;
    return (ref = this._ui) != null ? ref.needFree() : void 0;
  };
  BattleUI.moveWeaponCircle = function(x, y) {
    var ref;
    if ((x != null) && (y != null)) {
      return (ref = this._getWeaponCircle()) != null ? ref.move(x, y) : void 0;
    }
  };
  BattleUI._getWeaponCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.weapCircle() : void 0;
  };
  BattleUI.terminate = function() {
    var ref;
    ButtonsProManager.setVisibilityForAllButtons(false);
    return (ref = this._ui) != null ? ref.terminate() : void 0;
  };
  BattleUI.isWeaponCircleTouchedAny = function() {
    var cl;
    cl = this._getWeaponCircle();
    if (cl == null) {
      return false;
    }
    return cl.isOpen() && cl.isTouchedAny();
  };
  BattleUI.isTouched = function() {
    var ref;
    return (ref = this._ui) != null ? ref.isTouched() : void 0;
  };
  BattleUI.addPopUpForPlayer = function(item) {
    var ref;
    if (item) {
      return (ref = this._ui) != null ? ref.addPopUpUser(item) : void 0;
    }
  };
  BattleUI.addPopUpForTarget = function(target, item) {
    var ref;
    if (target && item) {
      return (ref = this._ui) != null ? ref.addPopUpTarget(target, item) : void 0;
    }
  };
  BattleUI.isVisible = function() {
    if (this._ui != null) {
      return this._ui.isVisible();
    }
    return false;
  };
  BattleUI.openWeaponCircle = function() {
    var circle;
    circle = this._getWeaponCircle();
    if (circle != null) {
      if (!circle.isOpen()) {
        circle.open();
        this.closeInventory();
        this.closeUserChest();
      }
    }
  };
  BattleUI.closeWeaponCircle = function() {
    var circle;
    circle = this._getWeaponCircle();
    if (circle != null) {
      if (circle.isOpen()) {
        circle.close();
      }
    }
  };
  BattleUI.isWeaponCircleOpen = function() {
    var ref;
    return (ref = this._getWeaponCircle()) != null ? ref.isOpen() : void 0;
  };
  BattleUI.selectOnControlPanel = function(index) {};
  BattleUI.diselectOnControlPanel = function(index) {};
  BattleUI.disableOnControlPanel = function(index) {};
  BattleUI.enableOnControlPanel = function(index) {};
  BattleUI.changeRotateIconToMouse = function() {};
  BattleUI.changeRotateIconToTarget = function() {};
  BattleUI.touchOnSkillPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._ui) != null ? ref.touchSkillAt(index) : void 0;
    }
  };
  BattleUI.touchOnControlPanel = function(index) {};
  BattleUI.touchOnWeaponCircle = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getWeaponCircle()) != null ? ref.click(index) : void 0;
    }
  };
  BattleUI.isUIFree = function() {
    var ref;
    return (ref = this._ui) != null ? ref.isFree() : void 0;
  };
  BattleUI.getPlayerStatusPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.userStatusPanel : void 0;
  };
  BattleUI.redrawVisualEqOnPortrait = function() {
    var ref;
    return (ref = this._ui) != null ? ref.redrawVisualOnFace() : void 0;
  };
  AlphaABS.BattleUI = BattleUI;
})();

// ■ END BattleUI.coffee
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleUI 2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.BattleUI;
  _.setCUI = function(ui) {
    return this._cui = ui;
  };
  _.refreshPlayerABGauge = function() {
    var ref;
    return (ref = this._ui) != null ? ref.refreshPlayerABGaugeAndIcon() : void 0;
  };
})();

// ■ END BattleUI 2.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParametersManagerABS.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    class ParametersManagerABS extends KDCore.ParametersManager {
        constructor() {
            super('Alpha ABS');
            this._newParser = new KDCore.ParamLoader("Alpha ABS");
        }

        prepareExtraParameters() {
            var animaX, i, len, ref;
            ref = this.xAnimations();
            // * Конвертируем список действий анимаций в упрощённый вид (сжатый)
            for (i = 0, len = ref.length; i < len; i++) {
                animaX = ref[i];
                animaX.actions = XAnimaTools.convertActionsFromParameters(animaX.actions);
            }
        }

        xAnimations() {
            return this._newParser.getParam("xAnimations", []);
        }

        xAnimationsParts() {
            return this._newParser.getParam("xAnimaParts", []);
        }

        xMapScrollSettings() {
            return this._newParser.getParam("mapScrolling", null);
        }

        isLeaderSwapAllowed() {
            return this._newParser.getParam("allowLeaderSwap", false);
        }

        isLeaderSwapAllowedInBattle() {
            return this._newParser.getParam("allowLeaderSwapInBattle", false);
        }

        isOneLeaderSwapMode() {
            return this.isLeaderSwapAllowed() && this._newParser.getParam("oneLeaderSwapMode", false);
        }

        isUseAlternativeAnimaXPreload() {
            return this._newParser.getParam("animaXAltLoader", false);
        }

        getCommonEventOnLeaderSwap() {
            return this._newParser.getParam("leaderSwapCE", 0);
        }

        isCanSpawnAboveEvents() {
            return this._newParser.getParam("allowSpawnAboveEvents", true);
        }

        _convertBasicElements(object) {
            this.convertField(object, 'Position');
            this.convertField(object.Position, 'X');
            this.convertField(object.Position, 'Y');
            this.convertField(object, 'Visible');
            return object;
        }

        _get_UIE_BasicElement(name) {
            return this.getFromCacheOrInit(name, function () {
                var object = this.getObject(name);
                this._convertBasicElements(object);
                return object;
            });
        }

        get_UIE_PlayerFirearm() {
            return this._get_UIE_BasicElement('UIE_Player_FirearmPanel');
        }
        get_UI_PlayerDamageColor() {
            var name = "UI_PlayerDamageColor";
            return this.getFromCacheOrInit(name, function () {
                var color = this.getString(name);
                if (color != null && color != "") {
                    return KDCore.Color.FromHex(color).ARR;
                } else {
                    return KDCore.Color.BLACK.ARR;
                }
            });
        }

        get_IsGamepadSupport() {
            return this._get_BooleanFromCacheWithDefault('Gamepad Support', true);
        }

        //?[DEPRECATED]
        loadAllStrings() {
            //var loader = new KDCore.StringsLoader(this._parameters);
            //loader.loadAllStringsToObject(AlphaABS.SYSTEM);
        }
        get_EnemyDeadSwitch() {
            var name = "Enemy Dead Switch";
            return this.getFromCacheOrInit(name, function () {
                var deadSwitch = this.getString(name);
                if (KDCore.SDK.checkSwitch(deadSwitch))
                    return deadSwitch;
                else
                    return 'B';
            });
        }
        get_EnemyReviveAnimationId() {
            return this._get_NumberFromCache("Revive Animation") || 45;
        }

        get_EnemyTeleportAnimationId() {
            return this._get_NumberFromCache("Teleport Animation") || 51;
        }

        get_EnemyEncounterSpawnAnimationId() {
            return this._get_NumberFromCache("Encounter Animation") || 0;
        }

        _get_NumberFromCache(name) {
            return this.getFromCacheOrInit(name, function () {
                var value = this.getNumber(name);
                return value;
            });
        }
        get_CastAnimation() {
            var animId = this._get_NumberFromCache("Cast Animation");
            if (animId > 0) {
                return $dataAnimations[animId];
            } else {
                return AlphaABS.DATA.DefaultCastAnimation;
            }
        }
        get_LevelUpAnimationId() {
            return this._get_NumberFromCache("Level Up Animation") || 49;
        }
        get_AutoLootEnemiesState() {
            return this._get_BooleanFromCache('Auto loot');
        }

        get_IsEnemiesLootingVisual() {
            return this._get_BooleanFromCacheWithDefault('Visual loot', true);
        }

        _get_BooleanFromCache(name) {
            return this.getFromCacheOrInit(name, function () {
                var object = this.getBoolean(name);
                return object;
            });
        }
        get_CastAnimationSE() {
            var name = 'Cast Animation SE';
            return this.getFromCacheOrInit(name, function () {
                if (this.isHasParameter(name)) {
                    var object = this.getBoolean(name);
                    if (object == true) {
                        object = AlphaABS.DATA.DefaltCastSE;
                    } else {
                        object = null;
                    }
                    return object;
                } else {
                    return AlphaABS.DATA.DefaltCastSE;
                }
            });
        }
        get_DeadMapId() {
            return this._get_NumberFromCache("Game Over Map ID");
        }
        get_DeadMapCommonEventId() {
            return this._get_NumberFromCache("Game Over Common Event");
        }
        get_DeadMapCommonEventId2() {
            return this._get_NumberFromCache("After Death Common Event");
        }
        get_DeadMapPosition() {
            var name = "Game Over Map Position";
            return this.getFromCacheOrInit(name, function () {
                var object = this.getObject(name);
                this.convertField(object, "X");
                this.convertField(object, "Y");
                return object;
            });
        }
        get_DeadMapDirection() {
            var name = "Game Over Map Direction";
            return this.getFromCacheOrInit(name, function () {
                var resultDir = 2;
                var object = this.getString(name);
                switch (object) {
                    case "top":
                        resultDir = 8;
                        break;
                    case "right":
                        resultDir = 6;
                        break;
                    case "left":
                        resultDir = 4;
                        break;
                    default:
                        resultDir = 2;
                        break;
                }
                return resultDir;
            });
        }
        get_PartyExpMode() {
            var name = "Party experience";
            return this.getFromCacheOrInit(name, function () {
                var result = 0;
                var object = this.getString(name);
                switch (object) {
                    case "For each member":
                        result = 0;
                        break;
                    case "For party":
                        result = 1;
                        break;
                    case "Share at all":
                        result = 2;
                        break;
                    default:
                        result = 0;
                        break;
                }
                return result;
            });
        }
        get_SpawnMapId() {
            var name = "Enemy Spawn Map Id";
            return this.getFromCacheOrInit(name, function () {
                return this.getNumber(name);
            });
        }
        get_MapSolidRegions() {
            var name = "Solid Regions";
            return this.getFromCacheOrInit(name, function () {
                var regions = [];
                var object = this.getString(name);
                try {
                    regions = object.split(',').map(Number);
                    regions.delete(0);
                } catch (error) {
                    console.error(error);
                    regions = [];
                }
                return regions;
            });
        }
        get_CustomUIButtons() {
            var name = "UIE_ButtonsCustom";
            return this.getFromCacheOrInit(name, function () {
                var buttons = [];
                var object = this.getString(name);
                try {
                    buttons = object.split(',').map(item => item.trim());
                } catch (error) {
                    console.error(error);
                    buttons = [];
                }
                return buttons;
            });
        }

        get_AllowTransferState() {
            return this._get_BooleanFromCache("Allow Transfrer");
        }
        isUIVisible() {
            return this._get_BooleanFromCacheWithDefault("UI_Visible", true);
        }
        _get_BooleanFromCacheWithDefault(name, defaultValue) {
            if (this.isHasParameter(name))
                return this._get_BooleanFromCache(name);
            else
                return defaultValue;
        }

        _get_NumberFromCacheWithDefault(name, defaultValue) {
            if(this.isHasParameter(name))
                return this._get_NumberFromCache(name);
            else
                return defaultValue;
        }

        get_AIUpdateTickTime() {
            var name = "AI Think Interval";
            var base = this._get_NumberFromCacheWithDefault(name, 300);
            return KDCore.SDK.rand(base - 5, base + 40);
        }

        get_EncounterSpawnRadius() {
            var name = "Encounters Spawn Radius";
            return this._get_NumberFromCacheWithDefault(name, 6);
        }

        get_AllowBloodSplatter() {
            return this._get_BooleanFromCacheWithDefault("AllowBloodSplatter", true);
        }

        get_BloodSplatterParameters() {
            var name = "get_BloodSplatterParameters";
            return this.getFromCacheOrInit(name, function () {
                var params = {};
                params.pic = this._get_BS_Picture();
                var color = this._get_BS_Color();
                color[3] = this._get_BS_Opacity();
                params.color = color;
                params.hp = this._get_BS_HpRate();
                params.duration = 20;
                return params;
            }.bind(this));
        }

        get_UsePerformanceSkillPanel() {
            return this._get_BooleanFromCacheWithDefault("SimpleSkillPanel", false);
        }

        get_ShowEnemyLevel() {
            return this._get_BooleanFromCacheWithDefault("ShowEnemyLevel", false);
        }

        get_ShowEquipedItemsInInventory() {
            return this._get_BooleanFromCacheWithDefault("ShowEquipedItemsInInventory", true);
        }

        get_MapInventoryAllowed() {
            return this._get_BooleanFromCacheWithDefault("MapInventory", true);
        }

        get_MapInventoryAllowedNoABS() {
            return this._get_BooleanFromCacheWithDefault("MapInventoryOnNonABS", true);
        }

        get_MapInventoryAllowDrag() {
            return this._get_BooleanFromCacheWithDefault("MapInventoryDrag", true);
        }
        
        get_MapInventorySortEquips() {
            return this._get_BooleanFromCacheWithDefault("MapInventorySortEquip", true);
        }

        get_MapInventorySortItems() {
            return this._get_BooleanFromCacheWithDefault("MapInventorySortItems", true);
        }

        get_MapInventoryAllowPartySelect() {
            return this._get_BooleanFromCacheWithDefault("AllowPartySelect", true);
        }

        get_AllowRareSystem() {
            return this._get_BooleanFromCacheWithDefault("AllowRareItemSystem", true);
        }

        get_IsWSSlowDown() {
            return this._get_BooleanFromCacheWithDefault("wSystemAllowSlowDown", false);
        }

        get_WSAutoState() {
            return this._get_NumberFromCache("wSystemAutoStateId") || 0;
        }

        get_AutoRefreshItems() {
            return this._get_BooleanFromCacheWithDefault("AllowAutoRefreshUsable", true);
        }

        get_AllowUseStoredChestLikeStorage() {
            return this._get_BooleanFromCacheWithDefault("AllowStoreInChest", true);
        }
        
        get_InitiateABSMapWithRandomTP() {
            return this._get_BooleanFromCacheWithDefault("RandomTPAtStart", true);
        }

        get_NewSpellInfoDescriptionStyle() {
            if(!AA.isPro()) {
                return false;
            } else
                return this._get_BooleanFromCacheWithDefault("NewDescriptionStyle", true);
        }

        get_IsBarrierPiercedDamage() {
            return this._get_BooleanFromCacheWithDefault("BarrierPiercedDamage", false);
        }

        get_IsABSSkillsAllowedInNONABSBattle() {
            return this._get_BooleanFromCacheWithDefault("ABSSkillsInSecondBS", true);
        }

        get_IsShowItemNotifyOnNONABS() {
            return this._get_BooleanFromCacheWithDefault("ShowItemNotifyOnNONABS", true);
        }

        get_IsAlterMovementMode() {
            return this._get_BooleanFromCacheWithDefault("Alter Move", false);
        }

        get_IsMouseMoveMode() {
            return this._get_BooleanFromCacheWithDefault("Move By Mouse", true);
        }

        get_IsAlwaysAttackByMouse() {
            return this._get_BooleanFromCacheWithDefault("Attack By Mouse", false);
        }

        get_IsPreviewTargetByMouse() {
            return this._get_BooleanFromCacheWithDefault("Preview Targets", true);
        }

        get_IsPreviewTargetByMouseWhenTargetSelected() {
            return this._get_BooleanFromCacheWithDefault("Preview Targets When Selected", true);
        }

        get_IsExtraPreviewAllowed() {
            return this._get_BooleanFromCacheWithDefault("Preview Extra Targets", true);
        }

        get_IsKeepSummonUnit() {
            return this._get_BooleanFromCacheWithDefault("Keep Summon Unit When Transfer?", false);
        }

        /*get_IsPartyMembersThrough() {
            return this._get_BooleanFromCacheWithDefault("Party Members is Solid", true);
        }*/

        get_IsPlayerCanSelectAlliesOnMap() {
            return this._get_BooleanFromCacheWithDefault("Party Members is Selectable", true);
        }

        get_IsUseExtraDashCharacterTilt() {
            return this._get_BooleanFromCacheWithDefault("Dashing tilt", false);
        }

        get_IsUseExtraJumpCharacterTilt() {
            return this._get_BooleanFromCacheWithDefault("Jumping tilt", true);
        }

        get_PostUseSkillTime() {
            return this._get_NumberFromCacheWithDefault('PostUseSkillTime', 20);
        }

        get_IsUseMapInventorySlider() {
            return this._get_BooleanFromCacheWithDefault("MapInventoryUseSlider", true);
        }

        get_IsUseMapInventoryWeightSystem() {
            return this._get_BooleanFromCacheWithDefault("MapInventoryWeightSystem", false);
        }

        get_MapInventoryWeigthSystemVarId() {
            return this._get_NumberFromCacheWithDefault('wSystemVariableId', 1);
        }

        get_PauseGameWhenInventoryIsOpen() {
            return this._get_BooleanFromCacheWithDefault("MapInventoryPauseGame", false);
        }

        get_AllowEquipStats() {
            return this._get_BooleanFromCacheWithDefault("AllowEquipsStats", true);
        }

        get_AllowFullStats() {
            return this._get_BooleanFromCacheWithDefault("ShowFullEquipedStats", false);
        }

        get_GoldItemId() {
            return this._get_NumberFromCacheWithDefault("GoldItem", 0); //TODO: 0
        }

        isIconImagesInDefaultWindows() {
            return this._get_BooleanFromCacheWithDefault("UseImageIconsInWindows", true);
        }

        isCustomSizeCells() {
            return this._get_BooleanFromCacheWithDefault("UseCustomCellsSize", false);
        }

        getCustomSizeCellsParameters() {
            return this._newParser.getParam("CustomCellSettings", {
                iconSize: 30,
                columnsPerPage: 5,
                rowsPerPage: 5,
                iconMode: 1
            });
        }

        // * ==================== SKILL WINDOW =====================================

        get_MapSkillWindowAllowed() {
            return this._get_BooleanFromCacheWithDefault("MapSkillWindow", true);
        }

        get_MapSkillWindowAllowDrag() {
            return this._get_BooleanFromCacheWithDefault("MapSkillWindowDrag", true);
        }

        get_MapSkillWindowAllowParty() {
            return this._get_BooleanFromCacheWithDefault("MapSkillWindowParty", true);
        }

        get_AutoRefreshSkills() {
            return this._get_BooleanFromCacheWithDefault("AllowAutoRefreshUsableSkills", true);
        }

        // * =======================================================================

        get_PatyMemberDeadCE() {
            return this._get_NumberFromCacheWithDefault('Party Member Death CE', 0);
        }

        _get_BS_Picture() {
            var name = "BS_Picture";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getString(name);
                return value;
            });
        }

        _get_BS_Color() {
            var name = "BS_Color";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getString(name);
                return KDCore.Color.FromHex(value).ARR;
            });
        }

        _get_BS_Opacity() {
            return this._get_NumberFromCacheWithDefault("BS_Opacity", 125);
        }

        _get_BS_HpRate() {
            var name = "BS_HpRate";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getNumber(name);
                return value / 100;
            });
        }

        get_AllowUsingExtraDamagePopUps() {
            return this._get_BooleanFromCacheWithDefault("UseNewDamagePopUp", true);
        }

        isUIEditorAllowed() {
            return false;//this._get_BooleanFromCacheWithDefault("UI_Editor", true);
        }
        isUIInOptionsAllowed() {
            return this._get_BooleanFromCacheWithDefault("UI_Options", true);
        }
        isUIButtonsAllowed() {
            return this._get_BooleanFromCacheWithDefault("UIE_Buttons", false);
        }
        //?[DEPRECATED]
        isKeyBindingAllowed() {
            return this._get_BooleanFromCacheWithDefault("Key_binding", true);
        }
        isAStarAllowed() {
            return this._get_BooleanFromCacheWithDefault("Use_AStar", true);
        }
        isAutoBindItemsToPanel() {
            return this._get_BooleanFromCacheWithDefault("AutoBindItems", true);
        }
        isNeedScreenShakeOnDamage() {
            return this._get_BooleanFromCacheWithDefault("ScreenShakeOnDamage", true);
        }
        isNeedShowPlayerPortraitPopUps() {
            return this._get_BooleanFromCacheWithDefault("ShowPlayerPopUp", true);
        }
        isEnemyHPInPercentage() {
            return this._get_BooleanFromCacheWithDefault("ShowEnemyHPInPercent", true);
        }

        isDiagonalMovement() {
            return this._get_BooleanFromCacheWithDefault("UseDiagonalMovement", false);
        }

        isMapStatusWindow() {
            return this._get_BooleanFromCacheWithDefault("MapStatusWindow", true);
        }

        //?[DEPRECATED]
        loadBindingScheme() {
            //if (this.isLoaded())
            //    this._loadStandartBindingKeys();
        }
        _loadStandartBindingKeys() {
            try {
                var keys = [];
                keys[0] = this.getString('Controls_Key_cpW');
                keys[1] = this.getString('Controls_Key_cpD');
                keys[2] = this.getString('Controls_Key_cpS');
                keys[3] = this.getString('Controls_Key_cpA');

                keys[4] = this.getString('Controls_Key_cpE');
                keys[5] = this.getString('Controls_Key_tS');

                keys[6] = this.getString('Controls_Key_scW');
                keys[7] = this.getString('Controls_Key_scD');
                keys[8] = this.getString('Controls_Key_scS');
                keys[9] = this.getString('Controls_Key_scA');

                for (var i = 0; i < 8; i++) {
                    keys[i + 10] = this.getString('Controls_Key_sp' + (i + 1));
                }

                keys[18] = this.getString("Controls_Key_wr");
                keys[19] = this.getString("Controls_Key_tn");

                AlphaABS.LIBS.IKey.loadKeyConfig(keys);
            } catch (error) {
                AlphaABS.error(error, ' load user key binding');
            }
        }
        isFollowAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Follow", true);
        }
        isJumpAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Jump", true);
        }
        isRotateAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Rotate", true);
        }
        isWeaponsAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Weapons", true);
        }

        get_EnemyMiniHpBarOption() {
            if(!AA.isPro()) {
                return 0;
            }
            var name = "Show Mini HP Bars";
            return this.getFromCacheOrInit(name, function () {
                var result = 0;
                var object = this.getString(name);
                switch (object) {
                    case "Never":
                        result = 0;
                        break;
                    case "Always":
                        result = 1;
                        break;
                    case "Only for selected":
                        result = 2;
                        break;
                    default:
                        result = 0;
                        break;
                }
                return result;
            });
        }

        // * BUILD 1190 =======================================================




    }

    AlphaABS.Parameters = new ParametersManagerABS();
    AlphaABS.register(ParametersManagerABS);
})();
// ■ END ParametersManagerABS.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[INTERFACE]
    var Interface_AIBot = {
        initializeABS: function () {
            this.LOG = new KDCore.DevLog(this.constructor.name);
            this.LOG.applyLibraryColors();
            this.aiName = "Unknown";

            this._stateMachine = null;

            this._absParams.battler = null;
            this._absParams.target = null;
            this._absParams.inBattle = false;
            this._absParams.active = true; //Со мной можно взаимодействовать
            this._absParams.selected = false; //Я выбран на карте игроком?
            this._absParams.myHomePosition = null;
            this._absParams.behavior = new AIBehavModel();
            this._absParams.allyToSearch = null;
            this._absParams.rageContainer = null; //Цель - урон, для ярости

            //escapeOnBattle; //Убегает во время битвы
            //canSearch; //Могу ля я искать противника, если мой сосед атакован
            //noFight; //Не будет сражаться
            //reviveTime; //Время возрождения (минуты)
            //slow; //Медленный враг
            //agressive; //Агрессивный враг (будет догонять)
            //returnType; //Тип возвращения 0 - быстрое, 1 - обычное, 2 - остановка
            //teamId;
            //rage; //Если 1, то агрится, если 0 , то нет
        },
        ABSParams: function () {
            return this._absParams;
        },
        isAlly: function (who) {
            if (who)
                return (this.teamId() == who.teamId());
            return false;
        },
        teamId: function () {
            return this.behaviorModel().teamId;
        },
        canFight: function () {
            return !this.behaviorModel().noFight;
        },
        behaviorModel: function () {
            return this._absParams.behavior;
        },
        isFastReturn: function () {
            return this.behaviorModel().returnType == 0;
        },
        isSlowReturn: function () {
            return this.behaviorModel().returnType == 1;
        },
        isNotReturn: function () {
            return this.behaviorModel().returnType == 2;
        },
        isCasting: function () {
            var action = this.currentAction();
            return (action && action.isCasting());
        },
        currentAction: function () {
            return this._absParams.currentAction;
        },
        target: function () {
            return this._absParams.target;
        },
        isAlive: function () {
            if (this.battler() != null)
                return this.battler().isAlive();
            else
                return true;
        },
        battler: function () {
            return this._absParams.battler;
        },
        getHomePosition: function () {
            return this._absParams.myHomePosition;
        },
        inBattle: function () {
            return this._absParams.inBattle;
        },
        inActive: function () {
            return this._absParams.active;
        },
        selectOnMap: function (isSelect) {
            this._absParams.selected = isSelect;
        },
        changeStateToBattle: function (target) {
            this.setTarget(target);
            this._stateMachine.switchStateToBattle(this);
        },
        changeStateToFree: function () {
            this._stateMachine.switchStateToFree(this);
        },
        changeStateToReturn: function () {
            this._stateMachine.switchStateToReturn(this);
        },
        changeStateToSearch: function (targetToSearch) {
            this.setAllyTarget(targetToSearch);
            this._stateMachine.switchStateToSearch(this);
        },
        setAllyTarget: function (ally) {
            this._absParams.allyToSearch = ally;
        },
        changeTeamTo: function(id) {
            this.behaviorModel().teamId = id;
        },
        isSelected: function() {
            return this._absParams.selected;
        },
        allyToSearch: function() {
            return this._absParams.allyToSearch;
        },
        canRage: function () {
            return this.behaviorModel().rage == 1;
        },
        rageContainer: function () {
            return this._absParams.rageContainer;
        },
        name: function() {
            return this.aiName;
        },
        isNeedHpBarShow: function () {
            return false;
        },
        isSummonUnit: function() {
            return false;
        },
        isPlayerAttackedMe: function() {
            return false;
        },
        isCanBeLooted: function() {
            return this._absParams.looted == false;
        },
        isHasAnyLoot: function() {
            return false;
        },
        level: function() {
            return this.behaviorModel().level;
        }
    };

    AlphaABS.LIBS.Interface_AIBot = Interface_AIBot;
})();
// Generated by CoffeeScript 2.5.1
(function() {
  var Interface_AIBotABS;
  //@[INTERFACE]
  Interface_AIBotABS = {
    initABS: function() {},
    _deactivate: function() {
      if (AlphaABS.BattleManagerABS.getPlayerTarget() === this) {
        AlphaABS.BattleManagerABS.setPlayerTarget(null);
      }
      this._absParams.active = false;
      this._resetTarget();
      if (this._stateMachine != null) {
        this._stateMachine.deactivate();
      }
    },
    _resetTarget: function() {
      this._absParams.target = null;
      this._absParams.inBattle = false;
      this.interruptCast();
    },
    _updateABS: function() {},
    _checkFloorEffect: function() {
      if ($gameMap.isDamageFloor(this.x, this.y)) {
        this.battler().executeFloorDamage();
      }
    },
    startCommonEvent: function(commonEventId) {},
    clearTarget: function() {
      return this.setTarget(null);
    },
    setTarget: function(target) {
      if (AlphaABS.BattleManagerABS.isValidTarget(target)) {
        this._absParams.target = target;
        if (target === $gamePlayer) {
          $gamePlayer.refreshBattleState();
        }
      } else {
        this._resetTarget();
      }
    },
    createNewHomePoint: function() {
      return this._absParams.myHomePosition = new KDCore.Point(this.x, this.y);
    },
    refreshBehavior: function() {
      this.clearTarget();
      return this.changeStateToFree();
    },
    refreshABSMotionState: function() {},
    refreshABSMotion: function() {},
    _checkCanShowByParameters: function() {
      var showWhenSelect;
      if (!AlphaABS.Parameters.isLoaded()) {
        return false;
      }
      showWhenSelect = AlphaABS.Parameters.get_EnemyMiniHpBarOption() === 2;
      return showWhenSelect === true;
      return false;
    },
    refreshGlobal: function() {}
  };
  AlphaABS.LIBS.Interface_AIBotABS = Interface_AIBotABS;
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Interface_AIBotABSEvents;
  //@[INTERFACE]
  Interface_AIBotABSEvents = {
    onTurnEnd: function() {
      if (this.inBattle()) {
        return this.battler().onTurnEnd();
      }
    },
    onActionOnMe: function(who) {
      if (!this.canFight()) {
        return;
      }
      if (this.isSummonUnit() && who === $gamePlayer) {
        return;
      }
      if (!!this.inBattle()) {
        if (this.behaviorModel().teamId === 0 && who === $gamePlayer) {
          return;
        }
        this.LOG.p('I\'am attacked!!!');
        return this.changeStateToBattle(who);
      } else {
        return this._performRageCalculation(who);
      }
    },
    _performRageCalculation: function(who) {
      var ref, result;
      result = this.battler().result();
      if (result.hpAffected && result.hpDamage > 0 && !result.drain) {
        if (who != null) {
          if ((ref = this.rageContainer()) != null) {
            ref.makeDamageBy(result.hpDamage, who);
          }
        }
      }
      if (this.canRage()) {
        this._selectNewTargetByRage();
      }
    },
    _selectNewTargetByRage: function() {
      var candidate, ref;
      candidate = (ref = this.rageContainer()) != null ? ref.getHigherDealer() : void 0;
      if ((candidate != null) && candidate !== this.target()) {
        this.LOG.p('New target ' + candidate.aiName);
        return this.setTarget(candidate); //if in view range?
      }
    },
    //@requestBalloon 1 unless @behaviorModel().noEmote
    onGameSave: function() {
      if (this._stateMachine != null) {
        return this._stateMachine.onGameSave();
      }
    },
    onGameLoad: function() {
      this.LOG.p('On Game Load');
      if (this._stateMachine != null) {
        this._stateMachine.onGameLoad();
      }
      this.battler().onGameLoad();
      this.refreshGlobal();
      this._updateSafeThreadTimer = function() {
        return this._updateSafeThreadTimerBody.bind(this);
      };
    },
    onSwitchToBattleState: function() {
      return this._onBattleStart();
    },
    _onBattleStart: function() {
      var ref;
      if (!this.behaviorModel().noEmote) {
        this.requestBalloon(1);
      }
      this.battler().onBattleStart();
      this._absParams.inBattle = true;
      $gameTemp._aaAIBotsInBattleGlobalCount += 1;
      this.createNewHomePoint();
      if (this.getHomePosition() != null) {
        this.LOG.p('Store home position: ' + this.getHomePosition().toString());
      }
      this.startCommonEvent(this.behaviorModel().cEonStart);
      if ((ref = this.rageContainer()) != null) {
        ref.addDealer(this.target());
      }
      this.refreshABSMotionState(true);
      if (this.isAnimX()) {
        this.switchToXAnimaState('inBattle');
      }
    },
    onReturnEnd: function() {},
    _onBattleEnd: function() {
      var ref;
      this._absParams.inBattle = false;
      this._absParams.allyToSearch = null;
      this.battler().onBattleEnd();
      if ((ref = this.rageContainer()) != null) {
        ref.clear();
      }
      this.changeStateToFree();
      this.refreshABSMotion();
      this.refreshABSMotionState(false);
      this.startCommonEvent(this.behaviorModel().cEonEnd);
      $gameTemp._aaAIBotsInBattleGlobalCount -= 1;
      if (this.isAnimX()) {
        this.resetXAnimaState();
      }
    },
    onSwitchToFreeState: function() {
      this.refreshABSMotion();
      this.LOG.p('In free state');
      this.clearTarget();
    },
    onSwitchToReturnState: function() {},
    onSwitchToSearchState: function() {},
    onSwitchToDeadState: function() {},
    onSwitchToStunState: function() {
      this.clearTarget();
      this.stay();
      this.LOG.p('AI : I\'am stunned!');
    },
    _callCEWhenTargetLevelIsHigh: function() {}
  };
  AlphaABS.LIBS.Interface_AIBotABSEvents = Interface_AIBotABSEvents;
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Interface_AIBotABSMoving;
  //@[INTERFACE]
  Interface_AIBotABSMoving = {
    stay: function() {},
    moveTypeTowardPlayer: function() {
      if (!this.isNearThePlayerX()) {
        return this.moveToPointAA($gamePlayer);
      }
    },
    returnSlow: function() {},
    returnFast: function() {},
    _escapeFromTarget: function(target) {
      if (target == null) {
        return;
      }
      if (!this.isMoving()) {
        this._performEscapeFromTarget(target);
      }
    },
    _performEscapeFromTarget: function(target) {
      var distance, escapeRange;
      if (this.isCanPerformTeleportOutNow()) {
        this.performTeleportFromTarget();
        this.turnTowardTarget();
      } else {
        escapeRange = 2;
        distance = AlphaABS.UTILS.distanceTo(this, target);
        if (distance < escapeRange) {
          this.moveFromPoint(target);
          this.turnTowardTarget();
        } else if (distance > (escapeRange + 1)) {
          if (this.behaviorModel().agressive === 1) {
            this.moveTowardCharacter(target);
          } else {
            this.turnTowardTarget();
          }
        } else {
          this.turnTowardTarget();
        }
      }
    },
    turnTowardTarget: function() {
      var target;
      target = this.target();
      if (target != null) {
        return this.turnTowardCharacter(target);
      }
    },
    runAwayFromTarget: function(target) {
      if (target == null) {
        return;
      }
      if (!this.isMoving()) {
        return this._performRunAwayFromTarget(target);
      }
    },
    _performRunAwayFromTarget: function(target) {
      var distance, escapeRange, realRange;
      realRange = this._absParams.viewRadius / 2;
      escapeRange = realRange >= 2 ? realRange : 2;
      distance = AlphaABS.UTILS.distanceTo(this, target);
      if (distance < escapeRange) {
        this._applyAproachSpeed();
        return this.moveFromPoint(target);
      } else {
        return this.changeStateToFree();
      }
    },
    _applyAproachSpeed: function() {},
    startPursuitTarget: function() {},
    moveTypeTowardTarget: function() {
      var target;
      target = this.target();
      if (target != null) {
        if (!this.isNearThePointX(target)) {
          return this.moveToPointAA(target);
        } else {
          return this.turnTowardTarget();
        }
      }
    },
    moveToAlly: function() {
      var e;
      try {
        if (!this.isMoving() && !this._absParams.behavior.noMove) {
          if (this._absParams.allyToSearch != null) {
            return this.moveToPointAA(this._absParams.allyToSearch);
          } else {
            return this.changeStateToFree();
          }
        }
      } catch (error) {
        e = error;
        return this.changeStateToFree();
      }
    }
  };
  AlphaABS.LIBS.Interface_AIBotABSMoving = Interface_AIBotABSMoving;
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Interface_AIBotActions;
  //@[INTERFACE]
  Interface_AIBotActions = {
    interruptCast: function() {
      var action, ref;
      if ((ref = this.battler()) != null) {
        ref.onAACastStop();
      }
      action = this.currentAction();
      if (this.isCasting()) {
        this.LOG.p('Cast intterupt');
        action.resetCast();
      }
    },
    _makeActions: function() {
      if (this.inSupportPhase()) {
        return this._makeSupportAction();
      } else {
        return this._makeBattleActions();
      }
    },
    _makeBattleActions: function() {
      var actions;
      if (this.isCasting()) {
        return;
      }
      this.battler().makeActions();
      actions = this.battler()._actions.filter((function(action) {
        var skill;
        skill = this.battler().skillABS_byAction(action);
        return this._checkAndPrepareAbsSkillForTarget(skill);
      }).bind(this));
      if (actions.length > 0) {
        //TODO: Сделать умный выбор, например в ближнем бою не выбирать навык с castTime
        this._setForceAction(actions.first());
      } else {
        //"NO ACTIONS".p()
        this._setCurrentAction(this.battler().action(0));
      }
    },
    
    // * mod in 1198
    //@_setCurrentAction null
    _checkAndPrepareAbsSkillForTarget: function(skill, target = null) {
      if (skill == null) {
        return false;
      }
      if (target == null) {
        target = this.target();
      }
      if (skill.isVectorType() && skill.isNoTarget() && (target != null)) {
        return this._checkNoTargetVector(skill);
      } else {
        if (skill) {
          target = skill.isNeedTarget() ? target : this;
        }
        if ((skill.isRadiusType() && !skill.isRadiusTypeR()) || skill.isZoneType()) {
          return this._checkRadiusTypeSkill(skill);
        } else {
          return AA.LIBS.AILogicManager.isUsableABSSkill(skill, this.battler().isEnemy()) && AA.BattleManagerABS.canUseABSSkillNow(this, target, skill);
        }
      }
    },
    _checkRadiusTypeSkill: function(skill) {
      var candidates, usable;
      usable = AA.LIBS.AILogicManager.isUsableABSSkill(skill, this.battler().isEnemy());
      if (usable === true) {
        candidates = AA.LIBS.AILogicManager.inSkillRadius(this, skill.radius);
        return candidates.length > 0;
      }
      return false;
    },
    _checkNoTargetVector: function(skill) {
      var d, isHard, result;
      if (!skill) {
        return false;
      }
      result = AlphaABS.BattleManagerABS.canUseABSSkillNow(this, this.target(), skill) && AlphaABS.LIBS.AILogicManager.isUsableABSSkill(skill, this.battler().isEnemy());
      d = AlphaABS.UTILS.distanceTo(this, this.target());
      if (skill.range >= d) {
        this.turnTowardTarget();
        if (skill.isDirectionFix()) {
          isHard = AlphaABS.UTILS.inDirectionHard(this, this.target());
          return isHard && result;
        }
        return result;
      }
      return false;
    },
    _setForceAction: function(action) {
      this._absParams.currentAction = this.battler().skillABS_byAction(action);
      this._stateMachine.switchActionStateToAction();
    },
    _setCurrentAction: function(action) {
      var skill;
      skill = this.battler().skillABS_byAction(action);
      if (this._absParams.currentAction !== skill) {
        this._absParams.currentAction = skill;
        if (this._absParams.currentAction != null) {
          this._stateMachine.switchActionStateToPrepare();
        } else {
          if (this.behaviorModel().escapeOnBattle) {
            this._stateMachine.switchActionStateToEscape();
          } else {
            this._stateMachine.switchActionStateToWait();
          }
        }
      }
    },
    _performAction: function() {
      var action, candidates, currentAction, process, target;
      currentAction = this.currentAction();
      this.LOG.p('Perform! ' + currentAction.skill().name);
      process = AlphaABS.BattleManagerABS.battleProcess();
      if (currentAction.isVectorType()) {
        action = this.battler().action(0);
        target = this.target();
        if (currentAction.isNoTarget()) {
          if (currentAction.isDirectionFix()) {
            target = AlphaABS.UTILS.getEndPointFromCharToRange(this, currentAction.range);
          } else {
            target = this.target().toPoint();
          }
        }
        //AlphaABS.UTILS.
        //    getEndPointFromChartToRangeNoFixed(
        //        @, currentAction.range, @target().toPoint())
        //console.info(target)
        process.startPostBattleAction(this, target, action, currentAction);
      } else {
        if (currentAction.isNeedTarget()) {
          process.performBattleAction(this, this.target());
        } else {
          if (currentAction.isRadiusType()) {
            //"RADIUS".p()
            candidates = AA.LIBS.AILogicManager.inSkillRadius(this, currentAction.radius);
            process.setForceTargetsForZoneAndRadius(candidates);
            process.performBattleActionRadius(this, this.toPoint(), this.battler().action(0), currentAction);
          } else if (currentAction.isZoneType()) {
            candidates = AA.LIBS.AILogicManager.inSkillRadius(this, currentAction.radius);
            process.setForceTargetsForZoneAndRadius(candidates);
            process.performBattleActionZone(this, this.battler().action(0));
          } else {
            process.performBattleAction(this, this);
          }
        }
      }
      this.battler().performCurrentAction();
      process.setForceTargetsForZoneAndRadius(null);
      this._absParams.currentAction.playStartSound(this.toPoint());
      this._stateMachine.switchActionStateToPrepare();
      if (this.inSupportPhase()) {
        this._cancelSupportPhase();
      }
    },
    checkActionCommonEvent: function() {
      this.startCommonEvent(this.currentAction().cEonStart);
    }
  };
  AlphaABS.LIBS.Interface_AIBotActions = Interface_AIBotActions;
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEntity.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL]
var AAEntity;

AAEntity = class AAEntity {
  constructor() {
    this._setup();
  }

  _setup() {
    this._active = false;
    this._target = null;
    this._inBattle = false;
    return this._dead = false;
  }

  initABS() {
    return this.activate();
  }

  teamId() {
    return 0;
  }

  update() {}

  character() {}

  battler() {}

  setTarget(target) {
    if (target != null) {
      return this._target = target;
    } else {
      return this.resetTarget();
    }
  }

  resetTarget() {
    return this._target = null;
  }

  getTarget() {
    return this._target;
  }

  isHasTarget() {
    return this.getTarget() != null;
  }

  isActive() {
    return this._active === true;
  }

  activate() {
    return this._active = true;
  }

  deactivate() {
    return this._active = false;
  }

  inBattle() {
    return this._inBattle === true;
  }

  setBattle() {
    return this._inBattle = true;
  }

  resetBattle() {
    return this._inBattle = false;
  }

  isDead() {
    return this._dead === true;
  }

  setDead() {
    return this._dead = true;
  }

  resetDead() {
    return this._dead = false;
  }

  isMyEnemy(character) {
    if (character != null) {
      return character.AAEntity().teamId() !== this.teamId();
    }
    return false;
  }

  stopABS() {}

};

// ■ END AAEntity.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GS GamePad Main class.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL]
var AAGamePadManager;

AAGamePadManager = function() {
  throw new Error('This is static classs');
};

// * Это для игрока
AAGamePadManager.SCHEME = {
  action: 'A',
  jump: 'X',
  attack: 'RTrigger',
  command: 'Y',
  menu: 'B',
  follow: 'LStick',
  target: 'RStick',
  select0: 'dUp',
  select1: 'dRight',
  select2: 'dDown',
  select3: 'dLeft',
  switchSkills: 'LB',
  dashing: 'LTrigger',
  switchCommand: 'RB'
};

// * Это конвертирование в сивмолы MV
AAGamePadManager.MAPPER = {
  X: 'shift',
  A: 'ok',
  B: 'cancel',
  Y: 'menu',
  LStick: 'LStick',
  RStick: 'RStick',
  dUp: 'dUp',
  dDown: 'dDown',
  dLeft: 'dLeft',
  dRight: 'dRight',
  LB: 'pageup',
  RB: 'pagedown',
  LTrigger: 'LTrigger',
  RTrigger: 'RTrigger'
};

AAGamePadManager.isReady = function() {
  return Input._axes != null;
};

AAGamePadManager.GetRightStickX = function() {
  var gamepad;
  gamepad = navigator.getGamepads().item(0);
  if (gamepad != null) {
    return gamepad.axes[2];
  } else {
    return 0;
  }
};

AAGamePadManager.GetRightStickY = function() {
  var gamepad;
  gamepad = navigator.getGamepads().item(0);
  if (gamepad != null) {
    return gamepad.axes[3];
  } else {
    return 0;
  }
};

AAGamePadManager.ActionKey = function() {
  return AAGamePadManager._convertKey('action');
};

AAGamePadManager.MenuKey = function() {
  return AAGamePadManager._convertKey('menu');
};

AAGamePadManager.CommandKey = function() {
  return AAGamePadManager._convertKey('command');
};

AAGamePadManager.SwitchCommandKey = function() {
  return AAGamePadManager._convertKey('switchCommand');
};

AAGamePadManager.JumpKey = function() {
  return AAGamePadManager._convertKey('jump');
};

AAGamePadManager.FollowKey = function() {
  return AAGamePadManager._convertKey('follow');
};

AAGamePadManager.NextTargetKey = function() {
  return AAGamePadManager._convertKey('target');
};

AAGamePadManager.AttackKey = function() {
  return AAGamePadManager._convertKey('attack');
};

AAGamePadManager.SelectKey0 = function() {
  return AAGamePadManager._convertKey('select0');
};

AAGamePadManager.SelectKey1 = function() {
  return AAGamePadManager._convertKey('select1');
};

AAGamePadManager.SelectKey2 = function() {
  return AAGamePadManager._convertKey('select2');
};

AAGamePadManager.SelectKey3 = function() {
  return AAGamePadManager._convertKey('select3');
};

AAGamePadManager.SwitchSkillsKey = function() {
  return AAGamePadManager._convertKey('switchSkills');
};

AAGamePadManager.DashingKey = function() {
  return AAGamePadManager._convertKey('dashing');
};

AAGamePadManager.GetSelectIndex = function() {
  var selectIndex;
  selectIndex = 0;
  if (Input.isTriggered(AAGamePadManager.SelectKey0())) {
    selectIndex = 1;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey1())) {
    selectIndex = 2;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey2())) {
    selectIndex = 3;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey3())) {
    selectIndex = 4;
  }
  return selectIndex;
};

//AAGamePadManager.ConvertSelectIndexToSymbol = (index) ->
//switch index
//when 0, 4
//return ""
//else
AAGamePadManager._convertKey = function(schemeName) {
  var gamepadKey;
  gamepadKey = AAGamePadManager.SCHEME[schemeName];
  return AAGamePadManager.MAPPER[gamepadKey];
};

AAGamePadManager.InitPlayerTargetCirclePosition = function() {
  return this._targetCirclePoint = (new KDCore.Point($gamePlayer.x, $gamePlayer.y)).convertToScreen();
};

AAGamePadManager.GetTargetCirclePositionByGamepad = function() {
  var pos, x, y;
  pos = this._targetCirclePoint;
  if (pos == null) {
    pos = AAGamePadManager.InitPlayerTargetCirclePosition();
  }
  x = AAGamePadManager.GetRightStickX();
  y = AAGamePadManager.GetRightStickY();
  if (x > 0.2 || x < -0.2) {
    pos._x = Math.round(pos._x + x * 5);
  }
  if (y > 0.2 || y < -0.2) {
    pos._y = Math.round(pos._y + y * 5);
  }
  return pos;
};

// ■ END GS GamePad Main class.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAGamepadUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var GamePadUI;
  GamePadUI = (function() {
    class GamePadUI {
      constructor(layer1) {
        this.layer = layer1;
        AA.log('GamePad UI inited');
        this.S = AAJsonSettings.getGamepadUISettings();
        //@gamePadUILayer = new Sprite()
        //@layer.addChild @gamePadUILayer
        this._create();
        AA.BattleUI.spellPanel().hide();
      }

      _create() {
        var p;
        this._hidden = false;
        //@_symbolsLayer = new Sprite()
        this._createSpellPad();
        //@layer.addChild @spellPad
        this.emptyCommand = AASprite.FromImg(this.S.Other.EmptyButtonImg);
        p = AA.Utils.convertPositionPointFromJSON(this.S.Other.EmptyButtonsPosition);
        this.emptyCommand.move(p);
        return this.emptyCommand.opacity = this.S.Other.EmptyButtonOpacity;
      }

      //@layer.addChild @emptyCommand

        //@layer.addChild @_symbolsLayer
      _createSpellPad() {
        var a;
        //if @spellPad?
        //    @spellPad.parent?.removeChild @spellPad
        this.spellPad = new AA.LIBS.SpriteSpellPanelGP();
        a = AA.BattleUI.spellPanel();
        return this.spellPad.setupItems(a.newSpellPanelUIElement._container.items);
      }

      update() {
        return this.spellPad.update();
      }

      hide() {
        var e, i, j, len, ref, ref1, ref2, ref3, ref4, ref5;
        this._hidden = true;
        try {
          if (this._syms != null) {
            ref = this._syms;
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              if (i != null) {
                i.visible = false;
              }
            }
          }
          if ((ref1 = this.spellPad) != null) {
            ref1.visible = false;
          }
          if ((ref2 = this.swichCmdIcon) != null) {
            ref2.visible = false;
          }
          if ((ref3 = this.emptyCommand) != null) {
            ref3.visible = false;
          }
          if ((ref4 = this.menuBtn) != null) {
            ref4.visible = false;
          }
          if ((ref5 = this.actionBtn) != null) {
            ref5.visible = false;
          }
        } catch (error) {
          e = error;
          AA.warning('warning', e);
        }
      }

      show() {
        var e, i, j, len, ref, ref1, ref2, ref3, ref4, ref5;
        this._hidden = false;
        try {
          if (this._syms != null) {
            ref = this._syms;
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              if (i != null) {
                i.visible = true;
              }
            }
          }
          ButtonsProManager.getAAButton('rotate').hide();
          ButtonsProManager.getAAButton('follow').hide();
          if ((ref1 = this.spellPad) != null) {
            ref1.visible = true;
          }
          if ((ref2 = this.swichCmdIcon) != null) {
            ref2.visible = true;
          }
          if ((ref3 = this.emptyCommand) != null) {
            ref3.visible = true;
          }
          if ((ref4 = this.menuBtn) != null) {
            ref4.visible = true;
          }
          if ((ref5 = this.actionBtn) != null) {
            ref5.visible = true;
          }
        } catch (error) {
          e = error;
          AA.warning('warning', e);
        }
      }

      setVisibility(isVisible) {
        if (isVisible === true) {
          return this.show();
        } else {
          return this.hide();
        }
      }

      refresh() {
        //AA.BattleUI.spellPanel()?.refresh()
        return this.spellPad.refresh(AA.BattleUI.spellPanel().newSpellPanelUIElement._container.items);
      }

      terminate() {
        var i, j, len, ref;
        this.hide();
        ref = this._syms;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          i.parent.removeChild(i);
        }
        return this.spellPad.parent.removeChild(this.spellPad);
      }

      afterButtonsLoad() {
        if (!AA.isABS()) {
          return;
        }
        ButtonsProManager.getAAButton('rotate').hide();
        ButtonsProManager.getAAButton('follow').hide();
        ButtonsProManager.getAAButton('inventory').hide();
        this._moveButtons();
        this._moveCmdButtons();
        this._createMenuBtn();
        this._createGPSymbols();
        this.refreshGCommands();
        if (this._hidden === true) {
          return this.hide();
        }
      }

      _moveButtons() {
        var S, atk, img0, img01, img2, img21, img3, img31, jmp, pp, shield, weap;
        S = this.S.Buttons;
        atk = ButtonsProManager.getAAButton('attack');
        img0 = ImageManager.loadAA('GP_Attack_00');
        img2 = ImageManager.loadAA('GP_Attack_02');
        img3 = ImageManager.loadAA('GP_Attack_03');
        atk.setButtonImages(img0, img0, img2, img3);
        atk.setHelpText("");
        atk.move(AA.Utils.convertPositionPointFromJSON(S.Attack.position));
        jmp = ButtonsProManager.getAAButton('jump');
        img0 = ImageManager.loadAA('GP_Jump_00');
        img2 = ImageManager.loadAA('GP_Jump_02');
        img3 = ImageManager.loadAA('GP_Jump_03');
        jmp.setButtonImages(img0, img0, img2, img3);
        jmp.setHelpText("");
        jmp.move(AA.Utils.convertPositionPointFromJSON(S.Jump.position));
        // * CMD BUTTONS
        this._cmdButtons = [];
        pp = AA.Utils.convertPositionPointFromJSON(S.AnyCommand.position);
        weap = ButtonsProManager.getAAButton('weapons');
        img0 = ImageManager.loadAA('GP_Weapons_00');
        img2 = ImageManager.loadAA('GP_Weapons_02');
        img3 = ImageManager.loadAA('GP_Weapons_03');
        weap.setButtonImages(img0, img0, img2, img3);
        weap.setHelpText("");
        weap.move(pp);
        this._cmdButtons[0] = weap;
        shield = ButtonsProManager.getAAButton('shield');
        img01 = ImageManager.loadAA('GP_Shield_00');
        img21 = ImageManager.loadAA('GP_Shield_02');
        img31 = ImageManager.loadAA('GP_Shield_03');
        shield.setButtonImages(img01, img01, img21, img31);
        shield.setHelpText("");
        shield.move(pp);
        this._cmdButtons[1] = shield;
        this._loadSummon();
        this.reloadBtn = new KDCore.Button();
        img0 = ImageManager.loadAA('GP_Reload_00');
        img2 = ImageManager.loadAA('GP_Reload_02');
        img3 = ImageManager.loadAA('GP_Reload_03');
        this.reloadBtn.setButtonImages(img0, img0, img2, img3);
        this.reloadBtn.move(pp);
        this.layer.addChild(this.reloadBtn);
        this._cmdButtons[2] = this.reloadBtn;
        return this.reloadBtn.hide();
      }

      _loadSummon() {
        var img0, img01, img2, img21, img3, img31, pp, summon, unsummon;
        pp = AA.Utils.convertPositionPointFromJSON(this.S.Buttons.AnyCommand.position);
        summon = ButtonsProManager.getAAButton('summon');
        img0 = ImageManager.loadAA('GP_Summon_00');
        img2 = ImageManager.loadAA('GP_Summon_02');
        img3 = ImageManager.loadAA('GP_Summon_03');
        summon.setButtonImages(img0, img0, img2, img3);
        summon.setHelpText("");
        summon.move(pp);
        this._cmdButtons[3] = summon;
        unsummon = ButtonsProManager.getAAButton('unsummon');
        img01 = ImageManager.loadAA('GP_Unsummon_00');
        img21 = ImageManager.loadAA('GP_Unsummon_02');
        img31 = ImageManager.loadAA('GP_Unsummon_03');
        unsummon.setButtonImages(img01, img01, img21, img31);
        unsummon.setHelpText("");
        unsummon.move(pp);
        return this._cmdButtons[4] = unsummon;
      }

      _moveCmdButtons() {
        var p;
        this.swichCmdIcon = AASprite.FromImg(this.S.Other.SwitchCommandImg);
        p = AA.Utils.convertPositionPointFromJSON(this.S.Other.SwitchCommandPosition);
        return this.swichCmdIcon.move(p);
      }

      //@layer.addChild @swichCmdIcon
      _createMenuBtn() {
        var act, img0, img2, img3, layer, menu, p;
        layer = ButtonsProManager.getCurrentSystem().scene;
        layer.addChild(this.spellPad);
        layer.addChildAt(this.emptyCommand, 0);
        layer.addChild(this.swichCmdIcon);
        menu = new KDCore.Button();
        img0 = ImageManager.loadAA('GP_Menu_00');
        img2 = ImageManager.loadAA('GP_Menu_02');
        img3 = ImageManager.loadAA('GP_Menu_03');
        menu.setButtonImages(img0, img0, img2, img3);
        p = AA.Utils.convertPositionPointFromJSON(this.S.SpecialButtons.Action.position);
        menu.move(p);
        layer.addChild(menu);
        this.menuBtn = menu;
        act = new KDCore.Button();
        img0 = ImageManager.loadAA('GP_Action_00');
        img2 = ImageManager.loadAA('GP_Action_02');
        img3 = ImageManager.loadAA('GP_Action_03');
        act.setButtonImages(img0, img0, img2, img3);
        p = AA.Utils.convertPositionPointFromJSON(this.S.SpecialButtons.Menu.position);
        act.move(p);
        layer.addChild(act);
        return this.actionBtn = act;
      }

      _createGPSymbols() {
        var _conv, _p, layer, symA, symB, symRT, symX, symY;
        // * Чтобы были выше кнопок
        _p = this.S.GamepadSymbols;
        _conv = AA.Utils.convertPositionPointFromJSON;
        this._syms = [];
        layer = ButtonsProManager.getCurrentSystem().scene;
        symA = AASprite.FromImg(_p.SYM_A.img);
        layer.addChild(symA);
        symA.move(_conv(_p.SYM_A.position));
        this._syms.push(symA);
        symB = AASprite.FromImg(_p.SYM_B.img);
        layer.addChild(symB);
        symB.move(_conv(_p.SYM_B.position));
        this._syms.push(symB);
        symX = AASprite.FromImg(_p.SYM_X.img);
        layer.addChild(symX);
        symX.move(_conv(_p.SYM_X.position));
        this._syms.push(symX);
        symY = AASprite.FromImg(_p.SYM_Y.img);
        layer.addChild(symY);
        symY.move(_conv(_p.SYM_Y.position));
        this._syms.push(symY);
        symRT = AASprite.FromImg(_p.SYM_RT.img);
        layer.addChild(symRT);
        symRT.move(_conv(_p.SYM_RT.position));
        return this._syms.push(symRT);
      }

      // * Кнопка меню дополнительная, она не входит в систему кнопок экрана
      simulateMenuClick() {
        return this.menuBtn.simulateClickManual();
      }

      simulateActionClick() {
        return this.actionBtn.simulateClickManual();
      }

      simulateFirearmClick() {
        return this.reloadBtn.simulateClickManual();
      }

      switchSkillMode(mode) {
        if (mode === true) {
          return this.spellPad._setMainContainerB();
        } else {
          return this.spellPad._setMainContainerA();
        }
      }

      refreshGCommands() {
        var cur, i, j, len, mainBtn, max, pos, ref;
        max = $gamePlayer._absParams._GPRegistredCommands.length;
        this.swichCmdIcon.visible = max > 1;
        this.reloadBtn.visible = $gamePlayer._absParams._GPRegistredCommands[2] != null;
        ref = this._cmdButtons;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          if (i != null) {
            i.move(Graphics.width + 100, Graphics.height + 100);
          }
        }
        cur = $gamePlayer._absParams._GPCommandIndex;
        mainBtn = this._cmdButtons[cur];
        if (cur === 4) { //TODO: TEMP SOLUTION
          mainBtn.show();
        }
        pos = AA.Utils.convertPositionPointFromJSON(this.S.Buttons.AnyCommand.position);
        mainBtn.move(pos);
        //mainBtn.applyScale(1)
        return this.emptyCommand.visible = this.swichCmdIcon.visible;
      }

    };

    AA.register(GamePadUI);

    return GamePadUI;

  }).call(this);
})();

// ■ END AAGamepadUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Alpha ABS JSON Settings.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
var AAJsonSettings;

AAJsonSettings = function() {
  throw new Error('This is a static class');
};

(function() {
  var _;
  //@[DEFINES]
  _ = AAJsonSettings;
  //* UI =============================================================
  _.UIActorPortrait = 'UIActorPortrait';
  _.UIGauges = 'UIGauges';
  _.UIActorWeapon = 'UIActorWeapon';
  _.UIElements = 'UIElements';
  _.UIActorCastBar = 'UIActorCastBar';
  _.UIActorCharacterDamage = 'UIActorCharacterDamage';
  _.UISpellPanel = 'UISpellPanel';
  _.UINotifyText = 'UINotifyText';
  _.UIEnemyCastBar = 'UIEnemyCastBar';
  _.UIAllyCastBar = 'UIAllyCastBar';
  _.UISpellInfo = 'UISpellInfo';
  _.UIShieldTimer = 'UIShieldTimer';
  _.UISummonUnit = 'UISummonUnit';
  _.UISummonCastBar = 'UISummonCastBar';
  _.UIGamepad = 'UIGamepad';
  _.UIMapInventory = 'UIMapInventory';
  _.UIMapChest = 'UIMapChest';
  _.UIUserChest = 'UIUserChest';
  _.UICommonSettings = 'UICommonSettings';
  _.UIMapSkillWindow = 'UIMapSkillWindow';
  _.UIMapStatesWindow = 'UIStatesWindow';
  //* DATA ===========================================================
  _.AAEnemies = 'AAEnemies';
  _.AASkills = 'AASkills';
  _.AAItems = 'AAItems';
  _.AAWeapons = 'AAWeapons';
  _.EnemyLeveling = 'EnemyLeveling';
  //* EXT ============================================================
  _.EventsHints = 'EventsHints';
  _.DamagePopUpSettings = 'DamagePopUpSettings';
  _.FogSettings = 'FogSettings';
  _.AbsorbBarriers = 'AbsorbBarriers';
  _.ExtraTargetInfos = 'ExtraTargetInfos';
  //* SYSTEM =========================================================
  _.KeyBinding = 'KeyBinding';
  _.Locale = 'Locale';
  _.Fonts = 'Fonts';
  _._FILES = [
    _.KeyBinding,
    _.Locale,
    //_.Fonts,
    _.UICommonSettings,
    _.UIActorPortrait,
    _.UIGauges,
    _.UIActorWeapon,
    _.UIElements,
    _.UIActorCastBar,
    _.UISpellPanel,
    _.UINotifyText,
    _.UIEnemyCastBar,
    _.UISpellInfo,
    _.UIShieldTimer,
    _.UISummonUnit,
    _.UISummonCastBar,
    _.UIGamepad,
    _.UIMapInventory,
    _.UIMapSkillWindow,
    _.UIMapChest,
    _.UIUserChest,
    _.UIMapStatesWindow,
    _.UIAllyCastBar,
    _.EventsHints,
    _.AbsorbBarriers,
    _.AAEnemies,
    _.AAItems,
    _.AAWeapons,
    _.AASkills,
    _.EnemyLeveling,
    _.DamagePopUpSettings,
    _.FogSettings,
    _.ExtraTargetInfos
  ];
  //@[PUBLIC]
  //@[=====================================================================]
  _.InitAndLoad = function() {
    var i, j, ref, results;
    this.data = {};
    results = [];
    for (i = j = 0, ref = _._FILES.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      results.push(_._loadAAJSONFile(_._FILES[i]));
    }
    return results;
  };
  _.getPortraitSettings = function(actorNumber = 0) {
    var e;
    try {
      return this.data[_.UIActorPortrait][actorNumber];
    } catch (error) {
      e = error;
      _._onJError(_.UIActorPortrait);
      return null;
    }
  };
  _.getGaugeSettings = function(id) {
    return _._getSettingsById(id, _.UIGauges);
  };
  _.getExtraTargetInfo = function(id) {
    return _._getSettingsById(id, _.ExtraTargetInfos);
  };
  _.getCommonUISettings = function() {
    return this._getWithRescue("UICommonSettings");
  };
  _.getWeaponIconSettings = function() {
    return this._getWithRescueWithIndex("UIActorWeapon");
  };
  _.getActorSpellCastSettings = function() {
    return this._getWithRescueWithIndex("UIActorCastBar");
  };
  _.getEnemySpellCastSettings = function() {
    return this._getWithRescueWithIndex("UIEnemyCastBar");
  };
  _.getAllySpellCastSettings = function() {
    return this._getWithRescueWithIndex("UIAllyCastBar");
  };
  _.getSummonSpellCastSettings = function() {
    return this._getWithRescueWithIndex("UISummonCastBar");
  };
  _.getFogOfWarSettings = function() {
    return this._getWithRescue("FogSettings");
  };
  _.getGamepadUISettings = function() {
    return this._getWithRescue("UIGamepad");
  };
  _.getUIMapInventorySettings = function() {
    return this._getWithRescue("UIMapInventory");
  };
  _.getUIMapSkillSettings = function() {
    return this._getWithRescue("UIMapSkillWindow");
  };
  _.getUIMapChestSettings = function() {
    return this._getWithRescue("UIMapChest");
  };
  _.getUIMapUserChestSettings = function() {
    return this._getWithRescue("UIUserChest");
  };
  _.getUIMapStatesWindowSettings = function() {
    return this._getWithRescue("UIMapStatesWindow");
  };
  _.getAbsorbBarriersSettings = function() {
    return this._getWithRescueWithIndex("AbsorbBarriers");
  };
  _.getAbsordBarrierStyle = function(id) {
    var result;
    result = this.data[_.AbsorbBarriers].find(function(i) {
      return i.id === id;
    });
    if (result != null) {
      return result;
    }
    return this.getAbsordBarrierStyle(0); // * Если нет, то стандартный
  };
  _.getEnemyLeveling = function(enemyId) {
    var e, result;
    try {
      result = this.data[_.EnemyLeveling].find(function(i) {
        return i.EnemyID === enemyId;
      });
      if (result != null) {
        return result;
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
    return null;
  };
  _.getUIElementSettings = function(id) {
    return _._getSettingsById(id, _.UIElements);
  };
  _.getUISummonUnitSettings = function(id) {
    return _._getSettingsById(id, _.UISummonUnit);
  };
  _.getActorCharacterDamageSettings = function() {
    return this._getWithRescue("UIActorCharacterDamage");
  };
  _.getEnemyParameters = function(id) {
    return _._getSettingsById(id, _.AAEnemies);
  };
  _.getSkillParameters = function(id) {
    return _._getSettingsById(id, _.AASkills);
  };
  _.getItemParameters = function(id) {
    return _._getSettingsById(id, _.AAItems);
  };
  _.getWeaponParameters = function(id) {
    return _._getSettingsById(id, _.AAWeapons);
  };
  _.getEventHintData = function(id) {
    return _._getSettingsById(id, _.EventsHints);
  };
  _.getSpellControllerSettings = function() {
    return this._getWithRescueWithIndex("UISpellPanel", 0);
  };
  _.getUISpellPanelSettings = function() {
    return this._getWithRescueWithIndex("UISpellPanel", 1);
  };
  _.getUISpellItemSettings = function() {
    return this._getWithRescueWithIndex("UISpellPanel", 2);
  };
  _.getUINotifyTextSettings = function() {
    return this._getWithRescueWithIndex("UINotifyText");
  };
  _.getUISpellInfoSettings = function() {
    return this._getWithRescue("UISpellInfo");
  };
  _.getDamageExtraPopUpSettings = function() {
    return this._getWithRescue("DamagePopUpSettings");
  };
  _.getShieldTimerSettings = function() {
    return this._getWithRescueWithIndex("UIShieldTimer");
  };
  _.getKeyBinding = function() {
    return this._getWithRescue("KeyBinding");
  };
  _.getLocale = function() {
    return this._getWithRescue("Locale");
  };
  _._getWithRescue = function(jsonItem) {
    var e;
    try {
      return this.data[_[jsonItem]];
    } catch (error) {
      e = error;
      _._onJError(_[jsonItem]);
      return null;
    }
  };
  _._getWithRescueWithIndex = function(jsonItem, index = 0) {
    var e;
    try {
      return this.data[_[jsonItem]][index];
    } catch (error) {
      e = error;
      _._onJError(_[jsonItem]);
      return null;
    }
  };
  _._onJError = function(fileName) {
    alert(fileName + ".json file not found! Or have errors! Check data/AABS folder! Game will crush!!!");
    SceneManager.stop();
  };
  //@[PRIVATE]
  //@[=====================================================================]
  _._loadAAJSONFile = function(name) {
    var src, url, xhr;
    xhr = new XMLHttpRequest();
    src = name + '.json';
    url = 'data/AABS/' + src;
    xhr.open('GET', url);
    xhr.overrideMimeType('application/json');
    xhr.onload = function() {
      var data, e, message;
      if (xhr.status < 400) {
        try {
          data = JSON.parse(xhr.responseText);
        } catch (error) {
          e = error;
          AlphaABS.criticalError(e, "Error in JSON file " + src);
          return;
        }
        AAJsonSettings._loadJSONData(name, data);
        if (name === _.KeyBinding) {
          AAJsonSettings._loadKeyBinding();
        }
        if (name === _.Locale) {
          AAJsonSettings._loadLocale();
        }
        if (name === _.Fonts) {
          return AAJsonSettings._loadFonts();
        }
      } else {
        message = url + " not found!";
        return AlphaABS.criticalError(new Error(message), message);
      }
    };
    xhr.send();
  };
  _._loadJSONData = function(name, settings) {
    return this.data[name] = settings;
  };
  _._getSettingsById = function(id, name) {
    var e, result, t;
    try {
      result = this.data[_[name]].find(function(i) {
        return i.id === id;
      });
      if (result != null) {
        return result;
      }
      t = id + ' not found in ' + name + '.json';
      return AA.criticalError(new Error(t), 'ID not found!');
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  //TODO: Этот метод должен реализовываться в Input модуле, тут только ссылка на него
  _._loadKeyBinding = function() {
    var db, keys;
    AlphaABS.LIBS.IKey.loadDefaultKeyConfig();
    keys = [];
    db = _.getKeyBinding();
    keys[0] = db.common.Follow;
    keys[1] = db.common.Rotate;
    keys[2] = db.common.Jump;
    keys[3] = db.common.Attack;
    keys[4] = db.common.Weapons;
    keys[5] = db.common.TargetSelect;
    keys[6] = db.weaponCircle.TopSlot;
    keys[7] = db.weaponCircle.RightSlot;
    keys[8] = db.weaponCircle.BottomSlot;
    keys[9] = db.weaponCircle.LeftSlot;
    keys[10] = db.SkillsPanel.slot1;
    keys[11] = db.SkillsPanel.slot2;
    keys[12] = db.SkillsPanel.slot3;
    keys[13] = db.SkillsPanel.slot4;
    keys[14] = db.SkillsPanel.slot5;
    keys[15] = db.SkillsPanel.slot6;
    keys[16] = db.SkillsPanel.slot7;
    keys[17] = db.SkillsPanel.slot8;
    keys[18] = db.common.FirearmReload;
    keys[19] = db.common.NearestTargetSelect;
    keys[20] = db.common.AutoRotate;
    keys[21] = db.common.Shield;
    keys[22] = db.common.SummonMenu;
    keys[23] = db.common.Inventory;
    if (db.common.TakeAll != null) {
      keys[24] = db.common.TakeAll;
    }
    if (db.AlterMove != null) {
      keys[25] = db.AlterMove.up;
      keys[26] = db.AlterMove.down;
      keys[27] = db.AlterMove.left;
      keys[28] = db.AlterMove.right;
    }
    if (db.common.SkillWindow != null) {
      keys[29] = db.common.SkillWindow;
    }
    if (db.common.StatusWindow != null) {
      keys[30] = db.common.StatusWindow;
    }
    if (db.ActorsSwap != null) {
      keys[31] = db.ActorsSwap.actor1;
      keys[32] = db.ActorsSwap.actor2;
      keys[33] = db.ActorsSwap.actor3;
    }
    AA.LIBS.IKey.loadKeyConfig(keys);
    if ((db.Gamepad != null) && AA.isPro()) {
      return AAGamePadManager.SCHEME = db.Gamepad;
    }
  };
  //TODO: Это тоже вынести в отдельный класс, как StringLoader
  _._loadLocale = function() {
    var db, loader;
    db = _.getLocale()[0];
    loader = new KDCore.StringsLoader(null);
    //TODO: оптимизировать загрузку!
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.Alerts);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.PopUps);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.Menu);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.KeyBinding);
    return loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.SpellInfo);
  };
  _._loadFonts = function() {};
})();

//@[EXTEND]
//fonts = @data[_.Fonts]
//return unless fonts?
//return if fonts.length == 0
//projectDirectory = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'))
//for font in fonts
//    name = font.substr(0, font.length - (font.lastIndexOf('.')))
//    Graphics.loadFont(name, projectDirectory + '/fonts/' + font)
AA.JSON = AAJsonSettings;

// ■ END Alpha ABS JSON Settings.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAnimMotion.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AAnimMotion;
  AAnimMotion = class AAnimMotion {
    constructor() {
      this.pattern = 0;
      this._motionFrames = 3;
      this._motionDelay = 9;
      this._motionParts = 12;
      this._waitComplete = false;
      this._loop = false;
      this._started = false;
      this._yOffset = 0;
    }

    setMotion(_motionName, _motionIndex) {
      this._motionName = _motionName;
      this._motionIndex = _motionIndex;
    }

    setFrames(_motionFrames) {
      this._motionFrames = _motionFrames;
    }

    setDelay(_motionDelay) {
      this._motionDelay = _motionDelay;
    }

    setParts(_motionParts) {
      this._motionParts = _motionParts;
    }

    getDelay() {
      return this._motionDelay;
    }

    getParts() {
      return this._motionParts;
    }

    getFrames() {
      return this._motionFrames;
    }

    isStarted() {
      return this._started === true;
    }

    isWait() {
      return this._waitComplete === true;
    }

    setWait() {
      return this._waitComplete = true;
    }

    setLoop() {
      return this._loop = true;
    }

    setOffset(_yOffset) {
      this._yOffset = _yOffset;
    }

    getOffset() {
      return this._yOffset;
    }

    setFromABSMotion(ABSMotionData) {
      this.setMotion(ABSMotionData.getMotionName(), ABSMotionData.getMotionActionIndex());
      this.setFrames(ABSMotionData.getFrames());
      this.setDelay(ABSMotionData.getActionDelay());
      this.setParts(ABSMotionData.getParts());
      this.setOffset(ABSMotionData.getOffset());
      if (ABSMotionData.isLooping()) {
        this.setLoop();
      }
      if (ABSMotionData.isNeedWait()) {
        return this.setWait();
      }
    }

    startMotion(character) {
      //"MOTION STARTED".p()
      this._started = true;
      this._lastCN = character._characterName;
      this._lastIN = character._characterIndex;
      character._characterName = this._motionName;
      character._characterIndex = this._motionIndex;
      character._pattern = 0;
      return character.__AnimMotionReady = false;
    }

    motionPattern() {
      this.pattern++;
      return this.pattern;
    }

    checkAnimEnd() {
      if (this._loop === false) {
        if (this.pattern >= this.getFrames()) {
          return true;
        }
      } else {
        if (this.pattern >= this.getFrames()) {
          this.pattern = 0;
        }
      }
      return false;
    }

    clear(character) {
      if (this._lastCN == null) {
        return;
      }
      //"END MOTION".p()
      character._characterName = this._lastCN;
      character._characterIndex = this._lastIN;
      character.__AnimMotionReady = false;
      return character.resetPattern();
    }

    isProperName(name) {
      return name === this._motionName;
    }

  };
  AA.register(AAnimMotion);
})();

// ■ END AAnimMotion.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AANotifyManagerNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AANotifyManagerNew;
  AANotifyManagerNew = class AANotifyManagerNew {
    constructor() {
      this._notifyTime = AA.JSON.getUINotifyTextSettings().notifyShowDuration;
      this._notifySprite = new AA.LIBS.SpriteNotifyText();
      this._notifySprite.visible = false;
      this._timer = 0;
    }

    getSprite() {
      return this._notifySprite;
    }

    update() {
      //TODO 13: Timer
      this._notifySprite.update();
      if (this._timer > 0) {
        this._timer--;
        if (this._timer === 0) {
          return this._notifySprite.hide();
        }
      }
    }

    terminate() {}

    pushNotify(text) {
      this._timer = this._notifyTime;
      if (this._notifySprite.isHidden()) {
        return this._notifySprite.showWithText(text);
      } else {
        return this._notifySprite.showOnlyText(text);
      }
    }

  };
  AA.register(AANotifyManagerNew);
})();

// ■ END AANotifyManagerNew.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASkillLoaderNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
var AASkillLoader;

AASkillLoader = function() {
  throw new Error('This is a static class');
};

(function() {
  AASkillLoader.loadABSData = function(absSkill) {
    var e;
    try {
      // * Базовые параметры
      AASkillLoader.collectBaseParams(absSkill);
      // * Параметры из редактора MV
      AASkillLoader.collectFromMVEditor(absSkill);
      // * Параметры из JSON
      AASkillLoader.collectFromJSON(absSkill, absSkill.skill());
      // * Note секция (meta)
      AASkillLoader.collectFromMetaData(absSkill, absSkill.skill());
    } catch (error) {
      e = error;
      AA.warning(e, 'error load ABS parameters for Skill, Item or Weapon');
    }
  };
  AASkillLoader.collectBaseParams = function(_) {
    var template, type;
    type = _.type;
    template = ABSSkillLoader.TEMPLATES[type];
    return ABSSkillLoader.PARAMS.forEach(function(p) {
      if (template[p] != null) {
        return _[p] = template[p];
      } else {
        if (AASkillLoader.isStringParameter(p)) {
          return _[p] = null;
        } else {
          return _[p] = 0;
        }
      }
    });
  };
  AASkillLoader.collectFromMVEditor = function(_) {
    var item;
    item = _.skill();
    if (AASkillLoader.isWeapon(item)) {
      return;
    }
    _.castTime = item.speed;
    if (_.range === 1) {
      _.range = 0;
    }
    _.needTarget = false;
    if ([1, 3, 4, 5, 6, 7].contains(item.scope)) {
      _.needTarget = true;
    }
    if (_.needTarget === true) {
      if (item.scope === 7) {
        return _.forOneAlly = true;
      }
    } else {
      if (item.scope === 8) {
        return _.forAllAlly = true;
      }
    }
  };
  AASkillLoader.collectFromJSON = function(_, item) {
    var e, id, params;
    try {
      if (AA.Utils.hasMeta('outer', item)) {
        id = AA.Utils.getNumberFromMeta('outer', item);
        if (id === 0) {
          id = item.id;
        }
        params = AASkillLoader.getJSONData(item, id);
        return AASkillLoader.applyJsonParams(_, params);
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with AA Skill/Item/Weapon outer JSON settings');
    }
  };
  AASkillLoader.collectFromMetaData = function(_, item) {
    var e;
    try {
      //t = AA.Utils.hasMeta 'outer', item
      return ABSSkillLoader.PARAMS.forEach(function(p) {
        if (AA.Utils.hasMeta(p, item)) {
          if (AASkillLoader.isStringParameter(p)) {
            return _[p] = AA.Utils.getValueFromMeta(p, item);
          } else {
            return _[p] = AA.Utils.getNumberFromMeta(p, item);
          }
        }
      });
    } catch (error) {
      //if t
      //    AA.log 'Skill override param: ' + p + ' new value ' + _[p], AASkillLoader
      e = error;
      return AA.warning(e, 'Something wrong with Skill/Item/Weapon Note settings');
    }
  };
  AASkillLoader.getStrParamsCount = function() {
    return ABSSkillLoader.PARAMS.indexOf('reloadSound') + 1;
  };
  AASkillLoader.isWeapon = function(item) {
    return (item['wtypeId'] != null) && (item['etypeId'] != null);
  };
  AASkillLoader.isItem = function(item) {
    return (item['price'] != null) && (item['consumable'] != null);
  };
  AASkillLoader.getJSONData = function(item, id) {
    if (AASkillLoader.isWeapon(item)) {
      return AAJsonSettings.getWeaponParameters(id);
    }
    if (AASkillLoader.isItem(item)) {
      return AAJsonSettings.getItemParameters(id);
    }
    return AAJsonSettings.getSkillParameters(id);
  };
  AASkillLoader.applyJsonParams = function(data, params) {
    var p, results, v;
    results = [];
    for (p in params) {
      v = params[p];
      if (p === 'id') {
        continue;
      }
      if (ABSSkillLoader.PARAMS.include(p)) {
        results.push(data[p] = v);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  AASkillLoader.isStringParameter = function(paramName) {
    var index;
    index = ABSSkillLoader.PARAMS.indexOf(paramName);
    return index < AASkillLoader.getStrParamsCount();
  };
})();

// ■ END AASkillLoaderNew.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASpelllPanelManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AASpelllPanelManager;
  AASpelllPanelManager = class AASpelllPanelManager {
    constructor(battler) {
      this.battler = battler;
      this._baseSprite = new Sprite();
      this.settings = AA.JSON.getSpellControllerSettings();
      this._oldThreadValue = this.settings.threadUpdateMS;
      if (AA.Parameters.get_UsePerformanceSkillPanel()) {
        this.settings.threadUpdateMS *= 2;
      }
      this._visibleWhenEmpty = this.settings.visibleWhenEmpty;
      this._lastIndexForInfo = -1;
      this._showInfoTimer = 0; //TODO: AA Timer
      this._createThread();
      this._createThread2();
      this._createThread3();
      this._createThread4();
    }

    setBattler(battler) {
      this.battler = battler;
      this.refresh();
      this._updateSkillsStatesFast();
      this._updateSkillsStateNormal();
      return this._updateSkillsStateSlow();
    }

    _createThread() {
      return this._thread = AA.setInterval((() => {
        this._updateSkillsStatesFast();
      }), this.settings.threadUpdateMS);
    }

    _createThread2() {
      return this._thread2 = AA.setInterval((() => {
        this._updateInfo();
      }), this._oldThreadValue * 5);
    }

    _createThread3() {
      return this._thread3 = AA.setInterval((() => {
        this._updateSkillsStateNormal();
      }), this.settings.threadUpdateMS * 2);
    }

    _createThread4() {
      return this._thread4 = AA.setInterval((() => {
        this._updateSkillsStateSlow();
      }), this.settings.threadUpdateMS * 3);
    }

    refresh() {
      this.clear();
      this.newSpellPanelUIElement = new AA.LIBS.SpriteSpellPanel(this.settings.maxItems);
      if (!Input.isGamepad()) {
        this._baseSprite.addChild(this.newSpellPanelUIElement);
      }
      return this._drawSkills();
    }

    clear() {
      this._symIndex = {}; // * хранение символов для индексов
      this._rechargedIndex = {};
      if (this.newSpellPanelUIElement != null) {
        return this._deletePanel();
      }
    }

    _drawSkills() {
      return this._forEachSkill((function(item, index, skill) {
        var ref;
        item.drawIcon((ref = skill.skill()) != null ? ref.iconIndex : void 0);
        return this._drawItemInputSymbol(item, index, skill);
      }).bind(this));
    }

    _forEachSkill(action) {
      var e, i, item, j, ref, results, skill, skills;
      if (this.battler == null) {
        return;
      }
      skills = this.battler.uiPanelSkills();
      results = [];
      for (i = j = 0, ref = this.newSpellPanelUIElement.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        skill = skills[i];
        if (skill == null) {
          continue;
        }
        item = this._getItem(i);
        if (item == null) {
          continue;
        }
        try {
          results.push(action(item, i, skill));
        } catch (error) {
          e = error;
          results.push(AA.warning('SpellPanel:_forEachSkill:applyAction', e));
        }
      }
      return results;
    }

    _getItem(index) {
      return this.newSpellPanelUIElement.getItemAt(index);
    }

    _drawItemInputSymbol(item, index, skill) {
      var sym;
      if (Utils.isMobileDevice()) {
        return;
      }
      if (Input.isGamepad()) {
        return;
      }
      sym = this._getKeySymbol(index);
      if (AlphaABS.BattleManagerABS.canUseABSSkillUI(skill)) {
        return item.drawText(sym);
      } else {
        return item.drawTextDisabled(sym);
      }
    }

    _getKeySymbol(index) {
      var symb, x;
      if (this._symIndex[index] == null) {
        x = AlphaABS.LIBS.IKey;
        symb = x['SP_' + (index + 1)]();
        this._symIndex[index] = x.convertIKeyToLetter(symb).toUpperCase();
      }
      return this._symIndex[index];
    }

    _deletePanel() {
      this._baseSprite.removeChild(this.newSpellPanelUIElement);
      return this.newSpellPanelUIElement = null;
    }

    getSprite() {
      return this._baseSprite;
    }

    update() {
      return this.newSpellPanelUIElement.update();
    }

    _updateSkillsStatesFast() {
      return this._forEachSkill((function(item, index, skill) {
        return this._drawItemRecharge(item, index, skill);
      }).bind(this));
    }

    _updateSkillsStateNormal() {
      return this._forEachSkill((function(item, index, skill) {
        this._drawItemInputSymbol(item, index, skill);
        if (skill.isItem()) {
          this._drawItemCount(item, skill);
        }
        if (skill.isNeedAmmo()) {
          return this._drawSkillAmmoCount(item, skill);
        }
      }).bind(this));
    }

    _updateSkillsStateSlow() {
      return this._forEachSkill((function(item, index, skill) {
        if (skill.isItem()) {
          this._drawItemCount(item, skill);
        }
        if (skill.isNeedAmmo()) {
          return this._drawSkillAmmoCount(item, skill);
        }
      }).bind(this));
    }

    _drawItemRecharge(item, index, skill) {
      var percent;
      if (AlphaABS.BattleManagerABS.canUseSkillByTimer(skill)) {
        item.drawRecharge(0);
        if (this._rechargedIndex[index] === true) {
          this._rechargedIndex[index] = false;
          return item.pulseOnceA();
        }
      } else {
        this._rechargedIndex[index] = true;
        percent = skill.timer.getValue() / skill.timer.getMaxValue();
        return item.drawRecharge(percent);
      }
    }

    _drawItemCount(item, skill) {
      var count;
      count = $gameParty.numItems(skill.skill());
      if (count === 0) {
        return item.drawText2Disabled(0);
      } else {
        return item.drawText2(count);
      }
    }

    _drawSkillAmmoCount(item, skill) {
      var count;
      count = $gameParty.numItems($dataItems[skill.ammo]);
      if (count === 0) {
        return item.drawText2Disabled(0);
      } else {
        return item.drawText2Special(count);
      }
    }

    _updateInfo() {
      var index;
      index = this.newSpellPanelUIElement.getIndexUnderMouse();
      if (index == null) {
        this._resetInfo();
        return;
      }
      if (index !== this._lastIndexForInfo) {
        this._lastIndexForInfo = index;
        return this._resetInfo();
      } else {
        this._showInfoTimer++;
        if (this._showInfoTimer > 3) {
          return this._showInfo();
        }
      }
    }

    _resetInfo() {
      this._showInfoTimer = 0;
      if (this._skillInfoSprite != null) {
        this.newSpellPanelUIElement.removeChild(this._skillInfoSprite);
        return this._skillInfoSprite = null;
      }
    }

    _showInfo() {
      var e, item, skill;
      try {
        if (this._skillInfoSprite != null) {
          return;
        }
        if (this.battler == null) {
          return;
        }
        skill = this.battler.uiPanelSkills()[this._lastIndexForInfo];
        if (skill == null) {
          return;
        }
        item = this._getItem(this._lastIndexForInfo);
        this._skillInfoSprite = new AA.LIBS.SpriteSpellInfo(skill, false);
        AA.UTILS.linkSprite(item, this._skillInfoSprite);
        return this.newSpellPanelUIElement.addChild(this._skillInfoSprite);
      } catch (error) {
        e = error;
        return AA.warning(e, 'Something wrong in Skill description');
      }
    }

    terminate() {
      clearInterval(this._thread);
      clearInterval(this._thread2);
      clearInterval(this._thread3);
      return clearInterval(this._thread4);
    }

    clickAt(index) {
      var ref;
      return (ref = this._getItem(index)) != null ? ref.pulseOnceB() : void 0;
    }

    getIndexUnderTouch() {
      return this.newSpellPanelUIElement.getIndexUnderTouch();
    }

    show() {
      var ref;
      return (ref = this.newSpellPanelUIElement) != null ? ref.visible = true : void 0;
    }

    hide() {
      var ref;
      return (ref = this.newSpellPanelUIElement) != null ? ref.visible = false : void 0;
    }

    isVisible() {
      var ref;
      return ((ref = this.newSpellPanelUIElement) != null ? ref.visible : void 0) === true;
    }

    isVisibleWhenEmpty() {
      return this._visibleWhenEmpty === true;
    }

  };
  AA.register(AASpelllPanelManager);
})();

// ■ END AASpelllPanelManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//@[GLOBAL]
var AATimedUpdate;

AATimedUpdate = class AATimedUpdate {
  constructor(interval, method) {
    this.interval = interval;
    this.method = method;
    this._timer = 0;
    this._once = false;
  }

  update() {
    if (this.interval == null) {
      return;
    }
    this._timer++;
    if (this._timer >= this.interval) {
      if (this.method != null) {
        this.method();
      }
      this._timer = 0;
      if (this._once === true) {
        return this.stop();
      }
    }
  }

  once() {
    return this._once = true;
  }

  onUpdate(method) {
    this.method = method;
  }

  stop() {
    return this.interval = null;
  }

  isAlive() {
    return this.interval != null;
  }

};

AA.register(AATimedUpdate);

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAWeaponIconManagerNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AAWeaponIconManagerNew;
  AAWeaponIconManagerNew = class AAWeaponIconManagerNew {
    constructor(_weaponSprite) {
      this._weaponSprite = _weaponSprite;
      this.settings = AA.JSON.getSpellControllerSettings();
      this.battler = $gameParty.leader();
      this._isRechargeStart = false;
      this._showInfoTimer = 0; //TODO: AA Timer
      this._createThread();
      this._createThread2();
    }

    _createThread() {
      return this._thread = AA.setInterval((() => {
        this._updateAttackState();
      }), this.settings.threadUpdateMS);
    }

    _createThread2() {
      return this._thread2 = AA.setInterval((() => {
        this._updateInfo();
      }), this.settings.threadUpdateMS * 5);
    }

    // * Можно чтобы он сам и оружие проверял на смену и рисовал иконку
    _updateAttackState() {
      var skill;
      if (this.battler == null) {
        return;
      }
      skill = this.battler.skillABS_attack();
      this._drawRecharge(skill);
      if (skill.isNeedAmmo()) {
        return this._drawAmmoCount(skill.ammo);
      }
    }

    _drawRecharge(skill) {
      var percent;
      if ($gamePlayer.ABSParams().isWeapRecharge) { //* ??
        if (!skill.isReady() && skill.getReloadTime() > 30) {
          this._isRechargeStart = true;
          percent = skill.timer.getValue() / skill.timer.getMaxValue();
          return this._weaponSprite.drawRecharge(percent);
        }
      } else {
        this._weaponSprite.drawRecharge(0);
        if (this._isRechargeStart === true) {
          this._isRechargeStart = false;
          return this._weaponSprite.pulseOnceA();
        }
      }
    }

    _drawAmmoCount(ammoId) {
      var count;
      count = $gameParty.numItems($dataItems[ammoId]);
      if (count === 0) {
        return this._weaponSprite.drawText2Disabled(0);
      } else {
        return this._weaponSprite.drawText2Special(count);
      }
    }

    _clearAmmo() {
      return this._weaponSprite.drawText2Disabled("");
    }

    _updateInfo() {
      if (!this._weaponSprite.isUnderMouse()) {
        this._resetInfo();
      } else {
        this._showInfoTimer++;
        if (this._showInfoTimer > 3) {
          return this._showInfo();
        }
      }
    }

    _resetInfo() {
      this._showInfoTimer = 0;
      if (this._skillInfoSprite != null) {
        //@_weaponSprite.removeChild @_skillInfoSprite
        AA.UI.getUI().removeChild(this._skillInfoSprite);
        return this._skillInfoSprite = null;
      }
    }

    _showInfo() {
      var item, skill;
      if (this._skillInfoSprite != null) {
        return;
      }
      skill = this.battler.skillABS_attack();
      item = this._weaponSprite;
      this._skillInfoSprite = new AA.LIBS.SpriteSpellInfo(skill, true);
      AA.UTILS.linkSprite(item, this._skillInfoSprite);
      return AA.UI.getUI().addChild(this._skillInfoSprite);
    }

    getSprite() {
      return this._weaponSprite;
    }

    drawIcon(icon) {
      return this._weaponSprite.drawIconOnReady(icon);
    }

    drawDefault() {
      return this._weaponSprite.drawDefault();
    }

    terminate() {
      return clearInterval(this._thread);
    }

    update() {
      return this._weaponSprite.update();
    }

    pulse() {
      if (!this._isRechargeStart) {
        return this._weaponSprite.pulseOnceB();
      }
    }

  };
  AA.register(AAWeaponIconManagerNew);
})();

// ■ END AAWeaponIconManagerNew.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  _.setupBarrier = function(id, hp) {
    this._absParams.barrierHp = hp;
    if (hp <= 0) {
      this._absParams.barrierHp = 100;
    }
    this._absParams.barrierHpMax = this._absParams.barrierHp;
    return this._absParams.barrierElementId = id;
  };
  _.isHaveAbBarrier = function() {
    return (this._absParams != null) && this._absParams.barrierElementId > 0;
  };
  _.gainHpBarrier = function(value) {
    if ((this._absParams != null) && (this._absParams.barrierHp != null)) {
      this._absParams.barrierHp = this._absParams.barrierHp + value;
      this._result.barrierAffected = true;
      this._result.barrierDamage = value;
      this._result.barrierDamageId = this._absParams.barrierElementId;
      //"Barrier HP".pe()
      //console.info(@_absParams.barrierHp)
      if (this._absParams.barrierHp < 0) {
        this._absParams.barrierHp = 0;
        this._absParams.barrierElementId = 0;
        return AA.UI.refreshTargetBarrierInfo(this);
      }
    }
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------

(function () {
    AlphaABS.DATA = {};

    AlphaABS.DATA.DefaultCastAnimation = {
        "id": "anim_cast",
        "animation1Hue": 50,
        "animation1Name": "StateDown1",
        "animation2Hue": 0,
        "animation2Name": "",
        "frames": [
            [
                [5, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -217, 200, 180, 0, 120, 1],
                [11, -120, -183, 100, 180, 0, 120, 1],
                [11, -32, -247, 100, 180, 0, 120, 1],
                [11, 50, -247, 100, 180, 0, 120, 1],
                [-1, 112.5, -263, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [6, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -233, 200, 180, 0, 120, 1],
                [11, -120, -247, 100, 180, 0, 120, 1],
                [-1, 368, -123, 100, 0, 0, 255, 1],
                [11, 50, -297, 100, 180, 0, 120, 1],
                [11, 110, -123, 100, 180, 0, 120, 1],
                [11, -64, -123, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [7, 0, -133, 260, 0, 0, 120, 1],
                [-1, -408, -216, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [11, 110, -135, 100, 180, 0, 120, 1],
                [11, -64, -183, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [8, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [11, 110, -199, 100, 180, 0, 120, 1],
                [11, -64, -247, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [9, 0, -133, 260, 0, 0, 120, 1]
            ],
            [
                [4, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [6, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -233, 200, 180, 0, 120, 1],
                [11, -120, -247, 100, 180, 0, 120, 1],
                [-1, 368, -123, 100, 0, 0, 255, 1],
                [11, 50, -297, 100, 180, 0, 120, 1],
                [11, 110, -123, 100, 180, 0, 120, 1],
                [11, -64, -123, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [7, 0, -133, 260, 0, 0, 120, 1],
                [-1, -408, -216, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [11, 110, -135, 100, 180, 0, 120, 1],
                [11, -64, -183, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [8, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [11, 110, -199, 100, 180, 0, 120, 1],
                [11, -64, -247, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [9, 0, -133, 260, 0, 0, 120, 1]
            ],
            [
                [4, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ]
        ],
        "name": "Cast4",
        "position": 2,
        "timings": [{
            "flashColor": [204, 204, 204, 204],
            "flashDuration": 11,
            "flashScope": 1,
            "frame": 3,
            "se": null
        }]
    };

    AlphaABS.DATA.DefaltCastSE = {
        name: 'Magic3',
        pan: 0,
        pitch: 100,
        volume: 90
    };

    AlphaABS.DATA.IMG = {};


    AlphaABS.DATA.IMG.IconSwitchWeaponSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAL8ElEQVRYR2WXCXQU5ZqGn7+qq7uzkj1hyx72IBD2BAggIiBLMEAQZFFAuF4WQUZEFBhFRu9hvCpHhzuXwSvgEREUL4LIIousIoLIDiFkTyAkATqdXqr+OVUduONY5/ynO3VS/b7f+73fUoIVK5Ss5s3VG3/9awtXWclCFFuBalPihE1DsdsRDvNoKJoDxalh3heaHcVmQ6oKQlXBkCANpN+P9JnHh9T9GF4P0u1F9/qQbjfo+h0UdVtIp4w1cTMnVLhcwX6R+8MK26lxa4cFh4d8M/CZKWRPfgZHWAReXcfr9+HRvXi8Pjw+36N7fmmg+3zoQmJIiZCgqAqqYh4VTajY7Rp21YbTZsdh07BrGv779zm1fSuHN26kUYq8xNUL94lmnTunaA/qCie+9Q5Bndvx89XLVNbV8PDy1dbhKS03EQK3pMTRqgVaZETgT92wIlUcjoAaUj569uH/Nz1IXHgEXVLS8V0pZMvy15Fpie2EIyJi7ag/z30xZcJYvv3p2KOHG0vLuLv/MHHxEaS0aY6CwPppATevVVBVWUvU4FzqDx4mKNiB2+0lbuK4AImHl6mOrhN+8TL6zWKcd2rRklrTZfFCbn79Lbv/a906YW/WrGL18eMJO6+dp+puDYbHg+vCZSIabjOofye6ZbQmIz4mAG7hC25U1fDLtRJ27T2D3aGR91R3Nn9+BNEzGy066ncKRF64QmqNxrSxA4iMieGlhS/By/MYntGRlY8PrhbOmGj5n+d+Y+2+HRZ47fYddOqWxIzR2TSPDEE3/NZx+RrN4AnWHKhCQ1VsFN6pw+PzkxQbxaLVW5Bde6PGRiOb0qD4fLTZfoSYvDdYN6OjRWz8wIFcmvw0zz0+kmX9shHBrVrI1UdPsO7Qd9w7dZrk4EaWTn0cuwKNfjd7frnCj6ducLfKZcUfFRtM3+5J9OmQQkxYODbFhi5h6cc7qYtMJTQjHYlEl5Kkf2yi5ahVVNc08MasXnRrGcFLs2ZxsH0a40c+zdtDn0CEpibJ177fxzsznyemdQRvzR9OdJCTktoa3t9yhLKrdeCTxA4dbDn+9p59CFWQ3imWReOyCQ4NwqZqrNt7mpPn7hM1sD8KEH7sBN1b9SW+xyCKb1TwypSenD2yn9U7v+Ze7ywm9ujHu3mjEWEd2shF23fw8dtv8mROPJNyMnH7PCzfsJfiX++QODEfnE4rItMHhmFwd/8heiarDMlKIyQ8CEeQg63HL3HqvJvI3BzsNbV0OlfEE69+wOmj5xmb05qUeI0Xnn2WW/kjkYpKXrderJ04EdGsS6Z8ds17bPvoXZYvGEpiZCg7f77C5xt/pnXBOHA40M0m01SC0pBUfvoZwZF2EMI6hiERThVfvY/I4SNI3n+EWas/4natgavoNgsndGHRggXsS26OL8Y0qcKIzK6snzkTEdmnl8ydPInCwh95a8pA/LrOG3/fjzsqndC2bTCbjgn+0FiWkwyJp6LSAq/de4CIFqH06ZvKuUsVyHI/z+dNJ/PJpzh66ALLx3bm5OHD/HnzJ7hy+lg+kkIwpH0mm+bNRUQN6iezxzxNSeFR3pjUD68heeX97wju2hdbQryVd7O5/L/2YvHwlFfgPX+SFXOHEON08ubGg8T/dp9FX+7m0MELzMhOITZYYdToUZROzkdadSSQisLAjPZs+beXEbFDB8qsYU9RfuMYy57JAZvK4g/2EJTZyyLwh+j/T5WbHVJePcMHC0fg8/l5e802hgx6kczcISTgIzc9htfmzWNnRmt8Ec0s6a1Opij0T2/DtteWIuJHDJWdBw+i9PoJlhX0JSQkiPe+PMUtI5qQju1+L/3vmywNV64R5SplxfQBeBu9fPDpMbIem8SAQf0ZnR7B0QMHWPD5RhpyeqMoCro0wU3fKGSnpPP1iuWIhLyRss+kyRzb9HfmFGRR6fKya99l1MS2Add7vdhbJGCPi/0dvOHxcvuLbUyZkUP/9ASuFlez658VjCqYy9TcjoT6PYweM5qSyfkoQliDyW0YTcY1CWSwY7lJIH+MzP3THI7u3o373FmcEU6iWkUQotmxKzaCg5wUX6/Ek9n1EQmTlOv8RVqGNLCkoDeeB43882QhjrpECibN4PE2kSyfP5+vM1qjh4dZU1JTVBoMAykUKwXZSWnsWLkCkTA+T+bOns258jK8FRW4Tx/m4yWjcDqC0BQHpfcbWfXeN+hdsiz3++vvce/kT6T1TGbOyK6ECklRVR179pSQ3X8KKyfmcvzgQeZ/sRlX7+6W7UwCdkXF9YiASr+UNL5a9joiflyeHPDCC/xaWY6n6BZc/onXpuYQ2SyEoOAgzpbVsfXbs9yrdaEogpjYcPr0SKJvWizue26q795jz7EKWkT15N35z2H3PWD8lMmUjhtlpcyUX7VSoPLAb1hNyFRhYHoGW19ZEkjBgDmzOVdZjq+8gobjB1mcn4XDqWF32HEG2a3vXikQQiL9Ol63F7erkZvlNZw6U4nqieTVpasY0iGepQsWsCspAV905CMCWtOi8kA3QFUtEkNS2/DZopcQ8WNHycHz5nKmrAxvSTGNp44wbUAa+69U4vUbdEmOJjUqDEU1xQRDlxTfqedqWR1FF8vp3mkozy9awrCUEMv18zZtoDE3JzC6zegBTbVhFkCDDlKo1nLzZLu2bPzTi4i4kcPlsMUvc7K0BF9ZKQ1HfyAhJohbN+sJSk/DX1SII9SG3d1IqMtFeJBGqPs+HVpHc+xqJB2HT6V9nx7c3baSixW3uZz/1CNws+qt/Ks2Gvw6flN+UwGhMrp9R/42bRoidtgQOXrZ6/xYXIQwdLxlZbiv3yCkbQZaTBR6XT2N5RVoLjdRlwpJqK5jSNskJs5J4sNl16mqLeVial/qBiVgRIRjaJoVuXk9zL3ZAV2GtIClqlmf4zM78uGECYiogf3khP94hx9uFlrrE9Jvbbhm+xXSsExkzoGHrTj84hXiTlxm1cx2fPLxEbKzuiFa3mHXreac6ZSBN9iJoQSMZ+bePPd1id/sgqoNQ7GBYuPZzpn8ZeQIRFTf3nLq2g/Zde0GwvAjDJ+5aVolpyCtxmURaCJhr75D/8PfkWy0oGOfWFqkqYR4vZRVebhSHso3wVEUtW8ZINDUfLzSrH2bZT5D1SwPzOrWlZW5/RERWV3l7P/ZwPar1yzwAAmTgKmGxKkIaxyj62jlVbQ6cIgJqRLp1ThW5eKmtyUd3PXkdovlam0lXzkTcQ3KxiZUGqRhRR4oPS3waaZAsTG/exde7dkDEda+jVz01Q4+u3gpQED3W+CBdOg0s6n4DJ2QX87To/IGXWJ0ys4qNEu8z2cimfrs7iQc+4XUohJqNJ2b0yajm5MSifEQ3IxemApoSNVmleLL3buxoHMmIiw1WS7bu4///vUiwvBa0ZsqWCQMnZYOjXsV1WR9v5s389sTMayAk5vX8++fnKNq8QtWpzP3gpDL1/E0T8AdHoZuLSpm5EoTcADcMFd2855N4/XuWcxOS0GEtGpVtWTnzrhvq2u443I1yW+mIkAkRlO463LT7m8bmH6hml4froGwA0yvT+GmEty0qwfmvEnEmvmm1CYQgdc3qdgxTAVU04garUOCKGgez/yuj1WJkOSk9U88P/25Fnn5fHe9GMFDD/zLC2Y1NN/yJXOvl/DbtRKMp3vzfY9s6mLjAtPN3JjMIfOHyFUL2FACJsQko9qYkJZM0T8+Yfuad98X8eNGZxrnL/2a/8YKlMzH+LniNnfcD5UImFGYVSENIk6cRGt4gCcqBlfbDKTD/kdwS3rTdAKpmpGrYHU/hVYhYfRuGY3/p9N8umQRDZozUWRu/iiyeNXawQ4ht+ZMKKDbmDxsIcG4vT68fi+N5kup34/H78Wn60jDdHagLDHLlECt21TFKjvNpgVeSM05Yn13EGTXsKkqnvp6jmzcyP5NG3hwu3aYZ/Hi70Xb9evD7E6PrerLXYmus+fnSq9vjOLUoq3X8aAghNOOsDtQ7XbQFITNATbF6nam+OaajtdvvZqbe4LhaQSPB73Rg9HQiOH3YvgMpMeN4dOrFYUvgmPi/vLY+inlB3OX6/8LL4RHZ9rigKQAAAAASUVORK5CYII=";
    AlphaABS.DATA.IMG.IconSwitchWeapon = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconSwitchWeaponSrc, 'IconSwitchWeapon');




    AlphaABS.DATA.IMG.VectorHolderScr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAAAmCAYAAABu+H0XAAAE4klEQVRoQ+Waf2xTVRTHv+fcretmFhF/JRpRcDEmi4T1tQw1KpqYaBQk4C9ijCFhW7NNmJmgIpHJDEuYbrg5RgsEJUET4o8EYowaAxrB0L12oJlRgaHGHxAWNgVhdH33mLessKxvutGW0K5/3nffue/76fnee+57l5BhPyNgzoNoP8A/gPBauMLbczEl0MUcLNmxZrR33kSwDjFD2bG0xglieinyp2cT6kgnG38s92cUMF8wdI8W3j1SmCaEiKgyUmaExyI6mT4ZBax4e5crt+fUV0qp0gTRWguI26PatfK7yum9yUD5r3szCpgtxIaW33u6xtKyipkLHMAdF6WWR/7wbE2HTTMOWByQry10g5WjmgmywCkjNGHPkE2/TWW2ZSywOATPhvADRLFWQBUlzG0almJpVWetVfuWzPo7FeAyHpgNYfaWXe6T0cJlWmMFM9wJ4ICjDNSGy433QCTJgMsKYOdsur5jmmZ5E8QPO0ERkV0CVd3p93x/odCyClgcgjfYMVdEtwDqRodsixGo6WzMXd9VVXxqvOCyEpgNwQiYBQJaQdpaBmZX4mqK30hJjVnm/XA8Ns1aYHFAM4P7bhmAeosF949i0880cqr3+0sOjiXbsh7YIAQRMoLhRwE0A7jeoXaLQvFaCBrCFd7TWVW4jiULRutz5+avC/sH3K9oQg0DOQ79fhahJRG/sXO0GBMjw0ao9wVDxSK0XkB3O4EhyE5mvTRUVnpk5PUJCSxuU08g8pSIvM6Max2K3n5mrCl0nWzcveje/vj188DqhB33XqlqT8ZLabx3xpbOSWrAWg3RVQBz4lDWIaGc6ki58al9jezNrLvvzDaInq+JTRfF5u4rm3UsVe3eYMcCSyjAwJVp1J3+0IJt0yZ3P0OeDeH5RPLBuRHtlcLvXZGq9pKA2ZPxsIbgiNBcG9gcItlx3qPyqlnhq0tVe0l76DgzX5X+FEj/CEI0hx7bvl0d7r25TSALFWRvzJWzcP+ikj67/Ujv1PUW6Mlk2gffwWsdBPPV6ZeUxhEEb0+b3L144q6SQ2ztSZ+jup5gVTpN+gL8KMJVnX7PF4OTfhr/k0s7tAh5A+bTQtII8DWJZYU+zcz1/VfkN3U9XhxNLCsubXkpfTojYN4G0W0gvssxsOAjEGrCFd5fJ3ThOrg1stx12sLS+Ke64UC01oeVomfNct8nE3trZNtvo/mEWPIGmK9zrOoVGgpzT64dXtU7b5tSmuyXXjAjYN46ZL/7nJ5ORD5WGks6Kn3dY3n6rJ30p289cJn65+xKALXMnOuw5fmFhJeaFd4dE/sFogh5NkbmiWWtY+YpCaC0jgqrRoKs+b93X1lvSc+mcBEG0EIsDzqJ1YTPc2FVh8pLfxqL/bIW2O1Ne/OjBa4XQfoFgPMchP4O4LlwufH+eOyXlcCMgPkQLLRCYWrC6gfEFKT5TKxg9YV8IcoqYPbRJ6WsdRA84rj6afpSKauqo3xm14XaLyuAFbUczJuU1/e8BXqZgXyHmuoYKaqNlHneTdZ+GQ/MhnV5Xt8egIxEMVpDuBWEVeEK71+pzKrhsTKqDvO2d8wWpl0jYYimvUJU2en3HEgXqHjcjAJmBMwpGjgc/0Smte4hUssjRz3vpOMsWMZb0hYwuCoOHQp25UQbvll8x4l0Z9Xw+P8Cx9dHZhLEvX4AAAAASUVORK5CYII=";
    AlphaABS.DATA.IMG.Vector = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.VectorHolderScr, 'Vector');

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSMotion.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ABSMotion;
  ABSMotion = class ABSMotion {
    constructor() {}

    setMotion(name, offset, character) {
      this._character = character;
      if (this._character.__basicCN == null) {
        this._character.__basicCN = character._characterName;
        this._character.__basicCI = character._characterIndex;
      }
      if (this._character.__basicCN != null) {
        //"APPLY BASIC".p()
        //console.info(@_character.__basicCN)
        this._charName = this._character.__basicCN;
        this._charIndex = this._character.__basicCI;
      } else {
        this._charName = character._characterName;
        this._charIndex = character._characterIndex;
      }
      this._motionName = this._createName(name);
      this._yOffset = offset;
      return this._loadMotion();
    }

    _createName(name) {
      return "zmotion_" + this._charName + "_" + this._charIndex + "_" + name;
    }

    _loadMotion() {
      return ImageManager.loadCharacter(this._motionName);
    }

    getOffset() {
      return this._yOffset;
    }

    setLooping() {
      return this.isLoop = true;
    }

    applyMotionIdle() {
      this._state = 'idle';
      this.character()._characterName = this._motionName;
      return this.character()._characterIndex = 0;
    }

    applyMotionState() {
      this._state = 'state';
      this.character()._characterName = this._motionName;
      return this.character()._characterIndex = 4;
    }

    applyMotionAction() {
      if (!this.inState()) {
        this.applyMotionState();
      }
      this._state = 'action';
      return this.character().updatePattern();
    }

    motionPattern(pattern) {
      if (this.inAction()) {
        return 2;
      }
      return pattern % 2;
    }

    onActionDone() {
      return this._state = 'state';
    }

    inAction() {
      return this._state === 'action';
    }

    inState() {
      return this._state === 'state';
    }

    character() {
      return this._character;
    }

    isOldABSMotion() {
      return true;
    }

    clearMotion() {
      // * Возвращяет обычную графику персонажу
      this.character()._characterName = this._charName;
      return this.character()._characterIndex = this._charIndex;
    }

  };
  AlphaABS.register(ABSMotion);
})();

// ■ END ABSMotion.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSMotion2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
AA.MotionType = {
  Actor: 0,
  Weapon: 1,
  Skill: 2,
  Enemy: 3,
  Action: 4,
  Cast: 5
};

ImageManager.loadAAMotion = function(filename) {
  return this.loadBitmap('img/AMotions/', filename, 0, true);
};

(function() {
  var ABSMotion2;
  ABSMotion2 = class ABSMotion2 extends AA.LIBS.ABSMotion {
    constructor() {
      super();
      this._motionDelay = 9;
      this._motionFrames = 3;
      this._motionParts = 12;
      this._actionDelay = 5;
      this._actionIndex = 8;
      this._currentMotionName = "";
    }

    setType(type) {
      this.type = type;
      switch (this.type) {
        case AA.MotionType.Weapon:
          this._motionParts = 12;
          return this._actionIndex = 8;
        case AA.MotionType.Enemy:
          this._motionParts = 12;
          return this._actionIndex = 8;
        default:
          this._motionParts = 4;
          return this._actionIndex = 0;
      }
    }

    //$[OVER]
    _createName(name) {
      if (this.type !== AA.MotionType.Enemy) {
        this._currentMotionName = this.__prefixName() + name + "_" + this.__charName();
      } else {
        this._currentMotionName = this.__prefixName() + this.__charName();
      }
      return this._currentMotionName;
    }

    //weapon_SimpleSword_Actor_1_0
    __prefixName() {
      switch (this.type) {
        case AA.MotionType.Weapon:
          return "weapon_";
        case AA.MotionType.Skill:
          return "skill_";
        case AA.MotionType.Enemy:
          return "enemy_";
        case AA.MotionType.Action:
          return "action_";
        case AA.MotionType.Actor:
          return "actor_";
        case AA.MotionType.Cast:
          return "cast_";
        default:
          return "unknown_";
      }
    }

    __charName() {
      return this._charName + "_" + this._charIndex;
    }

    //$[OVER]
    _loadMotion() {
      return ImageManager.loadAAMotion(this._motionName);
    }

    getDelay() {
      return this._motionDelay;
    }

    setDelay(delay) {
      if (delay > 0) {
        return this._motionDelay = delay;
      }
    }

    getFrames() {
      return this._motionFrames;
    }

    setFrames(frames) {
      if (frames > 0) {
        return this._motionFrames = frames;
      }
    }

    setActionDelay(delay) {
      if (delay > 0) {
        return this._actionDelay = delay;
      }
    }

    getActionDelay() {
      return this._actionDelay;
    }

    isLooping() {
      return this.isLoop === true;
    }

    setWait() {
      return this._isNeedWait = true;
    }

    isNeedWait() {
      return this._isNeedWait === true;
    }

    getParts() {
      return this._motionParts;
    }

    getMotionName() {
      return this._motionName;
    }

    getMotionActionIndex() {
      return this._actionIndex;
    }

    //$[OVER]
    isOldABSMotion() {
      return false;
    }

    //$[OVER]
    applyMotionState() {
      if (this.type === AA.MotionType.Actor) {

      } else {
        return super.applyMotionState();
      }
    }

    isProperName(name) {
      return name === this._currentMotionName;
    }

  };
  AlphaABS.register(ABSMotion2);
})();

// ■ END ABSMotion2.coffee
//---------------------------------------------------------------------------

(function () {

  "use strict";

  //ABSObject_PopUp
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class ABSObject_PopUp {
    constructor(text, color, iconIndex, fontSettings) {
      this._text = text || null;
      this._color = color;
      this._iconIndex = iconIndex || null;
      this._fontSettings = fontSettings || ABSObject_PopUp.FONT_DEFAULT();
      this._effectType = ABSObject_PopUp.EFFECT_DEFAULT;
      this._sprite = null;
    }

    clone() {
      var tempObj = new ABSObject_PopUp(this._text, this._color, this._iconIndex, this._fontSettings.clone());
      tempObj.setEffectSettings(this._effectType);
      return tempObj;
    }

    getText() {
      return this._text;
    }

    getFontSettings() {
      return this._fontSettings;
    }

    setX(x) {
      this.x = x;
      this._sprite.x = x;
    }

    setY(y) {
      this.y = y;
      this._sprite.y = y;
    }

    setNumered() //This is number value in this PopUp
    {
      this._numered = true;
    }

    isNumered() {
      return (this._numered === true);
    }

    hasIcon() {
      return (this._iconIndex != null);
    }

    setExtraText(text) {
      this._text = (text + " " + this._text);
    }

    setEffectSettings(settings) {
      this._effectType = settings;
    }

    setup(x, y, width, layer) {
      this._layer = layer;
      this._width = width;
      this.x = x;
      this.y = y;
      this._refresh();
    }

    dispose() {
      if (!this._sprite) return;
      this._sprite.bitmap.clear();
      this._layer.removeChild(this._sprite);
      this._sprite = null;
    }

    update() {
      if (this._sprite != null) {
        this._update_zoom();
        this._sprite.update();
      }
    }

    static FONT_DEFAULT() {
      return ['Skratch Punk', 30, false, 3, KDCore.Color.BLACK]; //FontFace, size, outline widht, outline color
    }

    //PRIVATE
    _refresh() {
      var h = 72;
      var bitmap = new Bitmap(this._width, h);
      bitmap.addLoadListener(function () {
        if (this._fontSettings[0] != null)
          bitmap.fontFace = this._fontSettings[0];
        bitmap.fontSize = this._fontSettings[1];
        bitmap.fontItalic = this._fontSettings[2];
        if (this._color) {
          bitmap.textColor = this._color.CSS;
        } else
          bitmap.textColor = KDCore.Color.WHITE.CSS;


        var dx = 0;
        var dw = 0;
        var tw = (this._text != null) ? bitmap.measureTextWidth(this._text) : 0;

        while (tw > this._width) {
          bitmap.fontSize = bitmap.fontSize - 4;
          tw = bitmap.measureTextWidth(this._text);
        }

        if (this._iconIndex) {
          dx += 24;
          dw += 24;
          bitmap.drawIcon((dx + ((this._width - tw) / 2) - 36), (h - 24) / 2, this._iconIndex, 24);
        }

        if (this._text) {
          bitmap.outlineWidth = this._fontSettings[3] || 0;
          if (this._fontSettings[4])
            bitmap.outlineColor = this._fontSettings[4].CSS;
          bitmap.outlineColor = KDCore.Color.BLACK.CSS;
          bitmap.drawText(this._text, dx + 2, 0, this._width - dw, h, 'center');
        }
      }.bind(this));

      this._sprite = new Sprite(bitmap);
      this._sprite.x = this.x;
      this._sprite.y = this.y;
      this._sprite.scale.x = this._effectType[0];
      this._sprite.scale.y = this._effectType[0];

      this._layer.addChild(this._sprite);
    }

    _update_zoom() {
      if (this._effectType[1]) {
        this._sprite.scale.x = Math.max(this._sprite.scale.x - 0.075, 1.0);
        this._sprite.scale.y = this._sprite.scale.x;
      }
      this._sprite.opacity = Math.max(this._sprite.opacity - 2, 0);
      if (this._sprite.opacity == 0) {
        this._layer.removeChild(this._sprite);
        this._sprite = null;
      }
    }
  }

  KDCore.SDK.setConstantToObject(ABSObject_PopUp, 'EFFECT_DEFAULT', [1.5, true, 0]); //zoom, isUpdateZoom, +toTextSize
  //END ABSObject_PopUp
  //------------------------------------------------------------------------------

  AlphaABS.ABSObject_PopUp = ABSObject_PopUp;
  AlphaABS.register(ABSObject_PopUp);
})();
(function () {

  "use strict";

  var SDK = KDCore.SDK;

  //ABSObject_PopUpMachine
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class ABSObject_PopUpMachine {
    constructor(x, y, width, stack_size, parent) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._stack_size = stack_size;
      this._parent = parent;
      this._effectType = null;
      this._upMode = false;

      this._items = [];
      this._timers = [];

      this._init_items();
    }

    setUpMode() {
      this._upMode = true;
    }

    setEffectSettings(effect) {
      this._effectType = effect;
    }

    setSingleMode() {
      //this._singleMode = true;
    }

    move(x, y) {
      this._x = x;
      this._y = y;
      this._step();
    }

    push(popUpItem) {
      if (this._effectType != null)
        popUpItem.setEffectSettings(this._effectType);

      popUpItem.setup(this._x, this._y, this._width, this._parent);

      var item = this._items.shift();
      if (item != null) item.dispose();

      this._items.push(popUpItem);
      this._step();
      this._timers.shift();
      this._timers.push(0);
    }

    clear() {
      this._items.forEach(function (item) {
        if (item != null) item.dispose();
      });
      this._items = [];
      this._timers = [];
      this._init_items();
    }

    update() {
      this._update_timers();
      this._items.forEach(function (item) {
        if (item != null) item.update();
      });
    }

    //PRIVATE
    _init_items() {
      SDK.times(this._stack_size, function () {
        this._items.push(null);
        this._timers.push(null);
      }.bind(this));
    }

    _update_timers() {
      SDK.times(this._stack_size, function (i) {
        var index = (this._timers.length - 1) - i; //Reverse
        var timer = this._timers[index];
        if (timer == null)
          return;
        else {
          if (timer < ABSObject_PopUpMachine.MAX_TIME)
            this._timers[index] = this._timers[index] + 1;
          if (timer == ABSObject_PopUpMachine.MAX_TIME) {
            if (this._items[index] != null) {
              this._items[index].dispose();
            }
            this._items[index] = null;
            this._timers[index] = null;
          }
        }
      }.bind(this));
    }

    _step() {
      SDK.times(this._items.length, function (i) {
        var index = (this._items.length - 1) - i; //Reverse
        var item = this._items[index];
        if (item == null)
          return;

        var y = 0;
        if (this._upMode)
          y = this._y - (ABSObject_PopUpMachine.Y_STEP * i);
        else
          y = this._y + (ABSObject_PopUpMachine.Y_STEP * i);

        this._items[index].setX(this._x);
        this._items[index].setY(y);
      }.bind(this));
    }
  }

  KDCore.SDK.setConstantToObject(ABSObject_PopUpMachine, 'Y_STEP', 24);
  KDCore.SDK.setConstantToObject(ABSObject_PopUpMachine, 'MAX_TIME', 60);
  KDCore.SDK.setConstantToObject(ABSObject_PopUpMachine, 'SETTINGS', [1, false, 12]); //zoom, isUpdateZoom, +toTextSize
  //END ABSObject_PopUpMachine
  //------------------------------------------------------------------------------


  AlphaABS.ABSObject_PopUpMachine = ABSObject_PopUpMachine;
  AlphaABS.register(ABSObject_PopUpMachine);
})();
(function () {
    //ABSPathfinding
    //------------------------------------------------------------------------------
        function ABSPathfinding() {
            throw new Error('This is a static class');
        }

        ABSPathfinding.init = function () {
            this.worldWidth = 0;
            this.worldHeight = 0;
            this.worldSize = 0;
            this.char = null;
            this.goalX = 0;
            this.goalY = 0;
        };

        ABSPathfinding.setup = function () {
            this.worldWidth = $gameMap.width();
            this.worldHeight = $gameMap.height();
            this.worldSize = this.worldWidth * this.worldHeight;
        };

        ABSPathfinding.OnMapLoad = function () {
            ABSPathfinding.init();
            ABSPathfinding.setup();
        };

        ABSPathfinding.findPath = function (char, goalX, goalY) {
            this.char = char;
            this.goalX = goalX;
            this.goalY = goalY;
            var path = ABSPathfinding.calculatePath();
            if (path.length > 0) {

                if (path.length > 1) {
                    var stepX = path[1][0];
                    var stepY = path[1][1];

                    var deltaX1 = $gameMap.deltaX(stepX, char.x);
                    var deltaY1 = $gameMap.deltaY(stepY, char.y);

                    if (deltaY1 > 0) {
                        return 2;
                    } else if (deltaX1 < 0) {
                        return 4;
                    } else if (deltaX1 > 0) {
                        return 6;
                    } else if (deltaY1 < 0) {
                        return 8;
                    }
                }

            }

            return 0;
        };

        //PRIVATE
        ABSPathfinding.canWalkHere = function (x, y, d) {
            if (x == this.goalX && y == this.goalY) {
                return true;
            }
            return this.char.canPass(x, y, d);
        };

        ABSPathfinding.Node = function (Parent, Point) {
            var newNode = {
                // pointer to another Node object
                Parent: Parent,
                // array index of this Node in the world linear array
                value: Point.x + (Point.y * this.worldWidth),
                // the location coordinates of this Node
                x: Point.x,
                y: Point.y,
                // the distanceFunction cost to get
                // TO this Node from the START
                f: 0,
                // the distanceFunction cost to get
                // from this Node to the GOAL
                g: 0
            };

            return newNode;
        };

        ABSPathfinding.Neighbours = function (x, y) {
            var N = y - 1,
                S = y + 1,
                E = x + 1,
                W = x - 1,
                myN = N > -1 && this.canWalkHere(x, N + 1, 8), //UP
                myS = S < this.worldHeight && this.canWalkHere(x, S - 1, 2), //DOWN
                myE = E < this.worldWidth && this.canWalkHere(E - 1, y, 6), //RIGHT
                myW = W > -1 && this.canWalkHere(W + 1, y, 4), //LEFT
                result = [];
            if (myN)
                result.push({
                    x: x,
                    y: N
                });
            if (myE)
                result.push({
                    x: E,
                    y: y
                });
            if (myS)
                result.push({
                    x: x,
                    y: S
                });
            if (myW)
                result.push({
                    x: W,
                    y: y
                });
            return result;
        };


        ABSPathfinding.ManhattanDistance = function (Point, Goal) {
            // linear movement - no diagonals - just cardinal directions (NSEW)
            return Math.abs(Point.x - Goal.x) + Math.abs(Point.y - Goal.y);
        };

        ABSPathfinding.calculatePath = function () {
            var distanceFunction = ABSPathfinding.ManhattanDistance;
            // create Nodes from the Start and End x,y coordinates
            var mypathStart = this.Node(null, {
                x: this.char.x,
                y: this.char.y
            });
            var mypathEnd = this.Node(null, {
                x: this.goalX,
                y: this.goalY
            });
            // create an array that will contain all world cells
            var AStar = new Array(this.worldSize);
            // list of currently open Nodes
            var Open = [mypathStart];
            // list of closed Nodes
            var Closed = [];
            // list of the final output array
            var result = [];
            // reference to a Node (that is nearby)
            var myNeighbours;
            // reference to a Node (that we are considering now)
            var myNode;
            // reference to a Node (that starts a path in question)
            var myPath;
            // temp integer variables used in the calculations
            var length, max, min, i, j;
            // iterate through the open list until none are left
            while (length = Open.length) {
                max = this.worldSize;
                min = -1;
                for (i = 0; i < length; i++) {
                    if (Open[i].f < max) {
                        max = Open[i].f;
                        min = i;
                    }
                }
                // grab the next node and remove it from Open array
                myNode = Open.splice(min, 1)[0];
                // is it the destination node?
                if (myNode.value === mypathEnd.value) {
                    myPath = Closed[Closed.push(myNode) - 1];
                    do {
                        result.push([myPath.x, myPath.y]);
                    }
                    while (myPath = myPath.Parent);
                    // clear the working arrays
                    AStar = Closed = Open = [];
                    // we want to return start to finish
                    result.reverse();
                } else // not the destination
                {
                    // find which nearby nodes are walkable
                    myNeighbours = this.Neighbours(myNode.x, myNode.y);
                    // test each one that hasn't been tried already
                    for (i = 0, j = myNeighbours.length; i < j; i++) {
                        myPath = this.Node(myNode, myNeighbours[i]);
                        if (!AStar[myPath.value]) {
                            // estimated cost of this particular route so far
                            myPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);
                            // estimated cost of entire guessed route to the destination
                            myPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);
                            // remember this new path for testing above
                            Open.push(myPath);
                            // mark this node in the world graph as visited
                            AStar[myPath.value] = true;
                        }
                    }
                    // remember this route as having no more untested options
                    Closed.push(myNode);
                }
            } // keep iterating until the Open list is empty
            return result;
        };
    AlphaABS.ABSPathfinding = ABSPathfinding;
    AlphaABS.register(ABSPathfinding);
    //END ABSPathfinding
    //------------------------------------------------------------------------------

})();
(function () {

  "use strict";

  var ABSObject_PopUp = AlphaABS.ABSObject_PopUp;
  var ABSObject_PopUpMachine = AlphaABS.ABSObject_PopUpMachine;

  var Color = KDCore.Color;

  //PopInfoManagerABS
  //------------------------------------------------------------------------------
  function PopInfoManagerABS() {
    throw new Error('This is a static class');
  }

  PopInfoManagerABS.makeDamagePopUp = function (user) {
    var result = user.result();
    var value;

    if (result.hpDamage != 0) {
      if(result.hpDamage < 0 && user.hp == user.mhp)
        return;
      value = PopInfoManagerABS.HP(result.hpDamage, result.critical);
      this._apply_pop_up(user, value);
    }

    if (result.mpDamage != 0) {
      if (result.mpDamage < 0 && user.mp == user.mmp)
        return;
      value = PopInfoManagerABS.MP(result.mpDamage, result.critical);
      this._apply_pop_up(user, value);
    }

    if (result.tpDamage != 0) {
      value = PopInfoManagerABS.TP(result.tpDamage, result.critical);
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeZeroDamagePopUp = function (user) {
    var result = user.result();
    var value = PopInfoManagerABS.HP(0, result.critical);
    this._apply_pop_up(user, value);
  };

  PopInfoManagerABS.makeDrainPopUp = function (user) { //user - who get drained HP
    var result = user.result();
    var value;
    if (result.hpDamage != 0) {
      value = PopInfoManagerABS.HP(result.hpDamage, result.critical);
      value.getFontSettings()[2] = true;
      this._apply_pop_up(user, value);
    }

    if (result.mpDamage != 0) {
      value = PopInfoManagerABS.MP(result.mpDamage, result.critical);
      value.getFontSettings()[2] = true;
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeStatePopUp = function (user, stateId, isErase) {
    var state = $dataStates[stateId];
    if (state.iconIndex == 0)
      return;
    if (state.id == user.deathStateId())
      return;
    var value = PopInfoManagerABS.STATE((user.isEnemy() ? "" : state.name), state.iconIndex, isErase);
    this._apply_pop_up(user, value);
  };

  PopInfoManagerABS.makeItemPopUp = function (user) {
    var result = user.result();
    if (!user.isAlive()) return;
    if (result.missed) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_MISS));
      return;
    }

    if (result.evaded) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_EVADE));
      return;
    }

    if (result.isHit() && !result.success) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_FAIL));
      return;
    }
  };

  PopInfoManagerABS.makeBuffPopUp = function (user, paramId, isPositive) {
    if (!user.isAlive()) return;
    var paramName = user.isEnemy() ? "" : TextManager.param(paramId);
    var temp = isPositive ? 1 : -1;
    var iconIndex = user.buffIconIndex(temp, paramId);
    var value = PopInfoManagerABS.BUFF(paramName, iconIndex, isPositive);
    if (!user.getInfoPops().include(value)) {
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeSkillRechargePopUp = function (user, skillId) {
    if (!user.isAlive()) return;
    if (user.isEnemy()) return; //This is for ActorEnemy, in version 1 not develop yet
    var skill = $dataSkills[skillId];
    var value = PopInfoManagerABS.SKILL(skill.name, skill.iconIndex);
    if (!user.getInfoPops().include(value)) {
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.calcRate = function (rate) {
    this.text = "";
  };

  //STATIC
  PopInfoManagerABS.HP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.YELLOW;
    if (value < 0) {
      color = Color.GREEN;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.RED;
      fontSettings[1] = 34;
    }

    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.TP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.ORANGE;
    if (value < 0) {
      color = Color.GREEN;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.RED;
      fontSettings[1] = 34;
    }

    value = value + " " + TextManager.tpA;
    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.MP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.MAGENTA;
    if (value < 0) {
      color = Color.BLUE;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.MAGENTA;
      fontSettings[1] = 34;
    }

    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.STATE = function (name, iconIndex, isErase) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;

    var temp = isErase ? "- " : "+ ";
    fontSettings[0] = AlphaABS.SYSTEM.FONT;
    return new ABSObject_PopUp(temp + name, null, iconIndex, fontSettings);
  };

  PopInfoManagerABS.BUFF = function (name, iconIndex, isPositive) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;

    var color = isPositive ? Color.GREEN : Color.RED;
    fontSettings[0] = AlphaABS.SYSTEM.FONT;
    return new ABSObject_PopUp(name, color, iconIndex, fontSettings);
  };

  PopInfoManagerABS.TEXT = function (text) {
    return new ABSObject_PopUp(text);
  };

  PopInfoManagerABS.TEXT_WITH_COLOR = function (text, color) {
    return new ABSObject_PopUp(text, color);
  };

  PopInfoManagerABS.ALERT = function (text) {
    if (AlphaABS.Parameters.isLoaded()) {
      if (!this._alertPopUpConfigurated) {
        this._alertPopUpConfigurated = true;
        //var parameters = AlphaABS.Parameters.get_UIE_PlayerMessageBar();
        this._alertPopUp_color = Color.RED;
        this._alertPopUp_fontName = null;
      }
      return new ABSObject_PopUp(text, this._alertPopUp_color, null, [this._alertPopUp_fontName, 22, false, 2, Color.BLACK]);
    } else
      return new ABSObject_PopUp(text, Color.RED, null, [null, 22, false, 2, Color.BLACK]);
  };

  PopInfoManagerABS.EXP = function (value) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[1] = 32;
    var x = new ABSObject_PopUp(value, Color.MAGENTA, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.SKILL = function (name, iconIndex) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;
    return new ABSObject_PopUp(AlphaABS.SYSTEM.STRING_POPUP_SKILL, Color.GREEN, iconIndex, fontSettings);
  };

  //PRIVATE
  PopInfoManagerABS._apply_pop_up = function (user, value) {
    /*if(this.text === undefined)
      this.text = "";
    if(this.text != "") {
      if(value.isNumered()) value.setExtraText(this.text);
      this.text = "";
    }*/
    if(AA.isABS())
      user.addInfoPop(value);
  };

  //END PopInfoManagerABS
  //------------------------------------------------------------------------------

  AlphaABS.PopInfoManagerABS = PopInfoManagerABS;
  AlphaABS.register(PopInfoManagerABS);

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL DEFINITION]
var ABSSkillLoader;

ABSSkillLoader = function() {
  return new Error('Static class');
};

(function() {
  //@[CLASS HEADER PART]

  // * Параметры из Note системы частиц
  ABSSkillLoader.loadParticleParams = function(_, metaData) {
    var count, particleParamsUser;
    particleParamsUser = {};
    count = 0;
    ABSSkillLoader.PARTICLES.forEach(function(p) {
      var e;
      if (metaData[p] == null) {
        return;
      }
      count++;
      try {
        if (p === ABSSkillLoader.PARTICLES[0]) {
          return particleParamsUser[p] = metaData[p];
        } else {
          return particleParamsUser[p] = parseInt(metaData[p]);
        }
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while loading particle data from skill Note');
      }
    });
    if (count !== 0) {
      _._particleParamsUser = particleParamsUser;
    }
  };
  // * Проверяет и преобразует параметры
  ABSSkillLoader.checkParams = function(_) {
    ABSSkillLoader._checkByType(_);
    ABSSkillLoader._checkNoTarget(_);
    ABSSkillLoader._checkFirearm(_);
    ABSSkillLoader._checkStack(_);
    ABSSkillLoader._convertParams(_);
    ABSSkillLoader._checkFormulas(_);
  };
  AlphaABS.register(ABSSkillLoader);
})();

// ■ END ABSSkillLoader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  ABSSkillLoader.PARAMS = [
    'reloadParam',
    'pType',
    'img',
    'light',
    'castTimeFormula',
    'startSound',
    'motion',
    'motionX',
    'castMotion',
    'animaXAction',
    'xAnimaSet',
    'reloadSound', //! LAST STRING PARAMETER, все параметры до него - строковые
    'vSpeed',
    'range',
    'reloadTime',
    'castTime',
    'needTarget',
    'radius',
    'castAnim',
    'lightSize',
    'stack',
    'stackTime',
    'directionFix',
    'ammo',
    'cEonUse',
    'cEonStart',
    'noDescription',
    'impulse',
    'ignoreObstacles',
    'impulseRandom',
    'repeatDelay',
    'firearm',
    'noTarget',
    'motionOffset',
    'castMotionOffset',
    'castMotionFrames',
    'swing',
    'pierce',
    'explosive',
    'motionDelay',
    'motionADelay',
    'motionFrames',
    'motionWait',
    'landmineSkillId',
    'landmineEventId',
    'landmineTime',
    'landmineTimeOnly',
    'noCastingDelay',
    'teleport',
    'noBattle',
    'ifState',
    'freeDirection',
    'imgOffsetR',
    'imgOffsetL',
    'imgOffsetU',
    'imgOffsetD'
  ];
  ABSSkillLoader.PARTICLES = ['pData', 'pMinSize', 'pMaxSize', 'pPower', 'pLife', 'pAlpha', 'pCount'];
  ABSSkillLoader.TEMPLATES = [ // * 0 -  INSTANCE
    {
      range: 0,
      needTarget: true,
      castTime: 0,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0 // * 1 - VECTOR
    },
    {
      range: 6,
      needTarget: true,
      castTime: 120,
      reloadTime: 0,
      reloadParam: null,
      pType: null,
      img: 'null',
      light: null,
      lightSize: 100,
      directionFix: 0,
      noTarget: 0,
      freeDirection: 0 // * 2 - RADIUS
    },
    {
      range: 6,
      needTarget: true,
      radius: 3,
      castTime: 0,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0,
      teleport: 0 // * 3 - ZONE
    },
    {
      castTime: 0,
      needTarget: false,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0,
      range: 4
    }
  ];
})();

// ■ END ABSSkillLoader2.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader3.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  ABSSkillLoader._strParamsCount = function() {
    return ABSSkillLoader.PARAMS.indexOf('reloadSound') + 1;
  };
  ABSSkillLoader._checkByType = function(_) {
    if (_.type === 1) {
      ABSSkillLoader._checkVector(_);
    }
    if (_.type === 2) {
      ABSSkillLoader._checkRadius(_);
    }
    if (_.type === 3) {
      return ABSSkillLoader._checkZone(_);
    }
  };
  ABSSkillLoader._checkVector = function(_) {
    if ((_.img == null) || _.img === "") {
      _.img = 'null';
    }
    if ((_.pType == null) || _.pType === '0' || _.pType === 'null' || _.pType === "") {
      _.pType = null;
    }
    if ((_.light == null) || _.light === '0' || _.light === 'null' || _.light === "") {
      _.light = null;
    }
    if (_.range === 0) {
      _.range = ABSSkillLoader.TEMPLATES[1].range;
    }
    if (_.radius > 0) {
      _.needTarget = false;
      if (_.radius > 5) {
        _.radius = 5;
        LOGW.p(_.skill().name + " spell Radius must be <= 5. Changed to 5!");
      }
    } else {
      _.needTarget = ABSSkillLoader.TEMPLATES[1].needTarget;
    }
    if (_.explosive >= 0) {
      if (_.radius === 0) {
        _.radius = _.explosive + 1;
      }
    }
  };
  ABSSkillLoader._checkRadius = function(_) {
    if (_.radius === 0) {
      _.radius = ABSSkillLoader.TEMPLATES[2].radius;
    }
    if (_.radius > 5) {
      _.radius = 5;
      LOGW.p(_.skill().name + " spell Radius must be <= 5. Changed to 5!");
    }
    if (_.needTarget) {
      if (_.range === 0) {
        _.range = ABSSkillLoader.TEMPLATES[2].range;
      }
    }
  };
  ABSSkillLoader._checkZone = function(_) {
    if (_.range === 0) {
      _.range = ABSSkillLoader.TEMPLATES[3].range;
    }
    _.radius = _.range;
  };
  ABSSkillLoader._checkNoTarget = function(_) {
    if (_.type === 2 || _.type === 3) {
      _.noTarget = 0;
    }
    if (_.noTarget === 0) {
      return;
    }
    if (_.range === 0) {
      _.range = 1;
    }
    if (_.range === 1) {
      _.pierce = false;
    }
    if (_.range > 1) {
      _.swing = false;
    }
  };
  //_.firearm = 0
  //_.directionFix = 1
  ABSSkillLoader._checkFirearm = function(_) {
    if (!_.isFirearm()) {
      return;
    }
    if (!_.isNeedAmmo()) {
      _.firearm = 0;
      LOGW.p(_.skill().name + " Firearm weapon should be with <Ammo> parameter!");
    }
  };
  ABSSkillLoader._checkStack = function(_) {
    if (_.stack === 1) {
      _.stack = 2;
      LOGW.p("Skill " + _.name() + " stack minimum 2!");
    }
    if (_.stackTime <= 0 && _.stack > 1) {
      ABSSkillLoader._autoCalculateStackTime(_);
    }
    if (_.stackTime > 0 && _.stack === 0) {
      LOGW.p("Skill " + _.name() + " if you use stackTime param, you need stack param too, param not active!");
      _.stackTime = 0;
    }
    if (_.stackTime > 0 && _.firearm === 0) {
      ABSSkillLoader._checkAmmoForStack(_);
    }
  };
  ABSSkillLoader._autoCalculateStackTime = function(_) {
    var text;
    _.stackTime = _.reloadTime * _.stack * 2;
    text = " You use stack withou stackTime param, stackTime set automaticaly = " + _.stackTime;
    LOGW.p("Skill" + _.name() + text);
  };
  ABSSkillLoader._checkAmmoForStack = function(_) {
    var text;
    if (_.ammo > 0 && _.firearm === 0) {
      text = " You use stack with ammo, is forbidden";
      LOGW.p("Skill" + _.name() + text);
      _.ammo = 0;
    }
    if (_.firearm === 0) {
      _._currentStack = _.stack;
      _._stackNeedReload = false;
    } else {
      _._currentStack = 0;
      _._stackNeedReload = true;
    }
  };
  ABSSkillLoader._convertParams = function(_) {
    if (_.directionFix > 0) {
      _.directionFix = true;
    }
    if (_.noDescription > 0) {
      _.noDescription = true;
    }
    if (_.startSound) {
      _.startSound = ABSSkillLoader._convertSound(_.startSound);
    }
    if (_.reloadSound) {
      _.reloadSound = ABSSkillLoader._convertSound(_.reloadSound);
    }
  };
  ABSSkillLoader._convertSound = function(sound) {
    return {
      name: sound,
      pan: 0,
      pitch: 100,
      volume: 100
    };
  };
  ABSSkillLoader._checkFormulas = function(_) {};
  ABSSkillLoader._convertFormula = function(_f) {
    var formula;
    formula = _f.replace(/attackSpeed/i, 'this.attackSpeed()');
    formula = formula.replace(/hp/i, 'this.hp');
    formula = formula.replace(/mp/i, 'this.mp');
    formula = formula.replace(/tp/i, 'this.tp');
    formula = formula.replace(/mhp/i, 'this.mhp');
    formula = formula.replace(/mmp/i, 'this.mmp');
    formula = formula.replace(/atk/i, 'this.atk');
    formula = formula.replace(/def/i, 'this.def');
    formula = formula.replace(/mat/i, 'this.mat');
    formula = formula.replace(/mdf/i, 'this.mdf');
    formula = formula.replace(/agi/i, 'this.agi');
    formula = formula.replace(/luk/i, 'this.luk');
    return formula;
  };
})();

// ■ END ABSSkillLoader3.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
var AIAlly;

AIAlly = class AIAlly extends Game_Follower {
  constructor(memberIndex) {
    super(memberIndex);
    this._isDummy = false;
    this._setupABS();
    this.setThrough(false);
  }

};

(function() {
  var _;
  _ = AIAlly.prototype;
  //$[OVER]
  _.update = function() {
    Game_Character.prototype.update.call(this);
    this._updateAllyMoving();
    //if @isAlive() and $gamePlayer.isAlive()
    //    @setTransparent $gamePlayer.isTransparent()
    this._aaEntity.update();
    this.battler().updateABS();
    this._updateOther();
    if (this.isAnimX()) {
      return this._updateAnimX();
    }
  };
  _._setupABS = function() {
    this.resetMoveFlags();
    return this._aaEntity = new AllyABS(this._memberIndex);
  };
  _.AAEntity = function() {
    return this._aaEntity;
  };
  _.AABattler = function() {
    return this.battler();
  };
  _.character = function() {
    return this._aaEntity.character();
  };
  _.battler = function() {
    return this._aaEntity.battler();
  };
  _.inActive = function() {
    return !this.isDummy() && this._aaEntity.isActive();
  };
  _.isDummy = function() {
    return this._isDummy === true;
  };
  // * Если режим переключения лидера без АИ группы
  // * (опасный метод, требует тестирования)
  _.setDummy = function() {
    this._isDummy = true;
    this.update = function() {}; // * EMPTY
    this._aaEntity.update = function() {}; // * EMPTY
    this._aaEntity._stateMachine.slowUpdate = function() {}; // * EMPTY
  };
  _.inBattle = function() {
    return this._aaEntity.inBattle();
  };
  _.behaviorModel = function() {
    return this._aaEntity.behaviorModel();
  };
  _.target = function() {
    return this._aaEntity.getTarget();
  };
  _.level = function() {
    return this.AABattler().level;
  };
  _.initABS = function() {
    this.AAEntity().initABS();
    this.battler().initABS();
    if (!this.isAlive()) {
      return this._onNotAliveAtMapStart();
    } else {
      return this.AAEntity().changeStateToFree();
    }
  };
  _.stopABS = function() {
    return this.AAEntity().stopABS();
  };
  _.resumeABS = function() {
    return this.AAEntity().resumeABS();
  };
  _.onGameSave = function() {
    return this.AAEntity().onGameSave();
  };
  _.onGameLoad = function() {
    return this.AAEntity().onGameLoad();
  };
  _.refreshABS = function() {}; //???
  _.teamId = function() {
    return this._aaEntity.teamId();
  };
  _.isAlly = function(target) {
    return this._aaEntity.teamId() === target.teamId();
  };
  _.isABS = function() {
    return true;
  };
  _.currentAction = function() {
    return this._aaEntity.currentAction();
  };
  _.onActionOnMe = function(who) {}; //TODO: onActionOnMe
  _.isAlive = function() {
    return this.battler().isAlive();
  };
  _.isSummonUnit = function() {
    return false;
  };
  _.isEnemy = function() {
    return false;
  };
  _.isAllyAI = function() {
    return true;
  };
  _.onAADeath = function() {
    this.resetMoveFlags();
    this.resetPlayerTarget();
    if (!this._deadAtStartFlag) {
      return this.requestMotion('sleep');
    }
  };
  _.onAARevived = function() {
    if (this._deadAtStartFlag === true) {
      this._reviveAfterDeadAtStartFlag();
    }
    this.requestMotion('none');
    this.setThrough(false);
    return this.playReviveAnimation();
  };
})();

// ■ END AIAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AIAlly.prototype;
  _._updateAllyMoving = function() {
    if (AA.UI.isGameShouldPause()) {
      return;
    }
    if (this._needChasePlayer === true) {
      return this.moveTypeChasePlayer();
    } else if (this._needChaseTarget === true) {
      return this.moveTypeChaseTarget();
    } else if (this._needChaseAlly === true) {
      return this.moveTypeChaseAlly();
    }
  };
  //$[OVER]
  _.chaseCharacter = function(character) {}; // * NOTHING
  _.resetMoveFlags = function() {
    this._needChasePlayer = false;
    this._needChaseTarget = false;
    return this._needChaseAlly = false;
  };
  _.setMoveFlagToChasePlayer = function() {
    this.resetMoveFlags();
    return this._needChasePlayer = true;
  };
  _.setMoveFlagToChaseTarget = function() {
    this.resetMoveFlags();
    return this._needChaseTarget = true;
  };
  _.setMoveFlagToChaseAlly = function() {
    this.resetMoveFlags();
    return this._needChaseAlly = true;
  };
  _.moveTypeChasePlayer = function() {
    if (this.isMoving()) {
      return;
    }
    if (!this.isNearThePointX($gamePlayer)) {
      return this.moveToPointAA($gamePlayer);
    } else {
      return this._needChasePlayer = false;
    }
  };
  _.moveTypeChaseTarget = function() {
    var t;
    if (this.isMoving()) {
      return;
    }
    t = this.AAEntity().getTarget();
    if (t == null) {
      return this.resetMoveFlags();
    } else {
      if (!this.isNearThePointX(t)) {
        return this.moveToPointAA(t);
      } else {
        return this.turnTowardCharacter(t);
      }
    }
  };
  _.moveTypeChaseAlly = function() {
    var t;
    if (this.isMoving()) {
      return;
    }
    t = this.AAEntity().getAllyTarget();
    if (t == null) {
      return this.resetMoveFlags();
    } else {
      if (!this.isNearThePointX(t)) {
        return this.moveToPointAA(t);
      } else {
        return this._needChaseAlly = false;
      }
    }
  };
  _.turnTowardTarget = function() {
    var t;
    t = this.AAEntity().getTarget();
    if (t != null) {
      return this.turnTowardCharacter(t);
    }
  };
  //$[OVER]
  _.isDashing = function() {
    return $gamePlayer.isDashing() && !this.inBattle();
  };
})();

// ■ END AIAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AIAlly.prototype;
  _.selectOnMap = function(isSelect) {}; //???
  _._updateOther = function() {};
  _.resetPlayerTarget = function() {
    if (BattleManagerABS.getPlayerTarget() === this) {
      return BattleManagerABS.resetPlayerTarget();
    }
  };
  // * Показывать ли имя над персонажем на карте
  _.isMapNameVisible = function() {
    if (this.isAlive()) {
      return !this.isTransparent();
    } else {
      return true;
    }
  };
  _.isCanChangeBehMode = function() {
    return this.behaviorModel().sChangeModeAllowed > 0;
  };
  // * ANIMATIONS =========================================
  _.playReviveAnimation = function() {
    var reviveAnimationId;
    reviveAnimationId = AA.Parameters.get_EnemyReviveAnimationId();
    return this.requestAnimationABS(reviveAnimationId);
  };
  
  // * DEAD AT START ======================================

  // * Если союзник dead и переходим на ABS карту, скрыть его
  _._onNotAliveAtMapStart = function() {
    this._deadAtStartFlag = true;
    this.locate(-10, -10); // * For hide Nameplate and Dead Icon
    this.AAEntity().onSwitchToDeadState(true);
    return this.setTransparent(true);
  };
  _._reviveAfterDeadAtStartFlag = function() {
    this.setTransparent(false);
    this.locate($gamePlayer.x, $gamePlayer.y);
    return this._deadAtStartFlag = false;
  };
  // * CHARACTER MOTIONS ================================
  _.requestMotion = function(motion) {
    return this._aaCharMotion = motion;
  };
  _.isMotionRequested = function() {
    return this._aaCharMotion != null;
  };
  _.motionType = function() {
    return this._aaCharMotion;
  };
  _.clearMotion = function() {
    return this._aaCharMotion = null;
  };
  // * ABS MOTIONS =====================================

  //TODO: ABS MOTIONS
  _._performCastMotion = function() {}; //???
  _._cancelCastMotion = function() {}; //???
  _._performSkillMotion = function() {
    var a, name;
    a = this.currentAction();
    if (this.isAnimX()) {
      name = "Skill";
      if (a.isHasAnimaXAction()) {
        name = a.animaXAction;
      }
      this.aaPerformBattleActionAnimation(name);
    }
  };
  // * COLLISIONS ======================================
  _.checkCollisionWithPlayer = function() {
    return this.checkCollisionWith($gamePlayer);
  };
  _.checkCollisionWithParty = function() {
    var i, len, m, ref, results;
    if (Math.random() < 0.5) {
      return;
    }
    ref = $gameParty.membersABS();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      m = ref[i];
      if (m === this) {
        continue;
      }
      if (m.inActive()) {
        results.push(this.checkCollisionWith(m));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  // * MAP INVENTORY =================================
  _.startABSItemFromInventory = function(item) {
    var e;
    if (item == null) {
      return;
    }
    try {
      return $gamePlayer.startABSItemFromInventory(item, this);
    } catch (error) {
      //$gamePlayer.setTarget(null)
      e = error;
      return AA.warning(e);
    }
  };
})();

// ■ END AIAlly.coffee
//---------------------------------------------------------------------------

// ! DEPRECATED
(function () {
  var LOG = new KDCore.DevLog("Game_AIBehavior");
  //Game_AIBehavior
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class Game_AIBehavior {
    constructor() {}

    loadEnemy(ai) {
      var templateIndex = 0;
      var enemyObject = $dataEnemies[ai._absParams.enemyId];
      if (enemyObject.meta.ABS) {
        var newTemplateIndex = parseInt(t.meta.ABS);
        if (newTemplateIndex > 0)
          templateIndex = newTemplateIndex;
      }
      this._loadParamsBase(templateIndex);
      //this._loadFromJSON(ai._absParams.enemyId);
      this._readEnemyData(ai._absParams.enemyId);
      this._readEventData(ai);
      this._checkParams();
    }

    _loadParamsBase(templateIndex) {
      if (templateIndex >= Game_AIBehavior.TEMPLATES.length) {
        templateIndex = 0;
      }
      var template = Game_AIBehavior.TEMPLATES[templateIndex];
      Game_AIBehavior.PARAMS.forEach(function (p) {
        if (template[p])
          this[p] = template[p];
        else
          this[p] = 0;
      }.bind(this));
    }

    _readEnemyData(enemyId) {
      var t = $dataEnemies[enemyId];
      Game_AIBehavior.PARAMS.forEach(function (p) {
        if (t.meta[p]) {
          if (p == 'faceName' || p == 'HPBarStyle') {
            this[p] = t.meta[p];
          } else {
            this[p] = parseInt(t.meta[p]);
          }
          LOG.p("AI override Enemy param : " + p + " new value " + this[p]);
        }
      }.bind(this));
    }

    _readEventData(gameEvent) {
      var t = gameEvent.page().list;
      for (var i = 0; i < t.length; i++) {
        var item = t[i];
        if (item.code == 108) {
          var comment = item.parameters[0];
          Game_AIBehavior.PARAMS.forEach(function (p) {
            if (comment.indexOf("<" + p) >= 0) {
              var t2 = new RegExp("<" + p + "\\s?:\\s?(.+?)>", "i");
              var match = t2.exec(comment);
              if (match) {
                if (p == 'faceName' || p == 'HPBarStyle') {
                  this[p] = match[1];
                } else {
                  this[p] = parseInt(match[1]);
                }
                LOG.p("AI override Event param : " + p + " new value " + this[p]);
              }
            }

          }.bind(this));
        }
      }
    }

    _checkParams() {
      if (this.slow == 1)
        this.slow = true;
    }

    loadAlly() {
      this._loadParamsBase(1);
      this._checkParams();
    }
  }

  AlphaABS.register(Game_AIBehavior);

  KDCore.SDK.setConstantToObject(Game_AIBehavior, 'TEMPLATES', //YOU CAN ADD YOU OWN TEMPLATE, but DON'T MODIFY EXIST ZERO TEMPLATE!!!
    [{ //Zero template
        viewRadius: 5, //Насколько клеток игровой карты видит АИ
        returnRadius: 12, //На сколько клеток может макисимум убежать от последней позиции, где сражался
        escapeOnBattle: false, //Будет ли убегать во время битвы когда нет доступных действий
        canSearch: true, //Слышит ли что происходит вокруг (реакция на битву рядом (в зоне viewRadius))
        noFight: false, //Не будет сражаться вообще
        reviveTime: 0, //Через сколько возродится (секунды)
        regen: true, //Регенерация
        slow: false, //Медленный в бою
        agressive: true, //Агрессивный (всегда догоняет)
        noMove: false, //Не может двигаться в бою
        noEmote: false, //Не показывает эмоции
        cEonStart: 0, //Common Event ID when start battle (see player)
        cEonEnd: 0, //Common Event ID when stop battle (after start)
        cEonDeath: 0, //Common Event ID when Death
        returnType: 0, //Тип возвращения (0 - быстрый, 1 - обычный, 2 - стоит на месте)
        teamId: 1, //Команда
        rage: true, //Может агрится
        ignoreObstacles: false, //Игнорирует регионы препядствий (видит сквозь стены)
        heavy: false, //Нельзя сдвинуь импульсом (1 - нельзя, 0 - можно)
        showHP: false, //Показывать полоску здоровья над врагом всегда (0 - нет, 1 - да)
        motion: false,
        motionX: false,
        faceName: null,
        faceIndex: 0,
        HPBarStyle: "miniHp",
        canLooting: 1,
        supportSkillId: 0,
        cEinBattle: 0, // Common Event ID in Battle
        sBattleMode: 0,
        sChangeModeAllowed: 1
      }, //END Zero template
      { //Template for Ally
        viewRadius: 5,
        returnRadius: 12,
        escapeOnBattle: false,
        canSearch: true,
        noFight: false,
        agressive: true,
        noMove: false,
        noEmote: true,
        cEonStart: 0,
        cEonEnd: 0,
        cEonDeath: 0,
        returnType: 1,
        teamId: 0,
        rage: false,
        ignoreObstacles: false,
        heavy: false,
        showHP: false,
        motion: false,
        motionX: false,
        HPBarStyle: "miniHp"
      }
    ]
  );

  KDCore.SDK.setConstantToObject(Game_AIBehavior, 'PARAMS', ['viewRadius', 'returnRadius', 'escapeOnBattle',
    'canSearch', 'noFight', 'reviveTime', 'regen', 'slow', 'agressive',
    'noMove', 'noEmote', 'cEonStart', 'cEonDeath', 'cEonEnd', 'returnType',
    'teamId', 'rage', 'ignoreObstacles', 'heavy', 'showHP', 'motion', 'motionOffset', 'motionX',
    'faceName', 'faceIndex', 'HPBarStyle', 'motionDelay', 'motionFrames', 'motionADelay', 'canLooting',
    'supportSkillId', 'cEinBattle', 'sBattleMode', 'sChangeModeAllowed'
  ]);

  //END Game_AIBehavior
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIBehavModel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Добавляем новый параметр в PARAMS, если это строка, то дублируем в STRINGS
// * Устанавливаем базовое значение для парметра в DEFAULT

//?{rev: 1174}
var AIBehavModel;

AIBehavModel = class AIBehavModel {
  constructor() {}

  loadEnemy(aiBot) {
    this.enemyId = aiBot._absParams.enemyId;
    this._loadDefault();
    this._loadFromJSON();
    this._loadFromMetaData();
    return this.loadEventMetadata(aiBot.eventId());
  }

  _loadDefault() {
    return AIBehavModel.PARAMS.forEach((p) => {
      if (AIBehavModel.DEFAULT[p] != null) {
        return this[p] = AIBehavModel.DEFAULT[p];
      } else {
        if (this.isStringParameter(p)) {
          return this[p] = null;
        } else {
          return this[p] = 0;
        }
      }
    });
  }

  _loadFromJSON() {
    var e, enemy, id, params;
    try {
      enemy = $dataEnemies[this.enemyId];
      if (enemy == null) {
        return;
      }
      if (AA.Utils.hasMeta('outer', enemy)) {
        id = AA.Utils.getNumberFromMeta('outer', enemy);
        if (id === 0) {
          id = this.enemyId;
        }
        params = AAJsonSettings.getEnemyParameters(id);
        this._applyJsonParams(params);
        return AA.log("AI load params from [JSON]", this);
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy outer JSON settings');
    }
  }

  _applyJsonParams(params) {
    var p, results, v;
    results = [];
    for (p in params) {
      v = params[p];
      if (p === 'id') {
        continue;
      }
      if (AIBehavModel.PARAMS.include(p)) {
        results.push(this[p] = v);
      } else {
        results.push(void 0);
      }
    }
    return results;
  }

  _loadFromMetaData() {
    var e, enemy;
    try {
      enemy = $dataEnemies[this.enemyId];
      if (enemy == null) {
        return;
      }
      return AIBehavModel.PARAMS.forEach((p) => {
        if (AA.Utils.hasMeta(p, enemy)) {
          if (this.isStringParameter(p)) {
            this[p] = AA.Utils.getValueFromMeta(p, enemy);
          } else {
            this[p] = AA.Utils.getNumberFromMeta(p, enemy);
          }
          return AA.log("AI override Enemy [Meta] param : " + p + " new value " + this[p], this);
        }
      });
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy Database Note settings');
    }
  }

  loadEventMetadata(eventId, pageIndex) {
    var comment, e, event, i, item, j, list, ref, results;
    try {
      event = $gameMap.event(eventId);
      if (event == null) {
        return;
      }
      if (pageIndex == null) {
        list = event.page().list;
      } else {
        list = event.event().pages[pageIndex].list;
      }
      results = [];
      for (i = j = 0, ref = list.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = list[i];
        if (item.code === 108) {
          comment = item.parameters[0];
          results.push(this._loadFromComment(comment));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy Event settings');
    }
  }

  _loadFromComment(comment) {
    AIBehavModel.PARAMS.forEach((p) => {
      var match, r;
      if (comment.indexOf("<" + p >= 0)) {
        r = new RegExp("<" + p + "\\s?:\\s?(.+?)>", "i");
        match = r.exec(comment);
        if (match) {
          if (this.isLevelingParameter(p)) {
            return this.calculateRandLevel(match[1]);
          } else {
            if (this.isStringParameter(p)) {
              this[p] = match[1];
            } else {
              this[p] = KDCore.SDK.toNumber(match[1]);
            }
            return AA.log("AI override Enemy [Event] param: " + p + " new value " + this[p], this);
          }
        }
      }
    });
  }

  isStringParameter(param) {
    return AIBehavModel.STRINGS.include(param);
  }

  isLevelingParameter(param) {
    return param === 'levelRange';
  }

  calculateRandLevel(range) {
    var e, newLevel, parts;
    try {
      parts = range.split(',').map(function(i) {
        return Number(i);
      });
      newLevel = Math.abs(parts[0] + (Math.randomInt(parts[1] - parts[0])));
      if (newLevel <= 0) {
        newLevel = 1;
      }
      this.level = newLevel;
      AA.log("AI Random Enemy Level: " + this.level, this);
    } catch (error) {
      e = error;
      AA.warning(e);
      this.level = 1;
    }
  }

  // * Тут задаём дополнительные настройки для союзников
  loadAlly() {
    this._loadDefault();
    this.teamId = 0;
    this.noEmote = true;
    this.returnType = 1;
    return this.rage = 0;
  }

};

KDCore.SDK.setConstantToObject(AIBehavModel, 'PARAMS', [
  'faceName',
  'faceIndex',
  'xAnima',
  // * MAIN
  'viewRadius',
  'tVisor',
  'sideVisor',
  'returnRadius',
  'returnType',
  'escapeOnBattle',
  'canSearch',
  'noFight',
  'reviveTime',
  'reviveMaxCount', // * Сколько раз враг может воскреснуть -> 0 бесконечно
  'regen',
  'agressive',
  'noMove',
  'slow',
  'noEmote',
  'rage',
  'ignoreObstacles',
  'heavy',
  // * TEAM
  'teamId',
  // * COMMON EVENTS
  'cEonStart',
  'cEonDeath',
  'cEonEnd',
  'cEinBattle',
  // * HP BAR
  'HPBarStyle',
  'showHP',
  // * MOTION
  'motion',
  'motionOffset',
  'motionX',
  'motionWait',
  'motionDelay',
  'motionFrames',
  'motionADelay',
  // * SUMMON
  'canLooting',
  'sBattleMode',
  'sChangeModeAllowed',
  // * SUPPORT
  'supportSkillId',
  // * LEVEL
  'level',
  'levelRange', // * Используется только в комментариях
  'noFightIfLvlBelow',
  'runAwayIfLvlBelow',
  'cEvIfLvlNotSame',
  // * BARRIER
  'barrierElemId',
  'barrierHp',
  // * TELEPORT
  'teleportDist',
  'teleportOut',
  'teleportRest', // * В секундах
  'teleportRate' // * Шанс от 0 до 100
]);

// * Эти параметры дублируются
KDCore.SDK.setConstantToObject(AIBehavModel, 'STRINGS', ['faceName', 'HPBarStyle', 'xAnima']);

KDCore.SDK.setConstantToObject(AIBehavModel, 'DEFAULT', {
  // * Насколько клеток игровой карты видит АИ
  viewRadius: 5,
  // * На сколько клеток может макисимум убежать от последней позиции, где сражался
  returnRadius: 12,
  // * Будет ли убегать во время битвы когда нет доступных действий
  escapeOnBattle: 0, //BOOL
  // * Слышит ли что происходит вокруг (реакция на битву рядом (в зоне viewRadius))
  canSearch: 1, //BOOL
  // * Не будет сражаться вообще
  noFight: 0, //BOOL
  // * Через сколько возродится (секунды)
  reviveTime: 0,
  // * Регенерация
  regen: 1, //BOOL
  // * Медленный в бою
  slow: 0, //BOOL
  // * Агрессивный (всегда догоняет)
  agressive: 1, //BOOL
  // * Не может двигаться в бою
  noMove: 0, //BOOL
  // * Не показывает эмоции
  noEmote: 0, //BOOL
  // * Common Event ID when start battle (see player)
  cEonStart: 0,
  // * Common Event ID when stop battle (after start)
  cEonEnd: 0,
  // * Common Event ID when Death
  cEonDeath: 0,
  // * Тип возвращения (0 - быстрый, 1 - обычный, 2 - стоит на месте)
  returnType: 0,
  // * Игнорирует регионы препядствий (видит сквозь стены)
  ignoreObstacles: 0, //BOOL
  // * Номер команды
  teamId: 1,
  // * Может агрится
  rage: 1, // BOOL
  // * Нельзя сдвинуь импульсом (1 - нельзя, 0 - можно)
  heavy: 0, // BOOL
  // * Показывать полоску здоровья над врагом всегда (0 - нет, 1 - да)
  showHP: 0, // BOOL
  motion: 0, // BOOL
  motionX: 0, // BOOL
  motionWait: 0, // BOOL
  motionOffset: 0,
  motionDelay: 0,
  motionADelay: 9,
  motionFrames: 3,
  faceName: "", // STRING
  faceIndex: 0,
  HPBarStyle: "miniHp",
  // * Common Event ID in Battle
  cEinBattle: 0,
  // * ДЛЯ ПИТОМЦА
  canLooting: 1, // BOOL
  supportSkillId: 0,
  sBattleMode: 0, // 0, 1, 2
  sChangeModeAllowed: 1, // BOOL
  // * УРОВЕНЬ
  level: 1,
  noFightIfLvlBelow: 0,
  runAwayIfLvlBelow: 0,
  cEvIfLvlNotSame: 0,
  levelRange: 0,
  // * Барьер
  barrierElemId: 0,
  barrierHp: 0,
  // * Визор
  tVisor: 0,
  sideVisor: 0,
  // * ТЕЛЕПОРТ
  teleportDist: 0,
  teleportOut: 0,
  teleportRest: 3,
  teleportRate: 100,
  // * Возрождение
  reviveMaxCount: 0, // * 0 - Бесконечно
  xAnima: ""
});

// ■ END AIBehavModel.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIAllyBehavModel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
//?{rev: 1190}
var AIAllyBehavModel;

AIAllyBehavModel = class AIAllyBehavModel {
  constructor() {}

  loadActor(actorId) {
    this.actorId = actorId;
    this._loadDefault();
    //@_loadFromJSON()
    return this._loadFromMetaData();
  }

  _loadDefault() {
    return AIAllyBehavModel.PARAMS.forEach((p) => {
      if (AIAllyBehavModel.DEFAULT[p] != null) {
        return this[p] = AIAllyBehavModel.DEFAULT[p];
      } else {
        if (this.isStringParameter(p)) {
          return this[p] = null;
        } else {
          return this[p] = 0;
        }
      }
    });
  }

  _loadFromMetaData() {
    var actor, e;
    try {
      actor = $dataActors[this.actorId];
      if (actor == null) {
        return;
      }
      return AIAllyBehavModel.PARAMS.forEach((p) => {
        if (AA.Utils.hasMeta(p, actor)) {
          if (this.isStringParameter(p)) {
            this[p] = AA.Utils.getValueFromMeta(p, actor);
          } else {
            this[p] = AA.Utils.getNumberFromMeta(p, actor);
          }
          return AA.log("AI override Actor [Meta] param : " + p + " new value " + this[p], this);
        }
      });
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Actor Database Note settings');
    }
  }

  isStringParameter(param) {
    return AIAllyBehavModel.STRINGS.include(param);
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = AIAllyBehavModel.prototype;
})();

// * ================================================
KDCore.SDK.setConstantToObject(AIAllyBehavModel, 'PARAMS', [
  'slow', // * Если 1, то будет Dash до цели
  'agressive', // * Если 1, то атакует сам цель (когда игрок не в бою)
  'sBattleMode', // * Режим поведения по умолчанию
  'canSearchAlly', // * Если 1, то будет помогать союзникам, иначе только игроку
  'ignoreObstacles', // * Видит сквозь препятствия
  'viewRadius',
  'canLooting', // * Может ли собирать лут
  'mainTpBar', // * Рисовать TP заместо MP на интерфейсе
  'sChangeModeAllowed', // * Можно ли менять режим поведения
  'noEmote', // * НЕ Показывать базовые эмоции
  'cEonStart', // * Общее событие, когда начинает бой
  'returnRadius', // * Как далеко может быть от игрока
  'cEonEnd' // * Общее событие, когда заканчивается бой
]);

// * Эти параметры дублируются
KDCore.SDK.setConstantToObject(AIAllyBehavModel, 'STRINGS', []);

KDCore.SDK.setConstantToObject(AIAllyBehavModel, 'DEFAULT', {
  slow: 0,
  agressive: 1,
  sBattleMode: 0,
  canSearchAlly: 1,
  ignoreObstacles: 0,
  viewRadius: 5,
  returnRadius: 6,
  canLooting: 1,
  mainTpBar: 0,
  sChangeModeAllowed: 1,
  noEmote: 1,
  cEonStart: 0,
  cEonEnd: 0
});

// ■ END AIAllyBehavModel.coffee
//---------------------------------------------------------------------------

//Class extension (for savefile compability)
function Game_AIBot() {
  this.initialize.apply(this, arguments);
}

(function () {

  "use strict";


  //Game_AIBot
  //------------------------------------------------------------------------------
  Game_AIBot.prototype = Object.create(Game_Event.prototype);
  Game_AIBot.prototype.constructor = Game_AIBot;
  KDCore.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBot);
  KDCore.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABS);
  KDCore.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABSEvents);
  KDCore.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotActions);
  KDCore.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABSMoving);
  AlphaABS.register(Game_AIBot);

  Game_AIBot.prototype.initialize = function (mapId, eventId, enemyId) {
    Game_Event.prototype.initialize.call(this, mapId, eventId);
    this.initializeABS();
    this.initMyStateMachine();
    this.LOG.p("AI inited " + $dataEnemies[enemyId].name + " at " + this.toPoint().toString());
    this.aiName = $dataEnemies[enemyId].name;
    if(AA.isDEV()) {
      this.aiName += "__" + eventId;
    }
    this._absParams.enemyId = enemyId;

    //Variables
    this._absParams.allyToSearch = null; //Кого мне искать
    this._absParams.reviveTimer = null; //Таймер для возраждения
    this._absParams.regenTimer = null; //Таймер для восстановления параметров
    this._absParams.myStartPosition = this.toPoint();
    this._absParams.looted = false;
    this._absParams.activateSwitch = null; //Used if enemy not been active at start
    this._absParams.reservedCommonEvent = null;
    this._absParams.reviveCount = 0;

    this._absParams.behavior.loadEnemy(this);

    //For compability with Sprite_CharacterABS
    this._absParams.viewRadius = this._absParams.behavior.viewRadius;
    this._absParams.returnRadius = this._absParams.behavior.returnRadius;

    this.setRevive(this._absParams.behavior.reviveTime);

    if (Imported.Quasi_Movement)
      this._absParams.useAStar = true;
    else
      this._absParams.useAStar = false;

    if(this.canRage())
      this._absParams.rageContainer = new AlphaABS.LIBS.RageContainer();

    this._storeMoveData();
  };

  Game_AIBot.prototype.initMyStateMachine = function () {
    this._stateMachine = new AlphaABS.LIBS.AIStateMachine();
  };

  Game_AIBot.prototype.changeReturnType = function (newReturnType) {
    this.behaviorModel().returnType = newReturnType;
    this.LOG.p("ReturnType: " + this.behaviorModel().returnType);
  };

  Game_AIBot.prototype.hasLoot = function () {
    return !this._absParams.looted;
  };

  Game_AIBot.prototype.isABS = function() {
    return this.inActive() && this.battler() != null;
  };

  // * No more limit
  Game_AIBot.prototype.isNearTheScreen = function() {
      return true;
  };

})();
// Generated by CoffeeScript 2.5.1
(function() {
  var __interface_method_performAction, __super_deactivate, __super_selectOnMap;
  Game_AIBot.prototype.activate = function() {
    var key;
    if (!this._absParams.activateSwitch) {
      return;
    }
    if (this._absParams.active === true) {
      return;
    }
    this.LOG.p('Activate');
    key = [$gameMap.mapId(), this.eventId(), this._absParams.activateSwitch];
    $gameSelfSwitches.setValue(key, true);
    this.refresh();
    this.refreshGlobal();
    this._stateMachine._setup(this);
    this._absParams.battler.initABS();
    this.initABS();
  };
  Game_AIBot.prototype.initABS = function() {
    var m;
    if (!this.battler()) {
      this._absParams.battler = new Game_EnemyABS(this._absParams.enemyId);
      m = this.behaviorModel();
      if (m.barrierElemId > 0) {
        this._absParams.battler.setupBarrier(m.barrierElemId, m.barrierHp);
      }
      if (this._absParams.active === true) {
        this._absParams.battler.initABS();
        this.refreshGlobal();
      }
      if (m.level > 1) {
        this.battler().applyLeveling(m.level);
      }
      this._loadSupportAction();
    }
    this.changeStateToFree();
    if (this.isNeedHpBarShow()) {
      this.showHpBarABS();
    }
    if (this._checkActiveState()) {
      this._absParams.active = true;
      this._checkDieSwitch();
      if (this.battler().enemy().actions.length === 0) {
        this.LOG.p('Not actions');
        this.behaviorModel().noFight = true;
      }
    } else {
      this.LOG.p('Deactivated from start');
      this._deactivate();
    }
    this.refreshABSMotion();
  };
  Game_AIBot.prototype.getCurrentAnimaXProfile = function() {
    return this.behaviorModel().xAnima;
  };
  Game_AIBot.prototype.isAnimaXAADefaultAction = function(actionName) {
    return ['Attack', 'Skill'].contains(actionName);
  };
  Game_AIBot.prototype.refreshGlobal = function() {
    SlowUpdateManager.clear(this.eventId());
    return SlowUpdateManager.register(this.eventId(), this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
  };
  //$[OVER I]
  Game_AIBot.prototype.isNeedHpBarShow = function() {
    var e, showFromModel, showFromPluginAlways;
    try {
      if (AlphaABS.Parameters.isLoaded()) {
        showFromPluginAlways = AlphaABS.Parameters.get_EnemyMiniHpBarOption() === 1;
      } else {
        showFromPluginAlways = false;
      }
      showFromModel = this.behaviorModel().showHP === 1;
      return showFromPluginAlways || showFromModel;
    } catch (error) {
      e = error;
      AlphaABS.error(e, 'while read show enemy mini HP parameter');
      return false;
    }
  };
  Game_AIBot.prototype.getHpBarStyleID = function() {
    return this.behaviorModel().HPBarStyle;
  };
  
  //@[ALIAS I]
  __super_selectOnMap = Game_AIBot.prototype.selectOnMap;
  Game_AIBot.prototype.selectOnMap = function(isSelect) {
    var e;
    __super_selectOnMap.call(this, isSelect);
    try {
      if (this._checkCanShowByParameters() === true) {
        if (isSelect === true) {
          return this.showHpBarABS();
        } else {
          if (this.behaviorModel().showHP === 0) {
            return this.hideHpBarABS();
          }
        }
      }
    } catch (error) {
      e = error;
      return AlphaABS.error(e, 'while read show enemy mini HP parameter on selection');
    }
  };
  Game_AIBot.prototype.deactivate = function() {
    var key;
    this.__isDeadForMotion = null;
    if (!this._absParams.activateSwitch) {
      return;
    }
    if (this._absParams.active === false) {
      return;
    }
    this.LOG.p('Deactivate');
    key = [$gameMap.mapId(), this.eventId(), this._absParams.activateSwitch];
    $gameSelfSwitches.setValue(key, false);
    this.refresh();
    this._onBattleEnd();
    this.battler().stopABS();
    this._deactivate();
  };
  __super_deactivate = Game_AIBot.prototype._deactivate;
  Game_AIBot.prototype._deactivate = function() {
    this.__isDeadForMotion = null;
    __super_deactivate.call(this);
    this.hideHpBarABS();
    this.refreshABSMotion();
    return SlowUpdateManager.clear(this.eventId());
  };
  Game_AIBot.prototype.loot = function() {
    var items;
    if (!this._absParams.looted) {
      this._absParams.looted = true;
      this._lootGainGoldToParty();
      items = this.battler().makeDropItems();
      if (items.length > 0) {
        items.forEach(function(item) {
          $gameParty.gainItem(item, 1);
        });
      }
      this.LOG.p('Looted!');
      if (!this.inActive()) {
        this._storeDeadData();
      }
    } else {
      this.LOG.p('Already looted!');
    }
  };
  Game_AIBot.prototype._lootGainGoldToParty = function() {
    var gold;
    gold = this.battler().gold();
    if ($gameParty.hasGoldDouble()) {
      gold *= 2;
    }
    if (gold > 0) {
      $gameParty.gainGold(gold);
    }
  };
  Game_AIBot.prototype.visualLoot = function() {
    var convertedItems, i, item, items, len;
    if (!this._absParams.looted) {
      this._absParams.looted = true;
      items = this.battler().makeDropItems();
      convertedItems = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        convertedItems.push([item, 1]);
      }
      this.LOG.p('Looted!');
      if (!this.inActive()) {
        this._storeDeadData();
      }
      $gameTemp.__visualLootGold = this.battler().gold();
      if ($gameParty.hasGoldDouble()) {
        $gameTemp.__visualLootGold *= 2;
      }
      return convertedItems;
    } else {
      this.LOG.p('Already looted!');
    }
    return [];
  };
  Game_AIBot.prototype._updateABS = function() {
    if (this.inActive() && !this.isErased()) {
      this.battler().updateABS();
      this._updateCEBTimer();
      this._updateTPThread();
      //@_updateSafeThreadTimer()
      this._stateMachine.update(this);
    } else {
      if (this._stateMachine.inReturnState()) {
        this._stateMachine.update(this);
      }
    }
    if (this.inActive() && this.isErased()) {
      this._deactivate();
    }
  };
  //?[NEW]
  Game_AIBot.prototype._updateSafeThreadTimer = function() {};
  //?[NEW]
  Game_AIBot.prototype._updateSafeThreadTimerBody = function() {
    if (this.__stt == null) {
      this.__stt = 0;
    }
    this.__stt += 1;
    if (this.__stt >= 240) {
      this.__stt = 0;
      this.refreshGlobal();
    }
  };
  //?[NEW]
  Game_AIBot.prototype._updateCEBTimer = function() {
    if (this.__cebTimer == null) {
      this.__cebTimer = 0;
    }
    this.__cebTimer += 1;
    if (this.__cebTimer >= 60) {
      this.__cebTimer = 0;
      if (this.inBattle()) {
        return this.startCommonEvent(this.behaviorModel().cEinBattle);
      }
    }
  };
  Game_AIBot.prototype._updateRevive = function() {
    if (this._absParams.reviveTimer === null || this.battler().isAlive()) {
      return;
    }
    this._absParams.reviveTimer.update();
    if (this._absParams.reviveTimer.isReady()) {
      if ($gameMap.isMapCellInAABlockZone(this.x, this.y)) {
        this._absParams.reviveTimer = null;
      } else {
        this._revive();
      }
    }
  };
  Game_AIBot.prototype._revive = function() {
    var key, reviveAnimationId;
    this.__isDeadForMotion = null;
    if (this.isErased()) {
      this._absParams.reviveTimer = null;
      return;
    }
    this.locate(this._absParams.myStartPosition.x, this._absParams.myStartPosition.y);
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    $gameSelfSwitches.setValue(key, false);
    this._absParams.battler = null;
    this._absParams.reviveTimer = null;
    this._absParams.active = true;
    this._absParams.looted = false;
    this.refresh();
    this.initABS();
    this.setRevive(this.behaviorModel().reviveTime);
    reviveAnimationId = AlphaABS.Parameters.get_EnemyReviveAnimationId();
    if (reviveAnimationId > 0) {
      this.requestAnimationABS(reviveAnimationId);
    }
    this._absParams.myHomePosition = null;
    this.changeStateToFree();
    $gamePlayer.resetStoredChest($gameMap.mapId(), this.eventId());
    this.checkReviveCounter();
    this.aaRefreshAnimaX();
    if (this.isAnimX()) {
      this.resetXAnimaState();
    }
  };
  Game_AIBot.prototype.checkReviveCounter = function() {
    if (this.behaviorModel().reviveMaxCount > 0) {
      this._absParams.reviveCount++;
      if (this._absParams.reviveCount >= this.behaviorModel().reviveMaxCount) {
        return this._updateRevive = function() {}; // * EMPTY
      }
    }
  };
  Game_AIBot.prototype.setRevive = function(time) {
    var t;
    if (time === 0) {
      this._absParams.reviveTimer = null;
      return;
    }
    t = time * AlphaABS.SYSTEM.FRAMES_PER_SECOND;
    this.LOG.p('Set revive ' + time + ' secs.');
    if (time) {
      this._absParams.reviveTimer = new Game_TimerABS();
      this._absParams.reviveTimer.start(t);
    }
  };
  Game_AIBot.prototype.startCommonEvent = function(commonEventId) {
    var commonEvent, list;
    if (commonEventId <= 0) {
      return;
    }
    if (commonEventId == null) {
      return;
    }
    this.LOG.p('Try call outer Common Event ' + commonEventId);
    commonEvent = $dataCommonEvents[commonEventId];
    if (commonEvent) {
      list = commonEvent.list;
      if (list && list.length > 1) {
        list.push({
          code: 355,
          indent: 0,
          parameters: ["this.__clearCMABSEvent();"]
        });
        this.LOG.p('Start outer Common Event ');
        this._absParams.reservedCommonEvent = [
          {
            code: 117,
            indent: 0,
            parameters: [commonEventId]
          }
        ];
        this._starting = true;
      }
    }
  };
  //@[ALIAS I]
  __interface_method_performAction = Game_AIBot.prototype._performAction;
  Game_AIBot.prototype._performAction = function() {
    this._performSkillMotion();
    __interface_method_performAction.call(this);
    if (this.battler().action(0).isAttack()) {
      this.aaPerformAttackAnimation();
    }
    if (this.inABSMotion()) {
      if (this.battler().action(0).isAttack()) {
        this.battler().requestABSMotionAction();
      }
    }
  };
  Game_AIBot.prototype.isPlayerAttackedMe = function() {
    var r;
    r = this.rageContainer();
    if (r == null) {
      return false;
    }
    return r.getDealerDamage($gamePlayer) > 0;
  };
  Game_AIBot.prototype.isHasAnyLoot = function() {
    var gold, items;
    gold = this.battler().gold();
    items = this.battler().enemy().dropItems;
    items = items.filter(function(item) {
      return (item != null ? item.kind : void 0) > 0;
    });
    return gold > 0 || items.length > 0;
  };
})();

// Generated by CoffeeScript 2.5.1
(function() {
  Game_AIBot.prototype.onActionOnMe = function(who) {
    var e;
    if (this.isSummonUnit() && who === $gamePlayer) {
      return;
    }
    if (!this.inBattle() && this.canFight()) {
      if (this.behaviorModel().teamId === 0 && who === $gamePlayer) {
        return;
      }
      this.LOG.p('I\'am attacked!!!');
      if (this._checkWhoActionOnMe(who)) {
        this.LOG.p('Start battle');
        this.changeStateToBattle(who);
      }
    }
    if (!this.isAlive() && this.inActive()) {
      try {
        this.gainExpProcess(who);
      } catch (error) {
        e = error;
        console.error(e);
      }
      if (AlphaABS.Parameters.get_AutoLootEnemiesState() === true) {
        this.loot();
      }
      this.startCommonEvent(this.behaviorModel().cEonDeath);
    }
    if (this.inBattle() && this.canFight()) {
      this._performRageCalculation(who);
    }
    if (this._checkCanShowByParameters()) {
      if (!this.ABSParams().selected) {
        this.showHpBarABS();
      }
      this.__tempThread1123 = AA.setTimeout((() => {
        try {
          if (this.ABSParams().selected !== true) {
            this.hideHpBarABS();
          }
          return AA.clearTimeout(this.__tempThread1123);
        } catch (error) {

        }
      }), 1000);
    }
    if (!who.inActive()) {
      if (who.isDefenseTower != null) {
        if (!this.isMoving()) {
          if (this._moveType !== 3) {
            if (!this.behaviorModel.noMove) {
              this.moveFromPoint(who);
            }
          }
        } //and !@inBattle()
      }
    }
  };
  Game_AIBot.prototype._callCEWhenTargetLevelIsHigh = function() {
    if (this.__cEOnNotSameIsCalled === true) {
      return;
    }
    this.__cEOnNotSameIsCalled = true;
    return this.startCommonEvent(this.behaviorModel().cEvIfLvlNotSame);
  };
  //?[NEW]
  Game_AIBot.prototype._checkWhoActionOnMe = function(who) {
    var r;
    r = this.battler().result();
    if (r.isDamageDone()) {
      return true;
    } else {
      return AA.AILogicManager.checkDistanceTo(this, who);
    }
  };
  Game_AIBot.prototype.gainExpProcess = function(whoKill) {
    var exp, expMode;
    if (whoKill.battler().isEnemy()) {
      return;
    }
    exp = this.battler().exp();
    if (AlphaABS.Parameters.isLoaded()) {
      expMode = AlphaABS.Parameters.get_PartyExpMode();
      if (expMode !== 0) {
        $gameParty.gainExpForAllABS(exp, expMode === 2);
        return;
      }
    }
    return whoKill.battler().gainExp(exp);
  };
  Game_AIBot.prototype.onReturnEnd = function() {
    this._absParams.active = true;
    this._onBattleEnd();
    this.initABS();
    if (this.isNeedHpBarShow()) {
      this.showHpBarABS();
    }
    this.refreshABSMotion();
  };
  Game_AIBot.prototype.onSwitchToFreeState = function() {
    this.LOG.p('In free state');
    this.clearTarget();
    this._restoreMoveData();
  };
  //@_moveSpeed += @battler().ABSParams().moveSpeedUpKoef
  Game_AIBot.prototype.onSwitchToReturnState = function() {
    //@_deactivate()
    if (AlphaABS.BattleManagerABS.getPlayerTarget() === this) {
      AlphaABS.BattleManagerABS.setPlayerTarget(null);
    }
    this._absParams.active = false;
    this._resetTarget();
    if (this._stateMachine != null) {
      this._stateMachine.deactivate();
    }
    this.refreshABSMotion();
    this.LOG.p('Return to ' + this.getHomePosition().toString());
  };
  Game_AIBot.prototype.onSwitchToSearchState = function() {
    this._restoreMoveData();
    this.LOG.p('Curious! I\'am searching...');
    if (!this.behaviorModel().noEmote) {
      this.requestBalloon(2);
    }
  };
  Game_AIBot.prototype.onSwitchToDeadState = function() {
    this._absParams.allyToSearch = null;
    this._moveType = 0;
    if (this.inABSMotion()) {
      this._absParams.absMotion.clearMotion();
      this._absParams.absMotion = null;
    }
    if (this.inAAnimMotion()) {
      this.getAAnimMotion().clear(this);
      this.battler().clearAAnimMotion();
    }
    if (this.isAnimX()) {
      this.switchToXAnimaState('dead');
    }
    this.battler().onAADeath();
    this._changeEventToDeadState();
    this.refresh();
    this._deactivate();
  };
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var _alias_Game_Event_updateSelfMovement;
  Game_AIBot.prototype.start = function() {
    if (this.inActive() && this !== AlphaABS.BattleManagerABS.getPlayerTarget()) {
      AlphaABS.BattleManagerABS.setPlayerTarget(this);
      this.LOG.p('Selected ' + this.event().name);
    }
    Game_Event.prototype.start.call(this);
  };
  Game_AIBot.prototype.erase = function() {
    Game_Event.prototype.erase.call(this);
    if (this.behaviorModel().reviveTime === 0 && !this.isAlive()) {
      // * Если нет возрождения и был убит, то очищаем навсегда
      // * Сохраняем Dead data ещё раз с флагом Erased == true
      this._storeDeadData();
    }
  };
  Game_AIBot.prototype.update = function() {
    var isMoving;
    isMoving = this.isMoving();
    Game_Event.prototype.update.call(this);
    if (!this.isMoving()) {
      this._updateNonmoving(isMoving);
    }
    this._updateABS();
    this._updateRevive();
    if (this.isAnimX()) {
      this._updateAnimX();
    }
  };
  Game_AIBot.prototype._checkActiveState = function() {
    var comment, e, i, item, list, match, regex;
    try {
      if (this.isErased()) {
        return;
      }
      list = this.list();
      i = 0;
      while (i < list.length) {
        item = list[i];
        comment = "";
        if (item.code === 108) {
          comment = item.parameters[0];
        }
        if (comment.indexOf('<noActive') >= 0) {
          regex = /<noActive\s?:\s?(.+?)>/;
          match = regex.exec(comment);
          if (match && KDCore.SDK.checkSwitch(match[1])) {
            this._absParams.activateSwitch = match[1];
            return false;
          }
        }
        i++;
      }
    } catch (error) {
      e = error;
      AlphaABS.error(e, ' while checking active state');
    }
    return true;
  };
  Game_AIBot.prototype._checkDieSwitch = function() {
    var key;
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    if ($gameSelfSwitches.value(key) === true) {
      this.behaviorModel().loadEventMetadata(this.eventId(), 0);
      this.behaviorModel().loadEventMetadata(this.eventId());
      if (this.behaviorModel().reviveTime === 0) {
        this._deactivate();
        this._restoreDeadData();
        if (this.isAnimX()) {
          this.switchToXAnimaState('dead');
        }
      } else {
        $gameSelfSwitches.setValue(key, false);
      }
    }
  };
  Game_AIBot.prototype._restoreDeadData = function() {
    var data, e;
    try {
      data = $gamePlayer.getABSMapData($gameMap.mapId(), this.eventId());
      if (data == null) {
        return;
      }
      "RESTORE DATA FOR".p(this.eventId());
      this.locate(data.x, data.y);
      this.battler().die();
      this.battler().onAADeath();
      this._absParams.looted = data.isLooted;
      if (data.isErased) {
        return this.erase();
      }
    } catch (error) {
      e = error;
      return console.error(e);
    }
  };
  Game_AIBot.prototype.list = function() {
    if (this._absParams.reservedCommonEvent != null) {
      //temp = @_absParams.reservedCommonEvent
      //@_absParams.reservedCommonEvent = null
      return this._absParams.reservedCommonEvent;
    } else {
      return Game_Event.prototype.list.call(this);
    }
  };
  _alias_Game_Event_updateSelfMovement = Game_Event.prototype.updateSelfMovement;
  Game_AIBot.prototype.updateSelfMovement = function() {
    if (this._moveType === 7) {
      if (this.inBattle()) {
        if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
          if (this.isCanPerformTeleportNow()) {
            this.performTeleportToTarget();
          }
          this.moveTypeTowardTarget();
          return;
        }
      }
    }
    _alias_Game_Event_updateSelfMovement.call(this, arguments);
  };
  Game_AIBot.prototype.isErased = function() {
    return this._erased === true;
  };
  Game_AIBot.prototype._changeEventToDeadState = function() {
    var key;
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    $gameSelfSwitches.setValue(key, true);
    this._originalDirection = -1;
    this._originalPattern = -1;
    return this._storeDeadData();
  };
  Game_AIBot.prototype._storeDeadData = function() {
    if (this.behaviorModel().reviveTime === 0) {
      "STORE ENEMY DATA".p(this.eventId());
      return $gamePlayer.setNewABSMapData({
        mapId: $gameMap.mapId(),
        enemyId: this.eventId(),
        x: this.x,
        y: this.y,
        isErased: this.isErased(),
        isLooted: this._absParams.looted
      });
    }
  };
})();

// Generated by CoffeeScript 2.5.1
(function() {
  Game_AIBot.prototype.refreshABSMotion = function() {
    this.aaRefreshAnimaX();
    if (this._absParams.absMotion != null) {
      this._absParams.absMotion.clearMotion();
      this._absParams.absMotion = null;
    }
    if (!this.battler().isAlive()) {
      return;
    }
    if (this.isDeadForMotion()) {
      return;
    }
    if (this.behaviorModel().motion > 0) {
      this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
      this._absParams.absMotion.setMotion("main", this.behaviorModel().motionOffset, this);
      this._absParams.absMotion.applyMotionIdle();
      return;
    }
    if (this.behaviorModel().motionX > 0) {
      this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
      this._absParams.absMotion.setType(AA.MotionType.Enemy);
      this._absParams.absMotion.setDelay(this.behaviorModel().motionDelay);
      this._absParams.absMotion.setFrames(this.behaviorModel().motionFrames);
      this._absParams.absMotion.setActionDelay(this.behaviorModel().motionADelay);
      if (this.behaviorModel().motionWait > 0) {
        this._absParams.absMotion.setWait();
      }
      this._absParams.absMotion.setMotion(null, this.behaviorModel().motionOffset, this);
      return this.refreshABSMotionState(this.inBattle());
    }
  };
  //* For Game_SpawnedAiBot
  Game_AIBot.prototype.isBotHasMotion = function() {
    return this.behaviorModel().motion > 0 || this.behaviorModel().motionX > 0;
  };
  Game_AIBot.prototype.isDeadForMotion = function() {
    var key;
    if (this.__isDeadForMotion != null) {
      return this.__isDeadForMotion;
    } else {
      key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
      this.__isDeadForMotion = $gameSelfSwitches.value(key) === true;
    }
    return this.__isDeadForMotion;
  };
  Game_AIBot.prototype.inABSMotion = function() {
    if (this.isAnimX()) {
      return false;
    }
    return this._absParams.absMotion != null;
  };
  Game_AIBot.prototype.inAAnimMotion = function() {
    if (this.isAnimX()) {
      return false;
    }
    if (this.battler() == null) {
      return false;
    }
    if (this.battler().isAAnimMotionRequested()) {
      //return false if !@battler().isAlive()
      return true;
    }
    return false;
  };
  Game_AIBot.prototype.getAAnimMotion = function() {
    if (this.inAAnimMotion()) {
      return this.battler().ABSParams().animMotion;
    }
    return null;
  };
  Game_AIBot.prototype.getABSMotion = function() {
    if (this.inABSMotion()) {
      return this._absParams.absMotion;
    }
    return null;
  };
  Game_AIBot.prototype._updateABSMotion = function() {
    var motion;
    if (this.battler().isNeedABSMotionAction() && this.battler().isAlive()) {
      this.battler().onABSMotionActionDone();
      motion = this.getABSMotion();
      if (motion == null) {
        return;
      }
      if (motion.isOldABSMotion()) {
        return motion.applyMotionAction();
      } else {
        if (this.battler().isAAnimMotionRequested()) {
          this.getAAnimMotion().clear(this);
        }
        return this.battler().performAAnimAction(motion);
      }
    }
  };
  Game_AIBot.prototype.refreshABSMotionState = function(toState) {
    if (!this.inABSMotion()) {
      return;
    }
    if (this.inAAnimMotion()) {
      return;
    }
    if (toState === true) {
      return this._absParams.absMotion.applyMotionState();
    } else {
      return this._absParams.absMotion.applyMotionIdle();
    }
  };
  Game_AIBot.prototype._performCastMotion = function() {
    var a, data;
    a = this.currentAction();
    if (a.isHasCastMotion()) {
      //"START CAST MOTION".p()
      this._absParams._inCastMotion = true;
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Cast);
      data.setFrames(a.castMotionFrames);
      data.setActionDelay(a.motionDelay);
      data.setLooping();
      data.setMotion(a.castMotion, a.castMotionOffset, this);
      return this.battler().performAAnimAction(data);
    } else {
      return this._absParams._inCastMotion = false;
    }
  };
  Game_AIBot.prototype._cancelCastMotion = function() {
    var motion;
    if (this._absParams._inCastMotion === false) {
      return;
    }
    //"CLEAR CAST MOTION".p()
    motion = this.getAAnimMotion();
    if (motion != null) {
      motion.clear(this);
    }
    this.battler().clearAAnimMotion();
    return this._absParams._inCastMotion = false;
  };
  Game_AIBot.prototype._performSkillMotion = function() {
    var a, data, name;
    if (this.battler().action(0).isAttack()) {
      return;
    }
    a = this.currentAction();
    if (this.isAnimX()) {
      name = "Skill";
      if (a.isHasAnimaXAction()) {
        name = a.animaXAction;
      }
      this.aaPerformBattleActionAnimation(name);
      return;
    }
    if (a.isHasMotionX()) {
      //"START SKILL MOTION".p()
      this._cancelCastMotion();
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Skill);
      data.setFrames(a.motionFrames);
      data.setActionDelay(a.motionADelay);
      data.setMotion(a.motionX, a.motionOffset, this);
      return this.battler().performAAnimAction(data);
    }
  };
})();

// Generated by CoffeeScript 2.5.1
(function() {
  Game_AIBot.prototype._storeMoveData = function() {
    this._absParams.moveData = {};
    this._absParams.moveData.moveSpeed = this._moveSpeed;
    this._absParams.moveData.moveType = this._moveType;
    this._absParams.moveData.moveFrequency = this._moveFrequency;
  };
  Game_AIBot.prototype._resetMoveData = function() {
    this._moveSpeed = this._absParams.moveData.moveSpeed;
    this.stay();
  };
  Game_AIBot.prototype.stay = function() {
    this._moveType = 0;
    try {
      return this._moveFrequency = this._absParams.moveData.moveFrequency;
    } catch (error) {

    }
  };
  Game_AIBot.prototype.returnSlow = function() {
    if (!this.isMoving()) {
      return this._performReturnToHome();
    }
  };
  Game_AIBot.prototype._performReturnToHome = function() {
    var direction, home;
    home = this.getHomePosition();
    direction = this.findDirectionTo(home.x, home.y);
    if (direction > 0) {
      this.moveStraight(direction);
    } else {
      this.LOG.p('AI : I\'am return to Home!');
      this._absParams.myHomePosition = null;
      this.onReturnEnd();
      this._restoreMoveData();
    }
  };
  Game_AIBot.prototype._restoreMoveData = function() {
    this._moveSpeed = this._absParams.moveData.moveSpeed;
    this._moveType = this._absParams.moveData.moveType;
    this._moveFrequency = this._absParams.moveData.moveFrequency;
  };
  Game_AIBot.prototype.returnFast = function() {
    return this._performReturnToHome();
  };
  Game_AIBot.prototype._applyAproachSpeed = function() {
    if (this.behaviorModel().slow <= 0) {
      this._moveFrequency = this._absParams.moveData.moveFrequency + 2;
    }
  };
  Game_AIBot.prototype._updateNonmoving = function(wasMoving) {
    if (!$gameMap.isEventRunning()) {
      if (wasMoving && !this.isMoveRouteForcing()) {
        this.battler().onWalk();
      }
    }
  };
  Game_AIBot.prototype.startPursuitTarget = function() {
    if (this.isCanPerformTeleportNow()) {
      this.performTeleportToTarget();
      this.performApproachToTarget();
    } else {
      this.performApproachToTarget();
    }
  };
  Game_AIBot.prototype.performApproachToTarget = function() {
    //"START PURSUIT".LOG()
    this._applyAproachSpeed();
    this._moveType = 7;
    this.__lastMovingActionDelay = 0;
  };
  Game_AIBot.prototype.moveTypeTowardTarget = function() {
    var target;
    if (this.isRequireActionDelay()) {
      target = this.target();
      if (target != null) {
        if (!this.isNearThePointX(target)) {
          this.moveToPointAA(target);
        } else {
          this.turnTowardCharacter(target);
        }
      }
      this.__lastMovingActionDelay = 0;
    }
    this.__lastMovingActionDelay++;
  };
  Game_AIBot.prototype.isRequireActionDelay = function() {
    if ($gamePlayer.aaIsSurrounded()) {
      return this.__lastMovingActionDelay >= 60;
    } else {
      return true; // * no wait
    }
  };
  Game_AIBot.prototype.moveToAlly = function() {
    if (!this.isMoving() && !this._absParams.behavior.noMove) {
      if (this._absParams.allyToSearch != null) {
        return this.moveToPointAA(this._absParams.allyToSearch);
      } else {
        return this.changeStateToFree();
      }
    }
  };
  Game_AIBot.prototype.turnTowardCharacter = function(character) {
    try {
      return Game_Character.prototype.turnTowardCharacter.call(this, character);
    } catch (error) {

    }
  };
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AILogicManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AILogicManager;
  AILogicManager = function() {
    throw new Error("This is a static class");
  };
  AILogicManager.getTargetsInRange = function(bot) {
    var all, enemy;
    try {
      if (!AlphaABS.isABS()) {
        return null;
      }
      all = AILogicManager.getAllInRange(bot);
      if (all.length > 0) {
        return ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = all.length; i < len; i++) {
            enemy = all[i];
            if (!enemy.isAlly(bot)) {
              results.push(enemy);
            }
          }
          return results;
        })()).first();
      } else {
        return null;
      }
    } catch (error) {
      return null;
    }
  };
  AILogicManager.getAllInRange = function(bot) {
    var all;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      all = $gameTroop.membersABS();
      if (!bot.isSummonUnit()) {
        all = all.concat([$gamePlayer]);
        all = all.concat($gameParty.membersABS());
      }
      return AILogicManager.getFilterInRange(bot, all);
    } catch (error) {
      return [];
    }
  };
  AILogicManager.getFilterInRange = function(bot, all) {
    var bm, e, inRange;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      bm = bot.behaviorModel();
      if (bm.tVisor > 0 && AA.isPro()) {
        inRange = [];
        if (bm.sideVisor > 0) {
          inRange = AlphaABS.UTILS.inFrontAndSides(bot, all);
        }
        inRange = inRange.concat(AlphaABS.UTILS.inTVisor(bot, bm.viewRadius, bm.tVisor, all));
      } else {
        inRange = AlphaABS.UTILS.inRadius(bot, bm.viewRadius, all);
      }
      if (inRange != null) {
        inRange = inRange.filter(function(item) {
          return AlphaABS.BattleManagerABS.isValidTarget(item);
        });
        if (!bm.ignoreObstacles) {
          return inRange.filter(function(item) {
            return AlphaABS.BattleManagerABS.checkLineOfSight(bot.toPoint(), item.toPoint());
          });
        } else {
          return inRange;
        }
      } else {
        return [];
      }
    } catch (error) {
      e = error;
      AA.warning(e);
      return [];
    }
  };
  // * scopeType
  // * 0 - player, 1 - enemies, 2 - all
  AILogicManager.getAllInRangeByScope = function(bot, scopeType) {
    var all;
    if (scopeType === 2) {
      return AILogicManager.getAllInRange(bot);
    } else if (scopeType === 1) {
      all = $gameTroop.membersABS();
      // * Remove summon unit
      if ($gameParty.leader()._mySummonUnit != null) {
        all.delete($gameParty.leader()._mySummonUnit);
      }
      return AILogicManager.getFilterInRange(bot, all);
    } else if (scopeType === 0) {
      all = [$gamePlayer];
      all = all.concat($gameParty.membersABS());
      // * Add summon unit
      if ($gameParty.leader()._mySummonUnit != null) {
        all.push($gameParty.leader()._mySummonUnit);
      }
      return AILogicManager.getFilterInRange(bot, all);
    } else {
      return [];
    }
  };
  AILogicManager.inSkillRadius = function(bot, skillRadius) {
    var inRange, targets;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      targets = AILogicManager.getAllInRange(bot);
      targets = targets.filter(function(item) {
        return !item.isAlly(bot);
      });
      inRange = AlphaABS.UTILS.inRadius(bot, skillRadius, targets);
      inRange = inRange.filter(function(item) {
        return AlphaABS.BattleManagerABS.isValidTarget(item);
      });
      if (!bot.behaviorModel().ignoreObstacles) {
        return inRange.filter(function(item) {
          return AlphaABS.BattleManagerABS.checkLineOfSight(bot.toPoint(), item.toPoint());
        });
      } else {
        return inRange;
      }
    } catch (error) {
      return [];
    }
  };
  AILogicManager.getAllDeadBotsInRange = function(bot) {
    var all, inRange;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      all = $gameTroop.deadMembersABS();
      inRange = AlphaABS.UTILS.inRadius(bot, bot.behaviorModel().viewRadius, all);
      if (!bot.behaviorModel().ignoreObstacles) {
        return inRange.filter(function(item) {
          return AlphaABS.BattleManagerABS.checkLineOfSight(bot.toPoint(), item.toPoint());
        });
      } else {
        return inRange;
      }
    } catch (error) {
      return [];
    }
  };
  AILogicManager.getAlliesInRange = function(bot) {
    var all, ally;
    try {
      if (!AlphaABS.isABS()) {
        return null;
      }
      all = AILogicManager.getAllInRange(bot);
      if (all.length > 0) {
        return ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = all.length; i < len; i++) {
            ally = all[i];
            if (ally.isAlly(bot) && ally.inBattle()) {
              results.push(ally);
            }
          }
          return results;
        })()).first();
      } else {
        return null;
      }
    } catch (error) {
      return null;
    }
  };
  AILogicManager.getAnyPointNearTarget = function(bot) {
    var e, result;
    result = [];
    try {
      if (bot.target() != null) {
        result = AILogicManager.getSquarePoints(bot.target().toPoint());
      }
      return result;
    } catch (error) {
      e = error;
      console.warn(e);
      return [];
    }
  };
  AILogicManager.getSquarePoints = function(centerPoint) {
    var e, isValidPoint, p, result;
    isValidPoint = function(p) {
      return p.x >= 0 && p.y >= 0 && p.x < $gameMap.width() && p.y < $gameMap.height();
    };
    result = [];
    try {
      p = [centerPoint.x - 1, centerPoint.y - 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x, centerPoint.y - 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x + 1, centerPoint.y - 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x - 1, centerPoint.y].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x + 1, centerPoint.y].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x - 1, centerPoint.y + 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x, centerPoint.y + 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
      p = [centerPoint.x + 1, centerPoint.y + 1].toPoint();
      if (isValidPoint(p)) {
        result.push(p);
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
    return result;
  };
  AILogicManager.targetInVisibleRange = function(bot) {
    var target;
    target = bot != null ? bot.target() : void 0;
    return AILogicManager.checkDistanceTo(bot, target);
  };
  AILogicManager.checkDistanceTo = function(bot, target) {
    var distance, view;
    if (!(target != null ? target.inActive() : void 0)) {
      return false;
    }
    view = bot.behaviorModel().viewRadius;
    distance = AlphaABS.UTILS.distanceTo(bot, target);
    return distance < view;
  };
  AILogicManager.inOutReturnRange = function(bot) {
    var distance, home, returnDistance;
    home = bot != null ? bot.getHomePosition() : void 0;
    if (home == null) {
      return false;
    }
    returnDistance = bot.behaviorModel().returnRadius;
    distance = AlphaABS.UTILS.distanceTo(bot, home);
    return distance > returnDistance;
  };
  AILogicManager.isAwayFromPlayer = function(bot) {
    var distance, returnDistance;
    returnDistance = bot.behaviorModel().returnRadius;
    distance = AlphaABS.UTILS.distanceTo(bot, $gamePlayer);
    return distance > returnDistance;
  };
  AILogicManager.isTargetAwayFromPlayer = function(bot, target) {
    var distance, e, returnDistance;
    try {
      returnDistance = bot.behaviorModel().returnRadius;
      distance = AlphaABS.UTILS.distanceTo(target, $gamePlayer);
      return distance > returnDistance;
    } catch (error) {
      e = error;
      AA.warning('AILogicManager.isTargetAwayFromPlayer', e);
      return false;
    }
  };
  AILogicManager.canUseActionNow = function(bot) {
    var action;
    action = bot != null ? bot.currentAction() : void 0;
    if (action != null) {
      return AlphaABS.BattleManagerABS.canUseSkilllBySpecialState(bot, action) && AlphaABS.BattleManagerABS.canUseSkillByTimer(action);
    } else {
      return false;
    }
  };
  AILogicManager.inActionRange = function(bot) {
    var action, target;
    action = bot != null ? bot.currentAction() : void 0;
    if (action != null) {
      target = bot.target();
      if (target != null) {
        return AlphaABS.BattleManagerABS.canUseSkillByRange(bot, target, action);
      }
    }
    return false;
  };
  AILogicManager.getDistanceToNearestFrom = function(aaEntity, targets) {
    var char, dist, e, i, len, maxDist, t;
    try {
      if (targets.length === 0) {
        return 100;
      }
      char = aaEntity.character();
      if (targets.length === 1) {
        return AlphaABS.UTILS.distanceTo(char, targets[0]);
      } else {
        maxDist = 1000;
        for (i = 0, len = targets.length; i < len; i++) {
          t = targets[i];
          dist = AlphaABS.UTILS.distanceTo(char, t);
          if (dist < maxDist) {
            maxDist = dist;
          }
        }
        return maxDist;
      }
    } catch (error) {
      e = error;
      AA.waring(e);
      return 100;
    }
  };
  AILogicManager.isAllyInActionRange = function(aaEntity) {
    var action, char, target;
    action = aaEntity != null ? aaEntity.currentAction() : void 0;
    if (action != null) {
      target = aaEntity.getTarget();
      char = aaEntity.character();
      if (target === char) {
        return true;
      }
      if (target != null) {
        return AA.BattleManagerABS.canUseSkillByRange(char, target, action);
      }
    }
    return false;
  };
  AILogicManager.isUsableABSSkill = function(absSkill, isEnemy) {
    if (isEnemy === true) {
      return AILogicManager.isUsableABSSkillForEnemy(absSkill);
    }
    return AILogicManager.isUsableABSSkillForAlly(absSkill);
  };
  AILogicManager.isUsableABSSkillForEnemy = function(absSkill) {
    if (absSkill.isRadiusTypeR()) {
      return false;
    }
    if (absSkill.isSpecialTeleportType()) {
      return false;
    }
    if (absSkill.isNeedAmmo()) {
      return false;
    }
    if (absSkill.isVectorTypeR()) {
      return false;
    }
    if (absSkill.isFirearm()) {
      return false;
    }
    return true;
  };
  AILogicManager.isUsableABSSkillForAlly = function(absSkill) {
    if (absSkill.isRadiusTypeR()) {
      return false;
    }
    if (absSkill.isSpecialTeleportType()) {
      return false;
    }
    if (absSkill.isVectorTypeR()) {
      return false;
    }
    if (absSkill.isFirearm()) {
      //TODO: firearms
      return false;
    }
    return true;
  };
  AlphaABS.register(AILogicManager);
  AlphaABS.LIBS.AILogicManager = AILogicManager;
  AlphaABS.AILogicManager = AILogicManager;
})();

// ■ END AILogicManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBase;
  AIStateBase = class AIStateBase {
    constructor() {
      this._bot = null;
      this._log = null;
      this._init();
    }

    _init() {} //EMPTY

    update(bot) {
      if (!this._setup(bot)) {
        return;
      }
      this._updateMainLogic();
      return this._bot = null;
    }

    _setup(bot) {
      if (bot == null) {
        return false;
      }
      this._bot = bot;
      return this._setupMain();
    }

    _updateMainLogic() {} //EMPTY

    _setupMain() {
      return true;
    }

    onStateStarted() {} //EMPTY

    log(text) {
      try {
        if (typeof DEV === "undefined" || DEV === null) {
          return;
        }
        if (this._log === null) {
          this._createLog();
        }
        if (this._bot != null) {
          return this._log.p(`${this._bot.aiName} : ${text}`);
        }
      } catch (error) {

      }
    }

    _createLog() {
      try {
        this._log = new KDCore.DevLog(this.constructor.name);
        return this._log.setColor(KDCore.Color.FromHex('#00BD43'));
      } catch (error) {

      }
    }

  };
  AlphaABS.register(AIStateBase);
})();

// ■ END AIStateBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattle;
  AIStateBattle = class AIStateBattle extends AlphaABS.LIBS.AIStateBase {
    _init() {
      this._newActionState = null;
      this._actionState = null;
      return this._failCount = 0;
    }

    _setupMain() {
      this.isStayStill = this._bot.behaviorModel().noMove;
      return true;
    }

    _updateMainLogic() {
      if (!this._checkTarget() || this._checkNoMoveMode()) {
        this._bot.changeStateToFree();
      } else {
        this._bot._makeActions();
        this._updateBattleStates();
      }
    }

    _checkTarget() {
      return AA.BattleManagerABS.isValidTarget(this._bot.target());
    }

    _checkNoMoveMode() {
      if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
        if (this.isStayStill) {
          true;
        }
      }
      return false;
    }

    _updateBattleStates() {
      if (this._newActionState != null) {
        this._applyActionState();
      }
      switch (this._actionState) {
        case "approach":
          this._updateApproachState();
          break;
        case "prepareAction":
          this._updatePrepareActionState();
          break;
        case "action":
          this._updateBattleActionState();
          break;
        case "cast":
          this._updateCastState();
          break;
        case "escape":
          this._updateEscapeState();
          break;
        case "wait":
          this._updateWaitState();
      }
    }

    _applyActionState() {
      this._actionState = this._newActionState;
      switch (this._actionState) {
        case "approach":
          this._applyApproachState();
          break;
        case "cast":
          this._applyCastState();
          break;
        case "action":
          this._applyBattleActionState();
          break;
        case "escape":
          this._applyEscapeState();
          break;
        case "wait":
          this._applyWaitState();
      }
      //when "prepareAction" then #EMPTY
      return this._newActionState = null;
    }

    _applyApproachState() {
      this.log("Apply Approach State");
      if (this.isStayStill) {
        return this._stayAndTurn();
      } else {
        return this._bot.startPursuitTarget();
      }
    }

    _stayAndTurn() {
      this._bot.stay();
      return this._bot.turnTowardTarget();
    }

    _applyCastState() {
      this._bot._performCastMotion();
      return this._stayAndTurn();
    }

    _applyBattleActionState() {
      this._stayAndTurn();
      return this._bot.createNewHomePoint();
    }

    _applyEscapeState() {
      this._bot.stay();
      return this._bot._applyAproachSpeed();
    }

    _applyWaitState() {
      return this._bot.stay();
    }

    _updateApproachState() {
      this._updateSupportAction();
      if (this.isStayStill) {
        this._stayAndTurn();
        if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
          return this._bot.changeStateToReturn();
        }
      } else {
        if (AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
          return this._bot.changeStateToReturn();
        }
      }
    }

    _updatePrepareActionState() {
      this._bot.checkActionCommonEvent();
      if (AlphaABS.LIBS.AILogicManager.canUseActionNow(this._bot)) {
        return this._prepareActionForNow();
      }
    }

    _prepareActionForNow() {
      if (AlphaABS.LIBS.AILogicManager.inActionRange(this._bot)) {
        return this.changeActionStateTo("action");
      } else {
        return this._whenActionOutOfTargetRange();
      }
    }

    _whenActionOutOfTargetRange() {
      this.log("Target away to action, try approach");
      if (this.isStayStill) {
        return this._whenCantApproachTarget();
      } else {
        return this._whenNeedApproachTarget();
      }
    }

    _whenCantApproachTarget() {
      this.log("Can't approach, (noMove == true)");
      this._failCount += 1;
      if (this._failCount > 10) {
        this._bot.changeStateToFree();
        this._failCount = 0;
        return;
      }
      return this._bot.turnTowardTarget();
    }

    _whenNeedApproachTarget() {
      var action;
      action = this._bot.currentAction();
      if ((action != null) && action.isCasting()) {
        action.resetCast();
        this._bot._cancelCastMotion();
      }
      return this.changeActionStateTo("approach");
    }

    changeActionStateTo(newActionState) {
      return this._newActionState = newActionState;
    }

    _updateBattleActionState() {
      var action;
      this.log("Try Perform Action");
      if (AA.LIBS.AILogicManager.inActionRange(this._bot)) {
        action = this._bot.currentAction();
        if (action != null ? action.isNeedCast() : void 0) {
          return this._updateOnCastingAction(action);
        } else {
          return this._bot._performAction();
        }
      } else {
        return this._prepareActionForNow();
      }
    }

    _updateOnCastingAction(action) {
      if (action.isCasting() && action.isReady()) {
        return this._bot._performAction();
      } else {
        this.log("Start casting");
        action.startCast(this._bot.battler());
        return this.changeActionStateTo("cast");
      }
    }

    _updateCastState() {
      var action;
      this._bot.turnTowardTarget();
      action = this._bot.currentAction();
      if ((action != null) && action.isCasting()) {
        if (this._bot.battler().isNeedAACastStop()) {
          action.resetCast();
          this._onCastingComplete();
          return;
        }
        if (AlphaABS.LIBS.AILogicManager.inActionRange(this._bot)) {
          if (action.isReady()) {
            this._bot._cancelCastMotion();
            return this.changeActionStateTo("action");
          }
        } else {
          this.log("Casting intterupt, target too far");
          action.resetCast();
          return this._onCastingComplete();
        }
      } else {
        return this._onCastingComplete();
      }
    }

    //TODO: Тут есть проблема
    _onCastingComplete() {
      this._bot.battler().onAACastStop();
      this._bot._cancelCastMotion();
      return this.changeActionStateTo("prepareAction");
    }

    _updateEscapeState() {
      this._updateSupportAction();
      this._bot._escapeFromTarget(this._bot.target());
      if (this._bot.currentAction() != null) {
        this.changeActionStateTo("prepareAction");
      }
      if (AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
        return this._bot.changeStateToReturn();
      }
    }

    _updateWaitState() {
      var isAgressive;
      this._updateSupportAction();
      isAgressive = this._bot.behaviorModel().agressive;
      if (isAgressive) {
        return this.changeActionStateTo("approach");
      } else {
        this._stayAndTurn();
        if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
          return this._bot.changeStateToFree();
        }
      }
    }

    onStateStarted() {
      return this.changeActionStateTo("approach");
    }

  };
  AlphaABS.register(AIStateBattle);
})();

// ■ END AIStateBattle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStteBattleAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattleAlly;
  AIStateBattleAlly = class AIStateBattleAlly extends AA.LIBS.AIStateBattle {
    _setupMain() {
      var error;
      try {
        this.model = this._bot.behaviorModel();
        this.battler = this._bot.battler();
        this.char = this._bot.character();
        return true;
      } catch (error1) {
        error = error1;
        console.error(error);
        return false;
      }
    }

    _updateMainLogic() {
      if (this._checkTarget()) {
        this._bot.setMoveActionIndex(3);
        this._bot.makeBattleActions();
        return this._updateBattleStates();
      } else {
        return this._bot.changeStateToFree();
      }
    }

    _checkTarget() {
      var t;
      t = this._bot.getTarget();
      if (t === this.char) {
        return this._bot.isHaveAnySupportAllySkill() && AA.BattleManagerABS.isValidTarget(t);
      } else {
        return AA.BattleManagerABS.isValidTarget(t);
      }
    }

    _prepareActionForNow() {
      if (AA.AILogicManager.isAllyInActionRange(this._bot)) {
        return this.changeActionStateTo("action");
      } else {
        return this._whenActionOutOfTargetRange();
      }
    }

    _whenActionOutOfTargetRange() {
      this.log("Target away to action, try approach");
      //TODO: only dist attacks? #TODO: long range attacks?
      return this._whenNeedApproachTarget();
    }

    _applyWaitState() {
      return this.log("Apply Wait State");
    }

    _applyCastState() {
      this.char._performCastMotion();
      return this._stayAndTurn();
    }

    _applyEscapeState() {
      return this.log("Apply Escape State");
    }

    _applyApproachState() {
      this.log("Apply Approach State");
      //TODO: move speed???
      this._checkCollisionWithTarget();
      return this.char.setMoveFlagToChaseTarget();
    }

    _applyBattleActionState() {
      this.log("Apply Battle Action State");
      return this._stayAndTurn();
    }

    _updateBattleActionState() {
      var action;
      this.log("Try Perform Action");
      if (AA.AILogicManager.isAllyInActionRange(this._bot)) {
        action = this._bot.currentAction();
        if (action.isNeedCast()) {
          return this._updateOnCastingAction(action);
        } else {
          return this._bot.performBattleAction();
        }
      } else {
        return this._prepareActionForNow();
      }
    }

    _updateOnCastingAction(action) {
      if (action.isCasting() && action.isReady()) {
        return this._bot.performBattleAction();
      } else {
        this.log("Start casting");
        action.startCast(this.battler);
        return this.changeActionStateTo("cast");
      }
    }

    _updateCastState() {
      var action;
      this._stayAndTurn();
      action = this._bot.currentAction();
      if ((action != null) && action.isCasting()) {
        if (this._bot.battler().isNeedAACastStop()) {
          action.resetCast();
          this._onCastingComplete();
          return;
        }
        if (AlphaABS.LIBS.AILogicManager.isAllyInActionRange(this._bot)) {
          if (action.isReady()) {
            this.char._cancelCastMotion();
            return this.changeActionStateTo("action");
          }
        } else {
          this.log("Casting intterupt, target too far");
          action.resetCast();
          return this._onCastingComplete();
        }
      } else {
        return this._onCastingComplete();
      }
    }

    _updateEscapeState() {
      if (this._bot.currentAction() != null) {
        //TODO: Escape from target
        //@_bot._escapeFromTarget @_bot.target()
        return this.changeActionStateTo("prepareAction");
      }
    }

    _stayAndTurn() {
      this.char.resetMoveFlags();
      return this.char.turnTowardTarget();
    }

    _updateApproachState() {
      return this._checkAllRanges();
    }

    _updateWaitState() { // * NOTHING?
      this._checkCollisions(); // * Надо или нет?
      return this._checkAllRanges();
    }

    _checkAllRanges() {
      this._checkRangeToTarget();
      return this._checkRangeToPlayer();
    }

    _checkCollisions() {
      this.char.checkCollisionWithPlayer();
      this.char.checkCollisionWithParty();
      return this._checkCollisionWithTarget();
    }

    _checkCollisionWithTarget() {
      var t;
      t = this._bot.getTarget();
      if (t != null) {
        return this.char.checkCollisionWith(t);
      }
    }

    _checkRangeToTarget() {
      if (!AA.LIBS.AILogicManager.targetInVisibleRange(this.char)) {
        return this._bot.changeStateToFree();
      }
    }

    _checkRangeToPlayer() {
      if (AA.LIBS.AILogicManager.isAwayFromPlayer(this.char)) {
        return this._bot.changeStateToFree();
      }
    }

    onStateStarted() {
      return this.changeActionStateTo("wait");
    }

  };
  AA.register(AIStateBattleAlly);
})();

// ■ END AIStteBattleAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattlePet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattlePet;
  AIStateBattlePet = class AIStateBattlePet extends AlphaABS.LIBS.AIStateBattle {
    onStateStarted() {
      return AlphaABS.LIBS.AIStateBattle.prototype.onStateStarted.call(this);
    }

    refreshBevMode() {} //*EMPTY

    _updateSupportAction() {} //*EMPTY

  };
  AlphaABS.register(AIStateBattlePet);
})();

// ■ END AIStateBattlePet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFree.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFree;
  AIStateFree = class AIStateFree extends AlphaABS.LIBS.AIStateBase {
    _init() {
      return this._regenTimer = null;
    }

    _setupMain() {
      var error, model;
      try {
        model = this._bot.behaviorModel();
        this.canSearchAlly = model.canSearch;
        this.canRegenerateInFreeMode = model.regen;
        this.canEscapeInBattle = model.escapeOnBattle;
        this.isNoFightIfLvlRange = model.noFightIfLvlBelow;
        this.isRunAwayIfLvlRange = model.runAwayIfLvlBelow;
        this.isCEIfLvlRange = model.cEvIfLvlNotSame > 0;
        this.active = this._bot.inActive();
        this.battler = this._bot.battler();
        return true;
      } catch (error1) {
        error = error1;
        console.error(error);
        return false;
      }
    }

    _updateMainLogic() {
      if (this._bot.canFight()) {
        return this._updateWithFightLogic();
      } else {
        return this._updateNoFightLogic();
      }
    }

    _updateWithFightLogic() {
      this._updateReturnToHome();
      this._regenerate();
      this._updateVision();
    }

    _updateReturnToHome() {
      if ((this._bot.getHomePosition() != null) && this.active) {
        return this._returnToHome();
      }
    }

    _returnToHome() {
      return this._bot.returnSlow();
    }

    _regenerate() {
      if (this.canRegenerateInFreeMode) {
        if (this._regenTimer == null) {
          this._createRegenTimer();
        }
        if (this._updateAndCheckRegenTimer()) {
          return this.battler.regenerateAllonFree();
        }
      }
    }

    _createRegenTimer() {
      this._regenTimer = new Game_TimerABS();
      return this._regenTimer.start(180);
    }

    _updateAndCheckRegenTimer() {
      this._regenTimer.update();
      if (this._regenTimer.isReady()) {
        this._regenTimer.reset();
        return true;
      } else {
        return false;
      }
    }

    _updateVision() {
      var target;
      target = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateVisionForAlly();
      }
    }

    _onSeeTarget(target) {
      var e, value;
      try {
        if (this.isCEIfLvlRange === true) {
          if (target.level() > this._bot.level()) {
            this._bot._callCEWhenTargetLevelIsHigh();
          }
        }
        if (this.isRunAwayIfLvlRange > 0) {
          value = this.isNoFightIfLvlRange + this._bot.level();
          if (target.level() > value) {
            // * RUN AWAY
            //TODO: new state, чтобы убегал прям
            this._bot.runAwayFromTarget(target);
            return;
          }
        }
        if (this.isNoFightIfLvlRange > 0) {
          value = this.isNoFightIfLvlRange + this._bot.level();
          if (target.level() >= value) {
            return;
          }
        }
      } catch (error1) {
        // * NOTHING
        e = error1;
        AA.warning('error', e);
      }
      return this._bot.changeStateToBattle(target);
    }

    _updateVisionForAlly() {
      var ally;
      if (this.canSearchAlly) {
        ally = AlphaABS.AILogicManager.getAlliesInRange(this._bot);
        if (ally != null) {
          return this._onSeeAlly(ally);
        }
      }
    }

    _onSeeAlly(ally) {
      return this._bot.changeStateToSearch(ally);
    }

    _updateNoFightLogic() {
      var target;
      target = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTargetInNoFightMode(target);
      } else {
        return this._regenerate();
      }
    }

    _onSeeTargetInNoFightMode(target) {
      if (this.canEscapeInBattle) {
        return this._bot.runAwayFromTarget(target);
      }
    }

    onStateStarted() {
      var ref;
      return (ref = this._regenTimer) != null ? ref.reset() : void 0;
    }

  };
  AlphaABS.register(AIStateFree);
})();

// ■ END AIStateFree.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFreeAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFreeAlly;
  AIStateFreeAlly = class AIStateFreeAlly extends AA.LIBS.AIStateFree {
    constructor() {
      super();
    }

    onStateStarted() {
      this.lastTarget = null;
      this.lastAlly = null;
      return this._resetLooting();
    }

    _resetLooting() {
      var ref;
      //AA.BattleUI.setSummonMoveMode 0
      if ((ref = this._bot) != null) {
        ref.setMoveActionIndex(0);
      }
      return this._targetToLooting = null;
    }

    _setupMain() {
      var error;
      try {
        this.model = this._bot.behaviorModel();
        this.canSearchAlly = this.model.canSearchAlly > 0;
        //@canRegenerateInFreeMode = model.regen * TO DELETE
        //@canEscapeInBattle = model.escapeOnBattle * TO DELETE in free
        //@isNoFightIfLvlRange = model.noFightIfLvlBelow
        //@isRunAwayIfLvlRange = model.runAwayIfLvlBelow
        //@isCEIfLvlRange = model.cEvIfLvlNotSame > 0
        this.char = this._bot.character();
        this.isHaveAnySupport = this._bot.isHaveAnySupportAllySkill();
        return true;
      } catch (error1) {
        error = error1;
        console.error(error);
        return false;
      }
    }

    _updateMainLogic() {
      this._checkTargetsToValid();
      this._updateLooting();
      this._updateBehavior();
      this._updateMoving();
      if (this.isHaveAnySupport === true) {
        return this._updateSelfSupport();
      }
    }

    _updateMoving() {
      if (this._targetToLooting == null) {
        this._bot.setMoveActionIndex(0);
        this.char.checkCollisionWithPlayer();
        this.char.checkCollisionWithParty(); //TODO: Вынести в отдельный параметр?
        return this._chaseThePlayer();
      } else {
        return this._updateMoveToLoot();
      }
    }

    _updateMoveToLoot() {
      var e;
      if (this._targetToLooting == null) {
        return;
      }
      try {
        if (!this.char.isNearThePointX(this._targetToLooting)) {
          return this.char.moveToPointAA(this._targetToLooting);
        } else {
          this.char.moveToPointAA(this._targetToLooting); // * Встать на него
          this._targetToLooting.loot();
          return this._resetLooting();
        }
      } catch (error1) {
        e = error1;
        console.err(e);
        return this._resetLooting();
      }
    }

    _chaseThePlayer() {
      return this.char.setMoveFlagToChasePlayer();
    }

    _checkTargetsToValid() {
      if (this.lastTarget != null) {
        if (!AA.BattleManagerABS.isValidTarget(this.lastTarget)) {
          this.lastTarget = null;
        }
      }
      if (this.lastAlly != null) {
        if (!this.lastAlly.inBattle()) {
          this.lastAlly = null;
        }
      }
      return this._checkTargetForLooting();
    }

    _checkTargetForLooting() {
      if (this._targetToLooting == null) {
        return;
      }
      if ($gamePlayer.inBattle()) {
        this._targetToLooting = null;
      } else {
        if (!this._targetToLooting.isCanBeLooted()) {
          this._targetToLooting = null;
        }
        // * Если игрок далеко, то идти за ним
        if (AA.LIBS.AILogicManager.isAwayFromPlayer(this.char)) {
          //"PLAYER TO FAR for Loot".p()
          this._targetToLooting = null;
        }
      }
      if (this._targetToLooting == null) {
        return this._resetLooting();
      }
    }

    _updateLooting() {
      if ((this.lastTarget != null) || (this.lastAlly != null)) {
        return;
      }
      if ($gamePlayer.inBattle()) {
        return;
      }
      if (!this.model.canLooting) {
        return;
      }
      return this._searchForLoot();
    }

    _searchForLoot() {
      var corpses, i, item, len;
      corpses = AA.AILogicManager.getAllDeadBotsInRange(this.char);
      corpses = corpses.filter(function(item) {
        return item.isCanBeLooted();
      });
      if (corpses.length > 0) {
        for (i = 0, len = corpses.length; i < len; i++) {
          item = corpses[i];
          if (item.isHasAnyLoot()) {
            this._targetToLooting = item;
            this._bot.setMoveActionIndex(1);
            return;
          } else {
            item.loot(); // * Чтобы не появлялся в поиске
          }
        }
      }
    }

    _updateBehavior() {
      switch (this._bot.behaviorMode()) {
        case 0: // * Attack All
          return this._updateBehavior_AttackAll();
        case 1: // * Attack Player Target
          return this._updateBehavior_Assistant();
        case 2: // * Protect Player
          return this._updateBehavior_Protect();
        case 3: // * Support
          return this._updateBehavior_Support();
        default:
          break;
      }
    }

    _updateBehavior_AttackAll() {
      if (this.lastTarget == null) {
        this._updateVision();
      }
      if (this.lastTarget != null) {
        // * Если агрессивный, то атакую цель сразу
        if (this.model.agressive > 0) {
          // * Цель не должна быть очень далеко от игрока
          if (!AA.LIBS.AILogicManager.isTargetAwayFromPlayer(this.char, this.lastTarget)) {
            return this._onSeeTarget(); // * Первым бой не начнёт
          }
        } else {
          if ($gamePlayer.inBattle()) {
            // * Если цель очень далеко, но игрок в бою, то пытаемся атаковать цель игрока
            if (AA.LIBS.AILogicManager.isTargetAwayFromPlayer(this.char, this.lastTarget)) {
              this._changeToPlayerTarget();
              return this._onSeeTarget();
            } else {
              return this._onSeeTarget(); // * Возможно кто-то другой в бою
            }
          } else {
            return this._searchForAllyInBattle();
          }
        }
      } else {
        return this._searchForAllyInBattle();
      }
    }

    _updateBehavior_Assistant() {
      var attackers, ref;
      this._changeToPlayerTarget();
      if (this.lastTarget != null) {
        if (this.model.agressive > 0) { // * Если бот агрессивный, то атакует цель игрока, даже без игрока
          if (AA.LIBS.AILogicManager.isTargetAwayFromPlayer(this.char, this.lastTarget)) {
            this.lastTarget = null;
          }
        } else {
          if ($gamePlayer.inBattle()) {
            if (!((ref = this.lastTarget) != null ? ref.isPlayerAttackedMe() : void 0)) {
              // * Атакует того, кого атакует игрок
              this.lastTarget = null;
            }
          } else {
            this.lastTarget = null; // * Если меня кто-то атакует, то в бой
          }
        }
      } else {
        attackers = $gameTroop.membersABSWhoTargetingFor(this.char);
        if (attackers.length > 0) {
          this.lastTarget = attackers.sample();
        }
      }
      if (this.lastTarget != null) {
        return this._onSeeTarget();
      }
    }

    //TODO: В бою, переключаться на цель, которую игрок не атакует (вторую)
    _updateBehavior_Protect() {
      var attackers, subject;
      subject = this.char;
      if ($gamePlayer.inBattle()) {
        subject = $gamePlayer;
      }
      attackers = $gameTroop.membersABSWhoTargetingFor(subject);
      if (attackers.length > 0) {
        this.lastTarget = attackers.sample();
      }
      this._onSeeTarget();
    }

    _updateBehavior_Support() {
      if (!this.isHaveAnySupport) {

      }
    }

    //TODO: тут лечение других и себя
    _changeToPlayerTarget() {
      var t;
      t = $gamePlayer.target();
      if (t != null ? t.isEnemy() : void 0) {
        if (AA.BattleManagerABS.isValidTarget(t)) {
          this.lastTarget = t;
          return;
        }
      }
      return this.lastTarget = null;
    }

    _searchForAllyInBattle() {
      if (!this.canSearchAlly) {
        return;
      }
      if (!$gameParty.inBattle()) {
        return;
      }
      if (this.lastAlly == null) {
        this._updateVisionForAlly(0);
      }
      if (this.lastAlly != null) {
        this._bot.setAllyTarget(this.lastAlly);
        this.char.setMoveFlagToChaseAlly();
      }
    }

    _updateVision() {
      var char, enemy, targets;
      targets = AlphaABS.AILogicManager.getAllInRangeByScope(this.char, 1);
      if (targets.length === 0) {
        return;
      }
      char = this.char;
      return this.lastTarget = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = targets.length; i < len; i++) {
          enemy = targets[i];
          if (!enemy.isAlly(char)) {
            results.push(enemy);
          }
        }
        return results;
      })()).first();
    }

    _updateVisionForAlly(state) {
      var allies, ally, candidates;
      allies = AlphaABS.AILogicManager.getAllInRangeByScope(this.char, 0);
      allies.delete(this.char); // * Себя исключить
      if (allies.length === 0) {
        return;
      }
      switch (state) {
        case 0: // * inBattle
          candidates = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = allies.length; i < len; i++) {
              ally = allies[i];
              if (ally.inBattle()) {
                results.push(ally);
              }
            }
            return results;
          })();
          break;
        default:
          break;
      }
      if (candidates.length > 0) {
        this.lastAlly = candidates.sample();
      }
    }

    _onSeeTarget() {
      if (this.lastTarget == null) {
        return;
      }
      return this._bot.changeStateToBattle(this.lastTarget);
    }

    _onSeeAlly(ally) {}

    _updateSelfSupport() {
      //*CHECK HP RATE FOR NON SPAMING ACTIONS
      if (this._bot.isNeedSelfSupport()) {
        //"IS HAVE SUPPORT".p()
        return this._bot.changeStateToBattle(this.char);
      }
    }

  };
  AA.register(AIStateFreeAlly);
})();

// ■ END AIStateFreeAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFreePet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFreePet;
  AIStateFreePet = class AIStateFreePet extends AlphaABS.LIBS.AIStateFree {
    onStateStarted() {
      AlphaABS.LIBS.AIStateFree.prototype.onStateStarted.call(this);
      this.lastTarget = null;
      return this._resetLooting();
    }

    _resetLooting() {
      AA.BattleUI.setSummonMoveMode(0);
      return this._targetToLooting = null;
    }

    _updateReturnToHome() {
      if ((this._bot.getHomePosition() != null) && this.active) {
        if (this._targetToLooting == null) {
          this._returnToHome();
        }
      }
      if ((this._targetToLooting != null) && this.active) {
        if (!this._bot.inSupportPhase()) {
          return this._updateMoveToLoot();
        }
      }
    }

    _updateMoveToLoot() {
      var e;
      if (this._targetToLooting == null) {
        return;
      }
      try {
        if (!this._bot.isNearThePointX(this._targetToLooting)) {
          return this._bot.moveToPointAA(this._targetToLooting);
        } else {
          this._bot.moveToPointAA(this._targetToLooting); // * Встать на него
          this._targetToLooting.loot();
          return this._resetLooting();
        }
      } catch (error) {
        e = error;
        console.err(e);
        return this._resetLooting();
      }
    }

    _updateWithFightLogic() {
      AlphaABS.LIBS.AIStateFree.prototype._updateWithFightLogic.call(this);
      this._updateLoot();
      return this._updateHealing();
    }

    _updateVision() {
      this.bMode = this._bot._bahMode;
      if (!this._bot.inSupportPhase()) {
        if (this.lastTarget == null) {
          this._selectTarget();
        }
        return this._checkLastTarget();
      }
    }

    _updateLoot() {
      if (this.lastTarget == null) {
        this._searchForLoot();
      }
      return this._checkTargetForLooting();
    }

    _selectTarget() {
      var attackers, candidats, t;
      switch (this.bMode) {
        case 1:
          if ($gamePlayer.inBattle()) {
            t = $gamePlayer.target();
            if (t != null ? t.isPlayerAttackedMe() : void 0) {
              this.lastTarget = t;
            }
          }
          break;
        case 2:
          if ($gamePlayer.inBattle()) {
            candidats = AlphaABS.AILogicManager.getAllInRange(this._bot);
            attackers = candidats.filter((item) => {
              return item !== this._bot && !item.isAlly(this._bot) && item.target() === $gamePlayer;
            });
            if (attackers.length > 0) {
              this.lastTarget = attackers.first();
            }
          }
          break;
        default:
          this.lastTarget = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      }
      if (this.lastTarget != null) {
        return this._onSeeTarget(this.lastTarget);
      }
    }

    _checkLastTarget() {
      if (!AA.BattleManagerABS.isValidTarget(this.lastTarget)) {
        return this.lastTarget = null;
      }
    }

    _searchForLoot() {
      var corpses, i, item, len;
      if ($gamePlayer.inBattle()) {
        return;
      }
      if (!this._bot.isCanLooting()) {
        return;
      }
      if (this._bot.inSupportPhase()) {
        return;
      }
      corpses = AA.AILogicManager.getAllDeadBotsInRange(this._bot);
      corpses = corpses.filter(function(item) {
        return item.isCanBeLooted();
      });
      if (corpses.length > 0) {
        for (i = 0, len = corpses.length; i < len; i++) {
          item = corpses[i];
          if (item.isHasAnyLoot()) {
            this._targetToLooting = item;
            AA.BattleUI.setSummonMoveMode(1);
            return;
          } else {
            item.loot(); // * Чтобы не появлялся в поиске
          }
        }
      }
    }

    _checkTargetForLooting() {
      if (this._targetToLooting == null) {
        return;
      }
      if ($gamePlayer.inBattle()) {
        this._targetToLooting = null;
      }
      if (!this._targetToLooting.isCanBeLooted()) {
        this._targetToLooting = null;
      }
      // * Если игрок далеко, то идти за ним
      if (AA.LIBS.AILogicManager.isAwayFromPlayer(this._bot)) {
        //"PLAYER TO FAR for Loot".p()
        this._targetToLooting = null;
      }
      if (this._targetToLooting == null) {
        return this._resetLooting();
      }
    }

    _updateVisionForAlly() {} // * EMPTY

    refreshBevMode() {} // * EMPTY

    _updateNoFightLogic() {
      AlphaABS.LIBS.AIStateFree.prototype._updateNoFightLogic.call(this);
      this._updateReturnToHome();
      this._updateLoot();
      return this._updateHealing();
    }

    _updateHealing() {
      if (!this._bot.isCanSupport()) { // * Включина ли опция
        return;
      }
      if (this._bot.inSupportPhase()) {
        return;
      }
      //"HEALING".p()
      if (this._isPlayerNeedToBeHealed()) {
        //"NEAD HEAL PLAYER".p()
        if (this._canUseHealSkill()) {
          return this._startHealing();
        }
      }
    }

    //else
    //    "CANT USE SKILL".p()
    _isPlayerNeedToBeHealed() {
      return this._bot._isNeedUseSupportOnPlayer();
    }

    _canUseHealSkill() {
      return this._bot._isCanUseSupportNow();
    }

    _startHealing() {
      return this._bot.activateSupportPhase();
    }

  };
  AlphaABS.register(AIStateFreePet);
})();

// ■ END AIStateFreePet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateMachine;
  AIStateMachine = class AIStateMachine {
    constructor() {
      this._bot = null;
      this._state = "";
      this._freeStateLogic = new AlphaABS.LIBS.AIStateFree();
      this._searchStateLogic = new AlphaABS.LIBS.AIStateSearch();
      this._returnStateLogic = new AlphaABS.LIBS.AIStateReturn();
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattle();
      this._slowUpdateActive = false;
    }

    // * THIS IS VERY DANGER METHOD!!!
    slowUpdate() {
      var e;
      try {
        if (AA.UI.isGameShouldPause()) {
          return;
        }
        if (SceneManager.isSceneChanging()) {
          return;
        }
        if (this._bot == null) {
          return;
        }
        if (!AlphaABS.isABS()) {
          return;
        }
        if (!this._bot.inActive()) {
          return;
        }
        switch (this._state) {
          case "free":
            return this._updateOnFree();
          case "search":
            return this._updateOnSearch();
          case "return":
            return this._updateOnReturn();
          case "battle":
            return this._updateOnBattle();
        }
      } catch (error) {
        e = error;
        return console.error(e);
      }
    }

    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    deactivate() {}

    onGameSave() {
      return this._bot = null;
    }

    onGameLoad() {
      return this._slowUpdateActive = false;
    }

    update(bot) {
      if (AA.UI.isGameShouldPause()) {
        return;
      }
      if (!this._setup(bot)) {
        return;
      }
      if (this._bot.inActive()) {
        if (!this._checkDeadState()) {
          this._updateInActiveMode();
        }
      } else {
        this._updateInNoActiveMode();
      }
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
    }

    _setup(bot) {
      this._bot = bot;
      if (bot == null) {
        return false;
      }
      this.battler = this._bot.battler();
      return true;
    }

    _checkDeadState() {
      if (!this.battler.isAlive()) {
        this._changeStateTo("dead");
        return true;
      }
      return false;
    }

    _changeStateTo(stateSymbol) {
      this._state = stateSymbol;
      switch (this._state) {
        case "free":
          return this._onStateFree();
        case "battle":
          return this._onStateBattle();
        case "search":
          return this._onStateSearch();
        case "return":
          return this._onStateReturn();
        case "stun":
          return this._onStateStun();
        case "dead":
          return this._onStateDead();
      }
    }

    _onStateFree() {
      this._bot.onSwitchToFreeState();
      this._bot._cancelCastMotion();
      return this._freeStateLogic.onStateStarted();
    }

    _onStateBattle() {
      this._bot.onSwitchToBattleState();
      return this._battleStateLogic.onStateStarted();
    }

    _onStateSearch() {
      return this._bot.onSwitchToSearchState();
    }

    _onStateReturn() {
      return this._bot.onSwitchToReturnState();
    }

    _onStateStun() {
      return this._bot.onSwitchToStunState();
    }

    _onStateDead() {
      return this._bot.onSwitchToDeadState();
    }

    _updateInActiveMode() {
      this._checkStunState();
      return this._updateStates();
    }

    _checkStunState() {
      if (!this.battler.canMove() && !this.inStunState()) {
        return this._changeStateTo("stun");
      }
    }

    inStunState() {
      return this._state === "stun";
    }

    _updateStates() {
      switch (this._state) {
        case "stun":
          return this._updateOnStun();
      }
    }

    _updateOnFree() {
      return this._freeStateLogic.update(this._bot);
    }

    _updateOnBattle() {
      return this._battleStateLogic.update(this._bot);
    }

    _updateOnSearch() {
      return this._searchStateLogic.update(this._bot);
    }

    _updateOnReturn() {
      return this._returnStateLogic.update(this._bot);
    }

    _updateOnStun() {
      if (this.battler.canMove()) {
        return this._changeStateTo("free");
      }
    }

    _updateInNoActiveMode() {
      if (this.inReturnState()) {
        return this._updateOnReturn();
      }
    }

    inReturnState() {
      return this._state === "return";
    }

    switchStateToFree(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("free");
      }
    }

    switchStateToBattle(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("battle");
      }
    }

    switchStateToSearch(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("search");
      }
    }

    switchStateToReturn(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("return");
      }
    }

    switchActionStateToAction() {
      return this._battleStateLogic.changeActionStateTo("action");
    }

    switchActionStateToPrepare() {
      return this._battleStateLogic.changeActionStateTo("prepareAction");
    }

    switchActionStateToApproach() {
      return this._battleStateLogic.changeActionStateTo("approach");
    }

    switchActionStateToEscape() {
      return this._battleStateLogic.changeActionStateTo("escape");
    }

    switchActionStateToWait() {
      return this._battleStateLogic.changeActionStateTo("wait");
    }

  };
  AlphaABS.register(AIStateMachine);
})();

// ■ END AIStateMachine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateMachineAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateMachineAlly;
  AIStateMachineAlly = class AIStateMachineAlly extends AlphaABS.LIBS.AIStateMachine {
    constructor() {
      super();
      this._state = "free";
      this._freeStateLogic = new AA.LIBS.AIStateFreeAlly();
      this._returnStateLogic = null;
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattleAlly();
      this._searchStateLogic = null;
    }

    //$[OVER]
    _updateInNoActiveMode() {
      if ($gamePlayer.isTransferring()) {
        return;
      }
      // * Если dead, то ничего
      if (!this._bot.isDead()) {
        return;
      }
      if (this.battler.isAlive()) {
        return this._bot.onSwitchToAliveState();
      }
    }

    //$[OVER]
    _onStateFree() {
      this._bot.onSwitchToFreeState();
      return this._freeStateLogic.onStateStarted();
    }

    //$[OVER]
    _onStateStun() {} // * NOTHING

  };
  AA.register(AIStateMachineAlly);
})();

// ■ END AIStateMachineAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var AIStateMachinePet;
  AIStateMachinePet = class AIStateMachinePet extends AlphaABS.LIBS.AIStateMachine {
    constructor() {
      super();
      this._freeStateLogic = new AlphaABS.LIBS.AIStateFreePet();
      this._returnStateLogic = new AlphaABS.LIBS.AIStateReturnParty();
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattlePet();
      this._searchStateLogic = new AlphaABS.LIBS.AIStateSearch();
    }

    _onStateBattle() {
      AlphaABS.LIBS.AIStateMachine.prototype._onStateBattle.call(this);
      if (this._bot.inSupportPhase()) {
        return AA.BattleUI.setSummonMoveMode(2);
      } else {
        return AA.BattleUI.setSummonMoveMode(3);
      }
    }

    refreshBehMode() {
      switch (this._state) {
        case "free":
          return this._freeStateLogic.refreshBevMode();
        case "battle":
          return this._battleStateLogic.refreshBevMode();
      }
    }

  };
  AlphaABS.register(AIStateMachinePet);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateReturn.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateReturn;
  AIStateReturn = class AIStateReturn extends AlphaABS.LIBS.AIStateBase {
    _updateMainLogic() {
      if (this._bot.getHomePosition() == null) {
        return this._bot.onReturnEnd();
      }
      if (this._bot.isNotReturn()) {
        return this._bot.onReturnEnd();
      }
      return this._updateReturnMode();
    }

    _updateReturnMode() {
      if (this._bot.isSlowReturn()) {
        this._bot.onReturnEnd();
        return this._bot.returnSlow();
      } else {
        return this._bot.returnFast();
      }
    }

  };
  AlphaABS.register(AIStateReturn);
})();

// ■ END AIStateReturn.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateReturnParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateReturnParty;
  // * Используется в Pet
  AIStateReturnParty = class AIStateReturnParty extends AlphaABS.LIBS.AIStateReturn {
    _updateReturnMode() {
      if (this._bot.isSlowReturn()) {
        return this._bot.returnSlow();
      } else {
        return this._bot.returnFast();
      }
    }

  };
  AlphaABS.register(AIStateReturnParty);
})();

// ■ END AIStateReturnParty.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateSearch.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateSearch;
  AIStateSearch = class AIStateSearch extends AlphaABS.LIBS.AIStateBase {
    _updateMainLogic() {
      if (this._haveOneToSearch()) {
        this._updateOnSearch();
      } else {
        this._bot.changeStateToFree();
      }
    }

    _haveOneToSearch() {
      var ref;
      return (ref = this._bot.allyToSearch()) != null ? ref.inActive() : void 0;
    }

    _updateOnSearch() {
      var target;
      target = AlphaABS.LIBS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateAllySearch();
      }
    }

    _onSeeTarget(target) {
      this._bot.setAllyTarget(null);
      return this._bot.changeStateToBattle(target);
    }

    _updateAllySearch() {
      this._bot.moveToAlly();
      if (this._bot.isNearThePointX(this._bot.allyToSearch())) {
        return this._bot.changeStateToFree();
      }
    }

  };
  AlphaABS.register(AIStateSearch);
})();

// ■ END AIStateSearch.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
var AllyABS;

AllyABS = class AllyABS extends AAEntity {
  constructor(_memberIndex) {
    super();
    this._memberIndex = _memberIndex;
    this.aiName = this.battler().name();
    this._isDeadOnMap = false;
    this._currentAction = null;
    this._newActionDecisionTimer = 0;
    this._createStateMachine();
  }

  character() {
    return $gamePlayer.followers().follower(this._memberIndex - 1);
  }

  battler() {
    return $gameParty.battleMembers()[this._memberIndex];
  }

  teamId() {
    return 0;
  }

  resetTarget() {
    AAEntity.prototype.resetTarget.call(this);
    this.allyTarget = null;
    return this.interruptCast();
  }

  //? Compability
  inActive() {
    return this.isActive();
  }

  isDead() {
    return this._isDeadOnMap;
  }

  setDead() {
    return this._isDeadOnMap = true;
  }

  revive() {
    return this._isDeadOnMap = false;
  }

  behaviorModel() {
    return this.behModel;
  }

  behaviorMode() {
    return this.behMode;
  }

  actionMode() {
    return this._currentMoveActionIndex;
  }

  currentAction() {
    return this._currentAction;
  }

  isCasting() {
    var ref;
    return (ref = this.currentAction()) != null ? ref.isCasting() : void 0;
  }

  initABS() {
    AAEntity.prototype.initABS.call(this);
    this.behModel = new AIAllyBehavModel();
    this.behModel.loadActor(this.battler().actorId());
    this._initStartParameters();
    return this._registerOnSlowUpdate();
  }

  resumeABS() {
    this.activate();
    return this.changeStateToFree();
  }

  stopABS() {
    if (this.inBattle()) {
      this._onBattleEnd();
    }
    this.resetTarget();
    return this.deactivate();
  }

  update() {
    AAEntity.prototype.update.call(this);
    this._stateMachine.update(this);
    return this._updateActionDecisionTimer();
  }

  onGameSave() {
    this.resetTarget();
    return this._stateMachine.onGameSave();
  }

  onGameLoad() {
    this._stateMachine.onGameLoad();
    return this._registerOnSlowUpdate();
  }

  log(text) {
    var e;
    try {
      if (!AA.isDEV()) {
        return;
      }
      if (this._log == null) {
        this._createLog();
      }
      return this._log.p(`${this.aiName} : ${text}`);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  }

  startCommonEvent(evId) {
    if (evId > 0) {
      return $gameTemp.reserveCommonEvent(evId);
    }
  }

  setMoveActionIndex(_currentMoveActionIndex) {
    this._currentMoveActionIndex = _currentMoveActionIndex;
  }

  // =====================================================================
  _createLog() {
    var e;
    try {
      this._log = new KDCore.DevLog("AllyABS");
      return this._log.setColor(KDCore.Color.FromHex('#626215'));
    } catch (error) {
      e = error;
      console.warn(e);
    }
  }

  _createStateMachine() {
    return this._stateMachine = new AA.LIBS.AIStateMachineAlly();
  }

  // * Задаёт начальный режим поведения
  _initStartParameters() {
    this._currentMoveActionIndex = 0;
    this.setBehMode(this.behModel.sBattleMode);
    if (!this.battler().isAlive()) {
      return this.setDead();
    }
  }

  _registerOnSlowUpdate() {
    this.log("REGISTRED ON SLOW UPDATE");
    return SlowUpdateManager.register(900 + this._memberIndex, this._stateMachine, AA.Parameters.get_AIUpdateTickTime() / 2);
  }

};

// ■ END AllyABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyABS.prototype;
  // * 0 - Обычный режим (атака всех врагов в области видимости)
  // * 1 - Атака только цели игрока (кого он атакует)
  // * 2 - Атака только тех, кто атакует игрока
  // * 3 - Поддержка
  _.setBehMode = function(behMode) {
    this.behMode = behMode;
    if (this.behMode < 0) {
      this.behMode = 3;
    }
    //TODO: support Beh Mode
    //? TEMP solution
    if (this.behMode === 3) {
      this.behMode = 0;
      return AA.warning("Support Mode not supported in current Build!");
    }
  };
  _.isInSupportBehMode = function() {
    return this.behMode === 3;
  };
  _.setAllyTarget = function(allyTarget) {
    this.allyTarget = allyTarget;
  };
  _.getAllyTarget = function() {
    return this.allyTarget;
  };
  _.isHaveAnySupportAllySkill = function() {
    return this.battler().isHaveAnySupportAllySkill();
  };
  _.isNeedSelfSupport = function() {
    var chance;
    chance = 0.2;
    if (this.inBattle()) {
      if (this.isInSupportBehMode()) {
        chance += 0.5;
      }
    } else {
      chance = 0.5;
    }
    if (Math.random() < chance) {
      return this.battler().isHaveProperAllySupportAction();
    } else {
      return false;
    }
  };
})();

// ■ END AllyABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyABS_Actions.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyABS.prototype;
  _._updateActionDecisionTimer = function() {
    if (this._newActionDecisionTimer >= 0) {
      return this._newActionDecisionTimer--;
    }
  };
  _.makeBattleActions = function() {
    var absSkills;
    //"MAKE BATTLE ACTIONS".p()
    this.battler().makeActions();
    //acts = @battler()._actions
    absSkills = this.battler()._actions.map((function(action) {
      var skill;
      return skill = this.battler().skillABS_byAction(action);
    }).bind(this));
    if (absSkills.length > 0 && (absSkills[0] != null)) {
      // * Выбираем случайное действие
      if (this.getTarget() === this.character() && absSkills[0].isAttack()) {
        // * Не знаю почему выбирает атаку!
        //"ATTACK".p()
        this._currentAction = null;
        this.resetTarget();
      } else {
        // * Нельзя выполнять союзные действия на врагов!
        if (absSkills[0].isForAlly() && this.getTarget().isEnemy()) {
          this.setTarget(this.character());
        }
        this._setCurrentAction(absSkills[0]);
      }
    } else {
      this._setCurrentAction(null);
    }
  };
  _._setCurrentAction = function(action) {
    if (this._currentAction === action) {
      if (this.isCasting()) { // * Нельзя менять, если каст
        return;
      } else {
        if (this._newActionDecisionTimer > 0) {
          return;
        }
      }
    }
    if (this.isCasting()) {
      // * Если мы кастуем, но появилось более приоритетное действие
      if (this.isGoodCastRate()) {
        return;
      }
    } else {
      // * Сбрасываем кастинг
      this.interruptCast();
    }
    this._currentAction = action;
    if (action != null) {
      this.log("New Action: " + action.skill().name);
      this._stateMachine.switchActionStateToPrepare();
      return this._newActionDecisionTimer = 30;
    } else {
      // * Если действий нет, но какое-либо действие просто не достаёт по Range, надо подойти
      if (this.isAnySkillIsOutOfDistance()) {
        return this._stateMachine.switchActionStateToApproach();
      } else {
        // * Если действий нет и цель в зоне поражения навыков, отходим (ждём)
        return this._stateMachine.switchActionStateToEscape();
      }
    }
  };
  // * Есть смысл продолжать каст?
  _.isGoodCastRate = function() {
    var distToNearesEnemy, enemies, timeLeft;
    // Надо смотреть цель, надо смотреть цели вокруг
    enemies = $gameTroop.membersABSWhoTargetingFor(this.character());
    if (enemies.length === 0) {
      return true;
    }
    timeLeft = this.currentAction().timer.timeLeft() / 60;
    if (timeLeft < 1) {
      return true;
    }
    distToNearesEnemy = AA.AILogicManager.getDistanceToNearestFrom(this, enemies);
    if (distToNearesEnemy < timeLeft) {
      this.log("Cancel cast, enemy too close");
      return false;
    }
    return true;
  };
  _.isAnySkillIsOutOfDistance = function() {
    var skills;
    skills = this.battler().usableSkillsABS();
    if (skills.length > 0 && (this.getTarget() != null)) {
      return skills.some((s) => {
        return this.battler()._isABSSkillOnProperRange(s) === false;
      });
    }
    return false;
  };
  _.checkActionCommonEvent = function() {
    var act;
    act = this.currentAction();
    if (act == null) {
      return;
    }
    this.startCommonEvent(act.cEonStart);
  };
  _.performBattleAction = function() {
    var action;
    this.character()._performSkillMotion();
    action = this.currentAction();
    this.log('Perform! ' + action.skill().name);
    if (action.isVectorType()) {
      this._performVectorBattleAction();
    } else {
      if (action.isNeedTarget() || action.isNoTarget()) {
        this._peformSingleTargetBattleAction();
      } else {
        if (action.isRadiusType()) {
          this._performRadiusBattleAction();
        } else if (action.isZoneType()) {
          this._performZoneBattleAction();
        } else {
          this._peformSelfBattleAction();
        }
      }
    }
    return this._onBattleAcitonBeenPerformed();
  };
  _._onBattleAcitonBeenPerformed = function() {
    this.battler().performCurrentAction();
    AA.BattleManagerABS.battleProcess().setForceTargetsForZoneAndRadius(null);
    this.currentAction().playStartSound(this.character().toPoint());
    this._stateMachine.switchActionStateToPrepare();
    if (this.battler().action(0).isAttack()) {
      this.character().aaPerformAttackAnimation();
    }
    if (this.currentAction().isForAlly()) { //and @getTarget() == @character()
      // * Если действие было на себя, то надо сбросить цель
      return this.resetTarget();
    }
  };
  _._performVectorBattleAction = function() {
    var action, char, currentAction, process, target;
    char = this.character();
    action = this.battler().action(0);
    target = this.getTarget();
    process = AA.BattleManagerABS.battleProcess();
    currentAction = this.currentAction();
    if (currentAction.isNoTarget()) {
      if (currentAction.isDirectionFix()) {
        target = AlphaABS.UTILS.getEndPointFromCharToRange(char, currentAction.range);
      } else {
        target = this.getTarget().toPoint();
      }
    }
    process.startPostBattleAction(char, target, action, currentAction);
  };
  _._performRadiusBattleAction = function() {
    var candidates, char, process;
    char = this.character();
    process = AA.BattleManagerABS.battleProcess();
    candidates = AA.LIBS.AILogicManager.inSkillRadius(char, this.currentAction().radius);
    process.setForceTargetsForZoneAndRadius(candidates);
    return process.performBattleActionRadius(char, char.toPoint(), this.battler().action(0), this.currentAction());
  };
  _._performZoneBattleAction = function() {
    var candidates, char, process;
    char = this.character();
    process = AA.BattleManagerABS.battleProcess();
    candidates = AA.LIBS.AILogicManager.inSkillRadius(char, this.currentAction().radius);
    process.setForceTargetsForZoneAndRadius(candidates);
    return process.performBattleActionZone(char, this.battler().action(0));
  };
  _._peformSelfBattleAction = function() {
    var char;
    char = this.character();
    return AA.BattleManagerABS.battleProcess().performBattleAction(char, char);
  };
  _._peformSingleTargetBattleAction = function() {
    return AA.BattleManagerABS.battleProcess().performBattleAction(this.character(), this.getTarget());
  };
  _.interruptCast = function() {
    var ref;
    if (this.currentAction() == null) {
      return;
    }
    if (this.isCasting()) {
      this.log('Cast intterupt');
      if ((ref = this.battler()) != null) {
        ref.onAACastStop();
      }
      this.character()._cancelCastMotion();
      this.currentAction().resetCast();
    }
  };
})();

// ■ END AllyABS_Actions.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyABS.prototype;
  _.changeStateToFree = function() {
    //"FREE".p()
    return this._stateMachine.switchStateToFree(this);
  };
  _.changeStateToBattle = function(target) {
    //"BATTLE".p()
    this.setTarget(target);
    return this._stateMachine.switchStateToBattle(this);
  };
  _.changeStateToSearch = function(targetToSearch) {};
  //"SEARCH".p()
  //@setAllyTarget targetToSearch
  //@_stateMachine.switchStateToSearch(@)
  _._onBattleEnd = function() {
    this.resetTarget();
    this.resetBattle();
    this.battler().onBattleEnd();
    if (this.character().isAnimX()) {
      this.character().resetXAnimaState();
    }
    return this.startCommonEvent(this.behaviorModel().cEonEnd);
  };
  //@refreshABSMotion()
  //@refreshABSMotionState(false)

  // * ==================================================
  _.onSwitchToFreeState = function() {
    this.log('In Free state');
    if (this.inBattle()) {
      this._onBattleEnd();
    }
    return this.setMoveActionIndex(0);
  };
  //TODO: reset motion refreshABSMotion
  _.onSwitchToBattleState = function() {
    this.setMoveActionIndex(3);
    if (!this.behaviorModel().noEmote) {
      this.character().requestBalloon(1);
    }
    this.battler().onBattleStart();
    this.setBattle();
    if (this.character().isAnimX()) {
      this.character().switchToXAnimaState('inBattle');
    }
    this.startCommonEvent(this.behaviorModel().cEonStart);
  };
  //TODO: rage?
  //@rageContainer()?.addDealer(@target())
  //@refreshABSMotionState(true)
  _.onSwitchToAliveState = function() {
    //"ALIVE".p()
    this.revive();
    this.character().onAARevived();
    return this.resumeABS();
  };
  _.onSwitchToDeadState = function(deadAtStart = false) {
    if (this.inBattle()) {
      //"DEAD STATE".p()
      this._onBattleEnd();
    }
    //TODO: ABS motions OFF
    //AllyToSearch = null ????
    if (deadAtStart !== true) {
      this.startCommonEvent(AA.Parameters.get_PatyMemberDeadCE());
    }
    this.setMoveActionIndex(4);
    this.setDead();
    this.character().onAADeath();
    this.battler().onAADeath();
    return this.stopABS();
  };
  _.onSwitchToStunState = function() {}; // * NOTHING
})();

// ■ END AllyABS.coffee
//---------------------------------------------------------------------------

// * ====================================================

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

    AudioManager._aaLoopBuffer = [];

    //?[NEW]
    AudioManager.pushToLoopBuffer = function (buffer) {
        AudioManager._aaLoopBuffer.push(buffer);
    };

    //?[NEW]
    AudioManager.removeFromLoopBuffer = function (buffer) {
        buffer.stop();
        this._seBuffers.delete(buffer);
        AudioManager._aaLoopBuffer.delete(buffer);
    }

    //?[NEW]
    AudioManager.clearLoopBuffer = function() {
        AudioManager._aaLoopBuffer.forEach(element => {
            AudioManager.removeFromLoopBuffer(element);
        });
    };

    //?[NEW]
    AudioManager.playSeLoop = function (se) {
        try {
            if (se.name) {
                this._seBuffers = this._seBuffers.filter(function (audio) {
                    return audio.isPlaying();
                });
                var buffer = this.createBuffer('se', se.name);
                this.updateSeParameters(buffer, se);
                buffer.play(true);
                this._seBuffers.push(buffer);
                AudioManager.pushToLoopBuffer(buffer);
                return buffer;
            }
        } catch (e) {
            console.error(e);
            return null;
        }
    };
// ■ END AudioManager.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Container.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Container;
  //TODO: Надо новый, тут центр. выравнивание не работает
  Container = class Container extends Sprite {
    constructor(size) {
      super(new Bitmap(size, size));
      this.size = size;
      this.items = [];
      this.orientation = "horizontal";
      this.placePoint = "rigth";
      this.itemsCount = 1;
      this.spacing = 0;
      this.move(100, 100);
    }

    //?{PUBLIC}
    setItemsCount(itemsCount) {
      this.itemsCount = itemsCount;
      return this._refreshMain();
    }

    _refreshMain() {
      var s;
      s = this._getSize() * this.itemsCount;
      this.bitmap = new Bitmap(s, s);
      this._rearrange();
      return this._refreshPlace();
    }

    _getSize() {
      return this.size + this.spacing;
    }

    //?{PUBLIC}
    setSpacing(spacing) {
      this.spacing = spacing;
      return this._refreshMain();
    }

    //?{PUBLIC}
    addChild(sprite) {
      this._createItem(sprite);
      this._rearrange();
      return this._refreshPlace();
    }

    _createItem(sprite) {
      this._reCreatePlacer(sprite.visible);
      this.items.push(sprite);
      return this._placer.addChild(sprite);
    }

    _reCreatePlacer(isNew) {
      var pl, s, visLen;
      if (this._placer != null) {
        super.removeChild(this._placer);
      }
      visLen = this._visItemsLength();
      if (isNew === true) {
        visLen += 1;
      }
      s = this._getSize() * visLen;
      s -= this.spacing;
      this._placer = new Sprite(new Bitmap(s, s));
      super.addChild(this._placer);
      pl = this._placer;
      this.items.forEach(function(item) {
        if (item.visible === true) {
          return pl.addChild(item);
        }
      });
    }

    _visItemsLength() {
      var count, i, j, ref;
      count = 0;
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this.items[i].visible === true) {
          count++;
        }
      }
      return count;
    }

    _rearrange() {
      var ref, ref1;
      if (this._placer == null) {
        return;
      }
      if ((ref = this._placer.children[0]) != null) {
        ref.x = 0;
      }
      if ((ref1 = this._placer.children[0]) != null) {
        ref1.y = 0;
      }
      if (this.isVertical()) {
        return this._rearrangeVertical();
      } else {
        return this._rearrangeHorizontal();
      }
    }

    _rearrangeVertical() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].y = items[0].y + (s * i));
      }
      return results;
    }

    _rearrangeHorizontal() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].x = items[0].x + (s * i));
      }
      return results;
    }

    _refreshPlace() {
      if (this._placer == null) {
        return;
      }
      if (this.isVertical()) {
        return this._refreshPlaceVertical();
      } else {
        return this._refreshPlaceHorizontal();
      }
    }

    _refreshPlaceVertical() {
      if (this.placePoint === "center") {
        this._placer.y = this.height / 2;
        this._placer.y = this._placer.y - (this._placer.height / 2);
      }
      if (this.placePoint === "left") {
        this._placer.y = this.height;
        return this._placer.y = this._placer.y - this._placer.height;
      }
    }

    _refreshPlaceHorizontal() {
      if (this.placePoint === "center") {
        this._placer.x = this.width / 2;
        this._placer.x = this._placer.x - (this._placer.width / 2);
      }
      if (this.placePoint === "left") {
        this._placer.x = this.width;
        return this._placer.x = this._placer.x - this._placer.width;
      }
    }

    //?{PUBLIC}
    refresh() {
      this._reCreatePlacer(false);
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    setHorizontal() {
      this.orientation = "horizontal";
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    isHorizontal() {
      return this.orientation === "horizontal";
    }

    //?{PUBLIC}
    setVertical() {
      this.orientation = "vertical";
      this._rearrange();
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    isVertical() {
      return this.isHorizontal() === false;
    }

    
      //?{PUBLIC}
    setPivotToCenter() {
      this.placePoint = "center";
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    setPivotToLeft() {
      this.placePoint = "left";
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    setPivotToRight() {
      this.placePoint = "right";
      return this._refreshPlace();
    }

  };
  AXUI.register(Container);
})();

// ■ END AXUI_Container.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_IPopInterface.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var IPopInterface;
  IPopInterface = class IPopInterface extends Sprite {
    constructor() {
      super();
    }

    setAnchors(value) {}

    dispose() {}

    isDisposed() {
      return false;
    }

    heightLine() {
      return this.height;
    }

    widthLine() {
      return this.width;
    }

    terminate() {}

  };
  AXUI.register(IPopInterface);
})();

// ■ END AXUI_IPopInterface.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopMachine;
  Sprite_PopMachine = (function() {
    class Sprite_PopMachine extends AXUI.IPopInterface {
      constructor() {
        super();
        this._items = [];
        this._mode = AXUI.PopMachineModeEnum.TOP;
        this._margin = 0;
        this.setItemsAnchor(0.5); // * CENTER
      }

      setMode(mode) {
        return this._mode = mode;
      }

      setItemsToLeft() {
        return this.setItemsAnchor(1);
      }

      setItemsToRight() {
        return this.setItemsAnchor(0);
      }

      setItemsAnchor(anchor) {
        return this._itemsAnchor = anchor;
      }

      setMargin(margin) {
        return this._margin = margin;
      }

      itemsCount() {
        return this._items.length;
      }

      push(item) {
        this._items.push(item);
        this._applyAnchorToItem(item);
        this.addChild(item);
        return this.refresh();
      }

      _applyAnchorToItem(item) {
        return item.setAnchors(this._itemsAnchor);
      }

      refresh() {
        this._clearDisposed();
        if (this._mode === AXUI.PopMachineModeEnum.NONE) {
          this._refreshNoneMode();
          return;
        }
        if (this._mode === AXUI.PopMachineModeEnum.CIRCLE) {
          this._refreshCircleMode();
          return;
        }
        this._refreshMode();
      }

      _refreshNoneMode() {
        if (this._items.length > 1) {
          this._clearItem(this._items[0]);
          return this._clearDisposed();
        }
      }

      _clearItem(item) {
        if (item == null) {
          return;
        }
        return item.dispose();
      }

      _clearDisposed() {
        var i, j, ref;
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].isDisposed()) {
            this._items[i] = null;
          }
        }
        return this._items.delete(null);
      }

      _refreshCircleMode() {}

      _refreshMode() {
        var _position, i, j, lastIndex, ref, results;
        if (this._items.length === 0) {
          return;
        }
        lastIndex = this._items.length - 1;
        results = [];
        for (i = j = ref = lastIndex; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
          if (i === lastIndex) {
            _position = {
              x: 0,
              y: 0
            };
          } else {
            _position = this._calculatePosition(i);
          }
          results.push(this._items[i].move(_position.x, _position.y));
        }
        return results;
      }

      _calculatePosition(i) {
        var x, y;
        x = 0;
        y = 0;
        if (this._mode === AXUI.PopMachineModeEnum.TOP) {
          y = this._items[i + 1].y - this._items[i + 1].heightLine() - this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.DOWN) {
          y = this._items[i + 1].y + this._items[i + 1].heightLine() + this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.LEFT) {
          x = this._items[i + 1].x - this._items[i + 1].widthLine() - this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.RIGHT) {
          x = this._items[i + 1].x + this._items[i + 1].widthLine() + this._margin;
        }
        return {x, y};
      }

      terminate() {
        var i, j, ref, ref1, results;
        results = [];
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push((ref1 = this._items[i]) != null ? ref1.terminate() : void 0);
        }
        return results;
      }

      clearAll() {
        var i, j, ref;
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          this._clearItem(this._items[i]);
        }
        return this._items = [];
      }

    };

    AXUI.register(Sprite_PopMachine);

    return Sprite_PopMachine;

  }).call(this);
})();

// ■ END AXUI_Sprite_PopMachine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopText;
  Sprite_PopText = class Sprite_PopText extends AXUI.IPopInterface {
    constructor() {
      super();
      this._fontSettings = AXUI.POP_DEFAULT_STYLE();
      this._effectSettings = AXUI.POP_DEFAULT_EFFECT();
      this._disposed = false;
      this._init();
      this._tick = 0;
      this._zoomSpeed = null;
      this._iconIndex = null;
      this._additionH = 0;
      this._additionW = 0;
    }

    _init() {
      return this.bitmap = new Bitmap(50, 50);
    }

    setFontSettings(fontSettings) {
      if (fontSettings == null) {
        return;
      }
      if (fontSettings.textVisible != null) {
        this._fontSettings.textVisible = fontSettings.textVisible;
      }
      if (fontSettings.fontName != null) {
        this._fontSettings.fontName = fontSettings.fontName;
      }
      if (fontSettings.fontSize != null) {
        this._fontSettings.fontSize = fontSettings.fontSize;
      }
      if (fontSettings.italy != null) {
        this._fontSettings.italy = fontSettings.italy;
      }
      if (fontSettings.fontOutlineWidth != null) {
        this._fontSettings.fontOutlineWidth = fontSettings.fontOutlineWidth;
      }
      if (fontSettings.fontOutlineColor != null) {
        this._fontSettings.fontOutlineColor = KDCore.Color.FromHex(fontSettings.fontOutlineColor);
      }
      if (fontSettings.iconSize != null) {
        this._fontSettings.iconSize = fontSettings.iconSize;
      }
    }

    setEffectSettings(effectSettings) {
      if (effectSettings == null) {
        return;
      }
      this._effectSettings.changeFontSize = effectSettings.changeFontSize != null ? effectSettings.changeFontSize : void 0;
      if (effectSettings.stayTime != null) {
        this._effectSettings.stayTime = effectSettings.stayTime;
      }
    }

    setText(text, color) {
      this.text = text;
      if (color != null) {
        this.tColor = color;
      }
      if (typeof this.tColor === "string") {
        return this.tColor = KDCore.Color.FromHex(this.tColor);
      }
    }

    setIcon(iconIndex) {
      return this._iconIndex = iconIndex;
    }

    create() {
      var sprH, sprW;
      this.bitmap.fontSize = Math.max(this._fontSettings.fontSize, this._effectSettings.changeFontSize);
      sprW = this._calcWidth();
      sprH = this._calcHeight();
      this.baseSprite = new Sprite();
      this._drawOnBase();
      this.textSprite = new Sprite(new Bitmap(sprW, sprH));
      this.textSprite.bitmap.addLoadListener(this._drawText.bind(this));
      this.baseSprite.addChild(this.textSprite);
      if (this.iconSprite != null) {
        this.baseSprite.addChild(this.iconSprite);
      }
      
      //@setAnchors(0.5)
      this.addChild(this.baseSprite);
      return this._startTimer();
    }

    _calcWidth() {
      var sprW, w;
      w = this.bitmap.measureTextWidth(this.text);
      sprW = w + 4;
      return sprW;
    }

    _calcHeight() {
      return this._fontSettings.fontSize + 10;
    }

    _drawOnBase() {} //?EMPTY

    setAnchors(xAnchor) {
      var sprW;
      //"SET ANCHOR".p(xAnchor)
      if (this.iconSprite != null) {
        this.iconSprite.anchor.x = xAnchor;
        this.iconSprite.anchor.y = 0.5;
        sprW = this._calcWidth();
        if (xAnchor === 0.5) {
          this.iconSprite.move(-sprW / 2 - this._fontSettings.iconSize / 2, 0);
        }
        if (xAnchor === 1) {
          this.iconSprite.move(-sprW, 0);
        }
        if (xAnchor === 0) {
          this.textSprite.move(this._fontSettings.iconSize, 0);
        }
      }
      if (this.baseSprite) {
        this.baseSprite.anchor.x = xAnchor;
        this.baseSprite.anchor.y = 0.5;
      }
      if (this.textSprite) {
        this.textSprite.anchor.x = xAnchor;
        return this.textSprite.anchor.y = 0.5;
      }
    }

    heightLine() {
      if (this.textSprite != null) {
        return this.textSprite.height + this._additionH;
      } else {
        return this.height;
      }
    }

    widthLine() {
      return this.width;
    }

    _drawText() {
      this._applySettings(this.textSprite.bitmap);
      this._applyEffect();
      if (this.tColor != null) {
        this.textSprite.bitmap.textColor = this.tColor.CSS;
      }
      this._drawTextLine();
      if (this._iconIndex != null) {
        this._drawIcon();
      }
    }

    _drawTextLine() {
      this.textSprite.bitmap.clear();
      //@textSprite.bitmap.fillAll(KDCore.Color.RED)
      return this.textSprite.bitmap.drawText(this.text, 0, this.textSprite.bitmap.height / 2, this.textSprite.bitmap.width, 1, 'center');
    }

    _drawIcon() {
      var iconSize, index, spr;
      this.iconSprite = new Sprite(new Bitmap(this._fontSettings.iconSize, this._fontSettings.iconSize));
      this.iconSprite.bitmap.drawIcon(0, 0, this._iconIndex, this._fontSettings.iconSize);
      //TODO: BAD CODE!
      if (this._iconIndex instanceof Bitmap) {
        //"START".p()
        spr = this.iconSprite;
        iconSize = this._fontSettings.iconSize;
        index = this._iconIndex;
        setTimeout((function() {
          var e;
          try {
            //"TRY".p()
            return spr.bitmap.drawIcon(0, 0, index, iconSize);
          } catch (error) {
            e = error;
          }
        //console.warn e
        }), 200);
      }
    }

    _applySettings(bitmap) {
      if (this._fontSettings.fontName != null) {
        bitmap.fontFace = this._fontSettings.fontName;
      }
      bitmap.fontSize = this._fontSettings.fontSize;
      bitmap.fontItalic = this._fontSettings.italy;
      bitmap.outlineColor = this._fontSettings.fontOutlineColor.CSS;
      bitmap.outlineWidth = this._fontSettings.fontOutlineWidth;
    }

    _applyEffect() {
      return this._zoomSpeed = 1;
    }

    _startTimer() {
      var timer;
      return this._thread = AA.setTimeout((timer = () => {
        this._updateTimer();
        AA.clearTimeout(this._thread);
        if (this._disposed === false) {
          return AA.setTimeout(timer, 60);
        }
      }), 60);
    }

    _updateTimer() {
      if (this.textSprite == null) {
        return;
      }
      if (this.parent == null) {
        return;
      }
      //"TIMER".p()
      return this._updateOpacity();
    }

    _updateOpacity() {
      var maxTime;
      if (this._zoomSpeed != null) {
        return;
      }
      maxTime = this._getStayTimeMax();
      if (maxTime <= 0) {
        return;
      }
      if (this._tick <= maxTime) {
        return this._tick++;
      } else {
        this.opacity -= 25;
        this._moveToDisapear();
        if (this.opacity <= 0) {
          return this.dispose();
        }
      }
    }

    _getStayTimeMax() {
      return this._effectSettings.stayTime;
    }

    _moveToDisapear() {
      return this.move(this.x, this.y - 1);
    }

    dispose() {
      var ref;
      this._disposed = true;
      this.textSprite = null;
      if ((ref = this.parent) != null) {
        ref.removeChild(this);
      }
      if (this._thread) {
        return AA.clearTimeout(this._thread);
      }
    }

    update() {
      super.update();
      return this._updateZoom();
    }

    _updateZoom() {
      var b;
      if (this._zoomSpeed == null) {
        return;
      }
      b = this.textSprite.bitmap;
      if (b.fontSize < this._effectSettings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
        this._drawTextLine();
      } else {
        if (b.fontSize > this._effectSettings.changeFontSize) {
          b.fontSize = b.fontSize - 1;
          this._drawTextLine();
        }
      }
      if (b.fontSize === this._effectSettings.changeFontSize) {
        this._zoomSpeed = null;
      }
    }

    isDisposed() {
      return this._disposed === true;
    }

  };
  AXUI.register(Sprite_PopText);
})();

// ■ END AXUI_Sprite_PopText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopTextNotifyLine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopTextNotifyLine;
  Sprite_PopTextNotifyLine = (function() {
    class Sprite_PopTextNotifyLine extends AXUI.Sprite_PopText {
      constructor(notifyTypeId) {
        super();
        this.notifyTypeId = notifyTypeId;
        this._loadedExtra = false;
        this._loadTextSettings();
      }

      _loadTextSettings() {
        var time, typeId;
        if (AlphaABS.jDATA.ItemsNotifySettings != null) {
          typeId = this.notifyTypeId + 1;
          if (this.notifyTypeId > 3) {
            typeId = 1;
          }
          this._params = AlphaABS.jDATA.ItemsNotifySettings[typeId];
          try {
            time = AlphaABS.jDATA.ItemsNotifySettings[0].stayTime;
            this._params.stayTime = time;
          } catch (error) {

          }
          //EMPTY
          this._loadedExtra = true;
        } else {
          this._params = this._getDefaultTextParameters();
        }
        this.setFontSettings(this._params);
        return this.setEffectSettings(this._params);
      }

      _getDefaultTextParameters() {
        return {
          fontName: null,
          fontSize: 18,
          fontOutlineWidth: 2,
          fontOutlineColor: "#000000",
          iconSize: 26,
          changeFontSize: 22,
          stayTime: 40,
          colorA: "#000000",
          colorB: null,
          opacity: 100,
          gType: 0,
          textColor: "#FFFFFF"
        };
      }

      _drawOnBase() {
        var colorA, colorB, gradientType, h, opacity, w;
        // * opacity, colorA, colorB, gradientType
        w = this._calcWidth();
        h = this._calcHeight();
        if (this._iconIndex != null) {
          w += this._fontSettings.iconSize;
        }
        this.baseSprite.bitmap = new Bitmap(w, this._calcHeight());
        colorA = KDCore.Color.FromHex(this._params.colorA);
        colorB = KDCore.Color.FromHex(this._params.colorB);
        opacity = this._params.opacity;
        gradientType = this._params.gType === 1;
        colorA = colorA.reAlpha(opacity);
        colorB = colorB.reAlpha(opacity);
        return this.baseSprite.bitmap.gradientFillRect(0, 0, w, h, colorA.CSS, colorB.CSS, gradientType);
      }

      setValue(value) {
        var e, extraImg, iconIndex, tColor;
        tColor = KDCore.Color.FromHex(this._params.textColor);
        switch (this.notifyTypeId) {
          case 4: // * TEXT AND ICON
            this.setText(value.text);
            this.setIcon(value.iconIndex);
            break;
          case 3: // * ITEMS
            this.setText(value.name, tColor);
            iconIndex = value.iconIndex;
            try {
              extraImg = DataManager.getItemInvImage(value);
              if (String.any(extraImg)) {
                iconIndex = ImageManager.loadAA_Icon(extraImg);
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
            this.setIcon(iconIndex);
            break;
          case 2: // * GOLD
            if (!this._loadedExtra) {
              tColor = KDCore.Color.YELLOW;
            }
            this.setText(value, tColor);
            this.setIcon(AlphaABS.jDATA.ItemsNotifySettings[0].goldIconIndex);
            break;
          case 1: // * EXP
            if (!this._loadedExtra) {
              tColor = KDCore.Color.MAGENTA;
            }
            this.setText(TextManager.exp + ' ' + value, tColor);
            break;
          default:
            this.setText(value);
        }
        return this.create();
      }

    };

    AXUI.register(Sprite_PopTextNotifyLine);

    return Sprite_PopTextNotifyLine;

  }).call(this);
})();

// ■ END AXUI_Sprite_PopTextNotifyLine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_StateIcon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_StateIcon;
  Sprite_StateIcon = class Sprite_StateIcon extends AXUI.Sprite_PopText {
    constructor() {
      super();
      this._isNeedDispose = false;
      this._textPositionId = 0;
      this._additionH = 0;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
    }

    setTextPosition(positionId) {
      return this._textPositionId = positionId;
    }

    // * FOR TEMP COMPABILITY
    setOuterSettings(settings) {
      this._params = this._loadParametersByStyleId(0, settings);
      this._additionH = this._params.addToHeight;
      return this._additionW = this._params.addToWidth;
    }

    create() {
      super.create();
      this._setTextPosition();
      // * Центрирование спрайта с тектом когда сверху или снизу
      return this._centerTopDownText();
    }

    _setTextPosition() {
      if (this._textPositionId === 0) { // * DOWN
        this.textSprite.move(-this._fontSettings.iconSize, this._fontSettings.iconSize);
      }
      if (this._textPositionId === 1) { // * TOP
        this.textSprite.move(-this._fontSettings.iconSize, -this._fontSettings.iconSize);
      }
      if (this._textPositionId === 2) { // * RIGHT
        this.textSprite.move(0, 0);
      }
      if (this._textPositionId === 3) { // * LEFT
        return this.textSprite.move(-(this._fontSettings.iconSize + 2) * 2, 0);
      }
    }

    _centerTopDownText() {
      if (this._textPositionId === 0 || this._textPositionId === 1) {
        if (this.textSprite.width < this._fontSettings.iconSize) {
          this.textSprite.move(this.textSprite.x + (this._fontSettings.iconSize - this.textSprite.width) / 2, this.textSprite.y);
        } else {
          this.textSprite.move(this.textSprite.x - Math.abs((this._fontSettings.iconSize - this.textSprite.width) / 2), this.textSprite.y);
        }
      }
    }

    _updateABS() {
      if (this.battler == null) {
        return;
      }
      if (this._disposed === true) {
        return;
      }
      return this._updateText();
    }

    _updateText() {
      if (this.state != null) {
        this._proccessState();
      } else {
        this._processBuff();
      }
      if (this.text == null) {
        this.text = "";
        this.destroy();
      }
      return this._drawTextLine();
    }

    _proccessState() {
      if (this._fontSettings.textVisible === true) {
        this.text = this.battler._stateTurns[this.stateId];
        if (this.text != null) {
          return this._convertTimeText();
        }
      } else {
        return this.text = "";
      }
    }

    _convertTimeText() {
      if (this.state.autoRemovalTiming === 1) {
        return this.text = this._params.stateAfterActionText;
      } else if (this.state.autoRemovalTiming === 0) {
        return this.text = ' ';
      } else {
        return this.text = AlphaABS.UTILS.framesToTimeA(this.text);
      }
    }

    _processBuff() {
      var realIndex, statesLen;
      statesLen = this.battler.states().length;
      realIndex = this.buffId - statesLen;
      this.text = this.battler._buffTurns[realIndex];
      if (this.text != null) {
        return this.text = AlphaABS.UTILS.framesToTimeA(this.text);
      }
    }

    //?[OVER BASE]
    _getStayTimeMax() {
      if (this._isNeedDispose === true) {
        return 4;
      }
      return -1;
    }

    dispose() {
      this._disposed = true;
      this.parent.refresh();
      this.terminate();
      return super.dispose();
    }

    terminate() {
      return AA.clearInterval(this._thread);
    }

    destroy() {
      return this._isNeedDispose = true;
    }

    setStateId(battler, stateId) {
      this.battler = battler;
      this.stateId = stateId;
      this.state = $dataStates[stateId];
      return this._setNewItem(this.state.iconIndex);
    }

    _setNewItem(iconIndex) {
      this._loadStateSettings();
      this.setIcon(iconIndex);
      this.setText("   ", this._params.textColor);
      this.setTextPosition(this._params.stateTimeTextPosition);
      return this.create();
    }

    _loadStateSettings() {
      var styleId;
      if (this._params == null) {
        if (AlphaABS.jDATA.StatesPanelSettings != null) {
          styleId = this._loadProperStyleId();
          this._params = this._loadParametersByStyleId(styleId, AlphaABS.jDATA.StatesPanelSettings);
          this._additionH = this._params.addToHeight;
          this._additionW = this._params.addToWidth;
        } else {
          this._params = this._getDefaultTextParameters();
        }
      }
      this.setFontSettings(this._params);
      return this.setEffectSettings(this._params);
    }

    _loadProperStyleId() {
      return 0;
    }

    _loadParametersByStyleId(styleId, settings) {
      var p, params;
      params = null;
      p = settings;
      p.forEach(function(item) {
        if (item.id === styleId) {
          return params = item;
        }
      });
      if (params == null) {
        params = this._getDefaultTextParameters();
      } else {
        params.stateAfterActionText = p[0].stateAfterActionText;
        params.stateTimeTextPosition = p[0].stateTimeTextPosition;
      }
      return params;
    }

    _getDefaultTextParameters() {
      return {
        fontName: null,
        fontSize: 18,
        fontOutlineWidth: 2,
        fontOutlineColor: "#000000",
        iconSize: 32,
        changeFontSize: 20,
        stayTime: -1,
        colorA: null,
        colorB: null,
        opacity: 0,
        gType: 0,
        textColor: "#caca00",
        stateAfterActionText: 'A',
        stateTimeTextPosition: 0,
        textVisible: true
      };
    }

    setBuff(battler, buffId) {
      this.battler = battler;
      this.buffId = buffId;
      this.state = null;
      return this._setNewItem(this.battler.allIcons()[buffId]);
    }

  };
  AXUI.register(Sprite_StateIcon);
})();

// ■ END AXUI_Sprite_StateIcon.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_System_BattleStates.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var System_BattleStates;
  System_BattleStates = class System_BattleStates extends AXUI.Sprite_PopMachine {
    constructor(battler) {
      super();
      this.setMode(2);
      this._battler = battler;
      this._maxItemsPerLine = 4;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
      this._thread2 = AA.setInterval((() => {
        return this._updateABSLong();
      }), 1000);
      this._collectedItems = 0;
      this._settings = null;
      this._loadSettings();
    }

    collectItems() {
      var all, b, i, j, ref, states;
      b = this._battler;
      all = b.allIcons();
      if (this._collectedItems === all.length) {
        return;
      }
      this._destroyMachines();
      this._collectedItems = all.length;
      states = b.states();
      for (i = j = 0, ref = all.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (i < states.length) {
          this.pushState(b, states[i].id);
        } else {
          this.pushBuff(b, i);
        }
      }
      return this.refresh();
    }

    _destroyMachines() {
      this._items.forEach(function(item) {
        var ref;
        item.terminate();
        if ((ref = item.parent) != null) {
          ref.removeChild(item);
        }
        return item = null;
      });
      return this._items = [];
    }

    pushState(battler, stateId) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setStateId(battler, stateId);
      return this.pushItem(item);
    }

    pushItem(item) {
      var e, machine;
      try {
        if (!this.anyMachineHasEmptySpace()) {
          if (this._settings.maxLines === 0) {
            this._createNewMachine();
          } else {
            if (this._items.length < this._settings.maxLines) {
              this._createNewMachine();
            }
          }
        }
        machine = this.machineWithEmptySpace();
        if (machine != null) {
          return machine.push(item);
        }
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, 'while add new State to states panel UI');
      }
    }

    _createNewMachine() {
      var m;
      m = new AXUI.Sprite_PopMachine();
      this._loadSettings();
      m.bitmap = new Bitmap(50, 80); //TODO: Тут из настроек самих Status (размеры)
      m.setMode(this._settings.mode);
      m.setMargin(this._settings.margin);
      return this.push(m);
    }

    _loadSettings() {
      var p;
      if (this._settings == null) {
        this._settings = {};
        if (AlphaABS.jDATA.StatesPanelSettings != null) {
          p = AlphaABS.jDATA.StatesPanelSettings[0];
          this._settings.mode = p.statesNavigation;
          this._settings.margin = p.statesMargin;
          this._settings.maxLines = p.maxLines;
        } else {
          this._settings.mode = 3;
          this._settings.margin = -14;
        }
      }
    }

    anyMachineHasEmptySpace() {
      return this._items.some((item) => {
        return item.itemsCount() !== this._maxItemsPerLine;
      });
    }

    machineWithEmptySpace() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].itemsCount() < this._maxItemsPerLine) {
          return this._items[i];
        }
      }
    }

    pushBuff(battler, buffIndex) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setBuff(battler, buffIndex);
      return this.pushItem(item);
    }

    update() {
      return super.update();
    }

    _updateABS() {
      var e;
      try {
        if (this._items.some(function(item) {
          return item.isDisposed() != null;
        })) {
          return this.refresh();
        }
      } catch (error) {
        //@_rearrageItems()
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    refresh() {
      this._clearEmpty();
      return super.refresh();
    }

    _clearEmpty() {
      var e, i, j, ref, results;
      try {
        if (this._items.length <= 1) {
          return;
        }
        results = [];
        for (i = j = 0, ref = this._items.length - 1; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].itemsCount() === 0) {
            results.push(this._items[i].isDisposed = function() {
              return true;
            });
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    //$[DEPRECATED]
    _rearrageItems() {
      var e, item;
      try {
        if (this._items[1] == null) {
          return;
        }
        if (!(this._items[1].itemsCount() < this._maxItemsPerLine)) {
          return;
        }
        if (this._items[0] == null) {
          return;
        }
        item = this._items[0]._items[0];
        this._items[0]._items[0] = null;
        this._items[0]._items.delete(null);
        if (item != null) {
          this._items[1].push(item);
        }
        return this.refresh();
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    _updateABSLong() {
      return this.collectItems();
    }

    terminate() {
      var ref;
      clearInterval(this._thread);
      clearInterval(this._thread2);
      this._items.forEach(function(item) {
        return item.terminate();
      });
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    setMaxItemCountPerLine(count) {
      return this._maxItemsPerLine = count;
    }

  };
  AXUI.register(System_BattleStates);
})();

(function() {  // ■ END AXUI_System_BattleStates.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AXUI_System_BattleStates.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var System_BattleStates2;
  System_BattleStates2 = class System_BattleStates2 extends AXUI.Sprite_PopMachine {
    constructor(battler) {
      super();
      this.setMode(2);
      this._battler = battler;
      this._maxItemsPerLine = 4;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
      this._thread2 = AA.setInterval((() => {
        return this._updateABSLong();
      }), 1000);
      this._collectedItems = 0;
      this._settings = null;
      this._loadSettings();
    }

    collectItems() {
      var all, b, i, j, ref, states;
      b = this._battler;
      all = b.allIcons();
      if (this._collectedItems === all.length) {
        return;
      }
      this._destroyMachines();
      this._collectedItems = all.length;
      states = b.states();
      for (i = j = 0, ref = all.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (i < states.length) {
          this.pushState(b, states[i].id);
        } else {
          this.pushBuff(b, i);
        }
      }
      return this.refresh();
    }

    _destroyMachines() {
      this._items.forEach(function(item) {
        var ref;
        item.terminate();
        if ((ref = item.parent) != null) {
          ref.removeChild(item);
        }
        return item = null;
      });
      return this._items = [];
    }

    pushState(battler, stateId) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setOuterSettings(AlphaABS.jDATA.EnemyStatusPanelSettings);
      item.setStateId(battler, stateId);
      return this.pushItem(item);
    }

    pushItem(item) {
      var e, machine;
      try {
        if (!this.anyMachineHasEmptySpace()) {
          if (this._settings.maxLines === 0) {
            this._createNewMachine();
          } else {
            if (this._items.length < this._settings.maxLines) {
              this._createNewMachine();
            }
          }
        }
        machine = this.machineWithEmptySpace();
        if (machine != null) {
          return machine.push(item);
        }
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, 'while add new State to states panel UI');
      }
    }

    _createNewMachine() {
      var m;
      m = new AXUI.Sprite_PopMachine();
      this._loadSettings();
      m.bitmap = new Bitmap(50, 80); //TODO: Тут из настроек самих Status (размеры)
      m.setMode(this._settings.mode);
      m.setMargin(this._settings.margin);
      return this.push(m);
    }

    _loadSettings() {
      var p;
      if (this._settings == null) {
        this._settings = {};
        if (AlphaABS.jDATA.EnemyStatusPanelSettings != null) {
          p = AlphaABS.jDATA.EnemyStatusPanelSettings[0];
          this._settings.mode = p.statesNavigation;
          this._settings.margin = p.statesMargin;
          this._settings.maxLines = p.maxLines;
        } else {
          this._settings.mode = 3;
          this._settings.margin = -14;
        }
      }
    }

    anyMachineHasEmptySpace() {
      return this._items.some((item) => {
        return item.itemsCount() !== this._maxItemsPerLine;
      });
    }

    machineWithEmptySpace() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].itemsCount() < this._maxItemsPerLine) {
          return this._items[i];
        }
      }
    }

    pushBuff(battler, buffIndex) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setOuterSettings(AlphaABS.jDATA.EnemyStatusPanelSettings);
      item.setBuff(battler, buffIndex);
      return this.pushItem(item);
    }

    update() {
      return super.update();
    }

    _updateABS() {
      var e;
      try {
        if (this._items.some(function(item) {
          return item.isDisposed() != null;
        })) {
          return this.refresh();
        }
      } catch (error) {
        //@_rearrageItems()
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    refresh() {
      this._clearEmpty();
      return super.refresh();
    }

    _clearEmpty() {
      var e, i, j, ref, results;
      try {
        if (this._items.length <= 1) {
          return;
        }
        results = [];
        for (i = j = 0, ref = this._items.length - 1; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].itemsCount() === 0) {
            results.push(this._items[i].isDisposed = function() {
              return true;
            });
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    //$[DEPRECATED]
    _rearrageItems() {
      var e, item;
      try {
        if (this._items[1] == null) {
          return;
        }
        if (!(this._items[1].itemsCount() < this._maxItemsPerLine)) {
          return;
        }
        if (this._items[0] == null) {
          return;
        }
        item = this._items[0]._items[0];
        this._items[0]._items[0] = null;
        this._items[0]._items.delete(null);
        if (item != null) {
          this._items[1].push(item);
        }
        return this.refresh();
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    _updateABSLong() {
      return this.collectItems();
    }

    terminate() {
      var ref;
      AA.clearInterval(this._thread);
      AA.clearInterval(this._thread2);
      this._items.forEach(function(item) {
        return item.terminate();
      });
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    setMaxItemCountPerLine(count) {
      return this._maxItemsPerLine = count;
    }

  };
  AXUI.register(System_BattleStates2);
})();

// ■ END AXUI_System_BattleStates.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ButtonsProLoader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ButtonsProLoader;
  ButtonsProLoader = function() {
    throw new Error('This is a static class');
  };
  ButtonsProLoader.createButtonFromJson = function(name) {
    var btnData, button, e;
    try {
      btnData = AlphaABS.jDATA.UIButtons.find(function(item) {
        return item.name === name;
      });
      if (btnData == null) {
        return null;
      }
      button = new KDCore.Button();
      if (btnData.visible === true) { // * Просто не настраиваем, оставлем пустой
        ButtonsProLoader.configurateButton(btnData, button);
      }
      return button;
    } catch (error) {
      e = error;
      AlphaABS.error(e, 'while load button ' + name + ' from JSON file');
      return null;
    }
  };
  ButtonsProLoader.configurateButton = function(data, button) {
    var e, imgs, posX, posY;
    try {
      button.buttonId = AlphaABS.jDATA.UIButtons.indexOf(data);
      button.buttonName = data.name;
      if (data.isCheckAlpha === true) {
        button.setAlphaMode();
      }
      if (data.labelText != null) {
        button.setHelpText(data.labelText[0], data.labelText[1]);
        button.setTextPosition(data.labelText[2]);
      }
      if (data.isOverrideClickInput === true) {
        button.setOverrideMode();
      }
      imgs = [data.mainImg != null ? ImageManager.loadAA(data.mainImg) : null, data.hoverImg != null ? ImageManager.loadAA(data.hoverImg) : null, data.pressedImg != null ? ImageManager.loadAA(data.pressedImg) : null, data.disabledImg != null ? ImageManager.loadAA(data.disabledImg) : null];
      button.setButtonImages(...imgs);
      button.global = true; //if data.isOnlyOnMap == false
      if (data.commonEventOnClick > 0) {
        button.addClickHandler(function() {
          return $gameTemp.reserveCommonEvent(data.commonEventOnClick);
        });
      }
      if (data.mapEventOnClick > 0) {
        button.addClickHandler(function() {
          var ev;
          ev = $gameMap.event(data.mapEventOnClick);
          if (ev != null) {
            return ev.start();
          }
        });
      }
      if (data.scriptOnClick != null) {
        button.addClickHandler(function() {
          return eval(data.scriptOnClick);
        });
      }
      if (data.condition != null) {
        button.setCondition(function() {
          return eval(data.condition);
        });
      }
      if (data.conditionForDisable != null) {
        button.setConditionForDisable(function() {
          return eval(data.conditionForDisable);
        });
      }
      if ((data.disabled != null) && data.disabled === true) {
        //button.setInfoData data.infoData if data.infoData?

        //button.visible = data.visible
        button.disable();
      }
      //MOVING
      posX = 0;
      posY = 0;
      try {
        if (KDCore.SDK.isInt(data.position[0])) {
          posX = data.position[0];
        } else {
          posX = eval(data.position[0]);
        }
        if (KDCore.SDK.isInt(data.position[1])) {
          posY = data.position[1];
        } else {
          posY = eval(data.position[1]);
        }
      } catch (error) {
        e = error;
        AlphaABS.warning(e, " while calculate button coordinate");
        posX = 0;
        posY = 0;
      }
      button.move(posX, posY);
      button.prepare();
    } catch (error) {
      //button.setLocalMode() if data.isOnScreen is false
      e = error;
      AlphaABS.error(e, 'while configurate button from JSON file');
    }
  };
  AlphaABS.ButtonsProLoader = ButtonsProLoader;
})();

// ■ END ButtonsProLoader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ButtonsProManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var ButtonsProManager;

ButtonsProManager = function() {
  throw new Error('This is a static class');
};

ButtonsProManager.init = function() {
  if (ButtonsProManager.buttons == null) {
    this.buttons = {};
  }
};

ButtonsProManager.loadABS = function() {
  if (AlphaABS.jDATA.UIButtons == null) {
    return;
  }
  //"CREA".p()
  ButtonsProManager.createButton('jump');
  ButtonsProManager.createButton('follow');
  ButtonsProManager.createButton('rotate');
  ButtonsProManager.createButton('weapons');
  ButtonsProManager.createButton('attack');
  ButtonsProManager.createButton('shield');
  ButtonsProManager.createButton('summon');
  ButtonsProManager.createButton('unsummon');
  return ButtonsProManager.createButton('inventory');
};

ButtonsProManager.loadCustom = function() {}; //?EMPTY {PRO ONLY}

ButtonsProManager.loadSaveContent = function(data) {
  var e;
  try {
    ButtonsProManager.init();
    Object.keys(data).forEach(function(item) {
      Object.keys(data[item]).forEach(function(itemInner) {
        ButtonsProManager._createButtonFromSaveData(Number(item), itemInner);
        ButtonsProManager.moveButton(itemInner, data[item][itemInner].x, data[item][itemInner].y);
        ButtonsProManager._setButtonVisibleFromSave(itemInner, data[item][itemInner].visibility, data[item][itemInner].manualHided);
        ButtonsProManager._setButtonDisabledFromSave(itemInner, data[item][itemInner].disabled, data[item][itemInner].manualDisabled);
      });
    });
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while load buttons from savefile');
  }
};

ButtonsProManager._createButtonFromSaveData = function(mapId, name) {
  var button;
  button = ButtonsProManager.getButton(mapId, name);
  if (button == null) {
    button = AlphaABS.ButtonsProLoader.createButtonFromJson(name);
    if (button == null) {
      return;
    }
    ButtonsProManager.saveButton(button);
  }
};

ButtonsProManager.createSaveContent = function() {
  var btns, contentToSave, e;
  contentToSave = {};
  try {
    btns = ButtonsProManager.buttons;
    Object.keys(btns).map(function(key) {
      return Number(key);
    }).forEach(function(key) {
      return contentToSave[key] = ButtonsProManager._extractSaveData(btns[key]);
    });
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while create save data');
  }
  return contentToSave;
};

ButtonsProManager._extractSaveData = function(values) {
  var data;
  data = {};
  Object.keys(values).forEach(function(key) {
    return data[key] = {
      x: values[key].realX(),
      y: values[key].realY(),
      visibility: values[key].visible,
      manualHided: values[key]._manualHided,
      disabled: values[key].isDisabled(),
      manualDisabled: values[key]._manualDisabled
    };
  });
  return data;
};

ButtonsProManager.createButton = function(name) {
  var button, e, mapId, system;
  try {
    if (name == null) {
      return;
    }
    if (!ButtonsProManager.isProperScene()) {
      return;
    }
    mapId = 0; //$gameMap.mapId()
    button = ButtonsProManager.getButton(mapId, name);
    if (button == null) {
      button = AlphaABS.ButtonsProLoader.createButtonFromJson(name);
      if (button == null) {
        return;
      }
      button.__aaName = name;
      //TODO: Свойство видимости сбрасывается почему то
      //ButtonsProManager.saveButton button
      system = ButtonsProManager.getCurrentSystem();
      if (system != null) {
        system.addButton(button);
      }
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while create button ' + name);
  }
};

ButtonsProManager.getAAButton = function(name) {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  return system != null ? system.getButtonByName(name) : void 0;
};

ButtonsProManager.getButton = function(mapId, name) {
  var buttonData, e, mapData;
  try {
    mapData = ButtonsProManager.buttons[mapId];
    if (mapData != null) {
      buttonData = ButtonsProManager.buttons[mapId][name];
      if (buttonData != null) {
        return buttonData;
      }
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while try get button ' + name + ' from manager');
  }
  return null;
};

ButtonsProManager.saveButton = function(button) {
  var e, mapId, name;
  try {
    name = button.buttonName;
    mapId = button.global === true ? 0 : $gameMap.mapId();
    if (ButtonsProManager.buttons[mapId] == null) {
      ButtonsProManager.buttons[mapId] = {};
    }
    return ButtonsProManager.buttons[mapId][name] = button;
  } catch (error) {
    e = error;
    return AlphaABS.error(e, 'while save button to manager');
  }
};

ButtonsProManager.getAllButtons = function() {
  return ButtonsProManager.getGlobalButtons().concat(ButtonsProManager.getMapButtons());
};

ButtonsProManager.getGlobalButtons = function() {
  return ButtonsProManager._getButtons(0);
};

ButtonsProManager.getMapButtons = function() {
  var e, mapId;
  try {
    mapId = $gameMap.mapId();
    if (mapId == null) {
      [];
    }
    return ButtonsProManager._getButtons(mapId);
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while try get Map buttons ');
    return [];
  }
};

ButtonsProManager._getButtons = function(id) {
  var buttons;
  buttons = ButtonsProManager.buttons[id];
  if (buttons != null) {
    return Object.values(buttons);
  } else {
    return [];
  }
};

ButtonsProManager.destroyButton = function(name) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButton($gameMap.mapId(), name);
    if (btn != null) {
      btn = ButtonsProManager._destroyButton(btn, $gameMap.mapId());
    } else {

    }
    btn = ButtonsProManager.getButton(0, name);
    if (btn != null) {
      return ButtonsProManager._destroyButton(btn, 0);
    }
  } catch (error) {
    e = error;
    return AlphaABS.error(e, 'while try destroy button ' + name);
  }
};

ButtonsProManager._destroyButton = function(button, mapId) {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  if (system != null) {
    system.deleteButton(button);
  }
  delete ButtonsProManager.buttons[mapId][button.buttonName];
};

ButtonsProManager.isProperScene = function() {
  var scene;
  scene = SceneManager._scene;
  if ((scene != null) && scene.constructor.name === 'Scene_Map') {
    if (scene.sceneButtonSystem != null) {
      return scene.sceneButtonSystem;
    }
  }
  return false;
};

ButtonsProManager.isAnyButtonOverrideInput = function() {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  if (system != null) {
    return system.isAnyButtonOverrideInput();
  }
  return false;
};

ButtonsProManager.isAnyButtonInInputPoint = function() {
  var e;
  try {
    if (ButtonsProManager.isAnyButtonOverrideInput()) {
      return ButtonsProManager.getCurrentSystem().isAnyButtonInTouchPoint();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while check any in Input');
  }
  return false;
};

ButtonsProManager.getCurrentSystem = function() {
  if (!ButtonsProManager.isProperScene()) {
    null;
  }
  return SceneManager._scene.sceneButtonSystem;
};

ButtonsProManager.moveButton = function(name, x, y) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn.move(x, y);
    if (btn.isLocalMode()) {
      btn.setLocalMode();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while moving button ' + name);
  }
};

ButtonsProManager.getButtonByName = function(name) {
  var btn;
  btn = ButtonsProManager.getButton($gameMap.mapId(), name);
  if (btn == null) {
    btn = ButtonsProManager.getButton(0, name);
  }
  return btn;
};

ButtonsProManager.setButtonVisible = function(name, visibility) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    if (visibility === false) {
      btn.hide();
    } else {
      btn.show();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while set button visibility ' + name);
  }
};

ButtonsProManager.setButtonDisabled = function(name, idDisabled) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    if (idDisabled === false) {
      btn.enable();
    } else {
      btn.disable();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while change disable or enable state to button ' + name);
  }
};

ButtonsProManager._setButtonVisibleFromSave = function(name, visibility, manualHided) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn.visible = visibility;
    btn._manualHided = manualHided;
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while set button visibility from save' + name);
  }
};

ButtonsProManager._setButtonDisabledFromSave = function(name, idDisabled, manualDisabled) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn._disabled = idDisabled;
    btn._manualDisabled = manualDisabled;
    btn.refreshEnDisState();
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while change disable or enable state to button ' + name);
  }
};

ButtonsProManager.refreshUIButtonsVisibility = function() {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  return system != null ? system.refresh() : void 0;
};

ButtonsProManager.setVisibilityForAllButtons = function(isVisible) {
  //ButtonsProManager.setVisibilityForMapButtons  isVisible
  return ButtonsProManager.setVisibilityForGlobalButtons(isVisible);
};

ButtonsProManager.setVisibilityForMapButtons = function(isVisible) {
  var buttons;
  buttons = ButtonsProManager.getMapButtons();
  return buttons.forEach(function(b) {
    if (isVisible === true) {
      return b.show();
    } else {
      return b.hide();
    }
  });
};

ButtonsProManager.setVisibilityForGlobalButtons = function(isVisible) {
  var buttons;
  buttons = ButtonsProManager.getGlobalButtons();
  return buttons.forEach(function(b) {
    if (isVisible === true) {
      return b.show();
    } else {
      return b.hide();
    }
  });
};

//ButtonsProManager.SetFastOpen = (isFastOpen) -> $gamePlayer._buttonsProFastOpen = isFastOpen

// ■ END ButtonsProManager.coffee
//---------------------------------------------------------------------------

(function () {
  //DataManager
  //------------------------------------------------------------------------------
  var _alias_DataManager_makeSaveContents = DataManager.makeSaveContents;
  DataManager.makeSaveContents = function () {
    if ($gameMap.isABS()) {
      var allABSAI = $gameTroop.membersABS().concat($gameParty.membersABS());
      allABSAI.forEach(function (item) {
        item.onGameSave();
      });
    }
    return _alias_DataManager_makeSaveContents.call(this);
  };

  var _DataManager_extractSaveContents = DataManager.extractSaveContents;
  DataManager.extractSaveContents = function (contents) {
    _DataManager_extractSaveContents.call(this, contents);
    if ($gameMap.isABS()) {
      var t = $gameMap.events();
      t.forEach(function (ev) {
        if (ev instanceof Game_AIBot) {
          ev.onGameLoad();
        }
      });
      try {
        $gameParty.membersABS().forEach(function (item) {
          item.onGameLoad();
        });
      } catch (e) {
        console.warn(e);
      }
      $gamePlayer.onGameLoad();
      if ($gameVariables._absUserKeys)
        AlphaABS.LIBS.IKey.loadKeyConfig($gameVariables._absUserKeys);
    } else {
      $gameScreen._resetBSEffect();
    }
  };

  var _DataManager_isDatabaseLoaded = DataManager.isDatabaseLoaded;
  DataManager.isDatabaseLoaded = function () {
    if (_DataManager_isDatabaseLoaded.call(this) == true) {
      if (!$dataSkills[1].meta.ABS) {
        //throw new Error(AlphaABS.SYSTEM.STRING_ERROR_SKILLNAN);
        $dataSkills[1].meta.ABS = "0";
      }
      if (DataManager._isOldRPGVersion()) {
        LOGW.p(AlphaABS.SYSTEM.STRING_ERROR_OLDDATA);
      }
      return true;
    } else
      return false;
  };

  DataManager._isOldRPGVersion = function () {
    if(KDCore.isMZ()) return false;
    if (Utils.RPGMAKER_VERSION) {
      var numbers = Utils.RPGMAKER_VERSION.split('.');
      return (numbers[1] < 6);
    } else {
      return true;
    }
  };

  //?[NEW]
  DataManager.loadAISpawnMap = function () {
    var mapId = AlphaABS.Parameters.get_SpawnMapId();
    if (mapId > 0) {
      var filename = 'Map%1.json'.format(mapId.padZero(3));
      this.loadDataFile('$dataSpawnMapAI', filename);
    }
  };

  //@[ALIAS]
  var _alias_DataManager_loadDatabase = DataManager.loadDatabase;
  DataManager.loadDatabase = function () {
    _alias_DataManager_loadDatabase.call(this);
    this.loadABSJSONSettings();
    AAJsonSettings.InitAndLoad();
  };

  DataManager._ABSSettingsJSONFiles = [{
      name: 'ItemsNotifySettings',
      src: 'ItemsNotifySettings.json'
    },
    {
      name: 'UIButtons',
      src: 'UIButtons.json'
    },
    {
      name: 'StatesPanelSettings',
      src: 'StatesPanelSettings.json'
    },
    {
      name: 'EnemyStatusPanelSettings',
      src: 'EnemyStatusPanelSettings.json'
    },
    {
      name: 'FirearmPanel',
      src: 'FirearmPanel.json'
    }
  ];

  //?[NEW]
  DataManager.loadABSJSONSettings = function () {
    for (var i = 0; i < this._ABSSettingsJSONFiles.length; i++) {
      var name = this._ABSSettingsJSONFiles[i].name;
      var src = this._ABSSettingsJSONFiles[i].src;
      this.loadABSJSONSettingsFile(name, src);
    }
  };

  DataManager.loadABSJSONSettingsFile = function (name, src) {
    var xhr = new XMLHttpRequest();
    var url = 'data/AABS/' + src;
    xhr.open('GET', url);
    xhr.overrideMimeType('application/json');
    xhr.onload = function () {
      if (xhr.status < 400) {
        AlphaABS.jDATA[name] = JSON.parse(xhr.responseText);
      }
    };
    xhr.onerror = function () {

    };
    AlphaABS.jDATA[name] = null;
    xhr.send();
  };

  //END DataManager
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  _.isItemHaveHPEffect = function(item) {
    return _.isItemHaveEffectWithCode(item, 11);
  };
  _.isItemHaveMPEffect = function(item) {
    return _.isItemHaveEffectWithCode(item, 12);
  };
  _.isItemHaveTPEffect = function(item) {
    return _.isItemHaveEffectWithCode(item, 13);
  };
  _.isItemHaveEffectWithCode = function(item, effectCode) {
    return _.isItem(item) && item.effects.some(function(e) {
      return e.code === effectCode;
    });
  };
  _.getItemWeight = function(item) {
    var e, w;
    if (item.weight != null) {
      return item.weight;
    } else {
      w = AA.Utils.getValueFromMeta("weight", item);
      if (w == null) {
        if (DataManager.isItem(item) && item.itypeId === 2) {
          item.weight = 0;
        } else {
          item.weight = 1;
        }
      } else {
        try {
          item.weight = Number(w);
        } catch (error) {
          e = error;
          AA.warning(e);
          item.weight = 1;
        }
      }
      return _.getItemWeight(item);
    }
  };
  _.getItemInvImage = function(item) {
    var img;
    if (!AA.isPro()) {
      return null;
    }
    if (item.iImg != null) {
      return item.iImg;
    } else {
      img = AA.Utils.getValueFromMeta("iImg", item);
      if (img == null) {
        item.iImg = "";
      } else {
        item.iImg = img;
      }
      return item.iImg;
    }
  };
  _.getItemQualityLevel = function(item) {
    var e, q;
    if (item.qLevel != null) {
      return item.qLevel;
    } else {
      q = AA.Utils.getValueFromMeta("itemRare", item);
      if (q == null) {
        item.qLevel = 0;
      } else {
        try {
          item.qLevel = Number(q);
        } catch (error) {
          e = error;
          console.warn(e);
          item.qLevel = 0;
        }
      }
      return _.getItemQualityLevel(item);
    }
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager_PRO.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _alias_DataManager_setupNewGame4342432424324234 = DataManager.setupNewGame;
    DataManager.setupNewGame = function () {
        _alias_DataManager_setupNewGame4342432424324234.call(this);
        try {
            if (Utils.isNwjs()) {
                FontLoadManager.init();
                FontLoadManager.loadAll();
            }
        } catch (error) {
            FontLoadManager._ready = true;
            AlphaABS.warning(error, 'while load text fonts');
        }
    };
})();
// ■ END DataManager_PRO.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension DefTowers Entity.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var DefEntity;
  DefEntity = class DefEntity {
    constructor(data, evId) {
      this.data = data;
      this.evId = evId;
      this._isProperData = false;
      this._state = 0;
      this._statesTimers = [];
      this.resetRoute();
      this._checkData();
      this._init();
    }

    _checkData() {
      var e;
      if (this.data.skillId <= 0) {
        return;
      }
      if (this.data.enemyId <= 0) {
        return;
      }
      try {
        this._skill = new Game_SkillABS(this.data.skillId, false);
        if (this._skill.isRadiusTypeR() || this._skill.isVectorTypeR() || this._skill.isNeedAmmo() || this._skill.isSpecialTeleportType()) {
          AA.warning('Defense Tower skill config not supported: ' + this._skill.skill().name);
          return;
        }
        if (!this._skill.isRadiusType() && !this._skill.isZoneType() && !this._skill.isNeedTarget()) {
          AA.warning('Defense Tower skill config not supported: ' + this._skill.skill().name + " Check Skill Scope");
          return;
        }
        this._subject = new Game_EnemyABS(this.data.enemyId);
        this._subject._actions = [new Game_Action(this._subject)];
        this._subject.action(0).setSkill(this.data.skillId);
        this._subject.__towerAbsSkill = this._skill;
        this._subject.skillABS_byAction = function() {
          return this.__towerAbsSkill;
        };
      } catch (error) {
        //console.info(@_skill)
        e = error;
        AA.warning(e);
        this._isProperData = false;
        return;
      }
      return this._isProperData = true;
    }

    _init() {
      this._statesTimers.push(new AATimedUpdate(30, this._onUpdateTTick.bind(this)));
      this._behav = {};
      this._behav.viewRadius = this._skill.range;
      return this._behav.ignoreObstacles = this._skill.isIgnoreObstacles();
    }

    isProperData() {
      return this._isProperData === true;
    }

    update() {
      this._updateBasic();
      if (this._state === 0) {
        this._updateInFree();
      }
      if (this._state === 1) {
        this._updateInAction();
      }
      if (this._state === 2) {
        return this._updateOnCast();
      }
    }

    _updateBasic() {
      return this._skill.update();
    }

    _updateInFree() {
      if (this._isReadyToSearch === true && this._isSkillIsReady()) {
        return this._statesTimers[0].update();
      }
    }

    _onUpdateTTick() {
      this._refreshPlacement();
      this._target = this._getPossibleTarget();
      if (this._target == null) {
        return;
      }
      //"TARGET FOUND".pe()
      return this._changeStateTo(1);
    }

    _getPossibleTarget() {
      this.candidates = AA.LIBS.AILogicManager.getAllInRangeByScope(this, this.data.scope);
      if (this.candidates.length > 0) {
        return this.candidates.sample();
      } else {
        return null;
      }
    }

    _changeStateTo(index) {
      this._state = index;
      if (this._state === 0) {
        this._target = null;
        return;
      }
      if (this._state === 2) {
        this._isCanStartR = true;
        if (this._skill.isCasting() && this._skill.isReady()) {
          return this._executeAttack();
        } else {
          this._skill.startCast(this.battler());
          return this._performCastMotion();
        }
      }
    }

    _updateInAction() {
      if (this._isTargetStillPropper()) {
        if (this._isSkillIsReady()) {
          if (this._isSkillIsNeedCast()) {
            return this._changeStateTo(2); //?CAST
          } else {
            return this._executeAttack();
          }
        } else {
          return this._waitSkillReady();
        }
      } else {
        //"NO PROPER TARGET".p()
        return this._onAttackDone();
      }
    }

    _isTargetStillPropper() {
      return (this.target() != null) && AA.AILogicManager.inActionRange(this) && AA.BattleManagerABS.isValidTarget(this.target());
    }

    _isSkillIsReady() {
      return AA.AILogicManager.canUseActionNow(this) && this._canUseSkillNow();
    }

    _canUseSkillNow() {
      var isHard, result;
      if (this._skill.isVectorType() && this._skill.isNoTarget() && (this.target() != null)) {
        result = this.battler().canUse(this._skill.skill());
        if (this._skill.isDirectionFix()) {
          isHard = AlphaABS.UTILS.inDirectionHard(this, this.target());
          return isHard && result;
        }
        return result;
      } else {
        return this.battler().canUse(this._skill.skill());
      }
    }

    _isSkillIsNeedCast() {
      return this._skill.isNeedCast();
    }

    _updateOnCast() {
      var action;
      action = this._skill;
      if ((action != null) && action.isCasting()) {
        if (this._isTargetStillPropper()) {
          if (action.isReady()) {
            this._executeAttack();
          }
        } else {
          action.resetCast();
          this._stopCastMotion();
          return this._onAttackDone();
        }
      } else {
        this._stopCastMotion();
        return this._onAttackDone();
      }
    }

    _stopCastMotion() {
      return this.event().isCasting = function() {
        return false;
      };
    }

    _performCastMotion() {
      return this.event().isCasting = function() {
        return true;
      };
    }

    _executeAttack() {
      this._isCanStartR = true;
      if (this.isReadyForAttack()) {
        this._performAttack();
        //if @isAttackDone()
        return this._onAttackDone();
      }
    }

    _performAttack() {
      var action, process, target;
      //"ATTACK".pe()
      //@battler().action()
      this._stopCastMotion();
      process = AlphaABS.BattleManagerABS.battleProcess();
      if (this._skill.isVectorType()) {
        action = this.battler().action(0);
        target = this.target();
        if (this._skill.isNoTarget()) {
          target = AlphaABS.UTILS.getEndPointFromCharToRange(this, this._skill.range);
        }
        process.startPostBattleAction(this, target, action, this._skill);
      } else if (this._skill.isRadiusType()) {
        process.setForceTargetsForZoneAndRadius(this.candidates);
        process.performBattleActionRadius(this, this.toPoint(), this.battler().action(0), this._skill);
      } else if (this._skill.isZoneType()) {
        process.setForceTargetsForZoneAndRadius(this.candidates);
        process.performBattleActionZone(this, this.battler().action(0));
      } else if (this._skill.isNeedTarget()) {
        process.performBattleAction(this, this.target());
      }
      process.setForceTargetsForZoneAndRadius(null);
      this.currentAction().playStartSound(this.toPoint());
      return this.battler().performCurrentAction();
    }

    //isAttackDone: -> true
    _onAttackDone() {
      this._isCanContR = true;
      this._isReadyToAttack = false;
      return this._changeStateTo(0);
    }

    _waitSkillReady() {}

    isDefenseTower() {
      return true;
    }

    // * FOR METHODS COMABILITY
    behaviorModel() {
      return this._behav;
    }

    isSummonUnit() {
      return false;
    }

    toPoint() {
      return this.event().toPoint();
    }

    teamId() {
      if (this.data.scope === 1) {
        return 0;
      }
      return -1;
    }

    setReadyToAttack() {
      if (this._isTargetStillPropper()) {
        this._isReadyToAttack = true;
        this._isCanContR = false;
        return this._isReadyToSearch = false;
      }
    }

    isCanContinueRoute() {
      return this._isCanContR === true;
    }

    isCanStartRoute() {
      return this._isCanStartR === true;
    }

    isReadyForAttack() {
      return this._isReadyToAttack === true;
    }

    resetRoute() {
      this._isCanStartR = false;
      this._isCanContR = false;
      this._isReadyToAttack = false;
      return this._isReadyToSearch = true;
    }

    event() {
      return $gameMap.event(this.evId);
    }

    currentAction() {
      return this._skill;
    }

    target() {
      return this._target;
    }

    battler() {
      return this._subject;
    }

    direction() {
      return this.dir;
    }

    turnTowardTarget() {} //*EMPTY

    inActive() {
      return false;
    }

    terminate() {
      var e, ref;
      try {
        if (this._state === 2) {
          if ((ref = this.event().findMySprite(true)) != null) {
            ref.__removeCastingAnim();
          }
        }
      } catch (error) {
        e = error;
        AA.warning(e);
      }
      return this.event().isCasting = function() {
        return false;
      };
    }

    _refreshPlacement() {
      var p;
      p = this.toPoint();
      if (this.dir == null) {
        this.dir = this.event().direction();
      }
      this.x = p.x;
      return this.y = p.y;
    }

  };
  AA.register(DefEntity);
})();

// ■ END Extension DefTowers Entity.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extensing Defense Towers Sprite Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_UPD, _;
  _ = Sprite_Character.prototype;
  ALIAS_UPD = _.updateOther;
  _.updateOther = function() {
    ALIAS_UPD.call(this);
    if (this._character._aaDefEntity == null) {
      return;
    }
    return this.__setupCasting();
  };
  _.__setupCasting = function() {
    if (this._character.isCasting()) {
      if (this.__castAnim == null) {
        this.__createCastAnim();
      }
      if (!this.__castAnim.isPlaying()) {
        this.__removeCastingAnim();
        return this.__createCastAnim();
      }
    } else {
      this.__castAnimAudio = false;
      if (this.__castAnim != null) {
        return this.__removeCastingAnim();
      }
    }
  };
  _.__createCastAnim = function() {
    var anim, dbAnim;
    if (this.__castAnim != null) {
      return;
    }
    this.__castAnim = new Sprite_Animation();
    dbAnim = this._character.battler().currentAction().castAnim;
    if (dbAnim > 0) {
      anim = $dataAnimations[dbAnim];
    } else {
      anim = AlphaABS.Parameters.get_CastAnimation();
    }
    this.__castAnim.setup(this._effectTarget, anim, false, 0);
    this.__castAnim.setABSMode();
    this.parent.addChild(this.__castAnim);
    if (this.__castAnimAudio === false) {
      this.__createCastAudio(dbAnim > 0);
    }
  };
  _.__createCastAudio = function(isOwnAnim) {
    var point, se;
    if (isOwnAnim === true) {
      return;
    }
    se = AlphaABS.Parameters.get_CastAnimationSE();
    point = this._character.toPoint();
    if (BattleManagerABS.isABSAudio()) {
      AudioManager.playSeAt(se, point.mapPointOnScreen());
    } else {
      AudioManager.playSe(se);
    }
    this.__castAnimAudio = true;
  };
  _.__removeCastingAnim = function() {
    if (this.__castAnim == null) {
      return;
    }
    this.__castAnim.remove();
    return this.__castAnim = null;
  };
})();

// ■ END Extensing Defense Towers Sprite Character.coffee
//---------------------------------------------------------------------------
//_.__clearCastAnim = ->
//    @__removeCastingAnim()

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Charcter.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {

    //@[DEFINES]
    var _ = Sprite_Character.prototype;

    //@[ALIAS]
    var _alias_Sprite_Character_update = Sprite_Character.prototype.update;
    Sprite_Character.prototype.update = function () {
        _alias_Sprite_Character_update.call(this, ...arguments);
        this._updateAA_Addon();
    };

    //@[ALIAS]
    var _alias__initMembers = _.initMembers;
    _.initMembers = function () {
        _alias__initMembers.call(this, ...arguments);
        this._initABSAddonThread();
    };

})();
// ■ END Sprite_Charcter.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ EventInfoExtension.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {

    var MYP_EHI = {};

    AA.EventInfoExtension = MYP_EHI;

    MYP_EHI.FOLDER_NAME = 'pictures';

    MYP_EHI.printError = function (error, message) {
        AA.warning(error, message);
        console.error(error);
    };

    MYP_EHI.GLOBAL_KEY_NOTE = 'pictureHint';
    MYP_EHI.GLOBAL_KEY_MSG = 'messageHint';
    MYP_EHI.GLOBAL_KEY_MSG_AUTO = 'autoHint';
    MYP_EHI.MARGINX = 0;
    MYP_EHI.MARGINY = 0;

    MYP_EHI.PIXELS_PER_SIZE = 6;
    MYP_EHI.TIME_TO_SHOW = 30;

    // * MYP_EHI MODULE ========================================================
    (function () {
        MYP_EHI.getEventUnderCursor = function () {
            try {
                var x = $gameMap.canvasToMapX(TouchInput.x);
                var y = $gameMap.canvasToMapY(TouchInput.y);
                var events = $gameMap.eventsXy(x, y);
                if (events.length > 0)
                    return events[0];
            } catch (error) {
                MYP_EHI.printError(error, 'getEventUnderCursor');
            }
            return null;
        };

        MYP_EHI.isEventWithPictureUnderCursor = function () {
            var event = MYP_EHI.getEventUnderCursor();
            if (event != null) {
                return event._MYP_HasHintImg() || event._MYP_HasHintMessage();
            }
            return false;
        };

        MYP_EHI.isEventWithAutoMessageUnderCursor = function () {
            var event = MYP_EHI.getEventUnderCursorX();
            if (event != null) {
                return event._MYP_HasHintMessageAuto();
            }
            return false;
        };

        MYP_EHI.getEventUnderCursorX = function () {
            try {
                var x = $gameMap.canvasToMapX(TouchInput.getMousePosition().x);
                var y = $gameMap.canvasToMapY(TouchInput.getMousePosition().y);
                var events = $gameMap.eventsXy(x, y);
                if (events.length > 0)
                    return events[0];
            } catch (error) {
                MYP_EHI.printError(error, 'getEventUnderCursorX');
            }
            return null;
        };

        MYP_EHI.applyStaticAnchor = function (sprite) {
            try {
                var mx = TouchInput.x;
                var my = TouchInput.y;
                var dx = 0;
                var dy = 0;
                if (sprite.width + mx + 5 > Graphics._boxWidth) {
                    dx = 1;
                }
                if (sprite.height + my + 5 > Graphics._boxHeight) {
                    dy = 1;
                }
                sprite.setStaticAnchor(dx, dy);
            } catch (error) {
                MYP_EHI.printError(error, 'applyStaticAnchor');
            }
        };

        MYP_EHI.loadHintImage = function (filename) {
            return ImageManager.loadBitmap('img/' + MYP_EHI.FOLDER_NAME + '/', filename, null, true);
        };


        MYP_EHI._getPxForSymbol = function () {
            return MYP_EHI.PIXELS_PER_SIZE;
        };
    })();

    // * TOUCH INPUT ===========================================================
    (function () {
        //?[NEW]
        TouchInput.isPressed2 = function () {
            return this._mouse2Pressed;
        };

        //@[ALIAS]
        var _alias_TouchInput__onRightButtonDown = TouchInput._onRightButtonDown;
        TouchInput._onRightButtonDown = function (event) {
            _alias_TouchInput__onRightButtonDown.call(this, event);
            var x = Graphics.pageToCanvasX(event.pageX);
            var y = Graphics.pageToCanvasY(event.pageY);
            if (Graphics.isInsideCanvas(x, y)) {
                this._mouse2Pressed = true;
                this._pressedTime = 0;
            }
        };

        //@[ALIAS]
        var _alias_TouchInput__onMouseUp = TouchInput._onMouseUp;
        TouchInput._onMouseUp = function (event) {
            _alias_TouchInput__onMouseUp.call(this, event);
            if (event.button === 2) {
                this._mouse2Pressed = false;
            }
        };
    })();

    // * GAME EVENT ============================================================
    (function () {
        //@[ALIAS]
        var _alias_Game_Event_initialize_2654 = Game_Event.prototype.initialize;
        Game_Event.prototype.initialize = function (mapId, eventId) {
            _alias_Game_Event_initialize_2654.call(this, mapId, eventId);
            this._MYP_checkPictureNote();
        };

        //?[NEW]
        Game_Event.prototype._MYP_checkPictureNote = function () {
            try {
                if (!this.page()) return;
                this._MYP_MyHintImage = null;
                this._MYP_MyHintMessage = null;
                this._MYP_MyHintAuto = false;
                var list = this.list();
                if (list && list.length > 1) {
                    var i = 0;
                    while (i < list.length) {
                        var item = list[i++];
                        if (!item) continue;
                        if (item.code == 108) {
                            var itemFinded = false;

                            var comment = item.parameters[0];
                            if (comment.contains(MYP_EHI.GLOBAL_KEY_NOTE)) {
                                var items = comment.split(' ');
                                if (items[1] != null) {
                                    this._MYP_MyHintImage = items[1];
                                    itemFinded = true;
                                } else {
                                    this._MYP_MyHintImage = null;
                                }
                            }
                            if (itemFinded == false) {
                                if (comment.contains(MYP_EHI.GLOBAL_KEY_MSG)) {
                                    var items = comment.split(' ');
                                    if (items[1] != null) {
                                        this._MYP_MyHintMessage = AAJsonSettings.getEventHintData(items[1]);
                                        itemFinded = true;
                                    } else {
                                        this._MYP_MyHintMessage = null;
                                        this._MYP_MyHintAuto = false;
                                    }
                                }
                                // * AUTO TURNED OFF
                                /*if (itemFinded == false && comment.contains(MYP_EHI.GLOBAL_KEY_MSG_AUTO)) {
                                    var items = comment.split(' ');
                                    if (items[1] != null) {
                                        this._MYP_MyHintMessage = AAJsonSettings.getEventHintData(items[1]);
                                        if (this._MYP_MyHintMessage != null) {
                                            this._MYP_MyHintAuto = true;
                                        }
                                    } else {
                                        this._MYP_MyHintAuto = false;
                                        this._MYP_MyHintMessage = null;
                                    }
                                }*/
                            }
                        }
                    }
                }
            } catch (e) {
                MYP_EHI.printError(e, 'error while redd event comments');
            }
        };

        //@[ALIAS]
        var _alias_Game_Event_setupPage = Game_Event.prototype.setupPage;
        Game_Event.prototype.setupPage = function () {
            _alias_Game_Event_setupPage.call(this);
            this._MYP_checkPictureNote();
        };


        //?[NEW]
        Game_Event.prototype._MYP_HasHintImg = function () {
            return (this._MYP_GetHintImage() != null) && (this.findProperPageIndex() != -1);
        };

        //?[NEW]
        Game_Event.prototype._MYP_HasHintMessage = function () {
            return (this._MYP_GetHintMessage() != null) && (this.findProperPageIndex() != -1);
        };

        //?[NEW]
        Game_Event.prototype._MYP_HasHintMessageAuto = function () {
            return this._MYP_HasHintMessage() && this._MYP_MyHintAuto === true;
        };

        //?[NEW]
        Game_Event.prototype._MYP_GetHintImage = function () {
            return this._MYP_MyHintImage;
        };

        //?[NEW]
        Game_Event.prototype._MYP_GetHintMessage = function () {
            return this._MYP_MyHintMessage;
        };
    })();

    // * SCENE MAP ============================================================
    (function () {
        //@[ALIAS]
        var _alias_Scene_Map_update = Scene_Map.prototype.update;
        Scene_Map.prototype.update = function () {
            _alias_Scene_Map_update.call(this);
            try {
                if ($gameMessage.isBusy()) {
                    this._MYP_HideEventHintImage();
                    this._MYP_HideEventHintMessage();
                    return;
                }
                if (MYP_EHI.isEventWithAutoMessageUnderCursor()) {
                    if (this._MYP_EventPressOn == true)
                        return;
                    if (this._myp_hintMessage == null) {
                        this._MYP_ShowEventHintMessage();
                    } else {
                        var ev = MYP_EHI.getEventUnderCursorX();
                        if (this._MYP_lastAutoEventMsg != ev) {
                            this._MYP_HideEventHintMessage();
                            this._MYP_ShowEventHintMessage();
                        }
                    }
                    return;
                }
                if (TouchInput.isPressed2()) {
                    if (MYP_EHI.isEventWithPictureUnderCursor()) {
                        if (!this._MYP_EventPressOn) {
                            this._MYP_EventPressOn = true;
                            this._MYP_ShowEventHintImage();
                            this._MYP_ShowEventHintMessage();
                        }
                    }
                } else {
                    if (this._MYP_EventPressOn == true) {
                        this._MYP_EventPressOn = false;
                        this._MYP_HideEventHintImage();
                        this._MYP_HideEventHintMessage();
                    }
                    if (this._myp_hintMessage != null) {
                        this._MYP_HideEventHintMessage();
                    }
                }
            } catch (error) {
                MYP_EHI.printError(error, 'error while right mouse click');
            }

        };

        //?[NEW]
        Scene_Map.prototype._MYP_ShowEventHintImage = function () {
            try {
                var ev = MYP_EHI.getEventUnderCursor();
                if (this._myp_hintSprite != null)
                    this._MYP_HideEventHintImage();
                var img = ev._MYP_GetHintImage();
                if (img == null) {
                    return;
                }
                this._myp_hintSprite = new Sprite(MYP_EHI.loadHintImage(img));
                var x = TouchInput.x;
                var y = TouchInput.y;
                this._myp_hintSprite.move(x, y);
                this._myp_hintSprite.bitmap.addLoadListener(function () {
                    MYP_EHI.applyStaticAnchor(this._myp_hintSprite);
                }.bind(this));
                this.addChild(this._myp_hintSprite);
            } catch (error) {
                MYP_EHI.printError(error, 'error while create hint image sprite');
                this._MYP_HideEventHintImage();
            }
        };

        //?[NEW]
        Scene_Map.prototype._MYP_ShowEventHintMessage = function () {
            try {
                var ev = MYP_EHI.getEventUnderCursorX();
                this._MYP_lastAutoEventMsg = ev;
                if (ev == null)
                    return;
                if (this._myp_hintMessage != null)
                    this._MYP_HideEventHintMessage();
                var msg = ev._MYP_GetHintMessage();
                if (msg == null) {
                    return;
                }
                var rect = this._MYP_CalculateWindowSize(msg);
                this._myp_hintMessage = new AA.LIBS.Window_EventInfo(msg, rect.width, rect.height);
                this._MYP_ConfigurateMessageWindowPosition(this._myp_hintMessage);
                this.addChild(this._myp_hintMessage);
            } catch (error) {
                MYP_EHI.printError(error, 'error while create hint message');
                this._MYP_HideEventHintMessage();
            }
        };

        //?[NEW]
        Scene_Map.prototype._MYP_CalculateWindowSize = function (infoData) {

            if (infoData.isManualSize == true) {
                return {
                    width: infoData.width,
                    height: infoData.height
                };
            }

            var size = {
                width: 200,
                height: 200
            };

            try {
                var text = infoData.text;
                if (text != null) {
                    var parts = text.split("\n");
                    var maxL = 0;
                    var maxIcs = 0;
                    parts.forEach(function (part) {
                        if (maxL < part.length) {
                            maxL = part.length;
                        }
                        if (part.contains('\i[')) {
                            var iconsCount = (part.split("\i[").length - 1);
                            if (maxIcs < iconsCount) {
                                maxIcs = iconsCount;
                            }
                        }
                    });
                    var newW = (maxL * MYP_EHI._getPxForSymbol(infoData.textSize)) + 4;
                    if (maxIcs > 0) {
                        newW += (maxIcs * 34);
                    }

                    size.width = newW;

                    if (parts.length > 1)
                        size.height = parts.length * infoData.textSize * 4;
                    else
                        size.height = parts.length * infoData.textSize * 8;
                }

                size.width = size.width + infoData.width;
                size.height = size.height + infoData.height;
            } catch (e) {
                MYP_EHI.printError(e, ' while auto size calculate');
            }

            return size;
        };

        //?[NEW]
        Scene_Map.prototype._MYP_ConfigurateMessageWindowPosition = function (w) {
            if (w == null) return;
            var dx, dy, mx, my, w;
            mx = TouchInput.getMousePosition().x;
            my = TouchInput.getMousePosition().y;
            dx = 0;
            dy = 0;
            if (w.width + mx + 5 > Graphics._boxWidth) {
                dx = 1;
            }
            if (w.height + my + 5 > Graphics._boxHeight) {
                dy = 1;
            }
            w.x = mx;
            w.y = my;
            w.setStaticAnchor(dx, dy);
        };

        //?[NEW]
        Scene_Map.prototype._MYP_HideEventHintImage = function () {
            try {
                if (this._myp_hintSprite != null) {
                    this.removeChild(this._myp_hintSprite);
                    this._myp_hintSprite.visible = false;
                    this._myp_hintSprite = null;
                }
            } catch (error) {
                MYP_EHI.printError(error, 'error while delete hint image sprite');
            }
        };

        //?[NEW]
        Scene_Map.prototype._MYP_HideEventHintMessage = function () {
            try {
                if (this._myp_hintMessage != null) {
                    this._myp_hintMessage.close();
                    this.removeChild(this._myp_hintMessage);
                    this._myp_hintMessage = null;
                }
            } catch (error) {
                MYP_EHI.printError(error, 'error while delete hint message');
            }
        };

        //@[ALIAS]
        var _alias_Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
        Scene_Map.prototype.onMapLoaded = function () {
            _alias_Scene_Map_onMapLoaded.call(this);
            $gameMap.events().forEach(function (event) {
                event._MYP_checkPictureNote();
            });
        };

    })();

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_EventInfo
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    (function () {
        var Window_EventInfo;
        Window_EventInfo = class Window_EventInfo extends Window_Base {
            constructor(infoData, wi, he) {
                super(0, 0, wi, he);
                this.infoData = infoData;
                this.openness = 0;
                this._setText();
                if (infoData.background >= 0) {
                    this.setBackgroundType(infoData.background);
                }
            }

            //$[OVER]
            _refreshFrame() {
                var w = this._width;
                var h = this._height;
                var m = 24;
                var bitmap = new Bitmap(w, h);

                this._windowFrameSprite.bitmap = bitmap;
                this._windowFrameSprite.setFrame(0, 0, w, h);

                if (w > 0 && h > 0 && this._windowskin) {
                    var skin = ImageManager.loadAA('WindowForHints');
                    var p = 96;
                    var q = 96;
                    bitmap.blt(skin, p + m, 0 + 0, p - m * 2, m, m, 0, w - m * 2, m);
                    bitmap.blt(skin, p + m, 0 + q - m, p - m * 2, m, m, h - m, w - m * 2, m);
                    bitmap.blt(skin, p + 0, 0 + m, m, p - m * 2, 0, m, m, h - m * 2);
                    bitmap.blt(skin, p + q - m, 0 + m, m, p - m * 2, w - m, m, m, h - m * 2);
                    bitmap.blt(skin, p + 0, 0 + 0, m, m, 0, 0, m, m);
                    bitmap.blt(skin, p + q - m, 0 + 0, m, m, w - m, 0, m, m);
                    bitmap.blt(skin, p + 0, 0 + q - m, m, m, 0, h - m, m, m);
                    bitmap.blt(skin, p + q - m, 0 + q - m, m, m, w - m, h - m, m, m);
                }
            };

            _setText() {
                var text = this.infoData.text;
                if (text != null) {
                    this.drawTextEx(text, 0, 0);
                }
            }

            update() {
                super.update();
                return this.updateOpennes();
            }

            updateOpennes() {
                if (this.openness >= 255) {
                    return;
                }
                return this.openness += 65;
            }

            setStaticAnchor(vx, vy) {
                this.x = this.x - Math.round(this.width * vx);
                this.y = this.y - Math.round(this.height * vy);
                this.refreshDimmerSprite();
            }

            dimColor1() {
                return 'rgba(0, 0, 0, 0.85)';
            }

            close() {
                this._destroyDimmer();
                Window_Base.prototype.close.call(this);
            }

            _destroyDimmer() {
                if (this._dimmerExtraFrames == true) {
                    if (this._dimmerSprite) {
                        this._dimmerSprite.visible = false;
                        if (this._dimmerSprite.parent)
                            this._dimmerSprite.parent.removeChild(this._dimmerSprite);
                    }
                }
            }

            _destroyDimmer2() {
                if ($gameTemp._extraDimmer) {
                    $gameTemp._extraDimmer.visible = false;
                    if ($gameTemp._extraDimmer.parent)
                        $gameTemp._extraDimmer.parent.removeChild($gameTemp._extraDimmer);
                }
            }

            //$[OVER]
            setBackgroundType(type) {
                this._destroyDimmer2();
                if (this._dimmerSprite) {
                    this._dimmerSprite.parent.removeChild(this._dimmerSprite);
                    this._dimmerSprite = null;
                }
                this._dimmerExtraBlack = false;
                this._dimmerExtraFrames = false;
                if (type <= 2)
                    Window_Base.prototype.setBackgroundType.call(this, type);
                else {
                    if (type == 3) {
                        this.opacity = 0;
                        this._dimmerExtraBlack = true;
                    } else { // * 4
                        this._dimmerExtraBlack = true;
                        this.opacity = 255;
                        this._dimmerExtraFrames = true;
                    }
                    this.showBackgroundDimmer();
                    if (this._dimmerExtraFrames == true) {
                        this._dimmerSprite.parent.removeChild(this._dimmerSprite);
                        SceneManager._scene.addChild(this._dimmerSprite);
                        this._destroyDimmer2();
                        $gameTemp._extraDimmer = this._dimmerSprite;
                        $gameTemp._extraDimmerHolder = this;
                    }
                }
            }

            refreshDimmerSprite() {
                if (this._dimmerExtraFrames == true) {
                    this._dimmerSprite.move(this.x, this.y);
                }
            }

            refreshDimmerSprite2(x, y) {
                if (this._dimmerExtraFrames == true) {
                    this._dimmerSprite.move(this.x + x, this.y + y);
                }
            }

            //$[OVER]
            refreshDimmerBitmap() {
                if (this._dimmerSprite) {
                    var bitmap = this._dimmerSprite.bitmap;
                    var w = this.width;
                    var h = this.height;
                    var m = this.padding;
                    var c1 = this.dimColor1();
                    if (this._dimmerExtraBlack == true) {
                        c1 = KDCore.Color.BLACK.CSS;
                    }
                    var c2 = this.dimColor2();
                    bitmap.resize(w, h);
                    /*bitmap.gradientFillRect(0, 0, w, m, c2, c1, true);
                    bitmap.fillRect(0, m, w, h - m * 2, c1);
                    bitmap.gradientFillRect(0, h - m, w, m, c1, c2, true);*/
                    if (this._dimmerExtraFrames == true) {
                        bitmap.fillRect(5, 5, w - 10, h - 10, c1);
                    } else
                        bitmap.fillRect(0, m, w, h - (m * 2), c1);
                    this._dimmerSprite.setFrame(0, 0, w, h);
                }
            }

        };
        AA.register(Window_EventInfo);
    })();

        // * SECTION 2 = HINTS IN TEXT ==================================================

        (function () {

            //@[DEFINE]
            var _ = Window_Message.prototype;

            //@[ALIAS]
            var _alias__startMessage = _.startMessage;
            _.startMessage = function () {
                this._tLinks = [];
                this._showLInfoTimer = 0;
                _alias__startMessage.call(this, ...arguments);
            };

            //@[ALIAS]
            var _alias__processEscapeCharacter = _.processEscapeCharacter;
            _.processEscapeCharacter = function (code, textState) {
                _alias__processEscapeCharacter.call(this, ...arguments);
                if (code == 'TM') {
                    this._workWithLink(textState);
                }
            };

            //@[ALIAS]
            var _alias__update = _.update;
            _.update = function () {
                _alias__update.call(this, ...arguments);
                if (!this._tLinks)
                    return;
                if (this.isAnyTLinkUnderMouse()) {
                    this._showLInfoTimer += 1;
                    if (this._showLInfoTimer >= MYP_EHI.TIME_TO_SHOW) {
                        this.__showLinkInfo();
                    }
                } else {
                    this._showLInfoTimer = 0;
                    this.__hideLinkInfo();
                }
            };

            //@[ALIAS]
            var _alias__terminateMessage = _.terminateMessage;
            _.terminateMessage = function () {
                _alias__terminateMessage.call(this);
                this.__hideLinkInfo();
                this.terminateTLinks();
                this._tLinks = null;
            };

        })();

        // Generated by CoffeeScript 2.3.1
        (function () {
            //@[DEFINE]
            var _ = Window_Message.prototype;
            _.isAnyTLinkUnderMouse = function () {
                if (!this._tLinks)
                    return false;
                var i, l, len, ref;
                ref = this._tLinks;
                for (i = 0, len = ref.length; i < len; i++) {
                    l = ref[i];
                    if (l.isMouseIn()) {
                        return true;
                    }
                }
                return false;
            };
            _.terminateTLinks = function () {
                if (!this._tLinks)
                    return;
                var i, l, len, ref, results;
                ref = this._tLinks;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    l = ref[i];
                    results.push(l.removeFromParent());
                }
                return results;
            };
            _._workWithLink = function (textState) {
                var value;
                value = this.obtainEscapeTextParam(textState);
                //console.info(value)
                if (value != "") {
                    //console.log("start")
                    return this._startLink(value, textState);
                } else {
                    ImageManager.loadAA('WindowForHints');
                    //console.log('end')
                    return this._stopLink(textState);
                }
            };
            _._startLink = function (value, textState) {
                if (this.__link == null) {
                    this.__link = {};
                    this.__link.startX = textState.x;
                    this.__link.y = textState.y;
                    this.__link.endX = 0;
                    this.__link.StartIndex = textState.index;
                    this.__link.EndIndex = 0;
                    return this.__link.Value = value;
                }
            };
            _._stopLink = function (textState) {
                if (this.__link == null) {
                    return;
                }
                this.__link.endX = textState.x;
                this.__link.EndIndex = textState.index;
                this.__createLinkZoneSprite();
                return this.__link = null;
            };
            _.__createLinkZoneSprite = function () {
                var h, spr, w;
                w = this.__link.endX - this.__link.startX;
                h = this.lineHeight();
                spr = new SpriteLink(w, h, this.__link.Value);
                spr.move(this.__link.startX + 20, this.__link.y + 20);
                //spr.bitmap.fillAll(KDCore.Color.RED);
                //spr.opacity = 100;
                this.addChild(spr);
                return this._tLinks.push(spr);
            };



            _.__showLinkInfo = function () {
                var info, size;
                info = this.__getInfoUnderMouse();
                if (info == null) {
                    return;
                }
                if (this.__lastLinkInfo === info) {
                    return;
                }
                var infoData = AAJsonSettings.getEventHintData(info);
                this.__hideLinkInfo();
                this.__lastLinkInfo = info;
                //size = MYP_EHI.ConfigurateWindowSize(infoData);
                size = Scene_Map.prototype._MYP_CalculateWindowSize.call(this, infoData);
                //console.info(size);
                this.__linkInfoWindow = new AA.LIBS.Window_EventInfo(infoData, size.width, size.height);
                this.__configurateLinkInfoWP(this.__linkInfoWindow);
                return SceneManager._scene.addChild(this.__linkInfoWindow);
            };
            _.__configurateLinkInfoWP = function (w) {
                Scene_Map.prototype._MYP_ConfigurateMessageWindowPosition.call(this, w);
            };

            _.__hideLinkInfo = function () {
                if (this.__linkInfoWindow == null) {
                    return;
                }
                this.__linkInfoWindow.close();
                this.__linkInfoWindow.parent.removeChild(this.__linkInfoWindow);
                this.__linkInfoWindow = null;
                return this.__lastLinkInfo = null;
            };


            _.__getInfoUnderMouse = function () {
                var i, l, len, ref;
                ref = this._tLinks;
                for (i = 0, len = ref.length; i < len; i++) {
                    l = ref[i];
                    if (l.isMouseIn()) {
                        return l.info;
                    }
                }
                return null;
            };

        })();

        (function () {
            var _;
            //@[DEFINES]
            _ = Window_Base.prototype;
            _.obtainEscapeTextParam = function (textState) {
                var arr;
                arr = /^\[(\w+)\]/.exec(textState.text.slice(textState.index));
                if (arr != null) {
                    textState.index += arr[0].length;
                    return arr[1];
                } else {
                    return '';
                }
            };
        })();


        // * SPRITE LINK =================================================================

        var SpriteLink;
        SpriteLink = class SpriteLink extends Sprite {
            constructor(w, h, info) {
                super(new Bitmap(w, h));
                this.info = info;
            }

            inPosition(point) {
                var rect, rx, ry;
                rx = KDCore.SDK.toGlobalCoord(this, 'x');
                ry = KDCore.SDK.toGlobalCoord(this, 'y');
                rect = new Rectangle(rx, ry, this.width, this.height);
                return this.inRect(point, rect);
            }

            inRect(point, rect) {
                var x2, y2;
                x2 = rect.x + rect.width;
                y2 = rect.y + rect.height;
                return point.x > rect.x && point.x < x2 && point.y < y2 && point.y > rect.y;
            }

            isMouseIn() {
                var p;
                p = TouchInput.getMousePosition();
                if (this.visible === true) {
                    return this.inPosition(p);
                } else {
                    return false;
                }
            }

            removeFromParent() {
                if (this.parent != null) {
                    return this.parent.removeChild(this);
                }
            }
        };

})();
// ■ END EventInfoExtension.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ EventSmallText_Extension.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {

    class PKD_Window_Message_Small extends Window_Message {
        constructor(sprParent) {
            super();
            this._textX = null;
            this._timeX = null;
            this._textSize = 0;
            this.sprParent = sprParent;

            this._popSprite = new Sprite(ImageManager.loadAA('windowPopUp'));
            this._popSprite.anchor.x = 0.5;
            this.addChild(this._popSprite);
        }

        setup(params) {
            if(params.party == false) {
                if(params.evId > 0)
                    this._event = $gameMap.event(params.evId);
                else
                    this._event = $gamePlayer;
            } else {
                if (params.evId > 0)
                    this._event = $gameParty.memberABSByActorId(params.evId);
                else
                    {
                        var candidates = $gameParty.aliveMembersABS();
                        if(candidates.length > 0) {
                            this._event = $gameParty.aliveMembersABS().sample();
                        } else {
                            this._event = null;
                        }
                    }
                if(this._event) {
                    if (!this._event.isAlive())
                        this._event = null;
                    else if (this._event.isTransparent())
                        this._event = null;
                }
            }
            this._timeX = 120; //params.time * 60;
            if(params.text.length > 20) {
                params.text = params.text.substring(0, 20);
            }
            this._pureText = params.text;
            if (Imported.YEP_MessageCore) {
                this._textX = '\\fs[12]' + params.text;
            } else
                this._textX = '\\}\\}\\}' + params.text;
            if(params.color >= 0)
                this._textX = '\\C[' + params.color + ']' + this._textX;
            this._terminated = false;
            this.sprParent.addChild(this);
            this.startMessage();
        }

        makeFontSmaller() {
            if (this.contents.fontSize >= 10) {
                this.contents.fontSize -= 4;
            }
        }

        windowWidth() {
            return 220;
        }

        windowHeight() {
            return 72;
        }

        numVisibleRows() {
            return 1;
        }

        calcMsgTextSize() {
            var l = this._pureText.length;
            var w2 = 30;

            if(l == 1) {
                w2 += 16;
            } else if(l > 1 && l < 7) {
                w2 += 8 * (l + 1);
            } else {
                w2 += 9 * (l + 1);
            }

            //var w = 30;

            //console.log(l)

            /*switch (l) {
                case 1:
                    w += 16;
                    break;
                case 2:
                    w += 24;
                    break;
                case 3:
                    w += 32;
                    break;
                case 4:
                    w += 40;
                    break;
                case 5:
                    w += 48;
                    break;
                case 6:
                    w += 54;
                    break;
            
                default:
                    w = 100;
                    break;
            }*/
            this.width = w2;
            //console.log(this.width);
        }

        canStart() {
            return (this._textX != null);
        }

        startMessage() {
            this._textState = {};
            this._textState.index = 0;
            this._textState.text = this.convertEscapeCharacters(this._textX);
            this.calcMsgTextSize();
            this.newPage(this._textState);
            this.updatePlacement();
            this.updateBackground();
            this.open();
        }

        update() {
            Window_Base.prototype.update.call(this);
            this.checkToNotClose();
            this.updatePlacement();
            while (!this.isOpening() && !this.isClosing()) {
                if (this.updateWait()) {
                    return;
                } else if (this.updateMessage()) {
                    return;
                } else if (this.canStart()) {
                    this.startMessage();
                } else {
                    return;
                }
            }
        }

        updateMessage() {
            if (this._textState) {
                while (!this.isEndOfText(this._textState)) {
                    this.processCharacter(this._textState);
                }
                if (this.isEndOfText(this._textState)) {
                    this.onEndOfText();
                }
                return true;
            } else {
                return false;
            }
        }

        updatePlacement() {
            if (this._event) {
                this.x = this._event.screenX() - this.width / 2;
                this.y = this._event.screenY() - (48 + this.height);
                this._popSprite.x = this.width / 2;
                this._popSprite.y = this.height;
            } else {
                this.x = -1000;
                this.y = -1000;
            }
        }

        updateBackground() {
            this.setBackgroundType(0);
        }

        onEndOfText() {
            if (this._timeX > 0)
                this._timeX -= 1;

            if (this._timeX <= 0) {
                this._textState = null;
                this.terminateMessage();
            }
        }

        isTerminated() {
            return (this._terminated === true);
        }

        terminateMessage() {
            this.close();
            this._popSprite.visible = false;
            this._textX = null;
            this._terminated = true;
            this.sprParent.removeChild(this);
            this.visible = false;
        }

    }

    AA.register(
        PKD_Window_Message_Small
    );

})();


(function(){
    
    //@[ALIAS]
    var _alias_Scene_Map_createAllWindows = Scene_Map.prototype.createAllWindows;
    Scene_Map.prototype.createAllWindows = function () {
        _alias_Scene_Map_createAllWindows.call(this);
        this.__layerForAAMiniMessages = new Sprite();
        this.addChild(this.__layerForAAMiniMessages);
    };

    //?[NEW]
    Scene_Map.prototype._showAAMiniMsg = function (params) {
        try {
            if (params != null) {
                if (params.text != null && params.text != "") {
                    if (params.evId > 0) {
                        if ($gameMap.event(params.evId) != null) {
                            var msgWindow = new AA.LIBS.PKD_Window_Message_Small(this.__layerForAAMiniMessages);
                            msgWindow.setup(params);
                        }
                    } else {
                        if(params.evId == 0) {
                            var msgWindow = new AA.LIBS.PKD_Window_Message_Small(this.__layerForAAMiniMessages);
                            msgWindow.setup(params);
                        }
                    }
                }
            }
        } catch (e) {
            AA.warning(e, 'Something wrong in Show Small Text command');
        }
    };

    //@[ALIAS]
    /*var _alias_Scene_Map_update = Scene_Map.prototype.update;
    Scene_Map.prototype.update = function () {
        _alias_Scene_Map_update.call(this);
        if (!this.__layerForAAMiniMessages)
            return;
        for(var i = 0; i<this.__layerForAAMiniMessages.children.length; i++) {
            var item = this.__layerForAAMiniMessages.children[i];
            if (item.isTerminated()) {
                this.__layerForAAMiniMessages.delete(item);
            }
        }
    };*/

})();

// ■ END EventSmallText_Extension.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.BattleUI;
  _.refreshTargetBarrierInfo = function(battler) {
    var ref;
    return (ref = this._ui) != null ? ref.refreshBarrierInfo(battler) : void 0;
  };
})();

// ■ END BatleUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AlphaABS.LIBS.AIStateBattle.prototype;
  _._updateSupportAction = function() {
    if (this._bot.inSupportPhase()) {
      return this._updateInSupportPhase();
    } else {
      return this._updateSupportPreapare();
    }
  };
  _._updateInSupportPhase = function() {};
  //debugger
  //"UPD IN SUPPORT PHASE".pe()
  _._updateSupportPreapare = function() {
    var e;
    if (!this._bot.isCanSupport()) {
      return;
    }
    if ($gameTemp._aaAIBotsInBattleGlobalCount <= 1) {
      return;
    }
    try {
      //"UPD SUPPORT".pe()
      if (this._bot.isAnyNeedToBeSupported()) {
        if (this._bot.isCanUseSupportSkillNow()) {
          this._startSupportPhase();
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  _._startSupportPhase = function() {
    return this._bot.activateSupportPhase();
  };
})();

// ■ END AIStateBattle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_AIBot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_AIBot.prototype;
  _._updateTPThread = function() {
    var ref;
    if (!this.isCanTeleport()) {
      return;
    }
    if ((ref = this._teleportThread) != null) {
      ref.update();
    }
  };
  _.isCanPerformTeleportNow = function() {
    return this.isCanTeleport() && this.isTeleportIsReady() && this.isTeleportPointExist();
  };
  _.isCanPerformTeleportOutNow = function() {
    return this.isCanTeleport() && this.isTeleportIsReady() && this.isTeleportOutPointExists();
  };
  _.isTeleportIsReady = function() {
    var t;
    if (this._teleportThread == null) {
      t = this.behaviorModel().teleportRest * 60;
      this._teleportThread = new AATimedUpdate(t, this._teleportThreadTick.bind(this));
      this._teleportThread.once();
      return this._isTeleportIsRateGood() && ($gameTemp._isAATeleportIsBusy == null);
    } else {
      return false;
    }
  };
  _._isTeleportIsRateGood = function() {
    var r, rate;
    rate = this.behaviorModel().teleportRate;
    if (rate < 100) {
      r = Math.random() * 100;
      if (r >= rate) {
        this.LOG.p('TP -> BAD rate %');
        return false;
      }
    }
    return true;
  };
  _._teleportThreadTick = function() {
    return this._teleportThread = null;
  };
  _.isTeleportPointExist = function() {
    var dist, e, points;
    try {
      //"IS TELEPORT EXISTS CALL".p()
      this._lastTpPoint = null;
      if (this.target() == null) {
        return false;
      }
      dist = AlphaABS.UTILS.distanceTo(this, this.target());
      if (dist <= 1) {
        return false;
      }
      //console.log("DIST " + dist)
      if (dist <= this.behaviorModel().teleportDist) {
        points = AA.AILogicManager.getAnyPointNearTarget(this);
        if (points.length > 0) {
          //console.info points
          this._lastTpPoint = this._findRandomAndProperPointForTeleport(points);
          return this._lastTpPoint != null;
        }
      } else {
        this.LOG.p('TP -> BAD distance');
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  };
  _.isTeleportOutPointExists = function() {
    var dist, e, points;
    try {
      //"IS TELEPORT OUT EXISTS CALL".p()
      this._lastTpPoint = null;
      if (this.target() == null) {
        return false;
      }
      dist = AlphaABS.UTILS.distanceTo(this, this.target());
      if (dist >= this.behaviorModel().teleportOut) {
        return false;
      }
      //console.log("DIST " + dist)
      points = AA.UTILS.GetCornerCirclePoints(this, this.behaviorModel().teleportOut);
      if (points.length > 0) {
        //console.info points
        this._lastTpPoint = this._findRandomAndProperPointForTeleport(points);
        return this._lastTpPoint != null;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  };
  _.isCanTeleport = function() {
    return this.behaviorModel().teleportDist > 0 || this.behaviorModel().teleportOut > 0;
  };
  _._findRandomAndProperPointForTeleport = function(points) {
    var goodPoints, i, len, p;
    goodPoints = [];
    for (i = 0, len = points.length; i < len; i++) {
      p = points[i];
      if (this.canPass(p.x, p.y, this.direction())) {
        goodPoints.push(p);
      }
    }
    if (goodPoints.length > 0) {
      //"GOOD POINTS".pe()
      //console.info(goodPoints)
      return goodPoints.sample();
    }
    return null;
  };
  _.performTeleportToTarget = function() {
    var e;
    try {
      if (this._lastTpPoint == null) {
        return;
      }
      this.performApproachToTarget();
      //console.info(@_lastTpPoint)
      this.LOG.p('TP -> Perform to Target');
      this.prepareSafeTeleport();
      this.performTeleportToPoint(this._lastTpPoint);
      this.turnTowardTarget();
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Чтобы боты не телепортировались одновременно, 1 секунда delay на карте
  _.prepareSafeTeleport = function() {
    $gameTemp._isAATeleportIsBusy = true;
    setTimeout((function() {
      var e;
      try {
        //"SAFE OFF".pe()
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._isAATeleportIsBusy = null : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }), 500);
  };
  _.performTeleportToPoint = function(point) {
    var animationId;
    if (point == null) {
      return;
    }
    //"PERFORM TP".pe()
    animationId = AlphaABS.Parameters.get_EnemyTeleportAnimationId();
    if (animationId > 0) {
      this.requestAnimationABS(animationId);
    }
    this.locate(point.x, point.y);
  };
  _.performTeleportFromTarget = function() {
    var e;
    try {
      if (this._lastTpPoint == null) {
        return;
      }
      this.LOG.p('TP -> Perform OUT');
      this.prepareSafeTeleport();
      this.performTeleportToPoint(this._lastTpPoint);
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
})();

// ■ END Game_AIBot.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_XXX_hideUI, _;
  //@[DEFINES]
  _ = AA.BattleUI;
  _.setExtraUI = function(eUI) {
    this.eUI = eUI;
  };
  _.isProcessEUITouch = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.isMouseInInventory() : void 0;
  };
  _.terminateEUI = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.terminate() : void 0;
  };
  _.invShowCategoryItems = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openCategory(0) : void 0;
  };
  _.invShowCategoryWeapons = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openCategory(1) : void 0;
  };
  _.invShowCategoryArmors = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openCategory(2) : void 0;
  };
  _.invShowCategoryKeyItems = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openCategory(3) : void 0;
  };
  _.refreshInventory = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.refreshInventory() : void 0;
  };
  _.openInventory = function() {
    var ref;
    this.closeWeaponCircle();
    if (AA.isPro()) {
      return (ref = this.eUI) != null ? ref.openInventory() : void 0;
    }
  };
  _.closeInventory = function() {
    var ref;
    if (AA.isPro()) {
      return (ref = this.eUI) != null ? ref.closeInventory() : void 0;
    }
  };
  _.openOrCloseInventory = function() {
    if (this.isInventoryOpened()) {
      return this.closeInventory();
    } else {
      return this.openInventory();
    }
  };
  _.isInventoryOpened = function() {
    var ref;
    if (AA.isPro()) {
      return (ref = this.eUI) != null ? ref.isInventoryOpen() : void 0;
    } else {
      return false;
    }
  };
  _.invShowNextPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showNextInvPage() : void 0;
  };
  _.invShowPrevPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showPrevInvPage() : void 0;
  };
  _.onInvCellClick = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.clickInvItem(index) : void 0;
  };
  _.onChestCellClick = function(index) {
    var ref;
    if (_.isChestIsOpen()) {
      if ((ref = this.eUI) != null) {
        ref.clickChestItem(index);
      }
    } else if (_.isUserChestIsOpen()) {
      this.eUI.clickUserChestItem(index);
    }
  };
  _.onInvHotKeyActive = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.activateHotKey(index) : void 0;
  };
  ALIAS_XXX_hideUI = _.hideUI;
  _.hideUI = function() {
    ALIAS_XXX_hideUI.call(this);
    return this.closeInventory();
  };
  _.IsInventoryWeaponFEKeyTriggered = function() {
    var index, ref;
    index = AlphaABS.LIBS.IKey.isTriggeredWeapCircleIndex();
    if (index != null) {
      return (ref = this.eUI) != null ? ref.activateFavKey(index) : void 0;
    } else {
      return false;
    }
  };
  _.isGameShouldPause = function() {
    if (!AA.isPro()) {
      return false;
    }
    if (!AA.Parameters.get_PauseGameWhenInventoryIsOpen()) {
      return false;
    }
    return this.isInventoryOpened() || this.isChestIsOpen() || this.isUserChestIsOpen() || this.isSkillWindowIsOpen() || this.isStatusWindowIsOpen();
  };
  // * ======================== CHEST ==================================
  _.openChest = function() {
    var ref;
    this.closeWeaponCircle();
    return (ref = this.eUI) != null ? ref.openMapChest() : void 0;
  };
  _.closeChest = function() {
    var e, ref, ref1, ref2;
    if ((ref = this.eUI) != null) {
      ref.closeMapChest();
    }
    try {
      if (this.isInventoryOpened() && ((ref1 = this.eUI) != null ? ref1.inventory.isSomeItemFocused() : void 0)) {
        return (ref2 = this.eUI) != null ? ref2.inventory.clearFocus() : void 0;
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.setChestName = function(name) {
    return $gameTemp.__aaChestName = name;
  };
  _.setChestLootIcon = function() {
    return $gameTemp.__aaChestIsLoot = true;
  };
  _.resetChestName = function() {
    return $gameTemp.__aaChestName = null;
  };
  _.isChestIsOpen = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.isChestOpen() : void 0;
  };
  _.takeAllFromChest = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.takeAllFromChest() : void 0;
  };
  _.chestShowNextPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showNextChestPage() : void 0;
  };
  _.chestShowPrevPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showPrevChestPage() : void 0;
  };
  // * ========================= USER CHEST ===========================
  _.openUserChest = function() {
    var ref;
    this.closeWeaponCircle();
    if (!_.isUserChestIsOpen()) {
      return (ref = this.eUI) != null ? ref.openUserChest() : void 0;
    }
  };
  _.closeUserChest = function() {
    var e, ref, ref1, ref2;
    if ((ref = this.eUI) != null) {
      ref.closeUserChest();
    }
    try {
      if (this.isInventoryOpened() && ((ref1 = this.eUI) != null ? ref1.inventory.isSomeItemFocused() : void 0)) {
        return (ref2 = this.eUI) != null ? ref2.inventory.clearFocus() : void 0;
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.isUserChestIsOpen = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.isUserChestOpen() : void 0;
  };
  _.refreshUserChest = function() {
    var ref;
    if (_.isUserChestIsOpen()) {
      if ((ref = this.eUI) != null) {
        ref.refreshUserChest();
      }
    }
  };
  _.userChestShowCategoryWeapons = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openUserChestCategory(1) : void 0;
  };
  _.userChestShowCategoryArmors = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openUserChestCategory(2) : void 0;
  };
  _.userChestShowCategoryItems = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openUserChestCategory(0) : void 0;
  };
  // * ============================ UPDATE 1.1 =========================
  _.onInvCellFocusedClick = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.clickInvFocusedItem(index) : void 0;
  };
  _.onInvPartyCellClick = function(actor) {
    var ref;
    return (ref = this.eUI) != null ? ref.clickInvPartyActor(actor) : void 0;
  };
  _.isPartyInventoryAllowed = function() {
    return AA.Parameters.get_MapInventoryAllowPartySelect() === true && AA.UI.partyGroup().length > 1;
  };
  _.isStoredChestIsOpen = function() {
    if (AA.Parameters.get_AllowUseStoredChestLikeStorage() === true) {
      return AA.UI.isChestIsOpen() && $gameTemp.__isStoredVisualChestShouldOpened === true;
    } else {
      return false;
    }
  };
  _.refreshStoredChest = function() {
    var ref;
    if (_.isStoredChestIsOpen()) {
      return (ref = this.eUI) != null ? ref.refreshStoredChest() : void 0;
    }
  };
  // * ============================ UPDATE 1.2 =========================

  // * ONLY 4
  _.partyGroup = function() {
    return $gameParty.battleMembers();
  };
  _.closeInventoryByClick = function() {
    if (this.eUI == null) {
      return;
    }
    if (this.eUI.inventory == null) {
      return;
    }
    if (this.eUI.inventory.isSomeItemFocused()) {
      return;
    }
    return this.eUI.closeInventory();
  };
  AA.UI = AA.BattleUI;
  // * ========================== SKILLS WINDOW =========================
  _.onSkillWindowCellClick = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.clickSkillWItem(index) : void 0;
  };
  _.skillsWPrevPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showPrevSkillWPage() : void 0;
  };
  _.skillsWNextPage = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.showNextSkillWPage() : void 0;
  };
  _.skillWindowShowCategory = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.openSkillCategory(index) : void 0;
  };
  _.isSkillWindowIsOpen = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.isSkillWindowIsOpen() : void 0;
  };
  _.onSkillHotKeyActive = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.activateHotKey(index) : void 0;
  };
  _.refreshSkillWindow = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.refreshSkillWindow() : void 0;
  };
  _.closeSkillWindow = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.closeSkillWindow() : void 0;
  };
  _.openSkillWindow = function() {
    var ref;
    return (ref = this.eUI) != null ? ref.openSkillWindow() : void 0;
  };
  _.closeSkillWindowByClick = function() {
    if (this.eUI == null) {
      return;
    }
    if (this.eUI.skills == null) {
      return;
    }
    if (this.eUI.skills.isSomeItemFocused()) {
      return;
    }
    return this.eUI.closeSkillWindow();
  };
  _.skillWActorClick = function(index) {
    var ref;
    return (ref = this.eUI) != null ? ref.clickSkillWActor(index) : void 0;
  };
  _.openOrCloseSkillWindow = function() {
    if (this.isSkillWindowIsOpen()) {
      return this.closeSkillWindow();
    } else {
      return this.openSkillWindow();
    }
  };
  // * ========================== STATUS WINDOW =========================
  _.openStatusWindow = function() {
    var ref;
    if (!AA.isPro()) {
      return;
    }
    return (ref = this.eUI) != null ? ref.openStatusWindow() : void 0;
  };
  _.closeStatusWindow = function() {
    var ref;
    if (!AA.isPro()) {
      return;
    }
    if (this.isStatusWindowIsOpen()) {
      return (ref = this.eUI) != null ? ref.closeStatusWindow() : void 0;
    }
  };
  _.openOrCloseStatusWindow = function() {
    if (!AA.isPro()) {
      return;
    }
    if (this.isStatusWindowIsOpen()) {
      return this.closeStatusWindow();
    } else {
      return this.openStatusWindow();
    }
  };
  _.isStatusWindowIsOpen = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.isStatusWindowIsOpen() : void 0;
  };
  _.refreshStatusWindow = function() {
    var ref;
    if (!AA.isPro()) {
      return;
    }
    if ((ref = this.eUI) != null) {
      ref.refreshStatusWindow();
    }
  };
  _.nextStatusWindowActor = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.nextStatusWindowActor() : void 0;
  };
  _.prevStatusWindowActor = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.prevStatusWindowActor() : void 0;
  };
  _.statusWindowInvShowPrevPage = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.statusWindowInvShowPrevPage() : void 0;
  };
  _.statusWindowInvShowNextPage = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.statusWindowInvShowNextPage() : void 0;
  };
  _.showStatusActorEquipCategory = function(index) {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.showStatusActorEquipCategory(index) : void 0;
  };
  _.onStatusInvCellClick = function(index) {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.onStatusInvCellClick(index) : void 0;
  };
  _.statusWindowInvOptimize = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.onStatusInvOptimize() : void 0;
  };
  _.statusWindowInvClear = function() {
    var ref;
    if (!AA.isPro()) {
      return false;
    }
    return (ref = this.eUI) != null ? ref.onStatusInvClear() : void 0;
  };
  // * ============================ UPDATE 1.3 =========================
  _.onSliderValueChanged = function(valuePercent) {
    return _.eUI.inventory.onSliderValueChanged(valuePercent);
  };
  _.onSliderChestValueChanged = function(valuePercent) {
    var ref;
    if (_.isUserChestIsOpen()) {
      return _.eUI.userChest.onSliderValueChanged(valuePercent);
    } else {
      return (ref = _.eUI.chest) != null ? ref.onSliderValueChanged(valuePercent) : void 0;
    }
  };
  _.onSliderOkClick = function() {
    if (_.isInventoryOpened()) {
      _.eUI.inventory.onSliderOkClick();
    }
  };
  _.onSliderChestOkClick = function() {
    var ref;
    if (_.isUserChestIsOpen()) {
      _.eUI.userChest.onSliderOkClick();
    } else {
      if ((ref = _.eUI.chest) != null) {
        ref.onSliderOkClick();
      }
    }
  };
  _.isUseSlider = function() {
    return AA.Parameters.get_IsUseMapInventorySlider() === true;
  };
  // * ============================ UPDATE 1.4 =========================
  _.requestWeigthNotify = function() {
    var ref, ref1;
    if (this.isInventoryOpened()) {
      return (ref = this.eUI) != null ? (ref1 = ref.inventory) != null ? ref1._executeNoWeightNotify() : void 0 : void 0;
    }
  };
  _.registerExtraMethods = function() {
    if (AA.Parameters.get_IsWSSlowDown() === true) {
      $gamePlayer.refreshInventoryWSpeedDebuff();
      Game_Player.prototype.realMoveSpeed = Game_Player.prototype.invRealMoveSpeed;
    }
    if (AA.Parameters.get_WSAutoState() <= 0) {
      Game_Party.prototype._refreshInventoryWAutoState = function() {}; // * EMTPY
      Game_Actor.prototype._updateInventoryWeightAutoState = function() {}; // * EMPTY
    }
    if (AA.Parameters.isIconImagesInDefaultWindows()) {
      return this.registerDrawImageIconMethods();
    }
  };
  // * ============================ UPDATE 1.5 =========================
  _.setChestItemTypeLimit = function(typesRaw) {
    var i, len, t, types;
    $gameTemp._visualChestRestrictionTypesRaw = typesRaw;
    types = typesRaw.split("|");
    for (i = 0, len = types.length; i < len; i++) {
      t = types[i];
      $gameTemp._visualChestRestrictionTypes.push(t);
    }
  };
  _.isHaveSomeTypeLimit = function() {
    var ref;
    if (AA.UI.isStoredChestIsOpen() && ((ref = $gameTemp._visualChestRestrictionTypes) != null ? ref.length : void 0) > 0) {
      return true;
    }
    return false;
  };
  _.isProperItemForTypeLimit = function(item) {
    var ref;
    if (((ref = item.meta) != null ? ref.aItemType : void 0) == null) {
      return false;
    }
    return $gameTemp._visualChestRestrictionTypes.some(function(t) {
      return t === item.meta.aItemType;
    });
  };
  // * ============================ UPDATE 1.7 =========================
  _.registerDrawImageIconMethods = function() {
    var _alias_Window_Base_drawIcon, _alias_Window_Base_drawItemName;
    _alias_Window_Base_drawItemName = Window_Base.prototype.drawItemName;
    Window_Base.prototype.drawItemName = function(item, x, y, width) {
      var _iconIndex;
      if (item == null) {
        return;
      }
      if (String.any(DataManager.getItemInvImage(item))) {
        // * field swapping
        _iconIndex = item.iconIndex;
        item.iconIndex = ImageManager.loadAA_Icon(item.iImg);
        _alias_Window_Base_drawItemName.call(this, item, x, y, width);
        item.iconIndex = _iconIndex;
      } else {
        _alias_Window_Base_drawItemName.call(this, item, x, y, width);
      }
    };
    _alias_Window_Base_drawIcon = Window_Base.prototype.drawIcon;
    Window_Base.prototype.drawIcon = function(iconIndex, x, y) {
      if (iconIndex instanceof Bitmap) {
        return this.contents.drawIcon(x, y, iconIndex, 32);
      } else {
        return _alias_Window_Base_drawIcon.call(this, iconIndex, x, y);
      }
    };
  };
  _.isGoldItem = function(item) {
    if (item == null) {
      return false;
    }
    if (AA.Parameters.get_GoldItemId() > 0) {
      return item.id === AA.Parameters.get_GoldItemId();
    } else {
      return false;
    }
  };
})();

// ■ END BattleUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Bitmap.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Bitmap.prototype;
  _.drawTriangle = function(w, h, color) {
    var context, sy;
    context = this._context;
    context.save();
    context.fillStyle = color;
    context.beginPath();
    sy = this.height / 2;
    context.moveTo(0, sy);
    context.lineTo(w, sy - h);
    context.lineTo(w, sy + h);
    context.lineTo(0, sy);
    context.fill();
    context.restore();
    this._setDirty();
  };
})();

// ■ END Bitmap.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ CStoredItems.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var CStoredItems;
  CStoredItems = class CStoredItems {
    constructor() {
      this.items = [];
    }

    putItem(item, count) {
      var exI, existsIndex, typeId;
      typeId = this._getItemTypeId(item);
      existsIndex = this._getIndexOfItem(item.id, typeId);
      if (existsIndex >= 0) {
        exI = this.items[existsIndex];
        return exI[1] = exI[1] + count;
      } else {
        return this.items.push([item.id, count, typeId]);
      }
    }

    _getIndexOfItem(itemId, typeId) {
      var i, id, index, j, len, ref, t;
      ref = this.items;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        i = ref[index];
        id = i[0];
        t = i[2];
        if (id === itemId && typeId === t) {
          return index;
        }
      }
      return -1;
    }

    _getItemTypeId(item) {
      var typeId;
      typeId = 0;
      if (DataManager.isWeapon(item)) {
        typeId = 1;
      } else if (DataManager.isArmor(item)) {
        typeId = 2;
      }
      return typeId;
    }

    removeType(typeId) {
      var i, item, j, ref;
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = this.items[i];
        if (item == null) {
          continue;
        }
        if (item[2] === typeId) {
          this.items[i] = null;
        }
      }
      this.items.delete(null);
    }

    removeItem(item, count) {
      var i, j, ref, typeId, x;
      typeId = this._getItemTypeId(item);
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        x = this.items[i];
        if (x[0] === item.id && x[2] === typeId) {
          x[1] = x[1] - count;
          if (x[1] <= 0) {
            this.items.splice(i, 1);
          }
          return;
        }
      }
    }

    getAllItems() {
      var i, j, len, ref, result;
      result = [];
      ref = this.items;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i[2] === 0) {
          result.push([$dataItems[i[0]], i[1]]);
        } else if (i[2] === 1) {
          result.push([$dataWeapons[i[0]], i[1]]);
        } else if (i[2] === 2) {
          result.push([$dataArmors[i[0]], i[1]]);
        }
      }
      return result;
    }

    static ConvertToMVItem(storedItem) {
      if (storedItem[2] === 0) {
        return $dataItems[storedItem[0]];
      } else if (storedItem[2] === 1) {
        return $dataItems[storedItem[0]];
      } else if (storedItem[2] === 2) {
        return $dataArmors[storedItem[0]];
      }
      return $dataItems[storedItem[0]];
    }

    getOnlyItems() {
      return this._getOnlyTypeId(0);
    }

    _getOnlyTypeId(typeId) {
      var i, j, len, ref, result, type;
      result = [];
      type = $dataItems;
      if (typeId === 1) {
        type = $dataWeapons;
      }
      if (typeId === 2) {
        type = $dataArmors;
      }
      ref = this.items;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i[2] === typeId) {
          result.push([type[i[0]], i[1]]);
        }
      }
      return result;
    }

    getOnlyWeapons() {
      return this._getOnlyTypeId(1);
    }

    getOnlyArmors() {
      return this._getOnlyTypeId(2);
    }

    static FromRawItems(items) {
      var c;
      c = new CStoredItems();
      c.items = items;
      return c;
    }

    static FromChestItems(items) {
      var c, i, j, len;
      c = new CStoredItems();
      for (j = 0, len = items.length; j < len; j++) {
        i = items[j];
        c.putItem(i[0], i[1]);
      }
      return c;
    }

  };
  AA.register(CStoredItems);
})();

// ■ END CStoredItems.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension Encounters MAIN.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_GP_EE;
  //@[ALIAS]
  ALIAS_GP_EE = Game_Player.prototype.executeEncounter;
  Game_Player.prototype.executeEncounter = function() {
    var angle, anim, dx, dy, e, inMap, newAi, plPoint, r, regionToSpawn, spawnEvId;
    if (AA.isABS()) { // * ALWAYS RETURN FALSE
      try {
        if (!$gameMap.isEventRunning() && this._encounterCount <= 0) {
          this.makeEncounterCount();
          spawnEvId = this.makeEncounterTroopId();
          //"ENCOUNTER".pe()
          if (spawnEvId > 0) {
            try {
              regionToSpawn = this.__getRegionIdForEncounter(spawnEvId);
            } catch (error) {
              e = error;
              AA.warning(e, 'Get proper Region from Encounter settings');
              regionToSpawn = 0;
            }
            //console.info(regionToSpawn)
            if (regionToSpawn !== 0) {
              uAPI.spawn(spawnEvId, regionToSpawn);
            } else {
              plPoint = this.toPoint();
              angle = Math.randomInt(360);
              r = AA.Parameters.get_EncounterSpawnRadius();
              dx = Math.round(plPoint.x + r * Math.cos(angle));
              dy = Math.round(plPoint.y + r * Math.sin(angle));
              inMap = dx > 0 && dx < $gameMap.width() && dy > 0 && dy < $gameMap.height();
              if (!inMap) {
                return false;
              }
              uAPI.spawn(spawnEvId, dx, dy);
            }
            $gameMap._onNewAAEncounter();
            anim = AA.Parameters.get_EnemyEncounterSpawnAnimationId();
            //anim = 45
            if (anim > 0) {
              try {
                newAi = $gameMap.events().last();
                if (newAi instanceof Game_SpawnedAiBot) {
                  newAi.requestAnimationABS(anim);
                }
              } catch (error) {
                e = error;
                AA.warning(e, ' when try play Encounter Spawn animation');
              }
            }
          }
          return false;
        } else {
          return false;
        }
      } catch (error) {
        e = error;
        AA.error(e, 'Execute Map Encounter');
        return false;
      }
    } else {
      return ALIAS_GP_EE.call(this);
    }
  };
  //?[NEW]
  Game_Player.prototype.__getRegionIdForEncounter = function(troopId) {
    var candidates, en, i, len, ref;
    candidates = [];
    ref = $gameMap.encounterList();
    for (i = 0, len = ref.length; i < len; i++) {
      en = ref[i];
      if (en.troopId === troopId) {
        if (en.regionSet.contains(this.regionId())) {
          candidates.push(...en.regionSet);
        }
      }
    }
    if (candidates.length === 0) {
      return 0;
    } else {
      return candidates.sample();
    }
  };
})();

// ■ END Encounters.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.initAAChestStorage();
    return this.initAAPlayerChestStorage();
  };
  _.initAAChestStorage = function() {
    return this._aaChestStorages = {};
  };
  _.initAAPlayerChestStorage = function() {
    return this._aaUserChestStorage = [];
  };
  _.aaRegisterStoredChest = function(mapId, eventId, storeItems) {
    if (this._aaChestStorages == null) {
      this.initAAChestStorage();
    }
    if (this._aaChestStorages[mapId] == null) {
      this._aaChestStorages[mapId] = {};
    }
    return this._aaChestStorages[mapId][eventId] = storeItems.items;
  };
  _.getItemsForStoredChest = function(mapId, eventId) {
    var itemsRaw;
    if (this._aaChestStorages == null) {
      this.initAAChestStorage();
    }
    if (this._aaChestStorages[mapId] != null) {
      if (this._aaChestStorages[mapId][eventId] != null) {
        itemsRaw = this._aaChestStorages[mapId][eventId];
        return AA.LIBS.CStoredItems.FromRawItems(itemsRaw);
      }
    }
    return null;
  };
  // * For visual loot revive
  _.resetStoredChest = function(mapId, eventId) {
    var e;
    if (this._aaChestStorages == null) {
      this.initAAChestStorage();
    }
    try {
      if (this._aaChestStorages[mapId] != null) {
        if (this._aaChestStorages[mapId][eventId] != null) {
          this._aaChestStorages[mapId][eventId] = null;
          delete this._aaChestStorages[mapId][eventId];
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  _.aaClearStoredChestOnMap = function(mapId) {
    if (this._aaChestStorages == null) {
      this.initAAChestStorage();
    }
    if (this._aaChestStorages[mapId] != null) {
      this._aaChestStorages[mapId] = {};
      delete this._aaChestStorages[mapId];
    }
  };
  _.aaGetPlayerChestStoredItems = function() {
    var sStored;
    if (this._aaUserChestStorage == null) {
      this.initAAPlayerChestStorage();
    }
    sStored = this.__getConvertedStoredItems();
    return sStored;
  };
  _.__getConvertedStoredItems = function() {
    return AA.LIBS.CStoredItems.FromRawItems(this._aaUserChestStorage);
  };
  _.addPutItemToPlayerChest = function(item, count) {
    var sStored;
    if (this._aaUserChestStorage == null) {
      this.initAAPlayerChestStorage();
    }
    sStored = this.__getConvertedStoredItems();
    sStored.putItem(item, count);
    AA.UI.refreshUserChest();
  };
  _.removeItemFromChestStorage = function(item, count) {
    var sStored;
    if (this._aaUserChestStorage == null) {
      this.initAAPlayerChestStorage();
    }
    sStored = this.__getConvertedStoredItems();
    sStored.removeItem(item, count);
    //console.info(sStored.items)
    this._aaUserChestStorage = sStored.items;
    AA.UI.refreshUserChest();
  };
  _.removeFullTypeFromChestStorage = function(typeId) {
    var sStored;
    if (this._aaUserChestStorage == null) {
      this.initAAPlayerChestStorage();
    }
    sStored = this.__getConvertedStoredItems();
    sStored.removeType(typeId);
    this._aaUserChestStorage = sStored.items;
    AA.UI.refreshUserChest();
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ScreenBloodSplatter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_GS_clear, ALIAS_GS_update, ALIAS_Spriteset_Base_USS, ALIAS_Spriteset_Base_createScreenSprites, _;
  _ = Game_Screen.prototype;
  ALIAS_GS_clear = _.clear;
  _.clear = function() {
    ALIAS_GS_clear.call(this);
    return this._resetBSEffect();
  };
  _._resetBSEffect = function() {
    this._bloodTimer = new AATimedUpdate(30, _._updateBloodSplatter.bind(this));
    this._bsInfo = null;
    return this.__needBlSpShow = false;
  };
  ALIAS_GS_update = _.update;
  _.update = function() {
    ALIAS_GS_update.call(this);
    if (this._bloodTimer != null) {
      this._bloodTimer.update();
      if (this._bloodTimer2 != null) {
        return this._bloodTimer2.update();
      }
    }
  };
  _._updateBloodSplatter = function() {
    if (AA.isABS()) {
      return this._updateOnABSMap();
    } else {
      if (this.__needBlSpShow === true) {
        return this._stopBloodPicture();
      }
    }
  };
  _._updateOnABSMap = function() {
    var color, e;
    if (AlphaABS.Parameters.get_AllowBloodSplatter() === false) {
      return;
    }
    if (this._bsInfo == null) {
      this._loadBloodSplaterInfo();
    }
    try {
      if ($gamePlayer.battler().hpRate() <= this._bsInfo.hp) {
        this._setBloodPicture();
        if (this._bsInfo.color != null) {
          if (this._bloodTimer2 == null) {
            color = this._bsInfo.color;
            this._bloodTimer2 = new AATimedUpdate(this._bsInfo.duration, function() {
              return $gameScreen.startFlash(color, 30);
            });
            this._bloodTimer2.once();
          }
          if (!this._bloodTimer2.isAlive()) {
            return this._bloodTimer2 = null;
          }
        }
      } else {
        return this._stopBloodPicture();
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Screen Blood Splatter - update');
      return this._bloodTimer.stop();
    }
  };
  _._loadBloodSplaterInfo = function() {
    return this._bsInfo = AlphaABS.Parameters.get_BloodSplatterParameters();
  };
  _._setBloodPicture = function() {
    if (this._bsInfo.pic != null) {
      return this.__needBlSpShow = true;
    }
  };
  _._stopBloodPicture = function() {
    return this.__needBlSpShow = false;
  };
  // =====================================================================
  ALIAS_Spriteset_Base_createScreenSprites = Spriteset_Base.prototype.createScreenSprites;
  Spriteset_Base.prototype.createScreenSprites = function() {
    this._bloodSplatterSpriteBase = new Sprite();
    this.addChild(this._bloodSplatterSpriteBase);
    return ALIAS_Spriteset_Base_createScreenSprites.call(this);
  };
  ALIAS_Spriteset_Base_USS = Spriteset_Base.prototype.updateScreenSprites;
  Spriteset_Base.prototype.updateScreenSprites = function() {
    var pic, ref, ref1;
    ALIAS_Spriteset_Base_USS.call(this);
    if ($gameScreen.__needBlSpShow === true) {
      if (this._bloodSplatterSprite == null) {
        if ($gameScreen._bsInfo.pic !== "") {
          pic = ImageManager.loadPicture($gameScreen._bsInfo.pic);
        } else {
          pic = ImageManager.loadEmptyBitmap();
        }
        this._bloodSplatterSprite = new Sprite(pic);
        return (ref = this._bloodSplatterSpriteBase) != null ? ref.addChild(this._bloodSplatterSprite) : void 0;
      }
    } else {
      if (this._bloodSplatterSprite != null) {
        if ((ref1 = this._bloodSplatterSpriteBase) != null) {
          ref1.removeChild(this._bloodSplatterSprite);
        }
        this._bloodSplatterSprite.visible = false;
        return this._bloodSplatterSprite = null;
      }
    }
  };
})();

// ■ END ScreenBloodSplatter.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DB_EditorMain.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

function AADBEditorManager() {
    throw new Error('This is a static class');
};

AADBEditorManager.init = function() {
    this._isAADBEditMode = false;
};

AADBEditorManager.openEnemiesEditor = function() {
    if (!AADBEditorManager.isSceneTitle() && !AA.Utils.isSceneMap()) return;
    if (this._isAADBEditMode) return;
    if (AA.isABS()) return;
    this._isAADBEditMode = true;
    SceneManager.push(Scene_AADBEnemiesEditor);
};


AADBEditorManager.closeEnemiesEditor = function() {
    this._isAADBEditMode = false;
    if (AADBEditorManager.isSceneEditorEnemy())
        SceneManager._scene.popScene();
};


AADBEditorManager.isSceneTitle = function() {
    return SceneManager._scene instanceof Scene_Title;
};

AADBEditorManager.isSceneEditorEnemy = function () {
    return SceneManager._scene instanceof Scene_AADBEnemiesEditor;
};

AADBEditorManager.saveEnemiesJsonData = function() {
    if (!$gameTemp._aaDBmodifiedEnemies) {
        return;
    }
    if ($gameTemp._aaDBmodifiedEnemies.length == 0) {
        return;
    }
    if(!Utils.isNwjs()) return;
    var data = JSON.stringify($dataEnemies, null, 2);
    let fs = require('fs');
    let path = require('path');
    let base = path.dirname(process.mainModule.filename);
    path = path.join(base, 'data/');
    var filePath = path + 'Enemies.json';
    fs.writeFileSync(filePath, data);
};

(function(){
    
    var _ = AADBEditorManager;

    _.onToggleParamValue = function(param) {
        SceneManager._scene.onToggleParamValue(param);
    };

    _.onResetParamValue = function(param) {
        SceneManager._scene.onResetParamValue(param);
    };

    _.onPlusParamValue = function(param) {
        SceneManager._scene.onPlusParamValue(param);
    };

    _.onMinusParamValue = function (param) {
        SceneManager._scene.onMinusParamValue(param);
    };

    _.onOptionParamValue = function(param) {
        SceneManager._scene.onOptionParamValue(param);
    };

    _.getAllFaceImages = function() {
        let fs = require('fs');
        let path = require('path');
        let base = path.dirname(process.mainModule.filename);
        let folderPath = path.join(base, 'img/faces/');
        var files = fs.readdirSync(folderPath);
        return files;
    };

})();
// ■ END DB_EditorMain.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

(function(){
    var _alias_Graphics_onKeyDown = Graphics._onKeyDown;
    Graphics._onKeyDown = function (event) {
        _alias_Graphics_onKeyDown.call(this, event);
        if (!event.ctrlKey && !event.altKey) {
            if (!$gameTemp) return;
            if (event.keyCode === 122) { // F11
                if (Utils.isNwjs() && Utils.isOptionValid('test'))
                    AADBEditorManager.openEnemiesEditor();
            }
        }
    };
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ExtDefTowers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var EDT;
  EDT = function() {
    throw new Error('This is static class');
  };
  EDT.searchDefSymbol = function(ev) {
    var comment, e, i, item, list, result, symbol;
    result = null;
    try {
      symbol = 'AADefenseEntity';
      if (ev.page() != null) {
        list = ev.list();
        if ((list != null) && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if ((item != null) && item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(symbol)) {
                result = comment;
              }
            }
          }
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'EDT.searchDefSymbol');
    }
    return result;
  };
  EDT.parseDefSymbol = function(symbol) {
    var d, e, parts;
    d = {};
    try {
      parts = symbol.split(":");
      d.skillId = Number(parts[1]);
      d.enemyId = Number(parts[2]);
      d.scope = Number(parts[3].substr(0, parts[3].length - 1));
      return d;
    } catch (error) {
      e = error;
      AA.warning(e, 'EDT.parseDefSymbol');
      return null;
    }
  };
  AA.EDT = EDT;
})();

// ■ END ExtDefTowers.coffee
//---------------------------------------------------------------------------

(function(){
    
    var GLOBAL_KEY_BLOCKWORD = 'extend';
    var GLOBAL_KEY_BLOCKWORD_R = 'R';
    var GLOBAL_KEY_BLOCKWORD_L = 'L';
    var GLOBAL_KEY_BLOCKWORD_U = 'U';
    var GLOBAL_KEY_BLOCKWORD_D = 'D';
    /*var GLOBAL_KEY_BLOCKWORD_RD = 'RD';
    var GLOBAL_KEY_BLOCKWORD_LD = 'LD';
    var GLOBAL_KEY_BLOCKWORD_UR = 'RU';
    var GLOBAL_KEY_BLOCKWORD_UL = 'LU';
    var GLOBAL_KEY_BLOCKWORD_SQ = 'SQ';
    var GLOBAL_KEY_BLOCKWORD_C = 'C';*/

    let extractIntFromString = function (string) {
        var digits = string.replace(/^\D+/g, '');
        var value = parseInt(digits);
        if (isNaN(value)) {
            value = 0;
        }
        return value;
    };

    let printError = function (error, message) {
        AA.warning(error, message);
    };

    //?[NEW]
    Game_Player.prototype._mypCheckExtTrigger = function (x, y, trigger, priority) {
        if (this.canStartLocalEvents()) {
            if ($gameMap.mypIsHasExtEvents()) {
                var evId = $gameMap.getExtEvOnPoint(x, y);
                if (evId != null) {
                    var event = $gameMap.event(evId);
                    if (event && event.isTriggerIn(trigger) && event.isNormalPriority() === priority) {
                        event.start();
                    }
                }
            }
        }
    };

    //@[ALIAS]
    var _alias_Game_Player_moveStrainght = Game_Player.prototype.moveStraight;
    Game_Player.prototype.moveStraight = function (d) {
        _alias_Game_Player_moveStrainght.call(this, d);
        // * TOUCH
        this._mypCheckExtTrigger(this.x, this.y, [1, 2], true);
    };

    //@[ALIAS]
    var _alias_Game_Player_checkEventTriggerThere = Game_Player.prototype.checkEventTriggerThere;
    Game_Player.prototype.checkEventTriggerThere = function (triggers) {
        _alias_Game_Player_checkEventTriggerThere.call(this, triggers);
        // * CLICK
        var direction = this.direction();
        var x1 = this.x;
        var y1 = this.y;
        var x2 = $gameMap.roundXWithDirection(x1, direction);
        var y2 = $gameMap.roundYWithDirection(y1, direction);
        this._mypCheckExtTrigger(x2, y2, triggers, true);
    };

    //?[NEW]
    Game_Map.prototype.mypIsHasExtEvents = function () {
        return (this._mypExtEventTriggerData != null);
    };

    //?[NEW]
    Game_Map.prototype.mypAddExtEvents = function (point, id) {
        if (this._mypExtEventTriggerData == null)
            this._mypExtEventTriggerData = {};
        this._mypExtEventTriggerData[point] = id;
    };

    //?[NEW]
    Game_Map.prototype.getExtEvOnPoint = function (x, y) {
        if(this.mypIsHasExtEvents()) {
            for (var name in this._mypExtEventTriggerData) {
                if (this._mypExtEventTriggerData.hasOwnProperty(name)) {
                    if(name == x + "," + y) {
                        return this._mypExtEventTriggerData[name];
                    }
                }
            }
            return null;
        } else {
            return null;
        }
    };

    //@[ALIAS]
    var _alias_Game_Map_eventsXy = Game_Map.prototype.eventsXy;
    Game_Map.prototype.eventsXy = function (x, y) {
        if(this.mypIsHasExtEvents()) {
            var id = this.getExtEvOnPoint(x, y);
            if(id != null) {
                return [$gameMap.event(id)];
            }
        }
        return _alias_Game_Map_eventsXy.call(this, x, y);
        
    };


    //@[ALIAS]
    var _alias_Game_Map_eventsXyNt = Game_Map.prototype.eventsXyNt;
    Game_Map.prototype.eventsXyNt = function (x, y) {
        if(this.mypIsHasExtEvents()) {
            var id = this.getExtEvOnPoint(x, y);
            if(id != null) {
                return [$gameMap.event(id)];
            }
        }
        return _alias_Game_Map_eventsXyNt.call(this, x, y);
    };

    //@[ALIAS]
    var _alias_Scene_Map_terminate = Scene_Map.prototype.terminate;
    Scene_Map.prototype.terminate = function () {
        $gameMap._mypExtEventTriggerData = null;
        _alias_Scene_Map_terminate.call(this);
    };

    // * =========================================================================
    // * GAME_EVENT

    //?[NEW]
    Game_Event.prototype._setupExtendedHitBoxes = function () {
        try {
            if(!this._extendedHitBoxesData) {
                this._extendedHitBoxesData = [];
            }
            if (!this.page()) return;
            this._aaExtendedHitBoxes = [];
            var list = this.list();
            if (list && list.length > 1) {
                var i = 0;
                while (i < list.length) {
                    var item = list[i++];
                    if (!item) continue;
                    if (item.code == 108) {
                        var comment = item.parameters[0];
                        if (comment.contains(GLOBAL_KEY_BLOCKWORD)) {
                            this._extrackKeyExtendSymbols(comment);
                        }
                    }
                }
            }
        } catch (e) {
            printError(e, 'error while find event block data from comments');
        }
    };

    //@[ALIAS]
    var _alias_Game_Event_pos = Game_Event.prototype.pos;
    Game_Event.prototype.pos = function (x, y) {
        if(this._extendedHitBoxesData) {
            var result = _alias_Game_Event_pos.call(this, x, y);
            if(result == true) {
                return true;
            }
            for(var i = 0; i<this._extendedHitBoxesData.length; i++) {
                var data = this._extendedHitBoxesData[i];
                this._extendTriggerByEvent(data[0], data[1]);
                for(var j = 0; j<this._aaExtendedHitBoxes.length; j++) {
                    var point = this._aaExtendedHitBoxes[j];
                    if(x == point[0] && y == point[1])
                        return true;
                }
            }
        }
        return _alias_Game_Event_pos.call(this, x, y);
    };

    (function () {
        //@[DEFINES]
        var _ = Game_Event.prototype;

        //?[NEW]
        _._extrackKeyExtendSymbols = function (comment) {
            try {
                if (this._myTriggerCellExtension == null)
                    this._myTriggerCellExtension = [];
                var symbolsArray = [
                    GLOBAL_KEY_BLOCKWORD_R,
                    GLOBAL_KEY_BLOCKWORD_L,
                    GLOBAL_KEY_BLOCKWORD_U,
                    GLOBAL_KEY_BLOCKWORD_D
                    /*GLOBAL_KEY_BLOCKWORD_RD,
                    GLOBAL_KEY_BLOCKWORD_LD,
                    GLOBAL_KEY_BLOCKWORD_UR,
                    GLOBAL_KEY_BLOCKWORD_UL,
                    GLOBAL_KEY_BLOCKWORD_SQ,
                    GLOBAL_KEY_BLOCKWORD_C*/
                ];

                var dirPart = comment.split(" ")[1];
                var findedSymbol = symbolsArray.filter(function (element) {
                    if (dirPart == element)
                        return element;
                });
                if (findedSymbol.length > 0 && findedSymbol[0]) {
                    var blockDirection = symbolsArray.indexOf(findedSymbol[0]);
                    if (blockDirection >= 0) {
                        this._extendedHitBoxesData.push([blockDirection, extractIntFromString(comment)]);
                    }
                }
            } catch (e) {
                printError(e, 'error while extract key block data from comment');
            }
        };

        //?[NEW]
        _._extendTriggerByEvent = function (direction, blockSize) {
            try {
                if (blockSize <= 0) return;
                if (direction < 0 || direction > 9) return;

                for (var dStep = 1; dStep < blockSize + 1; dStep++) {
                    this._addBlockPassageToMap(direction, dStep);
                }
            } catch (e) {
                printError(e, 'error while add blocked cell to map');
            }
        };

        //?[NEW]
        _._addBlockPassageToMap = function (direction, dStep) {
            var newCell = [];
            switch (direction) {
                case 0: // * RIGHT
                    newCell = [this.x + dStep, this.y];
                    break;
                case 1: // * LEFT
                    newCell = [this.x - dStep, this.y];
                    break;
                case 2: // * TOP
                    newCell = [this.x, this.y - dStep];
                    break;
                case 3: // * DOWN
                    newCell = [this.x, this.y + dStep];
                    break;
                default:
                    break;
            }

            if (newCell.length != 0) {
                this.mypAddExtHitBoxOnMap(newCell);
            }
        };

        _.mypAddExtHitBoxOnMap = function(point) {
            this._aaExtendedHitBoxes = [];
            this._aaExtendedHitBoxes.push(point);
        };

    })();


    // * =========================================================================

})();


/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_ExtraDmgPopUp.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {


    // Spriteset_Map =====================================================================
    (function(){
        //@[ALIAS]
        var _alias_Spriteset_Map_createToneChanger = Spriteset_Map.prototype.createToneChanger;
        Spriteset_Map.prototype.createToneChanger = function () {
            _alias_Spriteset_Map_createToneChanger.call(this);
            this._createAdditionLayerForAA();
        };

        Spriteset_Map.prototype._createAdditionLayerForAA = function () {
            this._absExtraLayer = new Sprite();
            this.addChild(this._absExtraLayer);
        };

        Spriteset_Map.prototype.getExtraAALayer = function () {
            return this._absExtraLayer;
        };
    })();

    

})();
// ■ END Extension_ExtraDmgPopUp.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_FogOfWar_PRO.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {

    AA.FOGWAR = {};

    //@[ALIAS]
    var _alias_Spriteset_Map_createToneChanger = Spriteset_Map.prototype.createToneChanger;
    Spriteset_Map.prototype.createToneChanger = function () {
        _alias_Spriteset_Map_createToneChanger.call(this);
        this._aafogLayer = new Sprite();
        this.___isFogExists = AA.Utils.hasMeta('AAFOG', $dataMap);
        if(this.___isFogExists) {
            this.___tw = $gameMap.tileWidth();
            this.___tw2 = this.___tw / 2;
            this.___th = $gameMap.tileHeight();
        }
        this.addChild(this._aafogLayer);
    };

    //@[ALIAS]
    var _alias_Spriteset_Map_updateTilemap = Spriteset_Map.prototype.updateTilemap;
    Spriteset_Map.prototype.updateTilemap = function () {
        _alias_Spriteset_Map_updateTilemap.call(this);
        if (AA.isABS() && this.___isFogExists == true) {
            this._updateFogAALayer();
        }
    };

    Spriteset_Map.prototype._updateFogAALayer = function () {
        var screenX = Math.round($gameMap.adjustX(-0.5) * this.___tw + this.___tw2);
        var screenY = Math.round($gameMap.adjustY(-1) * this.___th + this.___th);
        this._aafogLayer.move(screenX, screenY);
        //this._visualItemDLayer.move(screenX, screenY);
    };

    //@[ALIAS]
    var _alias_Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function () {
        _alias_Scene_Map_onMapLoaded.call(this);
        if (AA.Utils.hasMeta('AAFOG', $dataMap)) {
            AA.FOGWAR.drawFogOnMap();
            $gamePlayer._AAFOG_checkFog();
        } else {
            AA.FOGWAR.ready = false;
        }
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        AA.FOGWAR.ready = false;
        _alias_Scene_Map_stop.call(this);
        AA.FOGWAR.saveFogForMap();
    };

    // * GAME_PLAYER ==============================================================================

    (function () {

        //@[DEFINE]
        var _ = Game_Player.prototype;


        //@[ALIAS]
        var _alias_Game_Player_moveStraight = Game_Player.prototype.moveStraight;
        Game_Player.prototype.moveStraight = function (d) {
            _alias_Game_Player_moveStraight.call(this, d);
            this._AAFOG_checkFog();
        };


        //@[ALIAS]
        var _alias_Game_Player_moveDiagonally = Game_Player.prototype.moveDiagonally;
        Game_Player.prototype.moveDiagonally = function (horz, vert) {
            _alias_Game_Player_moveDiagonally.call(this, horz, vert);
            this._AAFOG_checkFog();
        };


        //@[ALIAS]
        var _alias_Game_Player_locate = Game_Player.prototype.locate;
        Game_Player.prototype.locate = function () {
            _alias_Game_Player_locate.call(this, ...arguments);
            this._AAFOG_checkFog();
        };

        //@[ALIAS]
        var _alias__refresh = _.refresh;
        _.refresh = function () {
            _alias__refresh.call(this);
            this._AAFOG_checkFog();
        };

        //?[NEW]
        _._AAFOG_checkFog = function () {
            if (AA.FOGWAR.isReady()) {
                AA.FOGWAR.openFogFromPoint(this.x, this.y);
            }
        };

        //?[NEW]
        _.getRegionIdUnder = function () {
            return $gameMap.regionId(this.x, this.y);
        };

        //?[NEW]
        _.saveFogForMap = function (fogData) {
            this._initFogStore();
            this.__mFogStore[$gameMap.mapId()] = fogData;
        };

        //?[NEW]
        _.getFogForMap = function () {
            var mapId = $gameMap.mapId();
            this._initFogStore();
            if (this.__mFogStore[mapId]) {
                return this.__mFogStore[mapId];
            }
            return null;
        };

        //?[NEW]
        _._initFogStore = function () {
            if (this.__mFogStore) {

            } else {
                this.__mFogStore = {};
            }
        };

        //?[NEW]
        _._resetFogOnMap = function (mapId) {
            this._initFogStore();
            this.__mFogStore[mapId] = null;
            delete this.__mFogStore[mapId];
        };

    })();

    // * MFSPRITE === === === === === === === === === === === === === === === === === === ///

    function MFSprite() {
        this.initialize.apply(this, arguments);
    }

    MFSprite.prototype = Object.create(Sprite.prototype);
    MFSprite.prototype.constructor = MFSprite;

    MFSprite.prototype.initialize = function (bitmap) {
        Sprite.prototype.initialize.call(this, bitmap);
        this._onStart();
    };
    AA.FOGWAR.MFSprite = MFSprite;


})();
// ■ END Extension_FogOfWar_PRO.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_Landmines.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//@[GLOBAL]
function Game_AASpawnedEvent() {
    this.initialize.apply(this, arguments);
}

(function(){
    

    //@[ALIAS]
    var _alias_Scene_Map_update = Scene_Map.prototype.update;
    Scene_Map.prototype.update = function () {
        _alias_Scene_Map_update.call(this);
        if($gameMap._AALandmines)
            $gameMap._AALandmines.update();
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        //if ($gameMap._AALandmines) {
        //    $gameMap._AALandmines.terminate();
        //}
        _alias_Scene_Map_stop.call(this);
    };

    //?[NEW]
    Spriteset_Map.prototype.createSpawnLandmineABS = function (id) {
        var event = $gameMap.event(id);
        var newChar = new Sprite_Character(event);
        this._characterSprites.push(newChar);
        this._tilemap.addChild(newChar);
    };


    // * AA SPAWNED EVENT
    (function(){

        Game_AASpawnedEvent.prototype = Object.create(Game_Event.prototype);
        Game_AASpawnedEvent.prototype.constructor = Game_AASpawnedEvent;

        Game_AASpawnedEvent.prototype.initialize = function (mapId, eventId, x, y, spawnEventId) {
            this._spawnX = x;
            this._spawnY = y;
            this._spawnEventId = spawnEventId;
            Game_Event.prototype.initialize.call(this, mapId, eventId);
            DataManager.extractMetadata(this.event());
        };
        Game_AASpawnedEvent.prototype.event = function () {
            return $dataSpawnMapAI.events[this._spawnEventId];
        };
        Game_AASpawnedEvent.prototype.locate = function () {
            var x = this._spawnX;
            var y = this._spawnY;
            Game_AIBot.prototype.locate.call(this, x, y);
        };

    })();

})();
// ■ END Extension_Landmines.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// * Thanks to SMO
(function(){
    
Game_Party.prototype.swapLeader = function(actorId){
	var memberIndex = this._actors.indexOf(actorId);
	if (memberIndex > 0){
		this.swapOrder(0, memberIndex);
		return true;
	}
	return false;
};

Game_Party.prototype.swapOrder = function(index1, index2) {
	var temp = this._actors[index1];
	this._actors[index1] = this._actors[index2];
	this._actors[index2] = temp;
	$gamePlayer.refresh();
	if (SceneManager._scene instanceof Scene_Map && $gameMap.isABS()){
		var spriteset = SceneManager._scene._spritesetUI;
		var sprites = spriteset.children;
		var remove = [];
		remove = sprites.filter(s => !(s instanceof AlphaABS.LIBS.UI_SelectCircleFW));
		for (var r = 0; r < remove.length; r++){
			spriteset.removeChild(remove[r]);
		}

		AlphaABS.BattleManagerABS.updateABSSession();
	}
};

})();


/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Map Inventory Extension.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Scene_Map_createSpriteset11 = Scene_Map.prototype.createSpriteset;
    Scene_Map.prototype.createSpriteset = function () {
        _alias_Scene_Map_createSpriteset11.call(this);
        this._createExtraUILayer();
    };

    //?[NEW]
    Scene_Map.prototype._createExtraUILayer = function () {
        this._spritesetEU = new Spriteset_ExtraUI();
        AA.BattleUI.setExtraUI(this._spritesetEU);
        if (AA.Parameters.get_MapInventoryAllowed()) {
            if (!AA.isMap() && !AA.Parameters.get_MapInventoryAllowedNoABS()) {
                return;
            }
            this.addChild(this._spritesetEU);

            AA.BattleUI.registerExtraMethods();
            uAPI.refreshWeightSystem();
        }
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        _alias_Scene_Map_stop.call(this);
        this._spritesetEU.terminate();
        this.removeChild(this._spritesetEU);
    };

    //@[ALIAS]
    var _alias_Scene_Map_processMapTouch = Scene_Map.prototype.processMapTouch;
    Scene_Map.prototype.processMapTouch = function () {
        if(!AA.isMap()) {
            if (AA.BattleUI.isProcessEUITouch()) {
                return;
            }
        }
        return _alias_Scene_Map_processMapTouch.call(this);
    };


    //@[ALIAS]
    var _alias_Scene_Map_isMenuCalled = Scene_Map.prototype.isMenuCalled;
    Scene_Map.prototype.isMenuCalled = function () {
        if (!AA.isMap()) {
            if (TouchInput.isCancelled() && AA.UI.isInventoryOpened()) {
                AA.UI.closeInventory();
                return false;
            }
        }
        return _alias_Scene_Map_isMenuCalled.call(this);
        
    };

    //@[ALIAS]
    var _alias_Game_Player_moveByInput = Game_Player.prototype.moveByInput;
    Game_Player.prototype.moveByInput = function () {
        if(!AA.isMap()) {
            if (Input.isTriggered(AlphaABS.LIBS.IKey.INV())) {
                if (AA.Parameters.get_MapInventoryAllowedNoABS()) {
                    if (AA.UI.isChestIsOpen() || AA.UI.isUserChestIsOpen()) {
                        this.onInventoryKey();
                    } else {
                        if (this.canMove())
                            this.onInventoryKey();
                    }
                }
            } else if (Input.isTriggered(AlphaABS.LIBS.IKey.SKLW())) {
                // * Один параметр для всех окон
                if (AA.Parameters.get_MapInventoryAllowedNoABS()) {
                    if (this.canMove())
                        this.onSkillWindowKey();
                }
            } else if (Input.isTriggered(AlphaABS.LIBS.IKey.STAW())) {
                // * Один параметр для всех окон
                if (AA.Parameters.get_MapInventoryAllowedNoABS()) {
                    if (this.canMove())
                        this.onStatusWindowKey();
                }
            }
        }
        return _alias_Game_Player_moveByInput.call(this);
    };

})();
// ■ END Map Inventory Extension.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
 //   example:
 //   find_nearest_event = function(notetag, range, varId)
 //   find_nearest_event("ABS",4,7) //Find any ABS event(<ABS:1>) within range of 4
 //   Apply the eventID to var#7(No events found will apply "-1")

(function(){
    
    window.find_nearest_event = function(notetag, range, varId, eventId, self) {

        try {
            
            var events = $gameMap.events();
            var candidates = [];
            var distances = {};
            var px = $gamePlayer.x;
            var py = $gamePlayer.y;
            for (var i = 0; i<events.length; i++) {
                var ev = events[i];
                if(ev && ev.battler) {
                    var evNoteData = ev.event().note;
                    if(evNoteData && evNoteData.contains(notetag)) {
                        var dist = $gameMap.distance(px, py, ev.x, ev.y);
                        if(dist <= range && ev.battler().isAlive()) {
                            candidates.push(dist);
                            distances[dist] = ev.eventId();
                        }
                    }
                }
            }

            //console.info(candidates)

            if(candidates.length > 0) {
                candidates.sort();

                //console.info(candidates)

                if(varId && varId > 0) {
					if(Imported.iavra_self_variables && eventId && self){
						$gameSelfVariables.setValue([$gameMap._mapId, eventId, varId], distances[candidates[0]]);
					}else{
						$gameVariables.setValue(varId, distances[candidates[0]]);
					}
                    return;
                }
            }

            if(varId && varId > 0){
				if(Imported.iavra_self_variables && eventId && self){
					$gameSelfVariables.setValue([$gameMap._mapId, eventId, varId], -1);
				}else{
					$gameVariables.setValue(varId, -1);
				}
			}

        } catch (e) {
            console.warn(e);
            if(varId && varId > 0){
				if(Imported.iavra_self_variables && eventId && self){
					$gameSelfVariables.setValue([$gameMap._mapId, eventId, varId], -1);
				}else{
					$gameVariables.setValue(varId, -1);
				}
			}
        }

    };

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Standard Battle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var $EXTENDS, ALIAS_SB_CREATE_432;
  $EXTENDS = function() {
    var ALIAS_SM_FIX;
    ALIAS_SM_FIX = AA.LIBS.AASpelllPanelManager.prototype._updateInfo;
    AA.LIBS.AASpelllPanelManager.prototype._updateInfo = function() {
      // * FIX to AASpelllPanelManager class
      if (this.newSpellPanelUIElement == null) {
        return;
      }
      return ALIAS_SM_FIX.call(this);
    };
    AA.LIBS.AASpellPanelManagerMenu.prototype._createThread2 = function() {}; // ? EMPTY
  };
  ALIAS_SB_CREATE_432 = Scene_Boot.prototype.create;
  Scene_Boot.prototype.create = function() {
    var e;
    ALIAS_SB_CREATE_432.call(this);
    try {
      $EXTENDS();
    } catch (error) {
      e = error;
      AA.warning(e, 'when try apply Standard Battle Extension');
    }
  };
})();

// ■ END Standard Battle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UIObject_FirearmPanel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UIObject_FirearmPanel;
  UIObject_FirearmPanel = (function() {
    var Color;

    //TODO: Переделать из новых UI элементов
    class UIObject_FirearmPanel extends Sprite {
      constructor() {
        super();
        this._loadSettings();
        this._createGlowFilter();
        this._createGauge();
        this._createWeaponNameText();
        this._createAmmoInfo();
        this.refresh();
      }

      _loadSettings() {
        this.S = AlphaABS.jDATA.FirearmPanel;
        UIObject_FirearmPanel.WIDTH = this.S.width;
        UIObject_FirearmPanel.HEIGHT = this.S.height;
        if (this.S.fillColor != null) {
          UIObject_FirearmPanel.FILL = this.S.fillColor;
        }
        if (this.S.alertColor != null) {
          UIObject_FirearmPanel.ALERT = this.S.alertColor;
        }
        if (this.S.blackColor != null) {
          return UIObject_FirearmPanel.BLACK = this.S.blackColor;
        }
      }

      _createGlowFilter() {
        var glowColor;
        this.glow = new Sprite(new Bitmap(UIObject_FirearmPanel.WIDTH, UIObject_FirearmPanel.HEIGHT));
        glowColor = null;
        if (this.S.glowColor != null) {
          glowColor = KDCore.Color.FromHex(this.S.glowColor);
        }
        if (glowColor == null) {
          glowColor = Color.GREEN;
        }
        this.glow.bitmap.fillAll(glowColor);
        //@glow.filters = [
        //    new PIXI.filters.GlowFilter(4, 4, 0, 0xFF0000, 0.5)
        //]
        this.glow.visible = false;
        return this.addChild(this.glow);
      }

      _createGauge() {
        this.gauge = new AlphaABS.LIBS.UI_Gauge(UIObject_FirearmPanel.WIDTH, UIObject_FirearmPanel.HEIGHT);
        this.gauge.setGaugeColors(UIObject_FirearmPanel.FILL, UIObject_FirearmPanel.BLACK);
        this.gauge.setBackgroundColor(this.S.backgroundColor);
        this.gauge.setValue(0);
        this.gauge.setMaxValue(100);
        this.gauge.opacity = this.S.backgroundOpacity;
        return this.addChild(this.gauge);
      }

      _createWeaponNameText() {
        this.weapText = AASprite.FromBitmap(this.S.weaponName.textBoxWidth, this.S.weaponName.textBoxHeight);
        //new Sprite(new Bitmap(60, UIObject_FirearmPanel.HEIGHT))
        //colorB = Color.BLACK #.reAlpha(180)
        //@weapText.bitmap.gradientFillRect(0, 0, 60, UIObject_FirearmPanel.HEIGHT,
        //    colorB.CSS, Color.NONE.CSS, false)
        this.weapText.applyTextSettingsByExtraSettings(this.weapText, this.S.weaponName);
        return this.addChild(this.weapText);
      }

      _createAmmoInfo() {
        var p;
        this.ammoInfo = new Sprite();
        this.ammoInfo.move(this.S.ammoInfoPositionX, this.S.ammoInfoPositionY);
        this.ammoIcon = new Sprite(new Bitmap(this.S.ammoIconSize, this.S.ammoIconSize));
        this.ammoIcon.move(this.S.ammoIconMarginX, this.S.ammoIconMarginY);
        this.ammoInfo.addChild(this.ammoIcon);
        p = this.S.ammoCountText;
        this.ammoCount = AASprite.FromBitmap(p.textBoxWidth, p.textBoxHeight);
        this.ammoCount.applyTextSettingsByExtraSettings(this.ammoCount, p);
        //new Sprite(new Bitmap(30, UIObject_FirearmPanel.HEIGHT))
        //@ammoCount.move(10, 0)
        this.ammoInfo.addChild(this.ammoCount);
        this.addChild(this.ammoInfo);
        p = this.S.chargesText;
        this.charges = AASprite.FromBitmap(p.textBoxWidth, p.textBoxHeight);
        this.charges.applyTextSettingsByExtraSettings(this.charges, p);
        //new Sprite(new Bitmap(30, UIObject_FirearmPanel.HEIGHT))
        //@charges.move(UIObject_FirearmPanel.WIDTH - 40, 4)
        return this.addChild(this.charges);
      }

      refresh() {
        var e, weapData;
        if (!$gamePlayer.battler()) {
          return;
        }
        try {
          weapData = $gamePlayer.battler().weapons()[0];
          if (weapData != null) {
            this._drawWeaponText(weapData.name);
          }
          this._absSkill = $gamePlayer.battler()._firstBattleABSSkill();
          if ((this._absSkill != null) && this._absSkill.isFirearm()) {
            return this._drawWeaponInfo();
          } else {
            return this.hide();
          }
        } catch (error) {
          e = error;
          AlphaABS.error(e, 'while refresh FirearmPanel');
          return this.hide();
        }
      }

      _drawWeaponText(text) {
        this.weapText.bitmap.clear();
        return this.weapText.bitmap.drawTextFull(text, this.S.weaponName.position);
      }

      _drawWeaponInfo() {
        var ammoItem;
        ammoItem = $dataItems[this._absSkill.ammo];
        if (ammoItem == null) {
          return;
        }
        this._drawIcon(ammoItem.iconIndex);
        this._drawAmmoCount($gameParty.numItems(ammoItem));
        return this._drawChargesCount(this._absSkill._currentStack, this._absSkill.stack);
      }

      _drawIcon(index) {
        this.ammoIcon.bitmap.clear();
        return this.ammoIcon.bitmap.drawIcon(0, 0, index, this.S.ammoIconSize - 2);
      }

      _drawAmmoCount(count) {
        var c;
        this.ammoCount.bitmap.clear();
        if (count === 0) {
          c = KDCore.Color.FromHex(this.S.ammoCountText.textColorWhenEmpty);
        } else {
          c = KDCore.Color.FromHex(this.S.ammoCountText.textColor);
        }
        this.ammoCount.bitmap.textColor = c.CSS;
        return this.ammoCount.bitmap.drawTextFull(count, this.S.ammoCountText.position);
      }

      _drawChargesCount(current, max) {
        var c, text;
        this.charges.bitmap.clear();
        //@charges.bitmap.fontSize = 12
        if (current === 0) {
          c = KDCore.Color.FromHex(this.S.chargesText.textColorWhenEmpty);
        } else {
          c = KDCore.Color.FromHex(this.S.chargesText.textColor);
        }
        this.charges.bitmap.textColor = c.CSS;
        if (current == null) {
          current = 0;
        }
        text = current.toString() + '/' + max.toString();
        return this.charges.bitmap.drawTextFull(text, this.S.chargesText.position);
      }

      hide() {
        return this.visible = false;
      }

      show() {
        return this.visible = true;
      }

      isTouched() {
        var isTouch, point;
        try {
          if (this.visible === false) {
            return false;
          }
          point = new KDCore.Point(TouchInput.x, TouchInput.y);
          return isTouch = AlphaABS.UTILS.SMath.inRect(point, this._getRectangle());
        } catch (error) {
          return false;
        }
      }

      _getRectangle() {
        return new Rectangle(AlphaABS.UTILS.toGlobalCoord(this, 'x'), AlphaABS.UTILS.toGlobalCoord(this, 'y'), this.gauge.width, this.gauge.height);
      }

      update() {
        var ref;
        super.update();
        if (this.visible === false) {
          return;
        }
        if (TouchInput.isLongPressed() && this.isTouched()) {
          if ((ref = $gamePlayer.battler()) != null) {
            ref.reloadFirearm();
          }
          this._pulse(0x00FF00);
          TouchInput.clear();
        }
        this.gauge.setMaxValue(this._absSkill.timer.getMaxValue());
        if (AlphaABS.BattleManagerABS.canUseSkillByAmmo(this._absSkill)) {
          this.gauge.setGaugeColors(UIObject_FirearmPanel.FILL, UIObject_FirearmPanel.BLACK);
          this.gauge.setValue(this._absSkill.timer.getValue());
          if (this._absSkill.timer.getMaxValue() === this._absSkill.timer.getValue()) {
            this.gauge.setValue(0);
            return this.refresh();
          }
        } else {
          this._drawChargesCount(this._absSkill._currentStack, this._absSkill.stack);
          this.gauge.setGaugeColors(UIObject_FirearmPanel.ALERT, UIObject_FirearmPanel.BLACK);
          return this.gauge.setValue(this._absSkill.timer.getMaxValue());
        }
      }

      _pulse(color) {
        var gl, tFunc, thread32, up;
        //@glow.filters[0].color = color
        this.glow.opacity = 0;
        this.glow.visible = true;
        gl = this.glow;
        up = true;
        return thread32 = AA.setTimeout((tFunc = function() {
          if (up === true) {
            gl.opacity += 30;
          }
          if (gl.opacity >= 255) {
            up = false;
          }
          if (up === false) {
            gl.opacity -= 60;
          }
          if (gl.opacity > 0) {
            return AA.setTimeout(tFunc, 100);
          }
        }), 100);
      }

    };

    Color = KDCore.Color;

    UIObject_FirearmPanel.WIDTH = 280;

    UIObject_FirearmPanel.HEIGHT = 20;

    UIObject_FirearmPanel.FILL = Color.GREEN.reAlpha(200).HEX;

    UIObject_FirearmPanel.ALERT = Color.RED.reAlpha(200).HEX;

    UIObject_FirearmPanel.BLACK = Color.BLACK.reAlpha(200).HEX;

    return UIObject_FirearmPanel;

  }).call(this);
  AlphaABS.register(UIObject_FirearmPanel);
})();

// ■ END UIObject_FirearmPanel.coffee
//---------------------------------------------------------------------------

//------------------------------------------------------------------------------
//FontLoadManager
var FontLoadManager = function () {
    throw new Error('This is a static class');
};
FontLoadManager.init = function () {
    var fs = require('fs');
    this._files = fs.readdirSync(this.localFileDirectoryPath());
    this._ready = false;
};

FontLoadManager.isReady = function () {
    return (this._ready == true);
};

FontLoadManager.loadAll = function () {
    if (FontLoadManager.isReady()) return;
    for (var i = 0; i < this._files.length; i++) {
        if (this._files[i].includes('.ttf') || this._files[i].includes('.TTF')) {
            console.log("Load font " + this._files[i]);
            var name = this._files[i].substring(0, this._files[i].length - 4);
            var url = this.localFileDirectoryPath() + this._files[i];
            url = url.replaceAll("\\", "\\\\");
            Graphics.loadFont(name, url);
        }
    }
    this._ready = true;
};

FontLoadManager._localFileDirectoryPath = null;
FontLoadManager.localFileDirectoryPath = function () {
    if (this._localFileDirectoryPath == null) {
        const path = require('path');
        const base = path.dirname(process.mainModule.filename);
        this._localFileDirectoryPath = path.join(base, 'fonts/');
    }
    return this._localFileDirectoryPath;
};
//END FontLoadManager
//------------------------------------------------------------------------------
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setSubject_111, ALIAS__subject_111, ALIAS__testApply_111, PopInfoManagerABS, _;
  //@[DEFINES]
  _ = Game_Action.prototype;
  PopInfoManagerABS = AlphaABS.LIBS.PopInfoManagerABS;
  (function() {    // * POP UPS
    // -----------------------------------------------------------------------
    var ALIAS__evalDamageFormula, ALIAS__executeDamage, ALIAS__executeHpDamage, ALIAS__itemEffectGainTp, ALIAS__itemEffectRecoverHp, ALIAS__itemEffectRecoverMp;
    //@[ALIAS]
    ALIAS__evalDamageFormula = _.evalDamageFormula;
    _.evalDamageFormula = function(target) {
      var value;
      value = ALIAS__evalDamageFormula.call(this, target);
      return Math.round(value);
    };
    
    //@[ALIAS]
    ALIAS__executeDamage = _.executeDamage;
    _.executeDamage = function(target, value) {
      this._checkCastInterrupt(target);
      ALIAS__executeDamage.call(this, target, value);
      PopInfoManagerABS.makeDamagePopUp(target);
      if (this.isDrain()) {
        PopInfoManagerABS.makeDrainPopUp(this.subject());
      }
    };
    //@[ALIAS]
    ALIAS__itemEffectRecoverHp = _.itemEffectRecoverHp;
    _.itemEffectRecoverHp = function(target, effect) {
      ALIAS__itemEffectRecoverHp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };
    //@[ALIAS]
    ALIAS__itemEffectRecoverMp = _.itemEffectRecoverMp;
    _.itemEffectRecoverMp = function(target, effect) {
      ALIAS__itemEffectRecoverMp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };
    //@[ALIAS]
    ALIAS__itemEffectGainTp = _.itemEffectGainTp;
    _.itemEffectGainTp = function(target, effect) {
      ALIAS__itemEffectGainTp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };
    //@[ALIAS]
    ALIAS__executeHpDamage = _.executeHpDamage;
    return _.executeHpDamage = function(target, value) {
      if (this._isDamageForBarrierDone(target, value)) { // On another method: _executeBarrierDamage
        return;
      } else {
        ALIAS__executeHpDamage.call(this, target, value);
        if (value === 0) {
          PopInfoManagerABS.makeZeroDamagePopUp(target);
        }
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    //?[NEWPARTY_E]
    // * NEW PARTY AI (1190)
    // -----------------------------------------------------------------------
    var ALIAS__itemTargetCandidates;
    //@[ALIAS]
    ALIAS__itemTargetCandidates = _.itemTargetCandidates;
    _.itemTargetCandidates = function() {
      // * Эта система пока эксперементальная и работает только на членов партии
      if (AA.isABS() && this.isValid() && this.subject().isActor()) {
        return this.itemTargetCandidatesABS();
      }
      return ALIAS__itemTargetCandidates.call(this);
    };
    //@[ALIAS]
    _.ALIAS__evaluateWithTarget = _.evaluateWithTarget;
    return _.evaluateWithTarget = function(target) {
      var aaEntity;
      if (AA.isABS() && this.subject().isActor() && this.isForFriend()) {
        aaEntity = this.friendsUnit().getAAEntityByBattler(this.subject());
        return this.evalueWithTargetAndSupport(target, aaEntity);
      }
      return _.ALIAS__evaluateWithTarget.call(this, target);
    };
  })();
  // -----------------------------------------------------------------------

  //@[ALIAS]
  ALIAS__testApply_111 = _.testApply;
  _.testApply = function(target) {
    var result;
    if (AA.isABS()) {
      result = this.isForDeadFriend() === target.isDead() && (this.isForOpponent() || this.isHpRecover() && target.hp < target.mhp || this.isMpRecover() && target.mp < target.mmp || this.hasItemAnyValidEffects(target));
      return result;
    } else {
      return ALIAS__testApply_111.call(this, target);
    }
  };
  
  //@[ALIAS]
  ALIAS__setSubject_111 = _.setSubject;
  _.setSubject = function(subject) {
    if (AA.isABS()) {
      this._subject = subject;
    } else {
      ALIAS__setSubject_111.call(this, subject);
    }
  };
  //@[ALIAS]
  ALIAS__subject_111 = _.subject;
  _.subject = function() {
    if (AA.isABS()) {
      return this._subject;
    } else {
      return ALIAS__subject_111.call(this);
    }
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Action.prototype;
  _._checkCastInterrupt = function(target) {
    var ref;
    if (((ref = this.item().meta) != null ? ref.stopCast : void 0) > 0) {
      target.setNeedAACastInterrupt();
    }
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Action.prototype;
  //?[ABSORB_E]
  // * Методы расширения Absorb Barriers
  // -----------------------------------------------------------------------
  _._isDamageForBarrierDone = function(t, v) {
    var elementId;
    if (t.isHaveAbBarrier()) {
      elementId = this._getActionElementId();
      if (elementId > 0) {
        if (elementId === t._absParams.barrierElementId) {
          this._executeBarrierDamage(t, v);
          return true;
        }
      }
    }
    return false;
  };
  _._getActionElementId = function() {
    var elements;
    if (this.item().damage.elementId < 0) {
      elements = this.subject().attackElements();
      if (elements.length > 0) {
        return elements.first();
      } else {
        return 0;
      }
    } else {
      return this.item().damage.elementId;
    }
  };
  _._executeBarrierDamage = function(t, v) {
    var bHp, hpDmg;
    // * Проникающий урон, т.е. часть урона идёт на HP после пробития барьера
    if (AA.Parameters.get_IsBarrierPiercedDamage()) {
      bHp = t._absParams.barrierHp;
      t.gainHpBarrier(-v);
      // * Barrier is broken
      if (!t.isHaveAbBarrier()) {
        hpDmg = v - bHp;
        if (hpDmg > 0) {
          ALIAS__executeHpDamage.call(this, t, hpDmg);
        } else {
          this.makeSuccess(t);
        }
      }
    } else {
      this.makeSuccess(t);
      t.gainHpBarrier(-v);
    }
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Action.prototype;
  //?[NEWPARTY_E]
  // * Методы выбора целей для нового AI группы
  // -----------------------------------------------------------------------

  //?NEW
  _.itemTargetCandidatesABS = function() {
    if (this.isForUser()) {
      return [this.subject()];
    }
    if (this.isForFriend()) {
      return this._selectAllyTargetsABS();
    }
    if (this.isForOpponent()) {
      return this._selectEnemyTargetsABS(); // * ?
    }
    return [];
  };
  _._selectAllyTargetsABS = function() {
    var aaEntity;
    aaEntity = this.friendsUnit().getAAEntityByBattler(this.subject());
    if (aaEntity.isInSupportBehMode()) {
      //TODO: select by type radius or Vector
      return this.friendsUnit().aliveMembersABS().map(function(t) {
        return t.battler();
      });
    } else {
      return [this.subject()]; // * Если не в режиме поддержки, то себя
    }
  };
  
  // * Тут мы не проверяем готовность навыка, это делается в makeActions (usableSkills)
  _._selectEnemyTargetsABS = function() {
    var aaEntity, absSkill, target, targets;
    aaEntity = this.friendsUnit().getAAEntityByBattler(this.subject());
    if (aaEntity == null) {
      return [];
    }
    target = aaEntity.getTarget();
    if (target == null) {
      return [];
    }
    //console.info target
    absSkill = this.subject().skillABS_byAction(this);
    if (absSkill == null) {
      return [];
    }
    targets = [];
    if (absSkill.isVectorType() && absSkill.isNoTarget()) {
      targets = this._selectEnemyForNoTargetVector(absSkill, aaEntity, target);
    } else {
      if (absSkill.isRadiusType() || absSkill.isZoneType()) {
        targets = this._selectEnemyForRadius(absSkill, aaEntity);
      } else {
        targets = [target]; // * Данная цель
      }
    }
    //TODO: если враг ближе, чем casting time, то не выбирать действие
    return targets.map(function(t) {
      return t.battler();
    });
  };
  _._selectEnemyForNoTargetVector = function(absSkill, aaEntity, target) {
    var char, d, e;
    try {
      char = aaEntity.character();
      d = AA.UTILS.distanceTo(char, target);
      if (absSkill.range >= d) {
        if (absSkill.isDirectionFix()) {
          if (AA.UTILS.inDirectionHard(char, target)) {
            return [target];
          }
        } else {
          return [target];
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
    return [];
  };
  _._selectEnemyForRadius = function(absSkill, aaEntity) {
    return AA.AILogicManager.inSkillRadius(aaEntity.character(), absSkill.radius);
  };
  _.evalueWithTargetAndSupport = function(target, aaAlly) {
    var mod, ref;
    if (aaAlly.inBattle() && ((ref = aaAlly.getTarget()) != null ? ref.isEnemy() : void 0)) {
      mod = 0.15;
      if (aaAlly.isInSupportBehMode()) {
        mod = 0.35;
      }
      if (Math.random() < mod) {
        if (this.isHpEffect()) {
          return _.ALIAS__evaluateWithTarget.call(this, target);
        } else {
          return -1;
        }
      } else {
        //    return 0
        //else
        // return @_evaluateValidEffects(target) * mod
        return -1;
      }
    } else {
      if (this.isHpEffect()) {
        return _.ALIAS__evaluateWithTarget.call(this, target);
      } else {
        //if Math.random() < 0.15
        return this._evaluateValidEffects(target);
      }
    }
  };
  //#else
  //return 0
  _._evaluateValidEffects = function(target) {
    //if @hasItemAnyValidEffects(target)
    //    return 1
    //else
    //   return -1
    return -1;
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  //?[ABSORB_E]
  // * Методы расширения Absorb Barriers
  // -----------------------------------------------------------------------

  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this.barrierAffected = false;
    this.barrierDamage = 0;
    return this.barrierDamageId = 0;
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------v

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  _.isDamageDone = function() {
    return this.isHit() && (this.isStatusAffected() || this.isSomeDamage());
  };
  _.isSomeDamage = function() {
    return this.hpDamage !== 0 || this.mpDamage !== 0 || this.tpDamage !== 0;
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------

(function () {
  var LOG = new KDCore.DevLog("Game_Actor");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  var Consts = AlphaABS.SYSTEM;

  //Game_Actor
  //------------------------------------------------------------------------------
  var _Game_Actor_initMembers = Game_Actor.prototype.initMembers;
  Game_Actor.prototype.initMembers = function () {
    _Game_Actor_initMembers.call(this);
    this._absParams.panelSkills = [null, null, null, null, null, null, null, null]; //[id,type]
    this._absParams.favoriteWeapons = [null, null, null, null];
  };

  //NEW
  Game_Actor.prototype.getFavWeapIcons = function () {
    return this._absParams.favoriteWeapons.map(function (argument) {
      if (argument) {
        return $dataWeapons[argument].iconIndex;
      }
      return null;
    });
  };

  Game_Actor.prototype.changeFormationABS = function () {};

  //NEW
  Game_Actor.prototype.setFavWeap = function (item, index) {
    if (index > 3) return;
    if (item == null) {
      this.removeFavWeap(index);
      return;
    }
    var existsIndex = this.getFavWeapIndex(item);
    if(existsIndex != null) {
      this.removeFavWeap(existsIndex);
    }
    if (this._absParams.favoriteWeapons[index] &&
      item.id == this._absParams.favoriteWeapons[index]) {
      this.removeFavWeap(index);
    } else {
      this._absParams.favoriteWeapons[index] = item.id;
    }
  };

  //NEW
  Game_Actor.prototype.isFavWeapExists = function () {
    return this._absParams.favoriteWeapons.some(function (elem) {
      return (elem !== null);
    });
  };

  //NEW
  Game_Actor.prototype.getFavWeapIndex = function (item) {
    var index = 0;
    if (item == null)
      return null;

    var finded = null; //This is not good at all
    this._absParams.favoriteWeapons.forEach(function (i) {
      if (i && i == item.id) {
        finded = index;
      }
      index++;
    }.bind(this));

    return finded;
  };

  //NEW
  Game_Actor.prototype.getFavWeapSymbol = function (item) {
    if (!DataManager.isWeapon(item)) return null;
    var index = this.getFavWeapIndex(item);
    if (index !== null) {
      var symbol = null;
      switch (index) {
        case 0:
          symbol = AlphaABS.LIBS.IKey.SC_W();
          break;
        case 1:
          symbol = AlphaABS.LIBS.IKey.SC_D();
          break;
        case 2:
          symbol = AlphaABS.LIBS.IKey.SC_S();
          break;
        case 3:
          symbol = AlphaABS.LIBS.IKey.SC_A();
          break;
        default:
          break;
      }
      if (symbol != null) {
        return AlphaABS.LIBS.IKey.convertIKeyToLetter(symbol);
      }
    }
    return null;
  };

  //NEW
  Game_Actor.prototype.removeFavWeap = function (index) {
    this._absParams.favoriteWeapons[index] = null;
  };

  //NEW
  Game_Actor.prototype.changeFavWeap = function (index) {
    if (!this._firstBattleABSSkill().isReady()) {
      return false;
    }
    var fvItem = this._absParams.favoriteWeapons[index];
    if (fvItem != null) {
      var fvItemX = $dataWeapons[fvItem];
      if (fvItemX != null) {
        if (this.hasWeapon(fvItemX)) {
          return false;
        }
        if ($gameParty.hasItem(fvItemX, false)) {
          AA.BattleUI.hideFirearmPanel();
          try {
            AA.BattleUI.getUI().userWeaponIconController._clearAmmo();
          } catch (e) {
            
          }
          if (Imported.YEP_ItemCore == true) {
            var slotId = fvItemX.etypeId - 1;
            this.changeEquip(slotId, fvItemX);
            return true;
          } else {
            this.changeEquipById(fvItemX.etypeId, fvItemX.id);
            return true;
          }
        }
      }
    }

    return false;
  };

  //?[NEW]
  Game_Actor.prototype._performAttackABS = function () {
    var weapons = this.weapons();
    var wtypeId = weapons[0] ? weapons[0].wtypeId : 0;
    if (this.isHasABSMotion() || this.isHasABSMotionX()) {
      this.requestABSMotionAction();
    } else {
      var attackMotion = $dataSystem.attackMotions[wtypeId];
      if (attackMotion) {
        this.startWeaponAnimation(attackMotion.weaponImageId);
      }
    }
  };

  var pkd_GameActor_learnSkill = Game_Actor.prototype.learnSkill;
  Game_Actor.prototype.learnSkill = function (skillId) {
    var skill = $dataSkills[skillId];
    if (!skill.meta.ABS) {
      LOGW.p("Skill " + skill.name + " not learned, not ABS type");
      return; //Not allow learn not ABS skills
    }
    if (Utils.isMobileDevice()) {
      if (skill.meta.ABS) {
        var skillType = JSON.parse(skill.meta.ABS);
        if (skillType == 2 && skill.scope != 11) {
          LOGW.p("Skill " + skill.name + " not learned, not support on mobile platform");
          return;
        }
      }
    }
    var isLearning = this.isLearnedSkill(skillId);
    pkd_GameActor_learnSkill.call(this, skillId);
    if (skill.occasion == 1 && !isLearning) {
      this._absParams.battleSkillsABS.push(skillId, false);
      this.setSkillOnPanel(skillId, undefined);
      AlphaABS.BattleUI.refresh();
    }
  };

  //NEW
  Game_Actor.prototype.uiPanelReset = function () {
    for (var i = 0; i < 8; i++) {
      this.setSkillOnPanel(null, i);
    }
  };

  Game_Actor.prototype.uiPanelSkills = function () {
    return this._absParams.panelSkills;
  };

  Game_Actor.prototype.skillByKeyIndex = function (index) {
    index = index - 1; //Keyboard from 1, but array from 0
    if (index < 0 || index > 7) {
      return null;
    }
    var skillABS = this._absParams.panelSkills[index];
    return skillABS;
  };

  Game_Actor.prototype.uiPanelObjectsCount = function () {
    var count = 0;
    this._absParams.panelSkills.forEach(function (i) {
      if (i !== null) count++;
    });
    return count;
  };

  Game_Actor.prototype.setItemOnPanel = function (itemId, position) {
    if (this._absParams.battleSkillsABS.itemById(itemId) == null) {
      this._absParams.battleSkillsABS.push(itemId, true);
    }
    this._setObjectOnPanel(itemId, 1, position);
  };

  // * В отличии от предыдущего, не обновляет позицию предмета
  Game_Actor.prototype.setOrRefreshItemOnPanel = function (itemId, position) {
    if (this._absParams.battleSkillsABS.itemById(itemId) == null) {
      this._absParams.battleSkillsABS.push(itemId, true);
      this._setObjectOnPanel(itemId, 1, position);
    }
  };

  Game_Actor.prototype.setSkillOnPanel = function (skillId, position) {
    this._setObjectOnPanel(skillId, 0, position);
  };

  Game_Actor.prototype._uiPanelFreeSlot = function () {
    for (var i = 0; i < 8; i++) {
      if (this._absParams.panelSkills[i] === null) {
        return i;
      }
    }
    return null; //Not empty slots
  };

  Game_Actor.prototype._setOnPosition = function (id, type, position) {
    if (id == null) {
      this._absParams.panelSkills[position] = null;
      return;
    }
    if (type == 1) {
      this._absParams.panelSkills[position] = this._absParams.battleSkillsABS.itemById(id);
    } else {
      this._absParams.panelSkills[position] = this._absParams.battleSkillsABS.skillById(id);
    }
  };

  Game_Actor.prototype._setObjectOnPanel = function (skillId, type, position) {
    if (position === undefined) {
      var slot = this._uiPanelFreeSlot();
      if (slot >= 0) {
        this._setObjectOnPanel(skillId, type, slot);
      } else {
        return;
      }
    } else {
      if (skillId == null) {
        this._setOnPosition(null, type, position);
      } else {
        if (this._compareObjectOnPosition(skillId, type, position)) { //Remove if on self position
          this._setObjectOnPanel(null, type, position);
        } else {
          var index = this.skillIndexOnUI(skillId, type);
          if (index >= 0) { //Remove from other position if exists
            this._setOnPosition(null, type, index);
          }
          this._setOnPosition(skillId, type, position);
        }
      }

    }
    AlphaABS.BattleUI.refresh();
  };

  Game_Actor.prototype._compareObjectOnPosition = function (id, type, position) {
    if (this._absParams.panelSkills[position]) {
      var item = this._absParams.panelSkills[position];
      if (item.skillId == id) {
        if (type == 1) {
          if (item.isItem()) return true;
        } else {
          if (!item.isItem()) return true;
        }
      }
    }

    return false;
  };

  //Возвращяет номер этого навыка на панели или -1, если навыка нет на панели
  Game_Actor.prototype.skillIndexOnUI = function (skillId, isItem) {
    for (var i = 0; i < this._absParams.panelSkills.length; i++) {
      var item = this._absParams.panelSkills[i];
      if (item === null) continue;
      if (item.skillId == skillId) {
        if (isItem) {
          if (item.isItem()) return i;
        } else
        if (!item.isItem()) return i;
      }
    }

    return -1;
  };


  Game_Actor.prototype.stopABS = function () {
    Game_Battler.prototype.stopABS.call(this);
    this._unloadLastFirearm();
    if (this._absParams.stackSkillExists) {
      this._absParams.stackSkillExists = false;
    }
  };

  Game_Actor.prototype._prepareABSSkill = function (absSkill) {
    Game_Battler.prototype._prepareABSSkill.call(this, absSkill);
  };

  //NEW
  Game_Actor.prototype.refreshABSSkills = function () {
    var skillsAll = this._absParams.battleSkillsABS.all();
    for (var i = skillsAll.length - 1; i > 0; i--) {
      var item = skillsAll[i];
      if (item.isItem()) {
        if (item.isReady()) {
          if ($gameParty.numItems(item.skill()) == 0) {
            if (!this._absParams.panelSkills.include(item)) {
              LOG.p("Remove ITEM ABS from memory " + item.name());
              skillsAll.splice(i, 0);
            }
          }
        }
      }
    }
  };

  Game_Actor.prototype.performCurrentAction = function () {
    Game_Battler.prototype.performCurrentAction.call(this);

  };

  var _Game_Actor_displayLevelUp = Game_Actor.prototype.displayLevelUp;
  Game_Actor.prototype.displayLevelUp = function (newSkills) {
    if ($gameMap.isABS()) {
      AA.BattleUI.refresh();
      this._showLevelupAnimation();
    } else
      _Game_Actor_displayLevelUp.call(this, newSkills);
  };

  Game_Actor.prototype._showLevelupAnimation = function () {
    var levelUpAnimationId = AlphaABS.Parameters.get_LevelUpAnimationId();
    if (levelUpAnimationId > 0) {
      var myChar = $gameParty.getAIBotByBattler(this);
      if (myChar != null)
        myChar.requestAnimationABS(levelUpAnimationId);
    }
    if(AA.isABS())
      AA.UI.alert(AA.SYSTEM.STRING_ALERT_NEWLEVEL);
  };

  var _Game_Actor_tradeItemWithParty = Game_Actor.prototype.tradeItemWithParty;
  Game_Actor.prototype.tradeItemWithParty = function (newItem, oldItem) {
    $gameParty._noNotifyABS = true;
    var r = _Game_Actor_tradeItemWithParty.call(this, newItem, oldItem);
    $gameParty._noNotifyABS = false;
    return r;
  };

  var _Game_Actor_gainExp = Game_Actor.prototype.gainExp;
  Game_Actor.prototype.gainExp = function (exp) {
    if ($gameMap.isABS() && exp > 0) {
      var nExp = Math.round(exp * this.finalExpRate());
      if (this.isPlayer())
        AlphaABS.BattleUI.pushExpOnPanel(nExp);
    }
    _Game_Actor_gainExp.call(this, exp);
  };

  var pkd_GameActor_forgetSkill = Game_Actor.prototype.forgetSkill;
  Game_Actor.prototype.forgetSkill = function (skillId) {
    pkd_GameActor_forgetSkill.call(this, skillId);
    var index = this.skillIndexOnUI(skillId, false);
    if (index >= 0)
      this.setSkillOnPanel(null, index); //Delete from UI
    this._absParams.battleSkillsABS.remove(skillId, false);

  };

  var _Game_Actor_changeEquip = Game_Actor.prototype.changeEquip;
  Game_Actor.prototype.changeEquip = function (slotId, item) {
    this._absParams.needWeaponCheck = true;
    _Game_Actor_changeEquip.call(this, slotId, item);
    this.aaRefreshAnimaX();
    this._refreshVisualEq();
    this._refreshCanApplyForShieldUIButton();
    if(AA.isABS())
      $gamePlayer._refreshGamePadCommands();
  };

  //@[ALIAS]
  var _alias_Game_Actor_forceChangeEquip = Game_Actor.prototype.forceChangeEquip;
  Game_Actor.prototype.forceChangeEquip = function () {
      _alias_Game_Actor_forceChangeEquip.call(this, ...arguments);
      this.aaRefreshAnimaX();
      this._refreshVisualEq();
      this._refreshCanApplyForShieldUIButton();
      if (AA.isABS())
        $gamePlayer._refreshGamePadCommands();
  };

  var _Game_Actor_discardEquip = Game_Actor.prototype.discardEquip;
  Game_Actor.prototype.discardEquip = function (item) {
    this._absParams.needWeaponCheck = true;
    _Game_Actor_discardEquip.call(this, item);
  };

  var _Game_Actor_refresh = Game_Actor.prototype.refresh;
  Game_Actor.prototype.refresh = function () {
    _Game_Actor_refresh.call(this);
    this.aaRefreshAnimaX();
    $gameParty.requestWeightCapacityRefresh();
    $gamePlayer.refreshInventoryWSpeedDebuff();
    this._updateInventoryWeightAutoState();
    if (this._absParams.needWeaponCheck) {
      if (!AA.Utils.isSceneBattle())
        this._checkAdditionSkills();
      if ($gameMap.isABS()) {
        this._refreshWeaponABS();
        this._absParams.needWeaponCheck = false;
        AlphaABS.BattleUI.refreshWeaponIconAt(0);
      }

    }
  };

  //?[NEW]
  Game_Actor.prototype.checkAutoReloadFirearm = function (item) {
    var skill = this._firstBattleABSSkill();
    if (!skill.isFirearm()) return;
    if (!skill.isNeedReloadStack()) return;
    if (item.id == skill.ammo) {
      this.reloadFirearm();
    }
  };

  //?[NEW]
  Game_Actor.prototype._refreshWeaponABS = function () {
    this._unloadLastFirearm();
    this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
    //LOG.p("PL : Check weapon skill");
    if (this.weapons().length > 0) {
      var w = this.weapons()[0];
      if (w.meta.ABS) {
        if (w.meta.ABS == 0) {
          this._firstBattleABSSkill().loadExternal(w);
        }
        if (w.meta.ABS == 1) {
          this._firstBattleABSSkill().loadExternal(w, 1);
        }
        if (w.meta.firearm == 1) {
          LOG.p("Firearm finded!");
          this._changeFirearm();
          AlphaABS.BattleUI.showFirearmPanel();
        } else {
          AlphaABS.BattleUI.hideFirearmPanel();
        }
      } else {
        this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
      }
    } else {
      this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
    }
    this.refreshABSMotion();
    try {
      var ui = AA.BattleUI.getUI();
      if (ui) {
        if (ui.userWeaponIconController)
          if (this.weapons()[0]) {
            var icon = this.weapons()[0].iconIndex;
            ui.userWeaponIconController.drawIcon(icon);
          } else {
            ui.userWeaponIconController.drawDefault();
          }
      }
    } catch (e) {

    }
    AlphaABS.BattleUI.refresh();
  };

  //?[NEW]
  Game_Actor.prototype.refreshABSMotion = function () {
    this._absParams._isNeedABSMotionRefresh = true;
  };

  //?[NEW]
  Game_Actor.prototype.isNeedABSMotionRefresh = function () {
    return (this._absParams._isNeedABSMotionRefresh == true);
  };

  //?[NEW]
  Game_Actor.prototype.onABSMotionRefresh = function () {
    this._absParams._isNeedABSMotionRefresh = false;
  };

  //?[NEW]
  Game_Actor.prototype.isHasABSMotion = function () {
    var skill = this._firstBattleABSSkill();
    return skill.isHasMotion();
  };

  //?[NEW]
  Game_Actor.prototype.isHasABSMotionX = function () {
    var skill = this._firstBattleABSSkill();
    return skill.isHasMotionX();
  };

  //?[NEW]
  Game_Actor.prototype._unloadLastFirearm = function () {
    var lastSkill = this._firstBattleABSSkill();
    if (lastSkill.isFirearm()) {
      this._absParams._lastFirearmWeaponData = [lastSkill._currentStack, lastSkill.ammo];
      this.unloadFirearm();
      lastSkill.reloadFirearm(0);
    }
  };

  //?[NEW]
  Game_Actor.prototype._firstBattleABSSkill = function () {
    return this._absParams.battleSkillsABS.all()[0];
  };

  //?[NEW]
  Game_Actor.prototype._changeFirearm = function () {
    if (!this.isPlayer()) return;
    this.reloadFirearm();
  };

  //?[NEW]
  Game_Actor.prototype.unloadFirearm = function () {
    if (this._absParams._lastFirearmWeaponData != null) {
      var itemsCountFromStack = this._absParams._lastFirearmWeaponData[0];
      if (itemsCountFromStack > 0) {
        var ammoItem = $dataItems[this._absParams._lastFirearmWeaponData[1]];
        $gameParty._noNotifyABS = true;
        $gameParty.gainItem(ammoItem, itemsCountFromStack);
        LOG.p("Firearm unloaded to inventory " + itemsCountFromStack);
        $gameParty._noNotifyABS = false;
      }
      this._absParams._lastFirearmWeaponData = null;
    }

    AA.BattleUI.refresh();
  };

  //?[NEW]
  Game_Actor.prototype.reloadFirearm = function () {
    var skill = this._firstBattleABSSkill();
    if (!skill.isFirearm()) return;
    if (!skill.isReady()) return;
    if (skill._currentStack == skill.stack) return;
    if (skill._currentStack > 0) {
      this._absParams._lastFirearmWeaponData = [skill._currentStack, skill.ammo];
      this.unloadFirearm();
      skill.reloadFirearm(0);
    }
    var ammoItem = $dataItems[skill.ammo];
    var itemsCount = $gameParty.numItems(ammoItem);
    LOG.p("Try reload firearm " + itemsCount);
    if (itemsCount >= skill.stack) {
      $gameParty.loseItem(ammoItem, skill.stack);
      skill.reloadFirearm(skill.stack);
    } else {
      if (itemsCount > 0) {
        skill.reloadFirearm(itemsCount);
        $gameParty.loseItem(ammoItem, itemsCount);
      } else {
        LOG.p("Try reload firearm : NO AMMO");
        AlphaABS.BattleManagerABS.alertOnUIbySym('noAmmo');
        skill.reloadFirearm(0);
      }
    }
    AlphaABS.BattleUI.refresh();
  };

  //?[NEW]
  Game_Actor.prototype.saveFirearm = function () {
    try {
      if (this.weaponIsFirearm()) {
        $gameTemp.__firearmAmmoBeforeTransfer = this._firstBattleABSSkill()._currentStack;
      } else {
        $gameTemp.__firearmAmmoBeforeTransfer = null;
      }
    } catch (e) {
      AA.warning(e);
    }
  };

  //?[NEW]
  Game_Actor.prototype.weaponIsFirearm = function () {
    try {
      var skill = this._firstBattleABSSkill();
      return skill.isFirearm();
    } catch (e) {
      AA.warning(e);
      return false;
    }
  };

  //?[NEW]
  Game_Actor.prototype.checkLastFirearmLoad = function () {
    try {
      if (this.weaponIsFirearm()) {
        if ($gameTemp.__firearmAmmoBeforeTransfer && $gameTemp.__firearmAmmoBeforeTransfer > 0) {
          var s = this._firstBattleABSSkill();
          var ammoItem = $dataItems[s.ammo];
          if ($gameParty.numItems(ammoItem) >= $gameTemp.__firearmAmmoBeforeTransfer) {
            var oldStackTime = s.stackTime;
            s.stackTime = 0;
            s.reloadFirearm($gameTemp.__firearmAmmoBeforeTransfer);
            $gameParty.loseItem(ammoItem, $gameTemp.__firearmAmmoBeforeTransfer);
            s.stackTime = oldStackTime;
            AlphaABS.BattleUI.refresh();
          } else {
            this.reloadFirearm();
          }
          $gameTemp.__firearmAmmoBeforeTransfer = null;
        }
      }
    } catch (e) {
      AA.warning(e);
    }
  };

  //NEW
  Game_Actor.prototype._checkAdditionSkills = function () {
    //LOG.p("Check addition skills");
    this.addedSkills().forEach(function (i) {
      if (this._absParams.battleSkillsABS.skillById(i) == null) {
        this._absParams.battleSkillsABS.push(i, false);
        this.setSkillOnPanel(i, undefined);
      }
    }.bind(this));

    //CHECK ALL
    var d = this._skills.concat(this.addedSkills());
    this._absParams.battleSkillsABS.all().forEach(function (i) {
      if (!d.include(i.skillId)) {
        if (i.skillId != this.attackSkillId()) {
          this._absParams.battleSkillsABS.remove(i.skillId, false);
          var index = this.skillIndexOnUI(i.skillId, false);
          if (index != -1) {
            this.setSkillOnPanel(null, index);
          }
        }
      }
    }.bind(this));
  };

  //ALIAS
  var _Game_Actor_isEquipTypeLocked = Game_Actor.prototype.isEquipTypeLocked;
  Game_Actor.prototype.isEquipTypeLocked = function (etypeId) {
    if (etypeId == 1) {
      if ($gameMap.isABS()) {
        var timer = this._absParams.battleSkillsABS.all()[0].isReady();
        if (timer) {
          return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
        } else {
          return true;
        }
      } else {
        return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
      }
    } else {
      return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
    }
  };


  Game_Actor.prototype._initBattleSkills = function () {
    Game_Battler.prototype._initBattleSkills.call(this);
    try {
          this._absParams.battleSkillsABS.push(this.attackSkillId(), false);
    } catch (e) {
    
    }
    this._absParams.needWeaponCheck = true;
  };

  Game_Actor.prototype.isPlayer = function () {
    return (this == $gamePlayer.battler());
  };


  //OVER
  Game_Actor.prototype.addNewState = function (stateId) {
    Game_Battler.prototype.addNewState.call(this, stateId);
    if (this.isPlayer() && AA.isABS()) {
      var panel = AlphaABS.BattleUI.getPlayerStatusPanel();
      if (panel != null) {
        panel.collectItems();
      }
    }
  };

  //@[ALIAS]
  var _alias_Game_Actor_changeLevel = Game_Actor.prototype.changeLevel;
  Game_Actor.prototype.changeLevel = function () {
    _alias_Game_Actor_changeLevel.call(this, ...arguments);
    //$[TEMP SOLUTION]
    try {
      if (AlphaABS.isABS()) {
        var ui = AA.BattleUI.getUI();
        if (ui) {
          ui.refreshLevel();
        }
      }
    } catch (e) {

    }
  };

  //@[ALIAS]
  var _alias_Game_Actor_performDamage = Game_Actor.prototype.performDamage;
  Game_Actor.prototype.performDamage = function () {
    if (AlphaABS.Parameters.isNeedScreenShakeOnDamage())
      _alias_Game_Actor_performDamage.call(this);
    else {
      if (this.isSpriteVisible()) {
        this.requestMotion('damage');
      } else {
        // * NOTHING
      }
      SoundManager.playActorDamage();
    }
  };

  //END Game_Actor
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__refresh, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.axLayersByEquips = [];
    this.axLayersByEquipsRelative = [];
    // * Слои которые надо снять, после обновления экипировки
    this.axPreviousLayers = [];
  };
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    this.refreshAnimaXLayers();
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isAutoBattle, ALIAS__makeAutoBattleActions, ALIAS__usableSkills, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__isAutoBattle = _.isAutoBattle;
  _.isAutoBattle = function() {
    if (AA.isABS()) {
      return true;
    } else {
      return ALIAS__isAutoBattle.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__makeAutoBattleActions = _.makeAutoBattleActions;
  _.makeAutoBattleActions = function() {
    //aaEntity = $gameParty.getAAEntityByBattler(@)
    //if aaEntity.isHaveAnySupportAllySkill()
    //@_makeAutoBattleActionsWithSupport()
    //else
    ALIAS__makeAutoBattleActions.call(this);
    if (AA.isABS()) {
      return this._actions.shuffle();
    }
  };
  //@[ALIAS]
  //_._makeAutoBattleActionsWithSupport = ->
  //    for i in [0...@numActions().length]
  //        list = @makeActionList()
  //        maxValue = Number.MIN_VALUE
  //        for j in [0...list.length]
  //            value = list[j].evaluateWithSupport()
  //            if value > maxValue

  //@[ALIAS]
  ALIAS__usableSkills = _.usableSkills;
  _.usableSkills = function() {
    if (AA.isABS()) {
      return this.usableSkillsForABS();
    } else {
      return ALIAS__usableSkills.call(this);
    }
  };
  _.usableSkillsForABS = function() {
    var list, result;
    list = this._absParams.battleSkillsABS.all();
    list = list.filter((absSkill) => {
      return (absSkill != null) && this.canUse(absSkill.skill()) && this._isUsableABSSkillNow(absSkill);
    });
    result = list.map(function(absSkill) {
      return absSkill.skill();
    });
    return result;
  };
  _.usableSkillsABS = function() {
    var list;
    list = this._absParams.battleSkillsABS.all();
    list = list.filter((absSkill) => {
      return (absSkill != null) && this.canUse(absSkill.skill()) && this._isUsableABSSkillNow(absSkill);
    });
    return list;
  };
  _._isUsableABSSkillNow = function(absSkill) {
    var e;
    try {
      return AA.AILogicManager.isUsableABSSkillForAlly(absSkill) && AA.BattleManagerABS.canUseSkillByTimer(absSkill) && AA.BattleManagerABS.canUseSkillByAmmo(absSkill) && this._isABSSkillOnProperRange(absSkill);
    } catch (error) {
      e = error;
      AA.warning(e);
      return false;
    }
  };
  _._isABSSkillOnProperRange = function(absSkill) {
    var aaEntity;
    aaEntity = $gameParty.getAAEntityByBattler(this);
    if (aaEntity == null) {
      return false;
    }
    return BattleManagerABS.canUseSkillByRange(aaEntity.character(), aaEntity.getTarget(), absSkill);
  };
  _.isHaveAnySupportAllySkill = function() {
    var list;
    list = this.getAllySupportSkillList();
    return list.length > 0;
  };
  _.getAllySupportSkillList = function() {
    var list;
    list = this._absParams.battleSkillsABS.all();
    list = list.filter(function(absSkill) {
      return (absSkill != null) && absSkill.isForAlly();
    });
    return list;
  };
  _.usableAllySupportSkillsABS = function() {
    var list, result;
    list = this.getAllySupportSkillList();
    list = list.filter((absSkill) => {
      return (absSkill != null) && this.canUse(absSkill.skill()) && this._isUsableABSSkillNow(absSkill);
    });
    result = list.map(function(absSkill) {
      return absSkill.skill();
    });
    return result;
  };
  _.isHaveProperAllySupportAction = function() {
    var list;
    list = this.usableAllySupportSkillsABS();
    if (list.length <= 0) {
      return false;
    }
    this.makeActions();
    this.makeAutoBattleActions();
    if (this._actions.length > 0 && this._actions[0].isValid() && this._actions[0].isForFriend()) {
      return true;
    }
    return false;
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_ShieldExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS, _;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]

  //@[DEFINES]
  _ = Game_Actor.prototype;
  ALIAS = {};
  _._removeAAShieldState = function() {
    //"REMOVE STATE".p()
    this.removeState(this._playerAAShieldStateId);
    this._startShieldRestTimer();
    return this._refreshCanApplyForShieldUIButton();
  };
  _._startShieldRestTimer = function() {
    this._shieldRestTimer = new Game_TimerABS();
    return this._shieldRestTimer.start(60);
  };
  _._addAAShieldState = function() {
    this._checkEquipedAAShield();
    this._refreshCanApplyForShieldUIButton();
    if (this._playerAAShieldStateId === 0) {
      return false;
    }
    //"ADD STATE".p()
    if (this.isStateAddable(this._playerAAShieldStateId)) {
      //"STATE ADDED".p()
      this.addState(this._playerAAShieldStateId);
      return true;
    }
    return false;
  };
  _._checkEquipedAAShield = function() {
    var e, equip, i, j, ref;
    this._playerAAShieldStateId = 0;
    this._playerAAShieldMotion = null;
    e = this.equips();
    for (i = j = 0, ref = e.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      equip = e[i];
      if (equip == null) {
        continue;
      }
      if (DataManager.isArmor(equip)) {
        if (Imported.YEP_ItemCore === true) {
          equip = $dataArmors[equip.baseItemId];
        }
        try {
          DataManager.extractMetadata(equip);
        } catch (error) {
          e = error;
          AA.warning(e, 'something wrong in Shield Note');
        }
        if (equip.meta != null) {
          if (equip.meta.blockState != null) {
            this._playerAAShieldStateId = Number(equip.meta.blockState);
            this._playerAAShieldEquipId = i;
            if (equip.meta.motionX != null) {
              this._playerAAShieldMotion = equip.meta.motionX;
            }
            return;
          }
        }
      }
    }
  };
  _._refreshCanApplyForShieldUIButton = function() {
    //"REFRESH".p()
    this._checkEquipedAAShield();
    this.__canApplyShieldState = this._playerAAShieldStateId > 0;
    if (this.__canApplyShieldState === false) {
      return this._destroyShieldRestTimer();
    }
  };
  //"RESULT".p(@__canApplyShieldState)
  _._destroyShieldRestTimer = function() {
    return this._shieldRestTimer = null;
  };
  _.updateABS = function() {
    Game_Battler.prototype.updateABS.call(this);
    return this._updateShieldExt();
  };
  _._updateShieldExt = function() {
    if (this._shieldRestTimer != null) {
      this._shieldRestTimer.update();
      if (this._shieldRestTimer.isReady()) {
        //console.info @_shieldRestTimer.getValue()
        return this._shieldRestTimer = null;
      }
    }
  };
  ALIAS.eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    ALIAS.eraseState.call(this, stateId);
    if (this._playerAAShieldStateId === stateId) {
      if (this.isPlayer()) {
        return $gamePlayer._removeAAShieldState();
      }
    }
  };
})();

// ■ END Game_Actor_ShieldExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_SummonExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS, _;
  
  //@[EXTENSION]
  //@[DEFINES]
  _ = Game_Actor.prototype;
  ALIAS = {};
  ALIAS.addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    if (this._isSummonState(stateId)) {
      if (this._canAddSummonState()) {
        if (this._onSummonStateAdded(stateId)) {
          return ALIAS.addNewState.call(this, stateId);
        }
      }
    } else {
      return ALIAS.addNewState.call(this, stateId);
    }
  };
  _._isSummonState = function(stateId) {
    var e;
    try {
      return AA.Utils.hasMeta('summon', $dataStates[stateId]);
    } catch (error) {
      e = error;
      AA.warning('Check State Meta (_isSummonState)', e);
      return false;
    }
  };
  _._canAddSummonState = function() {
    return AA.isABS() && !this._isHasSummonUnit();
  };
  _._onSummonStateAdded = function(stateId) {
    var bot, e, enemyEvId;
    if (this._isHasSummonUnit()) { // * НЕЛЬЗЯ 2 СОСТОЯНИЯ ВЫЗОВА
      return false;
    }
    try {
      //"SUMMON STATE ADDED".p()
      enemyEvId = AA.Utils.getNumberFromMeta('summon', $dataStates[stateId]);
      bot = $gameMap.spawnSummonUnit(enemyEvId, $gamePlayer.x, $gamePlayer.y);
      if (bot != null) {
        this._mySummonUnit = bot;
        this._mySummonStateId = stateId;
        this.__playSummonStartAnimation();
        AA.BattleUI.showSummonUnitUI();
        return true;
      }
    } catch (error) {
      e = error;
      AA.warning('Create Summon Unit (_onSummonStateAdded)', e);
    }
    return false;
  };
  _.__playSummonStartAnimation = function() {
    var animId, e;
    try {
      if (AA.Utils.hasMeta('summonStartAnimId', $dataStates[this._mySummonStateId])) {
        animId = AA.Utils.getNumberFromMeta('summonStartAnimId', $dataStates[this._mySummonStateId]);
        if (animId > 0) {
          this._mySummonUnit.requestAnimationABS(animId);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Play Summon Unit Start animation (__playSummonStartAnimation)', e);
    }
  };
  ALIAS.eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    ALIAS.eraseState.call(this, stateId);
    if (this._isHasSummonUnit()) {
      if (this._isSummonState(stateId)) {
        return this._onSummonStateRemoved();
      }
    }
  };
  _._isHasSummonUnit = function() {
    return this._mySummonUnit != null;
  };
  _._onSummonStateRemoved = function() {
    //"SUMMON STATE REMOVED".p()
    if (!this._isHasSummonUnit()) {
      return;
    }
    this._mySummonUnit._beforeRemoveFromMap();
    this._removeSummonFromMap();
    this._mySummonUnit = null;
    this._mySummonStateId = null;
    return $gamePlayer._resetSummonUnit();
  };
  _._removeSummonFromMap = function() {
    var e;
    if (!this._isHasSummonUnit()) {
      return;
    }
    try {
      this.__playSummonEndAnimation();
      this._mySummonUnit.erase();
      if (AA.Utils.isSceneMap()) {
        SceneManager._scene._spriteset.removeSpawnEventABS(this._mySummonUnit.eventId());
        AA.BattleUI.hideSummonUnitUI();
      }
      $gameMap._events[this._mySummonUnit.eventId()] = null;
      $gameMap.refresh();
      return $gameTroop.setup();
    } catch (error) {
      //"UNIT REMOVE FROM MAP".p()
      e = error;
      AA.warning('(_removeSummonFromMap)', e);
      return false;
    }
  };
  _.__playSummonEndAnimation = function() {
    var animId, e;
    try {
      if (AA.Utils.hasMeta('summonEndAnimId', $dataStates[this._mySummonStateId])) {
        animId = AA.Utils.getNumberFromMeta('summonEndAnimId', $dataStates[this._mySummonStateId]);
        AA.BattleManagerABS.battleProcess()._centerPoint = this._mySummonUnit.toPoint();
        AA.BattleManagerABS.battleProcess()._requestMapAnimation(animId);
      }
    } catch (error) {
      e = error;
      AA.warning('Play Summon Unit Start animation (__playSummonStartAnimation)', e);
    }
  };
  _._deleteSummonState = function() {
    if (this._mySummonStateId == null) {
      return;
    }
    return this.removeState(this._mySummonStateId);
  };
})();

// ■ END Game_Actor_SummonExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_VisualEqExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Actor.prototype;
  // * OnEquipChange
  _._refreshVisualEq = function() {
    this._checkVisualEq();
    this._needAAVisualEQRefresh = true;
    return AA.BattleUI.redrawVisualEqOnPortrait();
  };
  _._isNeedVisualEqRefresh = function() {
    return this._needAAVisualEQRefresh === true;
  };
  _._onVisualEqRefresh = function() {
    return this._needAAVisualEQRefresh = false;
  };
  _._getVisualEqData = function() {
    return this._visualEqData;
  };
  _.isHasVisualEq = function() {
    var ref;
    return ((ref = this._getVisualEqData()) != null ? ref.length : void 0) > 0;
  };
  _._checkVisualEq = function() {
    var equip, i, len, ref, ref1, results;
    this._visualEqData = [];
    ref = this.equips();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      equip = ref[i];
      if (equip == null) {
        continue;
      }
      if (DataManager.isArmor(equip)) {
        if (Imported.YEP_ItemCore === true) {
          equip = $dataArmors[equip.baseItemId];
        }
        DataManager.extractMetadata(equip);
        if (((ref1 = equip.meta) != null ? ref1.visual : void 0) != null) {
          results.push(this._visualEqData.push(equip.meta.visual));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
})();

// ■ END Game_Actor_VisualEqExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //?[ANIMAX_E]
  // * Система анимации XAnima
  // -----------------------------------------------------------------------
  _.aaRefreshAnimaX = function() {
    return this._isNeedAnimaXRefresh = true;
  };
  _.aaIsNeedAnimaXRefresh = function() {
    return this._isNeedAnimaXRefresh === true;
  };
  _.aaOnAnimaXRefresh = function() {
    return this._isNeedAnimaXRefresh = null;
  };
  _.getAnimaXEquipmentSet = function() {
    var e, equipSet, i, len, ref;
    ref = this.equips();
    for (i = 0, len = ref.length; i < len; i++) {
      e = ref[i];
      if (e == null) {
        continue;
      }
      equipSet = KDCore.Utils.getValueFromMeta('xAnimaSet', e);
      if (equipSet != null) {
        return equipSet;
      }
    }
    return null;
  };
  // * Чтобы не удалялись части, которые добавленны параметром плагина
  // * используется массив axPreviousLayers, в котором храняться части
  // * которые были в прошлый раз, но в этот их уже нету - т.е. их надо удалить
  _.refreshAnimaXLayers = function() {
    var e, equipLayer, i, len, ref;
    this.axPreviousLayers = [...this.axLayersByEquips, ...this.axLayersByEquipsRelative];
    this.axLayersByEquips = [];
    this.axLayersByEquipsRelative = [];
    ref = this.equips();
    for (i = 0, len = ref.length; i < len; i++) {
      e = ref[i];
      if (e == null) {
        continue;
      }
      equipLayer = KDCore.Utils.getValueFromMeta('xAnimaLayer', e);
      this._registerLayerByEquip(equipLayer, false);
      equipLayer = KDCore.Utils.getValueFromMeta('xAnimaLayerRelative', e);
      this._registerLayerByEquip(equipLayer, true);
    }
  };
  _._registerLayerByEquip = function(name, isRelative) {
    if (!String.any(name)) {
      return;
    }
    this.axPreviousLayers.delete(name);
    if (isRelative === true) {
      this.axLayersByEquipsRelative.push(name);
    } else {
      this.axLayersByEquips.push(name);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor EXT.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Actor.prototype;
  _._setSkillOnPanelByID = function(skillId, index) {
    var e, skill;
    if (!this.isLearnedSkill(skillId)) {
      return;
    }
    try {
      skill = $dataSkills[skillId];
      if (skill.occasion === 1) {
        if (index != null) {
          if (index === this._getSkillIndexOnUIByID(skillId)) {
            return;
          }
        }
        return this.setSkillOnPanel(skillId, index);
      }
    } catch (error) {
      e = error;
      return AA.warning('when set skill on panel with uAPI', e);
    }
  };
  _._getSkillIndexOnUIByID = function(skillId) {
    var data, i, j, ref;
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] == null) {
        continue;
      }
      if (data[i].skillId === skillId && !data[i].isItem()) {
        return i;
      }
    }
    return null;
  };
  _._removeSkillFromPanelByID = function(skillId) {
    var index;
    index = this._getSkillIndexOnUIByID(skillId);
    if (index != null) {
      return this.setSkillOnPanel(null, index);
    }
  };
  _._saveUISkillPanelState = function() {
    var data, i, j, ref;
    $gamePlayer.__savedUIPanelSkills = [];
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] != null) {
        $gamePlayer.__savedUIPanelSkills[i] = [data[i].skillId, data[i].isItem()];
      } else {
        $gamePlayer.__savedUIPanelSkills[i] = null;
      }
    }
  };
  _._restoreUISkillPanelState = function() {
    var data, i, item, j, ref;
    if ($gamePlayer.__savedUIPanelSkills == null) {
      return;
    }
    this.uiPanelReset();
    data = $gamePlayer.__savedUIPanelSkills;
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      item = data[i];
      if (item != null) {
        if (item[1] === true) {
          this._setItemOnPanelByID(item[0], i);
        } else {
          this._setSkillOnPanelByID(item[0], i);
        }
      } else {
        this.setSkillOnPanel(null, i);
      }
    }
  };
  _._setItemOnPanelByID = function(itemId, index) {
    var e, item;
    item = $dataItems[itemId];
    if (!this.__isProperItemToPanel(item)) {
      return;
    }
    try {
      if (index != null) {
        if (index === this._getItemIndexOnUIByID(itemId)) {
          return;
        }
      }
      return this.setItemOnPanel(itemId, index);
    } catch (error) {
      e = error;
      return AA.warning('when set item on panel with uAPI', e);
    }
  };
  _.__isProperItemToPanel = function(item) {
    return (item != null) && item.occasion === 1 && (item.meta.ABS != null);
  };
  _._getItemIndexOnUIByID = function(itemId) {
    var data, i, j, ref;
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] == null) {
        continue;
      }
      if (data[i].skillId === itemId && data[i].isItem()) {
        return i;
      }
    }
    return null;
  };
  _._removeItemFromPanelByID = function(itemId) {
    var index;
    index = this._getItemIndexOnUIByID(itemId);
    if (index != null) {
      return this.setSkillOnPanel(null, index);
    }
  };
})();

// ■ END Game_Actor EXT.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor3.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__performAttack_111, ALIAS__performMapDamage_111, ALIAS__turnEndOnMap_111, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  ALIAS__performAttack_111 = _.performAttack;
  _.performAttack = function() {
    if (AA.isABS()) {
      return this._performAttackABS();
    } else {
      return ALIAS__performAttack_111.call(this);
    }
  };
  ALIAS__performMapDamage_111 = _.performMapDamage;
  _.performMapDamage = function() {
    if (AA.isABS()) {
      return $gameScreen.startFlashForDamage();
    } else {
      return ALIAS__performMapDamage_111.call(this);
    }
  };
  ALIAS__turnEndOnMap_111 = _.turnEndOnMap;
  _.turnEndOnMap = function() {
    if (AA.isABS()) {

    } else {
      //?[EMPTY]
      return ALIAS__turnEndOnMap_111.call(this);
    }
  };
  _._updateInventoryWeightAutoState = function() {
    var stateId;
    stateId = AA.Parameters.get_WSAutoState();
    if (stateId <= 0) {
      return;
    }
    if (uAPI.isOverWeight) {
      return this.addState(stateId);
    } else {
      return this.removeState(stateId);
    }
  };
})();

// ■ END Game_Actor3.coffee
//---------------------------------------------------------------------------

(function () {
  "use strict";

  var LOG = new KDCore.DevLog("BattleProcessABS");
  LOG.applyLibraryColors();

  var ABSUtils = AlphaABS.UTILS;

  //BattleProcessABS
  //------------------------------------------------------------------------------
  class Game_BattleProcessABS {
    constructor() {
      this._postProcesses = [];
      this._skill = null;
      this._centerPoint = null;
    }

    performBattleAction(subject, target) {
      this._processAction(subject, target, subject.battler().currentAction());
    }

    performBattleActionZone(subject, action) {
      LOG.p("Battle : Start Zone Action");
      this._processAction(subject, null, action);
    }

    performBattleActionRadius(subject, point, action, skill) {
      LOG.p("Battle : Start Radius Action");
      if (skill.isSpecialTeleportType() && subject == $gamePlayer) {
        LOG.p("Battle: Perform Playe Teleport Action");
        this._processPlayerTeleport(point);
      }
      this._centerPoint = point;
      this._processAction(subject, null, action);
    }

    _processPlayerTeleport(point) {
      try {
        //$gamePlayer.requestAnimationABS(startAnimId);
        //this._requestMapAnimation(startAnimId);
        $gamePlayer.locate(point.x, point.y);
      } catch (e) {
        AA.warning(e);
      }
    }

    startPostBattleAction(subject, target, action, skill) {
      LOG.p("Battle : Start post Action");
      action._forcing = true; //Because subject use MP and other on action start
      var postProcess = {};
      postProcess.subject = subject;
      postProcess.target = target;
      postProcess.action = action;
      postProcess.skill = skill;
      var t = new AlphaABS.LIBS.Game_SVector(postProcess);
      this._postProcesses.push(t);
      $gameMap.addSVector(t);
      if (subject == $gamePlayer) {
        if (!$gamePlayer.inBattle())
          $gamePlayer.onBattleStart();
      }
    }

    performPostBattleAction(sVector) {
      try {
        var t = sVector.data();
        if (t.skill.isVectorTypeR()) {
          LOG.p("Battle : Start Radius Action by Vector");
          this._centerPoint = t.target;
          this._processAction(t.subject, null, t.action);
        } else {
          if(t.skill.isNoTarget()) {
            if(sVector._target != null) {
              this._processAction(t.subject, sVector._target, t.action);
            } else {
              this._centerPoint = t.target;
              this._processAction(t.subject, null, t.action);
            }
          } else {
            this._processAction(t.subject, t.target, t.action);
          }
        }
      } catch (e) {
        console.error(e);
      } finally {
        this._postProcesses.delete(sVector);
      }
    }

    isPostProcessExists() {
      return (this._postProcesses.length != 0);
    }

    //PRIVATE
    _processAction(subject, target, action) {
      if (subject == null) {
        return;
      }
      if (!subject.battler()) {
        return;
      }
      if (action) {
        action.prepare(); //???
        if (action.isValid()) {
          this._start_action(subject, target, action);
          this._end_action(subject);
        }
      }
    }

    _start_action(subject, target, action) {
      //subject.requestEffect('whiten'); TODO
      try {
        this._skill = subject.battler().skillABS_byAction(action);
        action.applyGlobal();
        var targets = this._makeTargets(subject, target);
        targets.delete(null);
        this._showAnimation(subject, targets, action);
        targets.forEach(function (item) {
          if (item && item.inActive()) {
            this._invokeAction(subject, item, action);
          }
        }.bind(this));
        if (this._skill.isLandmine()) {
          //"IS LAND MINE".pe()
          this._checkAndPlaceLandMine(this._skill, subject, target);
        }
      } catch (e) {
        console.error(e);
      }
    }

    _end_action(subject) {
      if (subject && subject.battler()) {
        subject.battler().performActionEnd(); //???
        subject.battler().onAllActionsEnd();
      }
      this._skill = null;
      this._centerPoint = null;
    }

    _invokeAction(subject, target, action) {
      if (action.numRepeats() > 1) {
        var time = 120;
        if (this._skill && this._skill.repeatDelay > 0) {
          time = this._skill.repeatDelay;
        }
        for (var i = 0; i < action.numRepeats(); i++) {
          AA.setTimeout(function () {
            this._invokeNormalAction(subject, target, action);
          }.bind(this), time * i);
        }
      } else
        this._invokeNormalAction(subject, target, action);
    }

    _invokeNormalAction(subject, target, action) {
      //var realTarget = this.applySubstitute(target);
      try {
        action.apply(target.battler());
        var _skill = this._skill;
        if (this._skill == null)
          _skill = subject.battler().skillABS_byAction(action);
        if (_skill && _skill.cEonUse > 0) {
          if (target instanceof Game_AIBot) {
            target.startCommonEvent(_skill.cEonUse);
          }
        }
        if (_skill && _skill.isHasImpulse()) {
          if (target.battler().result().used)
            this._processImpulseAction(subject, target, _skill);
        }
        this._onActionResult(subject, target);
      } catch (e) {
        console.error(e);
      }
    }

    _checkAndPlaceLandMine(absSkill, subject, target) {
      // * Только на себя или выбор места расположения
      try {
        if (absSkill.type == 0 || absSkill.type == 2) {
          var placerId = 0;
          if(subject.isEnemy()) {
            placerId = subject.battler().enemyId();
          }
          var d = {
            "objectId": absSkill.landmineSkillId,
            "placerId": placerId,
            "timer": absSkill.landmineTime,
            "onlyTimer": absSkill.landmineTimeOnly
          };
          //"Land mine spawned".pe();
          var spawnPoint = subject;
          if(target == null) {
            // * RADIUS
            spawnPoint = this._centerPoint;
          }
          $gameMap.spawnLandMine(absSkill.landmineEventId, spawnPoint.x, spawnPoint.y, d);
        }
      } catch (e) {
        AA.warning(e, "When try place landmine : BattleProcessABS");
      }
    }

    _processImpulseAction(subject, target, absSkill) {
      if (target != $gamePlayer) {
        if (target.behaviorModel().heavy)
          return;
      }
      var d = subject.direction();
      var dx = 0;
      var dy = 0;
      var dd = d;
      if (absSkill.isRandomImpulseDirecton()) {
        dx = KDCore.SDK.rand(0, 1);
        dy = KDCore.SDK.rand(0, 1);
      } else {
        if (target.x == subject.x && target.y == subject.y) { //ON SELF

          if (d == 4 || d == 6) { //X
            if (d == 4) {
              dx = -1;
            } else
              dx = 1;

          } else if (d == 2 || d == 8) { //Y
            if (d == 2) {
              dy = 1;
            } else {
              dy = -1;
            }
          }
        } else {
          if (target.x < subject.x) {
            dx = -1;
            dd = 4;
          }

          if (target.y < subject.y) {
            dy = -1;
            dd = 8;
          }

          if (target.x > subject.x) {
            dx = 1;
            dd = 6;
          }

          if (target.y > subject.y) {
            dy = 1;
            dd = 2;
          }
        }
      }
      target.onApplyImpulseForce(dx * absSkill.impulse, dy * absSkill.impulse, dd);
    }

    _makeTargets(subject, target) {
      try {
        var targets = [];
        if (this._skill.isZoneType()) {
          var zone = this._generateZone(subject, !this._skill.isIgnoreObstacles());
          var points = zone.points;
          this._centerPoint = zone.center;
          var candidates = [];
          if (this._forceTargetsCandidates) {
            candidates = this._forceTargetsCandidates;
          } else {
            if (subject == $gamePlayer) {
              candidates = $gameTroop.onlyHostileMembersABS();
            } else {
              candidates = [$gamePlayer];
            }
          }
          for (var i = 0; i < points.length; i++) {
            candidates.forEach(function (item) {
              if (ABSUtils.inPoint(item, points[i])) {
                targets.push(item);
              }
            });
          }
          return targets;
        } else
        if (this._skill.isRadiusType() || this._skill.isVectorTypeR() || this._skill.isExplosive()) {
          if(this._skill.isExplosive() && this._centerPoint == null) {
            this._centerPoint = target.toPoint();
          }
          if (this._forceTargetsCandidates) {
            targets = this._forceTargetsCandidates;
          } else {
            if (subject == $gamePlayer || subject.isAlly($gamePlayer)) {
              targets = ABSUtils.inRadius(this._centerPoint, this._skill.radius, $gameTroop.onlyHostileMembersABS());
            } else {
              targets = ABSUtils.inRadius(this._centerPoint, this._skill.radius, [$gamePlayer].concat($gameParty.aliveMembersABS()));
            }
          }
        } else {
          targets.push(target);
          if (this._skill.isForAllAlly() && subject.isAlly($gamePlayer)) {
              if(target != $gamePlayer)
                targets.push($gamePlayer);
              var allies = $gameParty.membersABS();
              for (var iii = 0; iii < allies.length; iii++) {
                var m = allies[iii];
                if(!targets.contains(m)) {
                  targets.push(m);
                }
              }
          }
        }
        this.setForceTargetsForZoneAndRadius(null);
        return targets;
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    setForceTargetsForZoneAndRadius(targets) {
      this._forceTargetsCandidates = targets;
    }

    _showAnimation(subject, targets, action) {
      try {
        if (action.isSkill() && action.item().id == subject.battler().attackSkillId()) {
          this._requestAnimation(targets, subject.battler().attackAnimationId1());
        } else {
          var animId = action.item().animationId;
          /*if(this._skill.isVectorType() && this._skill.isNoTarget()) {
            if(targets.length == 0) {
              this._requestMapAnimation(animId);
              return;
            }
          }*/
          if (this._skill.isZoneType() || this._skill.isRadiusType() || this._skill.isVectorTypeR() || this._skill.isExplosive()) {
            this._requestMapAnimation(animId);
          } else {
            this._requestAnimation(targets, animId);
          }
        }
      } catch (e) {
        console.error(e);
      }
    }

    _requestAnimation(objects, animationId) {
      objects.forEach(function (item) {
        if (item)
          item.requestAnimationABS(animationId);
      });
    }

    _requestMapAnimation(animationId) {
      try {
        if (!this._centerPoint) {
          return;
        }
        if (!(this._centerPoint instanceof KDCore.Point)) {
          this._centerPoint = this._centerPoint.toPoint();
        }
        LOG.p("Request Map animation on " + this._centerPoint.toString());

        var point = this._centerPoint;

        $gameMap.requestAnimationABS({
          point: point,
          id: animationId
        });
      } catch (e) {
        console.error(e);
      }
    }

    _onActionResult(subject, target) {
      try {
        if (target.battler().result().used) {
          this._resultOnDamage(target.battler());
          target.battler().startDamagePopup();
          subject.battler().startDamagePopup();
          if(!subject.__isGlobal)
            target.onActionOnMe(subject);
        }
      } catch (e) {
        console.error(e);
      }
    }

    _resultOnDamage(target) {
      try {
        if (target.result().missed) {
          if (target.result().physical) {
            target.performMiss();
          } else {
            this._resultOnFailure(target);
          }

        } else if (target.result().evaded) {
          if (target.result().physical) {
            target.performEvasion();
          } else {
            target.performMagicEvasion();
          }
        } else {
          //HP
          if (target.result().hpAffected) {
            if (target.result().hpDamage > 0 && !target.result().drain) {
              target.performDamage();
            }
            if (target.result().hpDamage < 0) {
              target.performRecovery();
            }
          }
          //MP
          if (target.isAlive() && target.result().mpDamage !== 0) {
            if (target.result().mpDamage < 0) {
              target.performRecovery();
            }
          }
          //TP
          if (target.isAlive() && target.result().tpDamage !== 0) {
            if (target.result().tpDamage < 0) {
              target.performRecovery();
            }
          }
        }
        target.performActionUsed();
      } catch (e) {
        console.error(e);
      }
    }

    _resultOnFailure(target) {
      //Empty
    }

    _resultOnAffectedStatus(target) {
      try {
        var states = target.result().addedStateObjects();
        states.forEach(function (state) {
          var state_msg = target.isActor() ? state.message1 : state.message2;
        }.bind(this));
      } catch (e) {
        console.error(e);
      }
    }

    _generateZone(subject, withZoneCheck) {
      try {
        var d = ABSUtils.getDirKey(subject);
        var points = [];
        var point = subject.toPoint();

        /*
            **
        SUBJECT ***
            **
        */

        var centerPoint = null;

        switch (d) {
          case 'r':
            centerPoint = new KDCore.Point(point.x + 2, point.y);
            points.push(new KDCore.Point(point.x + 1, point.y + 1));
            points.push(new KDCore.Point(point.x + 1, point.y - 1));
            break;
          case 'l':
            centerPoint = new KDCore.Point(point.x - 2, point.y);
            points.push(new KDCore.Point(point.x - 1, point.y + 1));
            points.push(new KDCore.Point(point.x - 1, point.y - 1));
            break;
          case 'u':
            centerPoint = new KDCore.Point(point.x, point.y - 2);
            points.push(new KDCore.Point(point.x + 1, point.y - 1));
            points.push(new KDCore.Point(point.x - 1, point.y - 1));
            break;
          default: //d
            centerPoint = new KDCore.Point(point.x, point.y + 2);
            points.push(new KDCore.Point(point.x + 1, point.y + 1));
            points.push(new KDCore.Point(point.x - 1, point.y + 1));
            break;
        }

        points.push(centerPoint);
        points.push(new KDCore.Point(centerPoint.x - 1, centerPoint.y));
        points.push(new KDCore.Point(centerPoint.x + 1, centerPoint.y));
        points.push(new KDCore.Point(centerPoint.x, centerPoint.y - 1));
        points.push(new KDCore.Point(centerPoint.x, centerPoint.y + 1));

        if (withZoneCheck == true) {
          for (var i = 0; i < points.length; i++) {
            if (!AlphaABS.BattleManagerABS.checkLineOfSight(point, points[i])) {
              points.delete(points[i]);
            }
          }
        }

        /*
         *
         * CenterPoint *
         *
         */

        return {
          center: centerPoint,
          points: points
        };
      } catch (e) {
        console.error(e);
        return {
          center: KDCore.Point.Empty,
          points: []
        };
      }
    }
  }

  AlphaABS.register(Game_BattleProcessABS);
  AlphaABS.BattleManagerABS.connectProcess();

  //END BattleProcessABS
  //------------------------------------------------------------------------------



})();
(function () {

  var PopInfoManagerABS;
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

  var _Game_Battler_initMembers = Game_Battler.prototype.initMembers;
  Game_Battler.prototype.initMembers = function () {
    _Game_Battler_initMembers.call(this);
    PopInfoManagerABS = AlphaABS.LIBS.PopInfoManagerABS;
    if(KDCore.isMV())
      this._initBattleSkills();
  };

  var _GameBattler_attackSpeed = Game_Battler.prototype.attackSpeed;
  Game_Battler.prototype.attackSpeed = function () {
    var attackSpeed = _GameBattler_attackSpeed.call(this);
    if (attackSpeed == 0) {
      return 120;
    } else
      return attackSpeed;
  };

  //NEW
  Game_Battler.prototype.initABS = function () {
    this.appear();
    if (!this.isPreserveTp()) {
      this.initTp();
    }
    if(KDCore.isMZ())
      this._initBattleSkills();
    this._absParams.battleSkillsABS.all().forEach(function (item) {
      this._prepareABSSkill(item);
    }.bind(this));
  };

  //NEW
  Game_Battler.prototype.onGameLoad = function () {
    //EMPTY
  };

  //NEW
  Game_Battler.prototype.updateABS = function () {
    this._absParams.battleSkillsABS.update();
    this.updateStateTurns();
    this.updateBuffTurns();
    this.removeStatesAuto(2);
    this.removeBuffsAuto();
  };

  var pkd_GameBattler_regenerateAll = Game_Battler.prototype.regenerateAll;
  Game_Battler.prototype.regenerateAll = function () {
    this.clearResult();
    pkd_GameBattler_regenerateAll.call(this);
    if (this.isAlive()) {
      if (this.hp < this.mhp || this.mp < this.mmp)
        PopInfoManagerABS.makeDamagePopUp(this);
    }
  };


  //NEW
  Game_Battler.prototype.stopABS = function () {
    this.onBattleEnd();
    this.removeBattleStates();
    this.removeAllBuffs();
  };

  //NEW
  Game_Battler.prototype.skillABS_byId = function (skillId, isItem = false) {
    if (isItem) {
      return this._absParams.battleSkillsABS.itemById(skillId);
    } else {
      return this._absParams.battleSkillsABS.skillById(skillId);
    }
  };

  //NEW
  Game_Battler.prototype.skillABS_byAction = function (action) {
    if (action != null && action.item())
      return this.skillABS_byId(action.item().id, action.isItem());
    else
      return null;
  };

  //NEW
  Game_Battler.prototype.skillABS_attack = function () {
    return this.skillABS_byId(this.attackSkillId(), false);
  };

  //NEW
  Game_Battler.prototype.performCurrentAction = function () {
    var action = this.action(0);
    var skill = this.skillABS_byAction(action);
    if (skill.isNeedReloadParam()) {
      skill.preUse(this._calculateABSSkillReloadParam(skill.reloadParam));
    }
    this.useItem(action.item());
    skill.onUse();
    if (skill.skillId != this.attackSkillId() && !skill.isNeedCast()) {
      //Атака не вызывает postUse
      //Навык, который необходимо кастовать, тоже не вызывает postUse
      this._absParams.battleSkillsABS.all().forEach(function (skill) {
        skill.postUse();
      });
    }

    this.removeStatesAuto(1);
    this.removeBuffsAuto();
  };

  Game_Battler.prototype._calculateABSSkillReloadParam = function (reloadParam) {
    var reloadVar = 10;
    try {
      /* jshint -W061 */
      reloadVar = Math.round(parseInt(eval(reloadParam)));
    } catch (err) {
      AlphaABS.error(err, "Can't calculate <reloadParam>");
      reloadVar = 10;
    }
    return reloadVar;
  };

  var _Game_Battler_onDamage = Game_Battler.prototype.onDamage;
  Game_Battler.prototype.onDamage = function (value) {
    _Game_Battler_onDamage.call(this, value);
    if (this._absParams.needInterruptCast == true)
      return;
    this._absParams.battleSkillsABS.all().forEach(function (s) {
      if (s.isCasting()) {
        s.onCastDelay(30); //TODO:: Подучать как лучше (в %), сколько урон от макс.HP в процентах, столько и в процентах от castMaxTime (начиная с порога)
      }
    });
  };

  //?[NEW]
  Game_Battler.prototype.setNeedAACastInterrupt = function () {
    if(AA.isABS()) {
      this._absParams.needInterruptCast = true;
    }
  };


  //?[NEW]
  Game_Battler.prototype.isNeedAACastStop = function () {
      return this._absParams.needInterruptCast == true;
  };

  //NEW
  Game_Battler.prototype._prepareABSSkill = function (absSkill) {
    //EMPTY
  };

  //?[NEW]
  Game_Battler.prototype.onAACastStop = function () {
      this._absParams.needInterruptCast = false;
  };

  //OVER
  Game_Battler.prototype.addNewState = function (stateId) {
    Game_BattlerBase.prototype.addNewState.call(this, stateId);
    if (this._states.include(stateId)) {
      PopInfoManagerABS.makeStatePopUp(this, stateId, false);
      if (AlphaABS.isABS())
        this._checkStateCommonEvent(stateId);
    }
  };

  //?[NEW]
  Game_Battler.prototype._checkStateCommonEvent = function (stateId) {
    try {
      var state = $dataStates[stateId];
      if (state) {
        if (state.meta.cEonStart > 0) {
          this._startCommonEventFromState(state.meta.cEonStart);
        }
        if (state.meta.cEonEnd > 0) {
          this._registerCommonEventOnStateEnd(stateId, state.meta.cEonEnd);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Game_Battler.prototype._startCommonEventFromState = function (evId) {
    if (this.isPlayer()) {
      $gamePlayer.startCommonEventABS(evId);
    } else {
      this._startCommonEventOnAI(evId);
    }
  };

  //?[NEW]
  Game_Battler.prototype._registerCommonEventOnStateEnd = function (stateId, evId) {
    if (!this._onEndStateEvents)
      this._onEndStateEvents = {};
    this._onEndStateEvents[stateId] = evId;
  };

  //?[NEW]
  Game_Battler.prototype._startCommonEventOnAI = function (commonEventId) {
    var all = BattleManagerABS.getAllBotsOnMap();
    for (var i = 0; i < all.length; i++) {
      var bot = all[i];
      if (bot.battler() == this) {
        bot.startCommonEvent(commonEventId);
        return;
      }
    }
  };

  var pkd_GameBattler_addBuff = Game_Battler.prototype.addBuff;
  Game_Battler.prototype.addBuff = function (paramId, turns) {
    PopInfoManagerABS.makeBuffPopUp(this, paramId, true);
    pkd_GameBattler_addBuff.call(this, paramId, turns);
  };

  var pkd_GameBattler_addDebuff = Game_Battler.prototype.addDebuff;
  Game_Battler.prototype.addDebuff = function (paramId, turns) {
    PopInfoManagerABS.makeBuffPopUp(this, paramId, false);
    pkd_GameBattler_addDebuff.call(this, paramId, turns);
  };

  Game_Battler.prototype._initBattleSkills = function () {
    this._absParams.battleSkillsABS = new Game_SkillManagerABS();
  };

  //?[NEW]
  Game_Battler.prototype.requestABSMotionAction = function () {
    this._absParams._needABSMotionAction = true;
  };

  //?[NEW]
  Game_Battler.prototype.onABSMotionActionDone = function () {
    this._absParams._needABSMotionAction = false;
  };

  //?[NEW]
  Game_Battler.prototype.isNeedABSMotionAction = function () {
    return (this._absParams._needABSMotionAction == true);
  };

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initTp, ALIAS__removeState, _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  //@[ALIAS]
  ALIAS__removeState = _.removeState;
  _.removeState = function(stateId) {
    var ceId, e;
    ALIAS__removeState.call(this, stateId);
    try {
      if (this._onEndStateEvents != null) {
        ceId = this._onEndStateEvents[stateId];
        if (ceId != null) {
          this._startCommonEventFromState(ceId);
          return this._onEndStateEvents[ceId] = null;
        }
      }
    } catch (error) {
      e = error;
      return AA.w(e, " while start commonEvent on state end");
    }
  };
  
  //@[ALIAS]
  ALIAS__initTp = _.initTp;
  _.initTp = function() {
    if (AA.isMap() && !AA.Parameters.get_InitiateABSMapWithRandomTP()) {
      return this.clearTp();
    } else {
      return ALIAS__initTp.call(this);
    }
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onAllActionsEnd, ALIAS__onBattleEnd, ALIAS__onBattleStart_111, ALIAS__onTurnEnd, _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  ALIAS__onBattleStart_111 = _.onBattleStart;
  _.onBattleStart = function() {
    if (AA.isABS()) {

    } else {
      //?EMPTY
      return ALIAS__onBattleStart_111.call(this);
    }
  };
  ALIAS__onTurnEnd = _.onTurnEnd;
  _.onTurnEnd = function() {
    if (AA.isABS()) {
      return this.regenerateAll();
    } else {
      return ALIAS__onTurnEnd.call(this);
    }
  };
  ALIAS__onAllActionsEnd = _.onAllActionsEnd;
  _.onAllActionsEnd = function() {
    if (AA.isABS()) {
      this.clearResult();
      return this.removeStatesAuto(1);
    } else {
      return ALIAS__onAllActionsEnd.call(this);
    }
  };
  ALIAS__onBattleEnd = _.onBattleEnd;
  _.onBattleEnd = function() {
    if (AA.isABS()) {
      this.onAllActionsEnd();
      this.clearActions();
      if (!this.isPreserveTp()) {
        return this.clearTp();
      }
    } else {
      // * Remove guard state after NON-ABS battle
      this.removeState(2);
      return ALIAS__onBattleEnd.call(this);
    }
  };
  //?[NEW]
  _.onAADeath = function() {
    var e, ref;
    try {
      this.onBattleEnd();
      this.removeAllBuffs();
      this.removeBattleStates();
      this.removeStatesAuto(1);
      this.removeStatesAuto(2);
      if ((ref = this._absParams) != null) {
        ref.moveSpeedUpKoef = 0; // * ???
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addNewState, ALIAS__canMove, ALIAS__eraseState, ALIAS__initMembers, ALIAS__isOccasionOk, ALIAS__overwriteBuffTurns_111, ALIAS__resetStateCounts, _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._absParams = {};
    this._absParams.popups = [];
    this._absParams.moveSpeedUpKoef = 0;
    return this._absParams.barrierElementId = 0;
  };
  //@[ALIAS]
  ALIAS__addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    var state;
    if (AA.isABS()) {
      state = $dataStates[stateId];
      if (state.restriction === 0 || state.restriction === 4) {
        ALIAS__addNewState.call(this, stateId);
        this.onSpeedUpState(stateId, true);
        this.onMotionState(stateId, true);
      } else {
        return LOGW.p("State " + state.name + " not supported in Alpha ABS");
      }
    } else {
      return ALIAS__addNewState.call(this, stateId);
    }
  };
  //@[ALIAS]
  ALIAS__eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    if (this._states.include(stateId)) {
      AA.LIBS.PopInfoManagerABS.makeStatePopUp(this, stateId, true);
      this.onSpeedUpState(stateId, false);
      this.onMotionState(stateId, false);
    }
    return ALIAS__eraseState.call(this, stateId);
  };
  
  //@[ALIAS]
  ALIAS__canMove = _.canMove;
  _.canMove = function() {
    if (this.isAAnimMotionRequested()) {
      return !this._absParams.animMotion.isWait() && ALIAS__canMove.call(this);
    } else {
      return ALIAS__canMove.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__isOccasionOk = _.isOccasionOk;
  _.isOccasionOk = function(item) {
    if (AA.isABS()) {
      return this._isOccasionOkABS(item);
    } else {
      return ALIAS__isOccasionOk.call(this, item);
    }
  };
  //@[ALIAS]
  ALIAS__resetStateCounts = _.resetStateCounts;
  _.resetStateCounts = function(stateId) {
    if (AA.isABS()) {
      return this._resetStateCountsABS(stateId);
    } else {
      return ALIAS__resetStateCounts.call(this, stateId);
    }
  };
  //@[ALIAS]
  ALIAS__overwriteBuffTurns_111 = _.overwriteBuffTurns;
  _.overwriteBuffTurns = function(paramId, turns) {
    var t;
    if (AA.isABS()) {
      t = turns * BattleManagerABS.TURN;
      if (this._buffTurns[paramId] < t) {
        return this._buffTurns[paramId] = t;
      }
    } else {
      return ALIAS__overwriteBuffTurns_111.call(this, ...arguments);
    }
  };
  Object.defineProperties(_, {
    mtp: {
      get: function() {
        return this.maxTp();
      },
      configurable: true
    }
  });
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  _.ABSParams = function() {
    return this._absParams;
  };
  _.isPlayer = function() {
    return this === $gamePlayer.battler();
  };
  (function() {    // * POP UPS
    // -----------------------------------------------------------------------
    _.getInfoPops = function() {
      return this.ABSParams().popups;
    };
    _.addInfoPop = function(info) {
      return this.getInfoPops().push(info);
    };
    _.clearInfoPops = function() {
      return this._absParams.popups = [];
    };
    return _.performActionUsed = function() {
      return AA.LIBS.PopInfoManagerABS.makeItemPopUp(this);
    };
  })();
  (function() {    //?[VISUALEQ_E]
    // * VISUAL EQUIPMENT
    // -----------------------------------------------------------------------
    _.isHasVisualEq = function() {
      return false;
    };
    return _._isNeedVisualEqRefresh = function() {
      return false;
    };
  })();
  // -----------------------------------------------------------------------
  _.onSpeedUpState = function(stateId, up) {
    var speed, state;
    state = $dataStates[stateId];
    speed = KDCore.Utils.getNumberFromMeta('speed', state);
    if (speed == null) {
      return;
    }
    if (up === true) {
      this._absParams.moveSpeedUpKoef += speed;
    } else {
      this._absParams.moveSpeedUpKoef -= speed;
    }
  };
  _.extraSpeedKoef = function() {
    return this._absParams.moveSpeedUpKoef;
  };
  // * Это не MotionSystem, это стандартный Motion смерти
  _.onMotionState = function(stateId, up) {
    var state;
    state = $dataStates[stateId];
    if (state.restriction === 4 && this.isPlayer()) {
      if (state.motion < 2) {
        return;
      }
      if (up === true) {
        $gamePlayer.requestMotion('sleep');
      } else {
        if ($gameTemp.transferedByDeathABS === false) {
          $gamePlayer.requestMotion('none');
        }
      }
    }
  };
  _._isOccasionOkABS = function(item) {
    if ($gameParty.inBattle()) {
      return item.occasion === 0 || item.occasion === 1;
    } else {
      return item.occasion === 0 || item.occasion === 1 || item.occasion === 2;
    }
  };
  _.allIconsWithPriority = function(value) {
    var stateIcons;
    stateIcons = this.states().map(function(state) {
      if (state.priority >= value) {
        return state.iconIndex;
      } else {
        return 0;
      }
    }).filter(function(iconIndex) {
      return iconIndex > 0;
    });
    return stateIcons;
  };
  _._resetStateCountsABS = function(stateId) {
    var state, variance;
    state = $dataStates[stateId];
    variance = 0;
    if (state.autoRemovalTiming !== 1) {
      // * For now, turns calcs in a seconds
      variance += Math.max(state.maxTurns - state.minTurns, 0);
      return this._stateTurns[stateId] = (state.minTurns + Math.randomInt(1 + variance)) * AA.BattleManagerABS.TURN;
    } else {
      return this._stateTurns[stateId] = 1; // * AFTER ACTION
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  (function() {    //?[MOTIONSYS_E]
    // * MOTION SYSTEM
    // -----------------------------------------------------------------------
    _.isAAnimMotionRequested = function() {
      var ref;
      return ((ref = this.ABSParams()) != null ? ref.animMotion : void 0) != null;
    };
    _.requestAAnimMotion = function(motion) {
      var ref;
      return (ref = this._absParams) != null ? ref.animMotion = motion : void 0;
    };
    _.clearAAnimMotion = function() {
      var ref;
      return (ref = this._absParams) != null ? ref.animMotion = null : void 0;
    };
    return _.performAAnimAction = function(ABSMotionData) {
      var aMotion;
      // * Если очищать, то будет возвращяться в базовую графику, а если нет, то обратно в текущую
      aMotion = new AA.LIBS.AAnimMotion();
      aMotion.setFromABSMotion(ABSMotionData);
      this.requestAAnimMotion(aMotion);
    };
  })();
})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _Game_Character_initMembers = Game_Character.prototype.initMembers;
    Game_Character.prototype.initMembers = function () {
        _Game_Character_initMembers.call(this);
        this._absParams = {};
        this._absParams.animationABS = 0;
        this._absParams.useAStar = false;
        this._needShowABSHpBar = false;
    };

    //NEW
    Game_Character.prototype.ABSParams = function () {
        return this._absParams;
    };

    //NEW
    Game_Character.prototype.requestAnimationABS = function (animationId) {
        if (animationId > 0)
            this._absParams.animationABS = animationId;
    };

    //NEW
    Game_Character.prototype.moveToPointAA = function (point) {
        var dir = this.findDirectionTo(point.x, point.y);
        if (dir > 0) {
            this.moveStraight(dir);
        }
    };

    //NEW
    Game_Character.prototype.isCasting = function() {
        return false;
    };

    //NEW
    Game_Character.prototype.moveFromPoint = function (point) {
        var points = [];
        for (var j = 0; j < 4; j++) {
            var direction = 2 + j * 2;
            if (this.canPass(this.x, this.y, direction)) {
                var x2 = $gameMap.roundXWithDirection(this.x, direction);
                var y2 = $gameMap.roundYWithDirection(this.y, direction);
                //if(x2 != point.x && y2 != point.y)
                points.push([x2, y2]);
            }
        }

        if (points.length > 0) {
            //LOG.p("POINTS " + points.length);
            var p;
            if (points.length > 1)
                p = points.sample();
            else
                p = points[0];
            var newPoint = {
                x: p[0],
                y: p[1]
            };
            this.moveToPointAA(newPoint);
        }
    };

    //?NEW
    Game_Character.prototype.onApplyImpulseForce = function (x, y, d) {
        if ((x === 1 || x === -1 || x === 0) && (y === 1 || y === -1 || y === 0)) {
            var jx = 0;
            var jy = 0;
            if (this.canPass(this.x, this.y, d) && !$gamePlayer.pos(this.x + x, this.y + y)) {
                jx = x;
                jy = y;
            }
            var ld = this.direction();
            this.jump(jx, jy);
            this.setDirection(ld);
        } else {
            this._onComplexImpulse(x, y, d);
        }
    };

    //?NEW
    Game_Character.prototype._onComplexImpulse = function (x, y, d) {
        var ld, safe;
        ld = this.direction();
        safe = 20;
        var startDestX = this.x;
        var startDestY = this.y;
        while (!$gameMap.isPassableForImpulse(startDestX + x, startDestY + y, d)) {
            x = AlphaABS.UTILS.decrement(x);
            y = AlphaABS.UTILS.decrement(y);
            if (x === 0 && y === 0) {
                break;
            }
            safe--;
            if (safe === 0) {
                return;
            }
        }
        this.jump(x, y);
        this.setDirection(ld);
    };

    //?[NEW]
    Game_Character.prototype.hideHpBarABS = function () {
        this._needShowABSHpBar = false;
    };

    //?[NEW]
    Game_Character.prototype.showHpBarABS = function () {
        this._needShowABSHpBar = true;
    };

    //?[NEW]
    Game_Character.prototype.isHpBarVisible = function () {
        return (this._needShowABSHpBar == true);
    };

    //?[NEW]
    Game_Character.prototype.inABSMotion = function () {
        return false;
    };

    //?[NEW]
    Game_Character.prototype.getABSMotion = function() {
        return null;
    };

    //@[ALIAS]
    var _alias_Game_Character_updatePattern = Game_Character.prototype.updatePattern;
    Game_Character.prototype.updatePattern = function () {
        try {
            if(this.inAAnimMotion()) {
                var amotion = this.getAAnimMotion();
                if(!amotion.isStarted()) {
                    amotion.startMotion(this);
                }
                if (amotion.isStarted() && this.__AnimMotionReady == true) {
                    this._pattern = amotion.motionPattern();
                    if(amotion.checkAnimEnd()) {
                        this._clearAAnimMotion();
                    }
                }
            } else
                if (this.inABSMotion()) {
                    var motion = this.ABSParams().absMotion;
                    if(motion.isOldABSMotion()) {
                        this._onABSMotionPattern();
                    } else {
                        this._onABSMotionPatternNew();
                    }
                } else {
                    if (Imported.Galv_CharacterFrames == true) {
                        if (!this.hasStepAnime() && this._stopCount > 0) {
                            this.resetPattern();
                        } else {
                            this._pattern = (this._pattern + 1) % (this._cframes + this._spattern);
                        }
                    } else
                        _alias_Game_Character_updatePattern.call(this);
                }
        } catch (error) {
            AlphaABS.warning(error, ' when try play ABS motion');
            _alias_Game_Character_updatePattern.call(this);
        }
    };

    //?[NEW]
    Game_Character.prototype._clearAAnimMotion = function () {
        if (this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            amotion.clear(this);
            this.battler().clearAAnimMotion();
        }
    };

    //?[NEW]
    Game_Character.prototype._onABSMotionPattern = function () {
        var motion = this.ABSParams().absMotion;
        if (motion.inAction()) {
            this._pattern = motion.motionPattern(this._pattern);
            motion.onActionDone();
        } else {
            _alias_Game_Character_updatePattern.call(this);
            if (!this.hasStepAnime() && this._stopCount > 0) {
                //?EMPTY
            } else
                this._pattern = motion.motionPattern(this._pattern);
        }
    };

    //?[NEW]
    Game_Character.prototype._onABSMotionPatternNew = function () {
        var motion = this.ABSParams().absMotion;
        if (motion.inAction()) {
            motion.onActionDone();
        } else {
            _alias_Game_Character_updatePattern.call(this);
            if (!this.hasStepAnime() && this._stopCount > 0) {
                this.resetPattern();
            }
        }
    };

    //@[ALIAS]
    var _alias_Game_Character_animationWait = Game_Character.prototype.animationWait;
    Game_Character.prototype.animationWait = function () {
        if(this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            if(amotion != null)
                return (amotion.getDelay() - this.realMoveSpeed()) * 3;
        }
        if (this.inABSMotion()) {
            var motion = this.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return (motion.getDelay() - this.realMoveSpeed()) * 3;
            }
        } 
        if (Imported.Galv_CharacterFrames == true) {
            return _alias_Game_Character_animationWait.call(this) - this._patSpd;
        } else
            return _alias_Game_Character_animationWait.call(this);    
    };

    //@[ALIAS]
    var _alias_Game_Character_updateAnimationCount = Game_Character.prototype.updateAnimationCount;
    Game_Character.prototype.updateAnimationCount = function () {
        if (this.inAAnimMotion()) {
            this._animationCount++;
        } else
            _alias_Game_Character_updateAnimationCount.call(this);
    };

    //@[ALIAS]
    var _alias_Game_Character_pattern = Game_Character.prototype.pattern;
    Game_Character.prototype.pattern = function () {
        if (this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            return this._pattern < amotion.getFrames() ? this._pattern : 1;
        }
        if (this.inABSMotion()) {
            var motion = this.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return this._pattern < motion.getFrames() ? this._pattern : 1;
            }
        }
        if (Imported.Galv_CharacterFrames == true) {
            return this._pattern < this._cframes ? this._pattern : this._spattern;
        } else
            return _alias_Game_Character_pattern.call(this);
    };


    //@[ALIAS]
    var _alias_Game_Character_maxPattern = Game_Character.prototype.maxPattern;
    Game_Character.prototype.maxPattern = function () {
        if(this.inABSMotion()) {
            var motion = this.getABSMotion();
            if(!motion.isOldABSMotion()) {
                return (motion.getFrames() + 1);
            }
        }
        return _alias_Game_Character_maxPattern.call(this);
    };

    //@[ALIAS]
    var _alias_Game_Character_update = Game_Character.prototype.update;
    Game_Character.prototype.update = function () {
        _alias_Game_Character_update.call(this);
        this._updateABSMotion();
    };

    //?[NEW]
    Game_Character.prototype._updateABSMotion = function () {
        // * EMPTY
    };

    //?[NEW]
    Game_Character.prototype.findMySprite = function (searchAll = false) {
        if (AA.isSceneMap()) {
            try {
                var spriteset = SceneManager._scene._spriteset;
                if(spriteset != null) {
                    return spriteset.getSpriteForCharacter(this, searchAll);
                }
                
            } catch (error) {
                AlphaABS.waring('Cant find sprite of battler');
            }

        }
        return null;
    };

    //?[NEW]
    Game_Character.prototype.getStartPointToVector = function () {
        var mySprite = this.findMySprite();
        if (mySprite == null) {
            return this.toPoint();
        } else {
            return mySprite.getStartPointToVector();
        }
    };

    //?[NEW]
    Game_Character.prototype.getHpBarStyleID = function () {
        return 'miniHp';
    };

    //$[OVER]
    Game_Character.prototype.searchLimit = function () {
        return 24;
    };

})();
// ■ END Game_Character.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  //?[ANIMAX_E]
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    return this._initMembersAnimaX();
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.checkCollisionWith = function(other) {
    var me, pl;
    if (other == null) {
      return;
    }
    me = this.toPoint();
    pl = other.toPoint();
    if (me.x === pl.x && me.y === pl.y) {
      if (!this.isMoving()) {
        return this.moveFromPoint(other);
      }
    }
  };
  _.isNearThePlayerX = function() {
    return this.isNearThePointX($gamePlayer);
  };
  _.isNearThePointX = function(point) {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      return (sx + sy) <= 1;
    } catch (error) {
      return false;
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  // * Анимация атаки
  _.aaPerformAttackAnimation = function() {
    var b;
    b = this.battler();
    if (b == null) {
      return;
    }
    if (this.isAnimX() && this.isHaveAnimaXActionWithName('Attack')) {
      this.startAnimaXAA_Attack();
    } else {
      b.performAttack();
    }
  };
  _.aaPerformBattleActionAnimation = function(name) {
    var b;
    b = this.battler();
    if (b == null) {
      return;
    }
    if (!this.isAnimX()) {
      return;
    }
    // * Если нет действия для Skill или специального, то будет Attack
    if (!this.isHaveAnimaXActionWithName(name)) {
      name = 'Attack';
    }
    if (this.isHaveAnimaXActionWithName(name)) {
      this.startAnimaXAA_Action(name, false, true);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character_Ext.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.inAAnimMotion = function() {
    return false;
  };
  _.getAAnimMotion = function() {
    return null;
  };
})();

// ■ END Game_Character_Ext.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //TODO: регистрация действий на персонаже?
  // Если вызвано действие, но данных нету, то надо пропускать, без ошибок!

  //@[DEFINES]
  _ = Game_Character.prototype;
  (function() {    //?[ANIMAX_E]
    // * Система анимации XAnima
    // -----------------------------------------------------------------------
    
    //@[FROM Game_CharacterBase]

    // * Персонаж использует XAnima
    _.isAnimX = function() {
      return this._isHaveAnimaX === true;
    };
    // * ID набора анимаций (по нему определяется имя папки)
    _.animXId = function() {
      return this._axId;
    };
    // * Есть ли Idle анимация у текущего состояния
    _.isHaveIdleAnimaX = function() {
      return this._axIdle() != null;
    };
    // * Есть ли Dashing (бег) анимация у текущего состояния
    _.isHaveDashAnimaX = function() {
      return this._axDashing() != null;
    };
    // * Есть ли анимация для состояния
    _.isHaveAnimaXState = function(state) {
      return this._axStates[state] != null;
    };
    // * Находится ли анимация в действии
    _.isInAnimXAction = function() {
      return this.isAnimX() && this.getCurrentAnimX().isAction();
    };
    // * Находится ли анимация в движении (имеется в виду moveSet)
    _.isInMovementAnimaX = function() {
      return this._axCurrent === this._axMovement();
    };
    _.isInAnyMovementAnimaX = function() {
      return this.isInMovementAnimaX() || this.isInDashingAnimaX();
    };
    // * Есть ли Idle анимация у текущего состояния
    _.isInIdleAnimaX = function() {
      return this._axCurrent === this._axIdle();
    };
    // * Находится ли анимация текущая в состоянии Dashing (Бег)
    _.isInDashingAnimaX = function() {
      return this._axCurrent === this._axDashing();
    };
    // * Когда запускается действие
    _.onAnimaXActionStart = function() {
      return this._xAnimaToIdleTimer = 0; // * Сбро таймера перехода в Idle
    };
    
    // * Когда действие заканчивается
    _.onAnimaXActionEnd = function() {
      return this.resetXAnima();
    };
    // * Должен ли ждать завершения действия
    _.isShouldWaitAnimaXAction = function() {
      var anima;
      if (this.isInAnyMovementAnimaX()) {
        return false;
      }
      if (!this.isInAnimXAction()) {
        // * Если не в действии, то нет (т.к. нет действия)
        return false;
      }
      anima = this.getCurrentAnimX();
      // * Idle тоже считается действием! Поэтому доп. проверка isAction
      return anima.isAction() && anima.isWait();
    };
    // * Есть ли данное действие у текущей XAnima конфигурации
    _.isHaveAnimaXActionWithName = function(name) {
      return this._axAvailableActionsList.contains(name);
    };
    // -----------------------------------------------------------------------

    // * Текущий XAnimaSet
    _.getCurrentAnimX = function() {
      return this._axCurrent;
    };
    // * Запустить действие
    _.startAnimaXAction = function(animX) {
      return this._axCurrent = animX;
    };
    //?X
    // * Переключить состояние анимации (обычное, бой, и т.д.)
    _.switchToXAnimaState = function(state) {
      if (this.isHaveAnimaXState(state)) {
        this._axState = state;
        if (!this.isInAnimXAction()) { //?line
          this.resetXAnima();
        }
      } else {
        //KDCore.warning 'AnimaX Set for ' + state + ' not registed'
        this.resetXAnimaState();
      }
    };
    // * Инициализация
    // * Base состояние - стандартное, инициализируется всегда
    // * Если нет Base или нет movement, то не акитвируется система
    _.initAnimaX = function(_axId, data) {
      this._axId = _axId;
      this.clearXAnimParts();
      this._axAvailableActionsList = [];
      this._axPreloadedActions = {};
      this._axStates = {};
      this._axState = 'base'; // * Базовое состояние
      this.registerAnimaXState(this._axState, data);
      if (this._axStates[this._axState] == null) {
        return;
      }
      this.resetXAnima();
      this._isHaveAnimaX = true;
      this.getCurrentAnimX().preLoad();
    };
    // * Добавить анимацию для состояния
    _.registerAnimaXState = function(state, data) {
      var dashSet, e, idleSet, moveSet;
      try {
        if (data == null) {
          return;
        }
        moveSet = this._createAnimaXSetFromParams(0, state, data.move);
        // * moveSet обязателен!
        if (moveSet == null) {
          return;
        }
        moveSet.preLoad();
        // * idleSet и dashSet - опционально
        idleSet = null;
        dashSet = null;
        idleSet = this._createAnimaXSetFromParams(1, state, data.idle);
        if (idleSet != null) {
          idleSet.preLoad();
        }
        if ((idleSet != null) && (data.moveToIdleDelay != null)) {
          idleSet.moveToIdleDelay = data.moveToIdleDelay;
        }
        dashSet = this._createAnimaXSetFromParams(3, state, data.dash);
        if (dashSet != null) {
          dashSet.preLoad();
        }
        this._createXAnimaSetsForState(state, moveSet, idleSet, dashSet);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this._axStates[state] = null;
      }
    };
    //?X
    // * Сбросить состояние до базового
    _.resetXAnimaState = function() {
      this._axState = 'base';
      if (!this.isInAnimXAction()) { //?line
        this.resetXAnima();
      }
    };
    // * Сбросить анимацию
    _.resetXAnima = function() {
      this._inAnimXAction = false;
      this._xAnimaToIdleTimer = 0;
      this._setAnimaXToMovement();
    };
    // * Добавить действие (зарегестрировать, чтобы не было ошибок если вызвано, а нету файлов)
    _.registerAnimaXAction = function(actionName) {
      return this._axAvailableActionsList.push(actionName);
    };
    // -----------------------------------------------------------------------
    _._initMembersAnimaX = function() {
      this._xAnimaPartsRequireRefresh = false;
      this._xAnimaToIdleTimer = 0;
      return this._isHaveAnimaX = false;
    };
    _._createXAnimaSetsForState = function(state, moveSet, idleSet, dashSet) {
      this._axStates[state] = {};
      moveSet.preLoad();
      this._axStates[state].moveSet = moveSet;
      if (idleSet != null) {
        idleSet.isLoop = true;
        idleSet.preLoad();
        this._axStates[state].idleSet = idleSet;
      } else {
        this._axStates[state].idleSet = null;
      }
      // * Dashing был введён с обновлением 1.1, является опциональным как и Idle
      if (dashSet != null) {
        this._axStates[state].dashSet = dashSet;
        dashSet.preLoad();
      } else {
        this._axStates[state].dashSet = null;
      }
    };
    _._createAnimaXSetFromParams = function(type, state, data) {
      var axSet, e;
      axSet = null;
      try {
        if (type === 0) {
          if (data != null) {
            axSet = XAnimaTools.createXAnimaSetForMove(this.animXId(), state, data);
          }
        } else if (type === 1) { // * IDLE
          if (data != null) {
            axSet = XAnimaTools.createXAnimaSetForIdle(this.animXId(), state, data);
          }
        } else if (type === 3) { // * DASHING
          if (data != null) {
            axSet = XAnimaTools.createXAnimaSetForDashing(this.animXId(), state, data);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        axSet = null;
      }
      return axSet;
    };
    _._updateAnimX = function() {
      this._updateAnimXRefresh();
      if (this.isShouldWaitAnimaXAction()) {
        return;
      }
      this._updateMovingAnimX();
      if (this.isHaveIdleAnimaX() && this.isInAnyMovementAnimaX()) {
        return this._updateMoveIdleAnimaX();
      }
    };
    _._updateMovingAnimX = function() {
      if (!this.isMoving()) {
        return;
      }
      if (this.isHaveDashAnimaX()) {
        this._updateMovingDashingAnimX();
      }
      this._xAnimaToIdleTimer = 0;
      if (!this.isInAnyMovementAnimaX()) {
        return this.resetXAnima();
      }
    };
    _._updateMovingDashingAnimX = function() {
      if (this.isDashingForAnimaX()) {
        if (!this.isInDashingAnimaX()) {
          this._setAnimaXToDashing();
        }
      } else if (this.isInDashingAnimaX()) {
        this._setAnimaXToMovement();
      }
    };
    _._updateMoveIdleAnimaX = function() {
      if (!this.isMoving()) {
        this._xAnimaToIdleTimer++;
        if (this._xAnimaToIdleTimer >= this._getAnimaXMoveToIdleDelay()) {
          return this._setAnimaXToIdle();
        }
      }
    };
    _._getAnimaXMoveToIdleDelay = function() {
      return this._axIdle().moveToIdleDelay;
    };
    _._axMovement = function() {
      return this._axStates[this._axState].moveSet;
    };
    _._axIdle = function() {
      return this._axStates[this._axState].idleSet;
    };
    _._axDashing = function() {
      return this._axStates[this._axState].dashSet;
    };
    _._setAnimaXToIdle = function() {
      return this._axCurrent = this._axIdle();
    };
    _._setAnimaXToMovement = function() {
      return this._axCurrent = this._axMovement();
    };
    _._setAnimaXToDashing = function() {
      return this._axCurrent = this._axDashing();
    };
    //TODO: Problem
    _.clearAnimaX = function() {
      this.resetXAnima();
      this._isHaveAnimaX = false;
      this.initAnimaX(null, null);
    };
    // * Обновить слои с учётом экипировки
    _.refreshAnimaXLayers = function() {
      var actor, e, i, j, k, l, len, len1, len2, ref, ref1, ref2;
      if (!this.isAnimX()) {
        return;
      }
      actor = this.getBattlerForAnimaX();
      if (actor == null) {
        return;
      }
      try {
        ref = actor.axLayersByEquips;
        for (i = 0, len = ref.length; i < len; i++) {
          l = ref[i];
          this.addNewXAnimPart(l, false);
        }
        ref1 = actor.axLayersByEquipsRelative;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          l = ref1[j];
          this.addNewXAnimPart(l, true);
        }
        ref2 = actor.axPreviousLayers;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          l = ref2[k];
          this.removeXAnimPart(l);
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
    };
    // PARTS (LAYERS)
    // ----------------------------------------------------------------------
    _.isAnimXPartsChanged = function() {
      return this._xAnimaPartsRequireRefresh === true;
    };
    _.onAnimXPartsRefreshed = function() {
      return this._xAnimaPartsRequireRefresh = false;
    };
    _.addNewXAnimPart = function(partId, isRelative = false) {
      var partSet;
      if (this.animaXParts[partId] != null) {
        return;
      }
      partSet = XAnimaTools.createXAnimaPart(this.animXId(), partId, isRelative);
      if (partSet == null) {
        return;
      }
      this.animaXParts[partId] = partSet;
      this._xAnimaPartsRequireRefresh = true;
    };
    _.removeXAnimPart = function(partId) {
      this.animaXParts[partId] = null;
      delete this.animaXParts[partId];
      this._xAnimaPartsRequireRefresh = true;
    };
    _.clearXAnimParts = function() {
      this.animaXParts = {};
      this._xAnimaPartsRequireRefresh = true;
    };
  })();
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  (function() {    //?[ANIMAX_E]
    // * Система анимации XAnima и ABS
    // -----------------------------------------------------------------------
    // * Предзагрузить действие
    _.preloadAnimaXAction = function(actionParams, isWaiting) {
      var animaSet;
      if (actionParams == null) {
        return;
      }
      animaSet = this.createAnimaXActionSet(actionParams);
      if (animaSet != null) {
        animaSet.preLoad();
      }
      this._axPreloadedActions[actionParams.name] = animaSet;
    };
    // * Создать AnimaXSet из параметров плагина анимации
    _.createAnimaXActionSet = function(actionParams) {
      var animaSet, name;
      name = actionParams.name;
      animaSet = XAnimaTools.createXAnimaSetForAction(this.animXId(), actionParams);
      animaSet.preLoad();
      return animaSet;
    };
    _.isAnimaXActionIsPreloaded = function(actionName) {
      return this.getPreloadAnimaXActionSet(actionName) != null;
    };
    _.getPreloadAnimaXActionSet = function(actionName) {
      return this._axPreloadedActions[actionName];
    };
    _.aaRefreshAnimaX = function() {
      var animaX, animaXProfile, animaXStateBattle, animaXStateDead;
      animaXProfile = this.getCurrentAnimaXProfile();
      if ((this._currentAnimaXProfile != null) && (animaXProfile == null)) {
        this._currentAnimaXProfile = null;
        if (this.isAnimX()) {
          this.clearAnimaX();
        }
        return;
      }
      if (this._currentAnimaXProfile === animaXProfile) {

      } else {
        animaX = XAnimaTools.getXAnimaParamsForState('base', animaXProfile);
        if (animaX == null) {
          return;
        }
        this._currentAnimaXProfile = animaXProfile;
        this.initAnimaX(animaXProfile, animaX);
        animaXStateBattle = XAnimaTools.getXAnimaParamsForState('inBattle', animaXProfile);
        this.registerAnimaXState('inBattle', animaXStateBattle);
        animaXStateDead = XAnimaTools.getXAnimaParamsForState('dead', animaXProfile);
        if (animaXStateDead != null) {
          this.registerAnimaXState('dead', animaXStateDead);
        }
        this.registerAnimaXActions(animaXProfile);
        this.refreshAnimaXLayers();
      }
    };
    
    // * Получить профиль анимации (для загрузки)
    _.getCurrentAnimaXProfile = function() {
      return null;
    };
    // * Получить начальный профиль персонажа (без экипировки)
    _.getInitialXProfile = function() {
      return null;
    };
    // * Регистрация действий (названий) и предзагрузка
    _.registerAnimaXActions = function(animaXProfile) {
      var action, actionList, i, len;
      actionList = XAnimaTools.getXAnimaActionList(animaXProfile);
      for (i = 0, len = actionList.length; i < len; i++) {
        action = actionList[i];
        this.registerAnimaXAction(action.name);
        if (this.isAnimaXAADefaultAction(action.name)) {
          this.preloadAnimaXAction(action);
        }
      }
    };
    // * Набор имён стандартных действий (нужны для предзагрузки)
    _.isAnimaXAADefaultAction = function(actionName) {
      return false;
    };
    // * Проверка обновления состояния анимации на Battler
    _._updateAnimXRefresh = function() {
      var b;
      b = this.getBattlerForAnimaX();
      if (b == null) {
        return;
      }
      if (b.aaIsNeedAnimaXRefresh()) {
        this.aaRefreshAnimaX();
        this.refreshAnimaXLayers();
        b.aaOnAnimaXRefresh();
      }
    };
    _.getBattlerForAnimaX = function() {
      return null;
    };
    // * Получить набор экипировки для Анимации
    return _._getEquipmentAnimaXSet = function() {
      var b, equipmentXSet;
      b = this.getBattlerForAnimaX();
      if (b == null) {
        return null;
      }
      equipmentXSet = b.getAnimaXEquipmentSet();
      if (equipmentXSet != null) {
        return this.getInitialXProfile() + "_" + equipmentXSet;
      }
      return null;
    };
  })();
  (function() {    // * Действия
    // -----------------------------------------------------------------------
    _.startAnimaXAA_Attack = function() {
      return this.startAnimaXAA_Action('Attack', false, true);
    };
    _.startAnimaXAA_Defense = function() {
      return this.startAnimaXAA_Action('Defense', true, false);
    };
    // * Запустить кастомное действие с параметрами (проверка предзагруженных)
    return _.startAnimaXAA_Action = function(name, isLoop = false, isWait = false) {
      var actionParams, animaX;
      if (!this.isHaveAnimaXActionWithName(name)) {
        return false;
      }
      if (this.isAnimaXActionIsPreloaded(name)) {
        animaX = this.getPreloadAnimaXActionSet(name);
      } else {
        actionParams = XAnimaTools.getXAnimaParamsForAction(name, this.animXId());
        animaX = this.createAnimaXActionSet(actionParams);
      }
      if (animaX != null) {
        animaX.waitActionEnd = isWait;
        animaX.isLoop = isLoop;
        this.startAnimaXAction(animaX);
        return true;
      }
      return false;
    };
  })();
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  (function() {    //?[DIAGONAL_E]
    // * Diagonal Movement Extension
    // ----------------------------------------------------------------
    var ALIAS__moveStraight, ALIAS__setDirection;
    //@[ALIAS]
    ALIAS__moveStraight = _.moveStraight;
    _.moveStraight = function(d) {
      this._diagonalDir = false;
      return ALIAS__moveStraight.call(this, d);
    };
    
    //@[ALIAS]
    ALIAS__setDirection = _.setDirection;
    return _.setDirection = function(d) {
      if (this._diagStraigten === true) {
        this._diagonalDir = false;
      }
      return ALIAS__setDirection.call(this, d);
    };
  })();
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__moveSpeed, _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  _.isABS = function() {
    return false;
  };
  _.isAllyAI = function() {
    return false;
  };
  //$[OVER]
  _.realMoveSpeed = function() {
    var final, koef;
    koef = 0;
    if (this.isDashing()) {
      koef = 1;
    }
    final = this.moveSpeed() + koef;
    if (this._diagonalDir) {
      final *= 0.85;
    }
    return final;
  };
  //@[ALIAS]
  ALIAS__moveSpeed = _.moveSpeed;
  _.moveSpeed = function() {
    var ref, spd;
    if (AA.isABS()) {
      if (this.battler != null) {
        spd = ALIAS__moveSpeed.call(this) + ((ref = this.battler()) != null ? ref.extraSpeedKoef() : void 0);
        if (spd < 0) {
          spd = 0;
        }
        return spd;
      }
    }
    return ALIAS__moveSpeed.call(this);
  };
  //?[ANIMAX_E]
  // * Добавляем метод canMove для всех персонажей
  // * В основном он нужен чтобы AAEntities не ходили во время XAnima
  _.canMove = function() {
    if (this.isAnimX()) {
      if (this.isAnimXIsBusy()) {
        // * Персонаж не может идти, если он выполняет действие анимации
        return false;
      }
    } else {
      return true;
    }
  };
  (function() {    //?[DIAGONAL_E]
    // * Diagonal Movement Extension
    // ----------------------------------------------------------------
    var get4Dir;
    get4Dir = function(horz, vert) {
      if (horz === 4 && vert === 2) {
        return 1;
      }
      if (horz === 6 && vert === 2) {
        return 3;
      }
      if (horz === 4 && vert === 8) {
        return 7;
      }
      if (horz === 6 && vert === 8) {
        return 9;
      }
      return 0;
    };
    _.moveDiagonally = function(horz, vert) {
      var diag, norm;
      diag = this.canPassDiagonally(this._x, this._y, horz, vert);
      norm = this.canPass(this._x, this._y, horz) || this.canPass(this._x, this._y, vert);
      if (diag) {
        this._diagonalDir = get4Dir(horz, vert);
        this._x = $gameMap.roundXWithDirection(this._x, horz);
        this._y = $gameMap.roundYWithDirection(this._y, vert);
        this._realX = $gameMap.xWithDirection(this._x, this.reverseDir(horz));
        this._realY = $gameMap.yWithDirection(this._y, this.reverseDir(vert));
        this.increaseSteps();
      } else if (norm) {
        this._diagonalDir = false;
        this.moveStraight(this.getOtherDirection(horz, vert));
      }
      this._diagStraigten = false;
      if (this._direction === this.reverseDir(horz)) {
        this.setDirection(horz);
      }
      if (this._direction === this.reverseDir(vert)) {
        this.setDirection(vert);
      }
      this._diagStraigten = true;
    };
    return _.getOtherDirection = function(horz, vert) {
      if (this.canPass(this._x, this._y, horz)) {
        return horz;
      } else {
        return vert;
      }
    };
  })();
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  (function() {    //?[ANIMAX_E]
    // * Система анимации XAnima
    // -----------------------------------------------------------------------
    
    // * Персонаж использует XAnima
    _.isAnimX = function() {
      return false;
    };
    // * ID набора анимаций
    _.animXId = function() {
      return null;
    };
    // * Когда запускается действие
    _.onAnimaXActionStart = function() {};
    // * Когда действие заканчивается
    _.onAnimaXActionEnd = function() {};
    
    // * Находится ли анимация в действии
    _.isInAnimXAction = function() {
      return false;
    };
    // * Находится ли анимация в действии и необходимо ждать завершения
    _.isAnimXIsBusy = function() {
      return this.isAnimX() && this.isInAnimXAction() && this.isShouldWaitAnimaXAction();
    };
    // * Находится ли анимация в движении (имеется в виду moveSet)
    _.isInMovementAnimaX = function() {
      return false;
    };
    // * Надо ли применять анимацию бега на персонаже
    _.isDashingForAnimaX = function() {
      return false;
    };
    // * Находился ли персонаж в какой-либо анимации движения (или бег)
    _.isInAnyMovementAnimaX = function() {
      return false;
    };
    // * Находится ли анимация в Idle
    _.isInIdleAnimaX = function() {
      return false;
    };
    // * Находится ли анимация текущая в состоянии Dashing (Бег)
    _.isInDashingAnimaX = function() {
      return false;
    };
    // * Есть ли Idle анимация у текущего состояния
    _.isHaveIdleAnimaX = function() {
      return false;
    };
    // * Есть ли анимация для состояния
    _.isHaveAnimaXState = function() {
      return false;
    };
    // * Есть ли Dashing (бег) анимация у текущего состояния
    _.isHaveDashAnimaX = function() {
      return false;
    };
    // * Есть ли данное действие у текущей XAnima конфигурации
    _.isHaveAnimaXActionWithName = function() {
      return false;
    };
    // * Должен ли ждать завершения действия
    _.isShouldWaitAnimaXAction = function() {
      return false;
    };
    // * Отключить анимацию
    _.clearAnimaX = function() {};
    // * Действие является стандартным (используется для предзагрузки)
    _.isAnimaXAADefaultAction = function(actionName) {
      return false;
    };
    // * Анимация действия была предзагруженна
    _.isAnimaXActionIsPreloaded = function() {
      return false;
    };
    // * Были ли изменены слои (части) анимации?
    _.isAnimXPartsChanged = function() {
      return false;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * XAnima и ABS
    // -----------------------------------------------------------------------
    //?X
    // * Анимация действия была предзагруженна
    return _.isAnimaXActionIsPreloaded = function() {
      return false;
    };
  })();
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Enemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, _;
  //@[DEFINES]
  _ = Game_Enemy.prototype;
  //?[ABSORB_E]
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    return this.setupBarrier(0, 0);
  };
})();

// ■ END Game_Enemy.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Enemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Enemy.prototype;
  (function() {    // * LEVELING SYSTEM
    // -----------------------------------------------------------------------
    _._getMyLevel = function() {
      var data;
      data = this.enemy().meta;
      if ((data != null) && ((data != null ? data.level : void 0) != null)) {
        return Number(data.level);
      } else {
        return 1;
      }
    };
    return Object.defineProperty(_, 'level', {
      get: function() {
        return this._getMyLevel();
      },
      configurable: true
    });
  })();
})();

// ■ END Game_Enemy.coffee
//---------------------------------------------------------------------------

function Game_EnemyABS() {
    this.initialize.apply(this, arguments);
}
(function () {
    //Game_EnemyABS
    //------------------------------------------------------------------------------
    Game_EnemyABS.prototype = Object.create(Game_Enemy.prototype);
    Game_EnemyABS.prototype.constructor = Game_EnemyABS;

    //OVER
    Game_EnemyABS.prototype.initialize = function (enemyId) {
        Game_Enemy.prototype.initialize.call(this, enemyId, 0, 0);
    };

    //OVER
    Game_EnemyABS.prototype.initMembers = function () {
        Game_Enemy.prototype.initMembers.call(this);
        this._absParams.myTurnCount = 0; //Количество секунд, проведённых в сессии боя
        this._absParams.rageContainer = null;
        this._absParams.leveling = null;
    };

    Game_EnemyABS.prototype.performAttack = function() {};

    //?[NEW]
    Game_EnemyABS.prototype.applyLeveling = function (level) {
        this._absParams.leveling = [0, 0, 0, 0, 0, 0, 0, 0];
        try {
            var levelingData = AAJsonSettings.getEnemyLeveling(this.enemyId());
            if (levelingData) {
                var lbs = levelingData.BaseParameters;
                if (lbs) {
                    var newValue = 0;
                    if (lbs.MaxHP) {
                        newValue = this.cummulativeValueByLevel(lbs.MaxHP, level);
                        this._absParams.leveling[0] = newValue;
                    }
                    if (lbs.MaxMP) {
                        newValue = this.cummulativeValueByLevel(lbs.MaxHP, level);
                        this._absParams.leveling[1] = newValue;
                    }
                    if (lbs.Attack) {
                        newValue = this.cummulativeValueByLevel(lbs.Attack, level);
                        this._absParams.leveling[2] = newValue;
                    }
                    if (lbs.Defense) {
                        newValue = this.cummulativeValueByLevel(lbs.Defense, level);
                        this._absParams.leveling[3] = newValue;
                    }
                    if (lbs.MAttack) {
                        newValue = this.cummulativeValueByLevel(lbs.MAttack, level);
                        this._absParams.leveling[4] = newValue;
                    }
                    if (lbs.MDefense) {
                        newValue = this.cummulativeValueByLevel(lbs.MDefense, level);
                        this._absParams.leveling[5] = newValue;
                    }
                    if (lbs.Agility) {
                        newValue = this.cummulativeValueByLevel(lbs.Agility, level);
                        this._absParams.leveling[6] = newValue;
                    }
                    if (lbs.Luck) {
                        newValue = this.cummulativeValueByLevel(lbs.Luck, level);
                        this._absParams.leveling[7] = newValue;
                    }
                }
            }
        } catch (e) {
            AA.warning(e, 'Somthing wrong with Enemy Leveling Parameters (EnemyLeveling.json)');
        }
        this.refresh();
        this.recoverAll();
    };

    //?[NEW]
    Game_EnemyABS.prototype.cummulativeValueByLevel = function (values, level) {
        try {
        
            var sum = 0;
            // * level - 1, потому что начинаем со второго уровня
            for(var i = 0; i<level - 1; i++) {
                if (values[i] != null) {
                    sum += values[i];
                } else
                    sum += 0;
            }
            return sum;
        } catch (e) {
            console.warn(e);
            return 0;
        }
    };

    //?[NEW]
    Game_EnemyABS.prototype.paramBase = function (paramId) {
        var value = Game_Enemy.prototype.paramBase.call(this, paramId);
        if (this._absParams.leveling) {
            value += this._absParams.leveling[paramId];
        }
        return value;
    };


    //NEW
    Game_EnemyABS.prototype.regenerateAllonFree = function () {
        if (this.isAlive()) {
            if (this._hp != this.mhp) {
                var value = Math.floor(this.mhp * 0.05);
                value = Math.max(value, -this.maxSlipDamage());
                if (value !== 0) {
                    this.gainHp(value);
                }
            }
            if (this._mp != this.mmp) {
                var value = Math.floor(this.mmp * 0.05);
                if (value !== 0) {
                    this.gainMp(value);
                }
            }
        }
    };

    //OVER
    Game_EnemyABS.prototype.isActionValid = function (action) {
        if (action == this._supportAction) // * Действие для лечение игрока нельзя использовать на себе
        {
            return false;
        }
        var t = this.skillABS_byId(action.skillId);
        if(!t) return false;
        return Game_Enemy.prototype.isActionValid.call(this, action) && t.isReady();
    };

    //OVER
    Game_EnemyABS.prototype.meetsTurnCondition = function (param1, param2) {
        var n = this._absParams.myTurnCount;
        if (param2 === 0) {
            return n === param1;
        } else {
            return n > 0 && n >= param1 && n % param2 === param1 % param2;
        }
    };

    Game_EnemyABS.prototype.clearStates = function () {
        Game_Enemy.prototype.clearStates.call(this);
        this._stateSteps = {};
    };

    Game_EnemyABS.prototype.eraseState = function (stateId) {
        Game_Enemy.prototype.eraseState.call(this, stateId);
        delete this._stateSteps[stateId];
    };

    Game_EnemyABS.prototype.resetStateCounts = function (stateId) {
        Game_Enemy.prototype.resetStateCounts.call(this, stateId);
        this._stateSteps[stateId] = $dataStates[stateId].stepsToRemove;
    };

    Game_EnemyABS.prototype.initABS = function () {
        Game_Enemy.prototype.initABS.call(this);
        if (this._absParams.battleSkillsABS.all().length == 0)
            this._createBattleSkills();
    };

    //NEW (вынести на бота)
    Game_EnemyABS.prototype.onWalk = function () {
        this.clearResult();
        this.states().forEach(function (state) {
            this.updateStateSteps(state);
        }, this);
    };

    //NEW
    Game_EnemyABS.prototype.executeFloorDamage = function () {
        var damage = Math.floor(this.basicFloorDamage() * this.fdr);
        damage = Math.min(damage, this.maxFloorDamage());
        this.gainHp(-damage);
        if (damage > 0) {
            this.startDamagePopup();
        }
    };

    //NEW
    Game_EnemyABS.prototype.updateStateSteps = function (state) {
        if (state.removeByWalking) {
            if (this._stateSteps[state.id] > 0) {
                if (--this._stateSteps[state.id] === 0) {
                    this.removeState(state.id);
                }
            }
        }
    };

    //NEW
    Game_EnemyABS.prototype.onTurnEnd = function () {
        Game_Enemy.prototype.onTurnEnd.call(this);
        this._absParams.myTurnCount += 1;
    };

    //NEW
    Game_EnemyABS.prototype.attackAnimationId1 = function () {
        return 6;
    };

    Game_EnemyABS.prototype.onBattleEnd = function () {
        Game_Enemy.prototype.onBattleEnd.call(this);
        this._absParams.myTurnCount = 0;
        this.removeBattleStates();
        this.removeAllBuffs();
    };

    Game_EnemyABS.prototype.onDamage = function (value) {
        Game_Enemy.prototype.onDamage.call(this, value);
        if (this._absParams.rageContainer) {

        }
    };

    //PRIVATE
    Game_EnemyABS.prototype._initBattleSkills = function () {
        Game_Enemy.prototype._initBattleSkills.call(this);
    };

    Game_EnemyABS.prototype._createBattleSkills = function () {
        $dataEnemies[this._enemyId].actions.forEach(function (t) {
            var skill = $dataSkills[t.skillId];
            if (skill.meta.ABS)
                this._absParams.battleSkillsABS.push(t.skillId, false);
        }.bind(this));
    };

    //?[NEW]
    Game_EnemyABS.prototype._getActionBySkillId = function (skillId) {
        if (skillId <= 0)
            return null;
        try {
            var actions = this.enemy().actions.filter(item => item.skillId == skillId);
            if (actions.length > 0) {
                return actions.first();
            }
        } catch (e) {
            AA.warning('Game_EnemyABS::_getActionBySkillId', e);
            return null;
        }
    };

    //?[NEW]
    Game_EnemyABS.prototype._meetsConditionForAnother = function (action, anotherBattler) {
        try {
            if (!action)
                return false;
            if ([1, 4, 6].contains(action.conditionType)) {
                return this.meetsCondition(action);
            } else {
                if (!anotherBattler)
                    return false;
                var param1 = action.conditionParam1;
                var param2 = action.conditionParam2;
                switch (action.conditionType) {
                    case 2:
                        return anotherBattler.hpRate() >= param1 && anotherBattler.hpRate() <= param2;
                    case 3:
                        return anotherBattler.mpRate() >= param1 && anotherBattler.mpRate() <= param2;
                    case 4:
                        return anotherBattler.isStateAffected(param1);
                    default:
                        return true;
                }
            }
        } catch (e) {
            AA.warning('Game_EnemyABS::_isValidActionForAnother', e);
        }
        return true;
    };

    //?[NEW]
    Game_EnemyABS.prototype._makeActionsForSupport = function (action) {
        Game_Battler.prototype.makeActions.call(this);
        if (action) {
            if (this.canUse($dataSkills[action.skillId]))
                this.action(0).setEnemyAction(action);
        }
    };

    //?[NEW]
    Game_EnemyABS.prototype.skillABS_byAction = function (action) {
        var result = Game_Battler.prototype.skillABS_byAction.call(this, action);
        if (this._isSupportFlag) {
            // * Костыль чтобы на игрока использовать
            result.needTarget = true;
        }
        return result;
    };

    //?[NEW + OVER]
    Game_EnemyABS.prototype._getMyLevel = function () {
        var b = $gameTroop.getABSEventByBattler(this);
        if(b != null) {
            return b.behaviorModel().level;
        } else
            return 1;
    };

    //END Game_EnemyABS
    //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__processMoveCommand, ALIAS__setupPage, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[ALIAS]
  ALIAS__setupPage = _.setupPage;
  _.setupPage = function() {
    ALIAS__setupPage.call(this);
    this._checkBlockAAEvents();
    if (AA.isPro()) {
      this._setupPageETInfo();
    }
    this._setupPageETD();
    this._setupExtendedHitBoxes();
    if (!(this instanceof Game_AIBot)) {
      this._isHaveAnimaX = false;
      this.aaRefreshAnimaX();
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    if (AA.UI.isGameShouldPause()) {
      return;
    }
    ALIAS__update.call(this);
    if (this.isAnimX()) {
      this._updateAnimX();
    }
  };
  //?[DEFTOWERS_E]
  //@[ALIAS]
  ALIAS__processMoveCommand = _.processMoveCommand;
  _.processMoveCommand = function(command) {
    var p;
    if (command.code === Game_Character.ROUTE_SCRIPT) {
      p = command.parameters;
      if (p[0] === 'towerAction') {
        if (this._aaDefEntity != null) {
          this._aaDefEntity.setReadyToAttack();
          return;
        } else {
          return;
        }
      }
    }
    return ALIAS__processMoveCommand.call(this, command);
  };
  
  //$[OVER]
  _.isCollidedWithEvents = function(x, y) {
    var events;
    events = $gameMap.eventsXyNt(x, y).filter(function(ev) {
      return ev.isNormalPriority();
    });
    if (events.length <= 0) {
      return false;
    }
    return this.isNormalPriority();
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.isABSEvent = function() {
    return KDCore.Utils.hasMeta("ABS", this.event());
  };
  _.aaGetCommentData = function(event, symbol) {
    if ((event != null) && (event.page() != null)) {
      return KDCore.Utils.getEventCommentValue(symbol, event.list());
    } else {
      return null;
    }
  };
  _._checkBlockAAEvents = function() {
    var isBlock, match, r;
    if (!$gameMap.isABS()) {
      return;
    }
    isBlock = this.aaGetCommentData(this, "disableSpawn");
    if (isBlock != null) {
      r = new RegExp("<disableSpawn\\s?:\\s?(.+?)>", "i");
      match = r.exec(isBlock);
      if (match) {
        $gameMap.registerAABlockSpawnEvent(this.eventId());
        this._aaBlockSpawnRadius = Number(match[1]) + 1;
        this._registredAsAABlockSpawnEvent = true;
      }
    } else {
      if (this._registredAsAABlockSpawnEvent === true) {
        this._registredAsAABlockSpawnEvent = false;
        this._aaBlockSpawnRadius = null;
        $gameMap.unRegistredAABlockSpawnEvent(this.eventId());
      }
    }
  };
  (function() {    //?[EXTRATARGTESP_E]
    // * Extra Target Preview
    // -----------------------------------------------------------------------
    _.isHaveETD = function() {
      return false;
    };
    _.extraTargetData = function() {
      return null;
    };
    return _._setupPageETD = function() {}; // * EMPTY
  })();
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ExpandEvent, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //?[DEFTOWERS_E]
  // * Defense Towers Extension
  // =====================================================================
  _._setupPageETD = function() {
    if (!$gameMap.isAADefenceMap()) {
      return;
    }
    if (!KDCore.Utils.hasMeta('ABS', this.event())) {
      return this._aa_searchForDefComment();
    }
  };
  _._aa_searchForDefComment = function() {
    var aaDefData, defSymbol;
    if (this._aaDefEntity != null) {
      this._aaDefEntity.terminate();
      this._aaDefEntity = null;
    }
    defSymbol = AA.EDT.searchDefSymbol(this);
    if (defSymbol != null) {
      aaDefData = AA.EDT.parseDefSymbol(defSymbol);
      if (aaDefData != null) {
        this._aaDefEntity = new AA.LIBS.DefEntity(aaDefData, this.eventId());
        // * Если проверка данных не пройдена, то не создавать юнит
        if (!this._aaDefEntity.isProperData()) {
          this._aaDefEntity = null;
          AA.warning('Wrong Defense Tower Settings on Event ' + this.eventId());
          this._moveType = 0;
        }
        if (this._aaDefEntity != null) {
          return ExpandEvent(this);
        }
      }
    }
  };
  ExpandEvent = function(_) {
    var ALIAS_AMRI, ALIAS_S, ALIAS_U, ALIAS_URM, ALIAS_USM;
    ALIAS_U = _.update;
    _.update = function() {
      ALIAS_U.call(this);
      if (!this._aa_isDefEntity()) {
        return;
      }
      return this._aaDefEntity.update();
    };
    _._aa_isDefEntity = function() {
      return this._aaDefEntity != null;
    };
    ALIAS_S = _.start;
    _.start = function() {
      if (this._aa_isDefEntity()) {
        if ((this.list() != null) && this.list().length > 1) {
          return this._starting = true;
        }
      } else {
        // * WITHOUT LOCKING EVENT
        return ALIAS_S.call(this);
      }
    };
    ALIAS_USM = _.updateSelfMovement;
    _.updateSelfMovement = function() {
      if (this._aa_isDefEntity()) {
        if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
          if (this._aaDefEntity.isCanStartRoute()) {
            return this.moveTypeCustom();
          }
        }
      } else {
        return ALIAS_USM.call(this);
      }
    };
    ALIAS_URM = _.updateRoutineMove;
    _.updateRoutineMove = function() {
      if (this._aa_isDefEntity()) {
        if (this._aaDefEntity.isReadyForAttack()) {
          if (!this._aaDefEntity.isCanContinueRoute()) {

          } else {
            return ALIAS_URM.call(this);
          }
        } else {
          return ALIAS_URM.call(this);
        }
      } else {
        return ALIAS_URM.call(this);
      }
    };
    ALIAS_AMRI = _.advanceMoveRouteIndex;
    _.advanceMoveRouteIndex = function() {
      ALIAS_AMRI.call(this);
      if (this._aa_isDefEntity()) {
        if (this._moveRouteIndex === 0 && this._aaDefEntity.isCanContinueRoute()) {
          return this._aaDefEntity.resetRoute();
        }
      }
    };
    return _.battler = function() {
      var ref;
      return (ref = this._aaDefEntity) != null ? ref.battler() : void 0;
    };
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.getCurrentAnimaXProfile = function() {
    var animXParameter, list;
    if (this.page() == null) {
      return null;
    }
    list = this.page().list;
    animXParameter = KDCore.Utils.getEventCommentValue('XA:', list);
    if (animXParameter != null) {
      return this._parseAnimaXAParameterForEvent(animXParameter);
    }
    return null;
  };
  _._parseAnimaXAParameterForEvent = function(animXParameter) {
    var id, parts;
    if (animXParameter == null) {
      return;
    }
    parts = animXParameter.split(":");
    id = parts[1];
    return id;
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  (function() {    //?[EXTRATARGTESP_E]
    // * Extra Target Preview
    // -----------------------------------------------------------------------
    _.getAAETIDataID = function() {
      var e, eTDI, match, r;
      try {
        eTDI = this.aaGetCommentData(this, "ExtraInfo");
        if (eTDI != null) {
          r = new RegExp("<ExtraInfo\\s?:\\s?(.+?)>", "i");
          match = r.exec(eTDI);
          if (match != null) {
            return match[1];
          }
        }
      } catch (error) {
        e = error;
        AA.warning(e);
      }
      return null;
    };
    _._setupPageETInfo = function() {
      this._eTDI_id = null;
      if (!this.isABSEvent()) {
        return this._eTDI_id = this.getAAETIDataID();
      }
    };
    _.isHaveETD = function() {
      return (this._eTDI_id != null) && !this.isABSEvent();
    };
    return _.extraTargetData = function() {
      if (this._eTDI_id != null) {
        return AAJsonSettings.getExtraTargetInfo(this._eTDI_id);
      } else {
        return null;
      }
    };
  })();
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__refresh, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    this.refreshABSMotion();
    return this.aaRefreshAnimaX();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this.isAnimX()) {
      return this._updateAnimX();
    }
  };
  //$[OVER]
  //_.realMoveSpeed = -> $gamePlayer.realMoveSpeed()
  _.getCurrentAnimaXProfile = function() {
    var equipAnimaXSet;
    if (this.isAnimX()) {
      equipAnimaXSet = this._getEquipmentAnimaXSet();
      if (String.any(equipAnimaXSet)) {
        return equipAnimaXSet;
      }
    }
    return this.getInitialXProfile();
  };
  //?X
  _.getInitialXProfile = function() {
    if ((this.actor() != null) && (this.actor().actor() != null)) {
      return KDCore.Utils.getValueFromMeta('xAnima', this.actor().actor());
    }
    return null;
  };
  _.getBattlerForAnimaX = function() {
    return this.actor();
  };
  _.isAnimaXAADefaultAction = function(actionName) {
    return Game_Player.prototype.isAnimaXAADefaultAction.call(this, actionName);
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  _.selectOnMap = function() {}; // * EMPTY (for compability)
  (function() {    
    // * Методы Motion System
    // -----------------------------------------------------------------------
    _.refreshABSMotion = function() {
      var skill;
      if (this._absParams.absMotion != null) {
        this._absParams.absMotion.clearMotion();
        this._absParams.absMotion = null;
      }
      if (this.isHasABSMotion()) {
        this._absParams.absMotion = new AA.LIBS.ABSMotion();
        skill = this.actor()._firstBattleABSSkill();
        this._absParams.absMotion.setMotion(skill.motion, skill.motionOffset, this);
        this._absParams.absMotion.applyMotionIdle();
      }
    };
    _.isHasABSMotion = function() {
      var actor;
      actor = this.actor();
      return (actor != null) && actor.isHasABSMotion();
    };
    return _.inABSMotion = function() {
      if (this.ABSParams() == null) {
        return false;
      }
      return this.ABSParams().absMotion != null;
    };
  })();
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  _.getCurrentAnimaXProfile = function() {
    var equipAnimaXSet;
    if (this.isAnimX()) {
      equipAnimaXSet = this._getEquipmentAnimaXSet();
      if (String.any(equipAnimaXSet)) {
        return equipAnimaXSet;
      }
    }
    return this.getInitialXProfile();
  };
  _.getInitialXProfile = function() {
    var actor;
    actor = this.getBattlerForAnimaX();
    if (actor == null) {
      return null;
    }
    return KDCore.Utils.getValueFromMeta('xAnima', actor.actor());
  };
  _.getBattlerForAnimaX = function() {
    return this.actor();
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------

//_.isDashingForAnimaX = -> $gamePlayer.isDashing()

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //?[NEW]
  Game_Followers.prototype.initializeABS = function() {
    var ally, i, results;
    this._visible = true;
    this._data = [];
    i = 1;
    results = [];
    while (i < $gameParty.battleMembers().length) {
      ally = new AIAlly(i);
      if (AA.Parameters.isOneLeaderSwapMode()) {
        // * Dummy for Genshin Impact like party change
        ally.setDummy();
      }
      this._data.push(ally);
      results.push(i++);
    }
    return results;
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__command129_4324234, ALIAS__command201, ALIAS__command322, _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  // * Убрал проверку $gameParty.inBattle(), так как на ABS карте по другому
  //$[OVER]
  _.character = function(param) {
    if (param < 0) {
      return $gamePlayer;
    } else if (this.isOnCurrentMap()) {
      if (param > 0) {
        return $gameMap.event(param);
      } else {
        return $gameMap.event(this._eventId);
      }
    } else {
      return null;
    }
  };
  // * Убрал проверку $gameParty.inBattle()
  // * Set Weather Effect
  //$[OVER]
  _.command236 = function() {
    $gameScreen.changeWeather(this._params[0], this._params[1], this._params[2]);
    if (this._params[3] && !$gameParty.inBattle()) {
      this.wait(this._params[2]);
    }
    return true;
  };
  // Change Party Member
  //@[ALIAS]
  ALIAS__command129_4324234 = _.command129;
  _.command129 = function() {
    if ($gameMap.isABS()) {
      alert("You can't change party members on ABS map!");
      //if ALIAS__command129_4324234.call(@)
      //    AA.BattleManagerABS.updateABSSession()
      //    return true
      return true;
    }
    return ALIAS__command129_4324234.call(this);
  };
  
  // Transfer Player
  //@[ALIAS]
  ALIAS__command201 = _.command201;
  _.command201 = function() {
    if (AA.Parameters.get_AllowTransferState() && AA.isABS()) {
      $gamePlayer.stopABS();
      return ALIAS__command201.call(this);
    } else {
      if ($gameParty.inBattle()) {
        AA.BattleManagerABS.alertNoInBattle();
        AA.BattleManagerABS.warning(1);
        return true;
      } else {
        return ALIAS__command201.call(this);
      }
    }
  };
  // Change Actor Images
  //@[ALIAS]
  ALIAS__command322 = _.command322;
  _.command322 = function() {
    if ($gameMap.isABS()) {
      ALIAS__command322.call(this);
      AA.BattleUI.refreshPlayerFace();
      return true;
    }
    return ALIAS__command322.call(this);
  };
  (function() {    // * COMMAND THAT TURN OFF ON ABS MAPS
    // -----------------------------------------------------------------------
    var ALIAS__command206, ALIAS__command216, ALIAS__command217, ALIAS__command301, ALIAS__command302, ALIAS__command303, ALIAS__command321, ALIAS__command335, ALIAS__command336, ALIAS__command338, ALIAS__command339, ALIAS__command351, ALIAS__command352;
    // Getting On and Off Vehicles
    //@[ALIAS]
    ALIAS__command206 = _.command206;
    _.command206 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(0);
        return true;
      }
      return ALIAS__command206.call(this);
    };
    
    // Change Player Followers
    //@[ALIAS]
    ALIAS__command216 = _.command216;
    _.command216 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(0);
        return true;
      }
      return ALIAS__command216.call(this);
    };
    
    // Gather Followers
    //@[ALIAS]
    ALIAS__command217 = _.command217;
    _.command217 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(0);
        return true;
      }
      return ALIAS__command217.call(this);
    };
    
    // Battle Processing
    //@[ALIAS]
    ALIAS__command301 = _.command301;
    _.command301 = function() {
      if (AA.isABS() || !AA.isPro()) {
        AA.BattleManagerABS.warning(2);
        return true;
      }
      return ALIAS__command301.call(this);
    };
    // Shop Processing
    //@[ALIAS]
    ALIAS__command302 = _.command302;
    _.command302 = function() {
      if ($gameParty.inBattle()) {
        AA.BattleManagerABS.alertNoInBattle();
        AA.BattleManagerABS.warning(1);
        return true;
      }
      return ALIAS__command302.call(this);
    };
    // Name Input Processing
    //@[ALIAS]
    ALIAS__command303 = _.command303;
    _.command303 = function() {
      if ($gameParty.inBattle()) {
        AA.BattleManagerABS.alertNoInBattle();
        AA.BattleManagerABS.warning(1);
        return true;
      }
      return ALIAS__command303.call(this);
    };
    
    // Change Class
    //@[ALIAS]
    ALIAS__command321 = _.command321;
    _.command321 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(321);
        return true;
      }
      return ALIAS__command321.call(this);
    };
    
    // Enemy Appear
    //@[ALIAS]
    ALIAS__command335 = _.command335;
    _.command335 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(2);
        return true;
      }
      return ALIAS__command335.call(this);
    };
    
    // Enemy Transform
    //@[ALIAS]
    ALIAS__command336 = _.command336;
    _.command336 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(2);
        return true;
      }
      return ALIAS__command336.call(this);
    };
    
    // Show Battle Animation
    //@[ALIAS]
    ALIAS__command338 = _.command338;
    _.command338 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(2);
        return true;
      }
      return ALIAS__command338.call(this);
    };
    
    // Force Action
    //@[ALIAS]
    ALIAS__command339 = _.command339;
    _.command339 = function() {
      if ($gameMap.isABS()) {
        AA.BattleManagerABS.warning(2);
        return true;
      }
      return ALIAS__command339.call(this);
    };
    
    // Open Menu Screen
    //@[ALIAS]
    ALIAS__command351 = _.command351;
    _.command351 = function() {
      if ($gameParty.inBattle()) {
        AA.BattleManagerABS.alertNoInBattle();
        AA.BattleManagerABS.warning(1);
        return true;
      }
      return ALIAS__command351.call(this);
    };
    // Open Save Screen
    //@[ALIAS]
    ALIAS__command352 = _.command352;
    return _.command352 = function() {
      if ($gameParty.inBattle()) {
        AA.BattleManagerABS.alertNoInBattle();
        AA.BattleManagerABS.warning(1);
        return true;
      }
      return ALIAS__command352.call(this);
    };
  })();
  (function() {    
    //?[ENEMYINTRPR_E]
    // * ENEMY INTERPRETER EXTENSION
    var ALIAS_CMD111, ALIAS_GDO, ALIAS__command331, ALIAS__command332, ALIAS__command333, ALIAS__command334, ALIAS__command337, ALIAS__command340, ALIAS__command342;
    //@[ALIAS] Change Enemy HP
    ALIAS__command331 = _.command331;
    _.command331 = function() {
      if (AA.isABS()) {
        return this.command331AA();
      } else {
        return ALIAS__command331.call(this);
      }
    };
    
    //@[ALIAS] Change Enemy MP
    ALIAS__command332 = _.command332;
    _.command332 = function() {
      if (AA.isABS()) {
        return this.command332AA();
      } else {
        return ALIAS__command332.call(this);
      }
    };
    //@[ALIAS] Change Enemy TP
    ALIAS__command342 = _.command342;
    _.command342 = function() {
      if (AA.isABS()) {
        return this.command342AA();
      } else {
        return ALIAS__command342.call(this);
      }
    };
    //@[ALIAS] Change Enemy State
    ALIAS__command333 = _.command333;
    _.command333 = function() {
      if (AA.isABS()) {
        return this.command333AA();
      } else {
        return ALIAS__command333.call(this);
      }
    };
    //@[ALIAS] Enemy Recover All
    ALIAS__command334 = _.command334;
    _.command334 = function() {
      if (AA.isABS()) {
        return this.command334AA();
      } else {
        return ALIAS__command334.call(this, ...arguments);
      }
    };
    //@[ALIAS] Show Battle Animation
    ALIAS__command337 = _.command337;
    _.command337 = function() {
      if (AA.isABS()) {
        return this.command337AA();
      } else {
        return ALIAS__command337.call(this, ...arguments);
      }
    };
    //@[ALIAS] Abort Battle
    ALIAS__command340 = _.command340;
    _.command340 = function() {
      if (AA.isABS()) {
        return this.command340AA();
      } else {
        return ALIAS__command340.call(this, ...arguments);
      }
    };
    //@[ALIAS] Conditional Branch
    ALIAS_CMD111 = _.command111;
    _.command111 = function() {
      var enemy, result;
      if (!AA.isABS()) {
        return ALIAS_CMD111.call(this);
      }
      if (this._isThisAIBot()) {
        if (this._params[0] === 5) {
          result = false;
          enemy = this.__getAiBot().battler();
          if (enemy) {
            switch (this._params[2]) {
              case 0:
                // * Appeared -> IGNORE
                result = true;
                break;
              case 1:
                // * State
                result = enemy.isStateAffected(this._params[3]);
            }
          }
          this._branch[this._indent] = result;
          if (this._branch[this._indent] === false) {
            this.skipBranch();
          }
          return true; // * END
        }
      }
      return ALIAS_CMD111.call(this);
    };
    //@[ALIAS]
    ALIAS_GDO = _.gameDataOperand;
    return _.gameDataOperand = function(type, param1, param2) {
      var enemy;
      if (!AA.isABS()) {
        return ALIAS_GDO.call(this, type, param1, param2);
      }
      if (this._isThisAIBot()) {
        if (type === 4) {
          enemy = this.__getAiBot().battler();
          if (enemy) {
            switch (param2) {
              case 0:
                // * HP
                return enemy.hp;
              case 1:
                // * MP
                return enemy.mp;
              default:
                // * Parameter
                if (param2 >= 2 && param2 <= 9) {
                  return enemy.param(param2 - 2);
                }
            }
          }
        }
      }
      return ALIAS_GDO.call(this, type, param1, param2);
    };
  })();
  (function() {    //?[MAPINV_E]
    // * MAP INVENTORY
    var ALIAS__command125, ALIAS__command126, ALIAS__command127, ALIAS__command128, ALIAS__command129_645646, ALIAS__updateWaitMode;
    //@[ALIAS]
    ALIAS__command125 = _.command125;
    _.command125 = function(params) {
      var value;
      if (this.isAAVisualChest()) {
        if (this._isAAStoredChest === false) {
          if (this._params == null) {
            this._params = params; // * MV PATCH
          }
          if (this._chestItemChance !== 1 && this._chestItemChance < Math.random()) {

          } else {
            // * NOTHING
            value = this.operateValue(this._params[0], this._params[1], this._params[2]);
            // * Если предмет для золота задан, то будет визуально
            if (AA.Parameters.get_GoldItemId() > 0) {
              // * Если значение больше 0, но золота ещё не было, то создаём предмет золота
              if (value > 0 && $gameTemp.__visualChestGoldCount === 0) {
                $gameTemp.__aaItemsForChest.push([$dataItems[AA.Parameters.get_GoldItemId()], 1]);
              }
              $gameTemp.__visualChestGoldCount += value; // * Иначе просто даём золото группе
            } else {
              $gameParty.gainGold(value);
            }
          }
        }
        this._params = null;
        this._chestItemChance = 1;
        return this._checkNextAAVisualChestCommand();
      } else {
        return ALIAS__command125.call(this, params);
      }
    };
    //@[ALIAS]
    ALIAS__command126 = _.command126;
    _.command126 = function() {
      var value;
      if (this.isAAVisualChest()) {
        if (this._isAAStoredChest === false) {
          if (this._chestItemChance !== 1 && this._chestItemChance < Math.random()) {

          } else {
            // * NOTHING
            value = Math.abs(this.operateValue(this._params[1], this._params[2], this._params[3]));
            $gameTemp.__aaItemsForChest.push([$dataItems[this._params[0]], value]);
          }
        }
        this._chestItemChance = 1;
        return this._checkNextAAVisualChestCommand();
      } else {
        return ALIAS__command126.call(this);
      }
    };
    //@[ALIAS]
    ALIAS__command127 = _.command127;
    _.command127 = function() {
      var value;
      if (this.isAAVisualChest()) {
        if (this._isAAStoredChest === false) {
          if (this._chestItemChance !== 1 && this._chestItemChance < Math.random()) {

          } else {
            // * NOTHING
            value = Math.abs(this.operateValue(this._params[1], this._params[2], this._params[3]));
            $gameTemp.__aaItemsForChest.push([$dataWeapons[this._params[0]], value]);
          }
        }
        this._chestItemChance = 1;
        return this._checkNextAAVisualChestCommand();
      } else {
        return ALIAS__command127.call(this);
      }
    };
    
    //@[ALIAS]
    ALIAS__command128 = _.command128;
    _.command128 = function() {
      var value;
      if (this.isAAVisualChest()) {
        if (this._isAAStoredChest === false) {
          if (this._chestItemChance !== 1 && this._chestItemChance < Math.random()) {

          } else {
            // * NOTHING
            value = Math.abs(this.operateValue(this._params[1], this._params[2], this._params[3]));
            $gameTemp.__aaItemsForChest.push([$dataArmors[this._params[0]], value]);
          }
        }
        this._chestItemChance = 1;
        return this._checkNextAAVisualChestCommand();
      } else {
        return ALIAS__command128.call(this);
      }
    };
    //@[ALIAS]
    ALIAS__updateWaitMode = _.updateWaitMode;
    _.updateWaitMode = function() {
      if (this._waitMode === 'chest') {
        return this._aaUpdateChestWait();
      } else {
        return ALIAS__updateWaitMode.call(this);
      }
    };
    //@[ALIAS]
    // * Change Party member
    ALIAS__command129_645646 = _.command129;
    return _.command129 = function(params) {
      var r, shouldOpen;
      shouldOpen = AA.UI.isInventoryOpened();
      AA.UI.closeInventory();
      r = ALIAS__command129_645646.call(this, params);
      if (shouldOpen === true) {
        AA.UI.openInventory();
      }
      return r;
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  (function() {    // * PLUGIN COMMANDS
    // -----------------------------------------------------------------------
    _._activateABSEnemy = function(name) {
      var enemy;
      enemy = this._getAbsAI(name);
      if (enemy != null) {
        enemy.activate();
      }
    };
    _._getAbsAI = function(name) {
      var e, x;
      if (name == null) {
        try {
          name = $dataMap.events[this.eventId()].name;
        } catch (error) {
          e = error;
          AA.w(e);
          name = null;
        }
      }
      if (name != null) {
        x = $gameMap.events().filter(function(ev) {
          return ev.event().name === name;
        });
        if (x.length > 0) {
          return x.first();
        }
      }
      return null;
    };
    _._deactivateABSEnemy = function(name) {
      var enemy;
      enemy = this._getAbsAI(name);
      if (enemy != null) {
        enemy.deactivate();
      }
    };
    _._onABSEnemyParam = function(paramName, paramValue, aiEventName) {
      var event, index;
      if (paramName == null) {
        return;
      }
      if (paramValue == null) {
        paramValue = 0;
      } else {
        if (isFinite(paramValue)) {
          paramValue = parseInt(paramValue);
        }
      }
      event = this._getAbsAI(aiEventName);
      if (event == null) {
        event = $dataMap.events[this.eventId()];
      }
      if (!(event instanceof Game_AIBot)) {
        return;
      }
      index = AA.LIBS.Game_AIBehavior.PARAMS.indexOf(paramName);
      if (index < 0) {
        return;
      }
      event.behaviorModel()[paramName] = paramValue;
      event.LOG.p("New value " + paramValue + " of " + paramName);
      if (event.inBattle()) {
        event.refreshBehavior();
      }
    };
    return _._onABSSpawn = function(eventId, xOrRegion, y) {
      var e, point, x, y2;
      if (!AA.isABS()) {
        return;
      }
      try {
        eventId = parseInt(eventId);
        xOrRegion = parseInt(xOrRegion);
        if (y == null) {
          point = $gameMap.getRandomSpawnPointOnRegionABS(xOrRegion);
          if (point != null) {
            $gameMap.spawnABSBot(eventId, point.x, point.y);
          }
        } else {
          x = xOrRegion;
          y2 = parseInt(y);
          if ($gameMap.canSpawnABSOn(x, y2)) {
            $gameMap.spawnABSBot(eventId, x, y2);
          }
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  //?[ENEMYINTRPR_E]
  // * ENEMY INTERPRETER EXTENSION
  //---------------------------------------------------------------------------
  _.__clearCMABSEvent = function() {
    var ev;
    if (!this.isOnCurrentMap()) {
      return;
    }
    ev = $gameMap.event(this.eventId());
    if ((ev != null) && ev instanceof Game_AIBot) {
      ev._absParams.reservedCommonEvent = null;
    }
  };
  _.setParamE = function(paramName, newValue) {
    if (this._isThisAIBot()) {
      uAPI.setParamE(this.eventId(), paramName, newValue);
    }
  };
  _.lootE = function() {
    if (this._isThisAIBot()) {
      return uAPI.loot(this.eventId());
    }
  };
  _.reviveE = function() {
    if (this._isThisAIBot()) {
      return uAPI.reviveE(this.eventId());
    }
  };
  _.activateE = function() {
    if (this._isThisAIBot()) {
      return uAPI.activateE(this.eventId());
    }
  };
  _.deactivateE = function() {
    if (this._isThisAIBot()) {
      return uAPI.deactivateE(this.eventId());
    }
  };
  _.clearInBattleEventE = function() {
    return this.setParamE('cEinBattle', 0);
  };
  _.showMiniText = function(text, colorIndex) {
    return uAPI.showMiniText(this.eventId(), text, colorIndex);
  };
  _.level = function() {
    if (this._isThisAIBot()) {
      return this.__getAiBot().level();
    }
  };
  _._isThisAIBot = function() {
    var ev;
    if (this.isOnCurrentMap() && AA.isABS()) {
      ev = this.__getAiBot();
      if (ev != null) {
        return ev instanceof Game_AIBot;
      }
    }
    return false;
  };
  _.__getAiBot = function() {
    return $gameMap.event(this.eventId());
  };
  (function() {    
    // * ALTERNATIVE COMMANDS
    // =================================================================
    _.command331AA = function() {
      var candidates, e, i, len, value;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        value = this.operateValue(this._params[1], this._params[2], this._params[3]);
        if (this._params[0] < 0) {
          // * FOR ALL
          candidates = $gameTroop.onlyHostileMembersABSInBattle();
          for (i = 0, len = candidates.length; i < len; i++) {
            e = candidates[i];
            this.changeHp(e.battler(), value, this._params[4]);
          }
        } else {
          // * FOR CURRENT
          this.changeHp(this.__getAiBot().battler(), value, this._params[4]);
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Change Enemy HP command');
      }
      return true;
    };
    _.command332AA = function() {
      var candidates, e, i, len, value;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        value = this.operateValue(this._params[1], this._params[2], this._params[3]);
        if (this._params[0] < 0) {
          // * FOR ALL
          candidates = $gameTroop.onlyHostileMembersABSInBattle();
          for (i = 0, len = candidates.length; i < len; i++) {
            e = candidates[i];
            e.battler().gainMp(value);
          }
        } else {
          // * FOR CURRENT
          this.__getAiBot().battler().gainMp(value);
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Change Enemy MP command');
      }
      return true;
    };
    _.command342AA = function() {
      var candidates, e, i, len, value;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        value = this.operateValue(this._params[1], this._params[2], this._params[3]);
        if (this._params[0] < 0) {
          // * FOR ALL
          candidates = $gameTroop.onlyHostileMembersABSInBattle();
          for (i = 0, len = candidates.length; i < len; i++) {
            e = candidates[i];
            e.battler().gainTp(value);
          }
        } else {
          // * FOR CURRENT
          this.__getAiBot().battler().gainTp(value);
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Change Enemy TP command');
      }
      return true;
    };
    _.command333AA = function() {
      var b, candidates, e, i, len;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        if (this._params[0] < 0) {
          // * FOR ALL
          candidates = $gameTroop.onlyHostileMembersABSInBattle();
          for (i = 0, len = candidates.length; i < len; i++) {
            e = candidates[i];
            b = e.battler();
            if (this._params[1] === 0) {
              b.addState(this._params[2]);
            } else {
              b.removeState(this._params[2]);
            }
            b.clearResult();
          }
        } else {
          // * FOR CURRENT
          b = this.__getAiBot().battler();
          if (this._params[1] === 0) {
            b.addState(this._params[2]);
          } else {
            b.removeState(this._params[2]);
          }
          b.clearResult();
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Change Enemy State command');
      }
      return true;
    };
    _.command334AA = function() {
      var candidates, e, i, len, value;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        value = this.operateValue(this._params[1], this._params[2], this._params[3]);
        if (this._params[0] < 0) {
          // * FOR ALL
          candidates = $gameTroop.onlyHostileMembersABSInBattle();
          for (i = 0, len = candidates.length; i < len; i++) {
            e = candidates[i];
            e.battler().recoverAll();
          }
        } else {
          // * FOR CURRENT
          this.__getAiBot().battler().recoverAll();
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Enemy Recover All command');
      }
      return true;
    };
    _.command337AA = function() {
      var e;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        this.__getAiBot().requestAnimationABS(this._params[1]);
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Enemy Recover All command');
      }
      return true;
    };
    return _.command340AA = function() {
      var e;
      if (!this._isThisAIBot()) {
        return true;
      }
      try {
        this.__getAiBot().refreshBehavior();
      } catch (error) {
        e = error;
        AA.warning(e, 'Something wrong in Abort Battle command');
      }
      return true;
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  //?[MAPINV_E]
  // * MAP INVENTORY
  //---------------------------------------------------------------------------
  _.isAAVisualChest = function() {
    return this._isAAChestMode === true;
  };
  _._checkNextAAVisualChestCommand = function() {
    if (!this._isNextCommandForChest()) {
      this._index++; // * Переходим к следующей команде
      this._aaShowVisualChest();
      return false;
    }
    return true;
  };
  _._aaShowVisualChest = function() {
    this.setWaitMode('chest');
    AA.UI.openChest();
    return this._isAAChestMode = false;
  };
  _._aaPrepareVisualChest = function() {
    this._chestItemChance = 1;
    $gameTemp.__visualChestGoldCell = null;
    $gameTemp.__visualChestGoldCount = 0;
    $gameTemp.__isStoredVisualChestShouldOpened = false;
    this._isAAStoredChest = false;
    $gameTemp.__aaItemsForChest = [];
    if (this._isNextCommandForChest()) {
      return this._isAAChestMode = true;
    }
  };
  _._aaPrepareVisualChestStored = function() {
    var chestData;
    this._aaPrepareVisualChest();
    if (this._isAAChestMode === true || !this._isNextCommandForChest()) {
      $gameTemp.__isStoredVisualChestShouldOpened = true;
      $gameTemp.__storedVisualChestId = [$gameMap.mapId(), this.eventId()];
      chestData = $gamePlayer.getItemsForStoredChest($gameMap.mapId(), this.eventId());
      this._isAAStoredChest = chestData != null;
      if (this._isAAStoredChest === true) {
        $gameTemp.__aaItemsForChest = chestData.getAllItems();
      }
      this._isAAChestMode = true;
      // * Чтобы в режиме лута не открывался пустой сундук дополнительно
      if (this._notOpenEmtyVC === true) {
        this._notOpenEmtyVC = false;
        return;
      }
      if (!this._isNextCommandForChest()) {
        return this._aaShowVisualChest();
      }
    }
  };
  _._aaPrepareVisualLoot = function(items) {
    this._notOpenEmtyVC = true;
    this._aaPrepareVisualChest();
    this._isAAChestMode = true;
    this._aaPrepareVisualChestStored();
    if (this._isAAStoredChest === false) {
      $gameTemp.__aaItemsForChest = items;
      if ($gameTemp.__visualLootGold > 0) {
        if (AA.Parameters.get_GoldItemId() > 0) {
          $gameTemp.__aaItemsForChest.push([$dataItems[AA.Parameters.get_GoldItemId()], 1]);
        } else {
          $gameParty.gainGold($gameTemp.__visualLootGold);
        }
        $gameTemp.__visualChestGoldCount = $gameTemp.__visualLootGold;
      }
      $gameTemp.__visualLootGold = 0;
    }
  };
  _._isNextCommandForChest = function() {
    return [125, 126, 127, 128].contains(this.nextEventCodeWithoutArgs());
  };
  _.nextEventCodeWithoutArgs = function() {
    var command, i;
    i = 1;
    command = this._list[this._index + i];
    while ((command != null) && (command.code === 657 || command.code === 108)) {
      if (command.code === 108) {
        if (this._isAAStoredChest === false) {
          this.checkChestChanceItem();
        }
      }
      command = this._list[this._index + ++i];
    }
    if (command != null) {
      return command.code;
    } else {
      return 0;
    }
  };
  _.checkChestChanceItem = function() {
    var command, e, value;
    command = this._list[this._index + 1];
    try {
      if (command.parameters[0].contains("chance")) {
        value = command.parameters[0].split(":")[1];
        this._chestItemChance = parseInt(value) / 100;
      }
    } catch (error) {
      e = error;
      console.warn(e);
      this._chestItemChance = 1;
    }
  };
  _._aaUpdateChestWait = function() {
    var waiting;
    waiting = AA.UI.isChestIsOpen() || AA.UI.isUserChestIsOpen();
    if (!waiting) {
      this._waitMode = '';
    }
    return waiting;
  };
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setup, ALIAS__setupEvents, _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  //?[DEFTOWERS_E]
  //@[ALIAS]
  ALIAS__setupEvents = _.setupEvents;
  _.setupEvents = function() {
    this._checkAADefenceTowersExt();
    this._isABSMap = KDCore.Utils.hasMeta("ABS", $dataMap);
    if (this.isABS()) {
      this._initialABSMapSetup();
    }
    ALIAS__setupEvents.call(this);
    if (!this.isABS()) {
      return;
    }
    AlphaABS.ABSPathfinding.init();
    AlphaABS.ABSPathfinding.setup();
    this.setupEventsABS();
  };
  //?[LANDMINES_E]
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function(mapId) {
    ALIAS__setup.call(this, mapId);
    // * Точки карты с регионами (для оптимизации)
    this.__regionPoints = {};
    if (this._AALandmines != null) {
      this._AALandmines.terminate();
      this._AALandmines = null;
    }
    if (AA.isABS()) {
      return this._AALandmines = new AA.LIBS.AAMapLandmines();
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.ABSParams = function() {
    return this._absParams;
  };
  _.isABS = function() {
    return this._isABSMap === true;
  };
  _.stopABS = function() {
    return this._isABSMap = false;
  };
  _.addSVector = function(item) {
    return this._absParams.sVectors.push(item);
  };
  _.requestCast = function(who) {
    return this._absParams.needCast = who;
  };
  _.requestAnimationABS = function(animationData) {
    return this._absParams.animationABS = animationData;
  };
  (function() {    // * Система ABS
    // -----------------------------------------------------------------------
    _._initialABSMapSetup = function() {
      this._absParams = {
        sVectors: [],
        animationABS: null,
        targetCircle: null,
        targetCircleNeedLock: false,
        needCast: null,
        menuClickCount: 1,
        encountersCount: 0
      };
      this._aaBlockSpawnEventExists = false;
    };
    _.setupEventsABS = function() {
      var i, j, ref;
      for (i = j = 0, ref = this._events.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._events[i] == null) {
          continue;
        }
        this.addABSEvent(i);
      }
      return $gamePlayer.followers().initializeABS();
    };
    _.addABSEvent = function(id) {
      var enemyId, ev;
      ev = this._events[id].event();
      enemyId = this._getABSEnemyId(ev);
      if (enemyId > 0) {
        this._events[id] = new Game_AIBot(this.mapId(), id, enemyId);
      }
    };
    return _._getABSEnemyId = function(event) {
      var e, enemyId;
      try {
        enemyId = KDCore.Utils.getNumberFromMeta('ABS', event);
        if (enemyId > 0) {
          return enemyId;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Target
    // -----------------------------------------------------------------------
    _.requestPlayerTargetCircle = function(skill) {
      this._absParams.menuClickCount = 0;
      return this._absParams.targetCircle = skill;
    };
    _.lockPlayerTargetCircle = function() {
      return this._absParams.targetCircleNeedLock = true;
    };
    return _.stopPlayerTargetCircle = function() {
      this._absParams.targetCircle = null;
      return this._absParams.targetCircleNeedLock = false;
    };
  })();
  (function() {    
    // -----------------------------------------------------------------------

    // * Спавн
    // -----------------------------------------------------------------------
    _.spawnABSBot = function(id, x, y) {
      var e, eId, enemyId, event, newAi;
      try {
        event = $dataSpawnMapAI.events[id];
        if (event == null) {
          return;
        }
        DataManager.extractMetadata(event);
        enemyId = this._getABSEnemyId(event);
        if (!(enemyId > 0)) {
          return;
        }
        eId = this._events.length;
        newAi = new Game_SpawnedAiBot(this.mapId(), eId, enemyId, x, y, id);
        this._events.push(newAi);
        newAi.initABS();
        newAi.afterAddedOnMap();
        $gameTroop.setup();
        return SceneManager._scene._spriteset.createSpawnEventABS(eId);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.isHasABSSpawnBlockEvent = function() {
      return this._aaBlockSpawnEventExists === true;
    };
    _.getRandomSpawnPointOnRegionABS = function(regionId) {
      var j, len, pointToSpawn, possiblePoints, ref, regionPoint;
      if (this.__regionPoints[regionId] == null) {
        this.aaCollectAllPointsForRegion(regionId);
      }
      possiblePoints = [];
      ref = this.__regionPoints[regionId];
      for (j = 0, len = ref.length; j < len; j++) {
        regionPoint = ref[j];
        if (this.canSpawnABSOn(regionPoint[0], regionPoint[1])) {
          possiblePoints.push(regionPoint);
        }
      }
      if (possiblePoints.length > 0) {
        pointToSpawn = possiblePoints.sample();
        return new KDCore.Point(pointToSpawn[0], pointToSpawn[1]);
      }
      return null;
    };
    _.aaCollectAllPointsForRegion = function(regionId) {
      var j, k, ref, ref1, x, y;
      //"COLLECT".p()
      this.__regionPoints[regionId] = [];
      for (x = j = 0, ref = this.width(); (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.height(); (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
          if (this.regionId(x, y) === regionId) {
            this.__regionPoints[regionId].push([x, y]);
          }
        }
      }
    };
    _.canSpawnABSOn = function(x, y) {
      if (!AA.Parameters.isCanSpawnAboveEvents()) {
        if (this.eventsXy(x, y).length > 0) {
          return false;
        }
      }
      if ($gamePlayer.x === x && $gamePlayer.y === y) {
        return false;
      }
      if (this.isMapCellInAABlockZone(x, y)) {
        //return false if Game_CharacterBase.prototype.isCollidedWithVehicles(x, y)
        return false;
      }
      return this.isPassable(x, y);
    };
    _.isMapCellInAABlockZone = function(x, y) {
      var ev, i, j, point, ref;
      if (this.isHasABSSpawnBlockEvent()) {
        point = {x, y};
        ev = null;
        for (i = j = 0, ref = this._aaBlockSpawnEvnts.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          ev = $gameMap.event(this._aaBlockSpawnEvnts[i]);
          if (ev != null) {
            if (AlphaABS.UTILS.distanceTo(point, ev) < ev._aaBlockSpawnRadius) {
              console.log("Block Event disable Spawn Or Revive on point");
              return true;
            }
          }
        }
      }
      return false;
    };
    _.registerAABlockSpawnEvent = function(evId) {
      if (this._aaBlockSpawnEvnts == null) {
        this._aaBlockSpawnEvnts = [];
      }
      this._aaBlockSpawnEventExists = true;
      return this._aaBlockSpawnEvnts.push(evId);
    };
    return _.unRegistredAABlockSpawnEvent = function(evId) {
      if (this._aaBlockSpawnEvnts == null) {
        return;
      }
      this._aaBlockSpawnEvnts.delete(evId);
      if (this._aaBlockSpawnEvnts.length === 0) {
        this._aaBlockSpawnEventExists = false;
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Impulse
    // -----------------------------------------------------------------------
    return _.isPassableForImpulse = function(x, y, d) {
      if ($gamePlayer.pos(x, y)) {
        return false;
      }
      if (this.isPassable(x, y, d)) {
        if (x < 0 || y < 0 || x > this.width() || y > this.height()) {
          return false;
        } else if (AA.BattleManagerABS.isNoSolidRegion({x, y})) {
          return true;
        } else {
          return false;
        }
      }
      return false;
    };
  })();
  (function() {    
    // -----------------------------------------------------------------------

    //?[ENCOUNTERS_E]
    // * Encounters extension
    // -----------------------------------------------------------------------
    _._getAAEncounterCount = function() {
      return this._absParams.encountersCount;
    };
    return _._onNewAAEncounter = function() {
      return this._absParams.encountersCount++;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    //?[EXTRATARGTESP_E]
    // * Extra Target Preview extension
    // -----------------------------------------------------------------------
    _.isHasExtraPrivewEvent = function() {
      return false;
    };
    _.getEventWithEPUnderMouse = function() {
      return null;
    };
    return _.getABSEventUnderMouse = function() {
      var candidates, event, pos;
      pos = TouchInput.getMousePosition().convertToMap();
      candidates = $gameTroop.membersABS();
      event = candidates.filter(function(e) {
        return e.pos(pos.x, pos.y);
      });
      return event[0];
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    //?[DEFTOWERS_E]
    // * Defence Towers extension
    // -----------------------------------------------------------------------
    _.isAADefenceMap = function() {
      return this.__aaDefense === true;
    };
    return _._checkAADefenceTowersExt = function() {
      return this.__aaDefense = KDCore.Utils.hasMeta("AADEFENSE", $dataMap);
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    //?[LANDMINES_E]
    // * Defence Towers extension
    // -----------------------------------------------------------------------
    // * MINE_DATA {objectId, placerId, isItem?}
    return _.spawnLandMine = function(id, x, y, mineData) {
      var e, eId, event, newMineEvent;
      if (this._AALandmines == null) {
        return;
      }
      if (!AA.isABS()) {
        return;
      }
      try {
        event = $dataSpawnMapAI.events[id];
        if (event != null) {
          eId = this._events.length;
          newMineEvent = new Game_AASpawnedEvent(this.mapId(), eId, x, y, id);
          this._events.push(newMineEvent);
          SceneManager._scene._spriteset.createSpawnLandmineABS(eId);
          return this._AALandmines.addLandmine(eId, mineData);
        } else {
          return AA.warning("You try place landmine, but not create event on spawn map!");
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    //?[SUMMON_E]
    // * Summon extension
    // -----------------------------------------------------------------------
    return _.spawnSummonUnit = function(id) {
      var e, eId, enemyId, event, newAi, x, y;
      try {
        event = $dataSpawnMapAI.events[id];
        if (event == null) {
          return;
        }
        DataManager.extractMetadata(event);
        enemyId = this._getABSEnemyId(event);
        if (!(enemyId > 0)) {
          return;
        }
        eId = this._events.length;
        ({x, y} = $gamePlayer);
        newAi = new Game_SummonAiBot(this._mapId, eId, enemyId, x, y, id);
        this._events.push(newAi);
        newAi.initABS();
        newAi.activateSummonUnit();
        $gameTroop.setup();
        SceneManager._scene._spriteset.createSpawnEventABS(eId);
        return newAi;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
  })();
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  (function() {    //?[EXTRATARGTESP_E]
    // * Extra Target Preview extension
    // -----------------------------------------------------------------------
    _.isHasExtraPrivewEvent = function() {
      return this.events().some(function(e) {
        return e.isHaveETD();
      });
    };
    return _.getEventWithEPUnderMouse = function() {
      var candidates, event, pos;
      pos = TouchInput.getMousePosition().convertToMap();
      candidates = this.events().filter(function(e) {
        return e.isHaveETD();
      });
      event = candidates.filter(function(e) {
        return e.x === pos.x && e.y === pos.y;
      });
      if (event[0] != null) {
        return event[0].eventId();
      }
      return null;
    };
  })();
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addActor, ALIAS__gainGold, ALIAS__gainItem, ALIAS__removeActor, _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  //@[ALIAS]
  ALIAS__gainGold = _.gainGold;
  _.gainGold = function(amount) {
    ALIAS__gainGold.call(this, amount);
    if (amount > 0) {
      return AA.UI.pushGoldOnPanel(amount);
    }
  };
  //@[ALIAS]
  ALIAS__gainItem = _.gainItem;
  _.gainItem = function(item, amount, includeEquip) {
    ALIAS__gainItem.call(this, item, amount, includeEquip);
    this._gainItemAA(item, amount);
    return AA.UI.refreshInventory();
  };
  //$[OVER]
  _.inBattle = function() {
    if (AA.isABS()) {
      return $gamePlayer.inBattle() || this.isAnyMemberInBattle();
    } else {
      return Game_Unit.prototype.inBattle.call(this);
    }
  };
  
  //?DEPRECATED (NOT WORKS)
  //@[ALIAS]
  ALIAS__removeActor = _.removeActor;
  _.removeActor = function(actorId) {
    ALIAS__removeActor.call(this, actorId);
    if (!AA.isABS()) {
      return;
    }
    $gamePlayer.followers().initializeABS();
    $gamePlayer.followers().forEach(function(f) {
      return f.initABS();
    });
    $gamePlayer.refresh();
    $gameMap.requestRefresh();
    AA.BattleManagerABS.updateABSSession();
  };
  //?DEPRECATED (NOT WORKS)
  //@[ALIAS]
  ALIAS__addActor = _.addActor;
  _.addActor = function(actorId) {
    var bots, e, ls;
    ALIAS__addActor.call(this, actorId);
    if (!AA.isABS()) {
      return;
    }
    try {
      bots = $gamePlayer.followers();
      ls = $gameParty.members().length - 1;
      bots._data[ls - 1].reInitABS(ls);
      bots._data[ls - 1].initABS();
      $gamePlayer.refresh();
      $gameMap.requestRefresh();
      AA.BattleManagerABS.updateABSSession();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  _.initABS = function() {
    this._inBattle = false;
    return this._noNotifyABS = false;
  };
  _.stopABS = function() {
    this.selectOnMap(null);
    return this.membersABS().forEach(function(member) {
      return member.stopABS();
    });
  };
  _.refreshABS = function() {
    this.membersABS().forEach(function(member) {
      return member.refreshABS();
    });
    return $gamePlayer.refreshABS();
  };
  _.terminateABSSession = function() {
    return this.membersABS().forEach(function(member) {
      return member.onGameSave();
    });
  };
  _.membersABS = function() {
    return $gamePlayer.followers()._data;
  };
  _.aliveMembersABS = function() {
    return this.membersABS().filter(function(member) {
      return member.battler().isAlive();
    });
  };
  _.getAIBotByBattler = function(battler) {
    var e, i, len, member, ref;
    try {
      if (battler === $gamePlayer.battler()) {
        return $gamePlayer;
      }
      ref = this.membersABS();
      for (i = 0, len = ref.length; i < len; i++) {
        member = ref[i];
        if (member.battler() === battler) {
          return member;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.gainExpForAllABS = function(exp, shared) {
    if (shared === true) {
      exp = Math.round(exp / (this.membersABS().length + 1));
    }
    $gamePlayer.battler().gainExp(exp);
    this.membersABS().forEach(function(member) {
      return member.battler().gainExp(exp);
    });
  };
  _.selectOnMap = function(who) {
    this.membersABS().forEach(function(member) {
      return member.selectOnMap(false);
    });
    if (who != null) {
      who.selectOnMap(true);
    }
    // * Если произошёл какой-либо выбор, мы закрываем круг
    AA.UI.closeBehCircle();
    $gamePlayer._resetSummonUnit();
  };
  _._gainItemAA = function(item, amount) {
    var e;
    try {
      if ((item != null) && amount > 0 && !this._noNotifyABS) {
        if (!Imported.YEP_ItemCore || !DataManager.isIndependent(item)) {
          AA.UI.pushItemOnPanel(item);
        }
      }
      if (!$gameMap.isABS()) {
        return;
      }
      if (item == null) {
        return;
      }
      if (DataManager.isWeapon(item)) {
        AA.UI.refreshWeaponCircle();
      }
      if (amount <= 0) {
        return;
      }
      AA.UI.refresh();
      if (!$gamePlayer.inBattle()) {
        $gamePlayer.battler().checkAutoReloadFirearm(item);
      }
      try {
        if (AlphaABS.Parameters.isAutoBindItemsToPanel()) {
          if (item.occasion === 1 && item.meta.ABS) {
            return $gamePlayer.battler().setOrRefreshItemOnPanel(item.id, void 0);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e, 'bind item to panel');
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //?[MAPINV_E]

  // * MAP Inventory extension
  // -----------------------------------------------------------------------

  //@[DEFINES]
  _ = Game_Party.prototype;
  _.moveAllItemsToAAStorage = function() {
    var count, item, items, j, len;
    items = this.allItems().filter(function(item) {
      return item.itypeId === 1;
    });
    for (j = 0, len = items.length; j < len; j++) {
      item = items[j];
      count = this.numItems(item);
      $gameParty.gainItem(item, -count);
      $gamePlayer.addPutItemToPlayerChest(item, count);
    }
    if (AA.UI.isUserChestIsOpen()) {
      AA.UI.refreshUserChest();
    }
  };
  _.moveEquipedItemsToStorage = function() {
    var item, j, len, pl, ref, ref1;
    pl = this.leader();
    if (pl == null) {
      return;
    }
    ref = pl.equips();
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item == null) {
        continue;
      }
      $gamePlayer.addPutItemToPlayerChest(item, 1);
      pl.discardEquip(item);
      $gameParty.gainItem(item, -1);
    }
    if ((ref1 = $gamePlayer.battler()) != null) {
      ref1._refreshVisualEq();
    }
    if (AA.UI.isUserChestIsOpen()) {
      AA.UI.refreshUserChest();
    }
    if (!AA.isABS()) {
      pl._refreshVisualEq();
    }
  };
  _.getAllEquippedItems = function(itemTypeMethod) {
    var actor, equiped, items, j, len, ref;
    equiped = [];
    ref = AA.UI.partyGroup();
    for (j = 0, len = ref.length; j < len; j++) {
      actor = ref[j];
      items = actor.equips().filter(function(i) {
        return (i != null) && itemTypeMethod(i);
      });
      equiped.push(...items);
    }
    return equiped;
  };
  _.canAnyEquip = function(item) {
    var actor, j, len, ref;
    ref = AA.UI.partyGroup();
    for (j = 0, len = ref.length; j < len; j++) {
      actor = ref[j];
      if (actor.canEquip(item)) {
        return true;
      }
    }
    return false;
  };
  _.getMaxWeightCapacity = function() {
    var varValue;
    varValue = AA.Utils.getVar(AA.Parameters.get_MapInventoryWeigthSystemVarId());
    varValue += this._collectWeightCapacityFromEquipment();
    varValue += $gamePlayer.getPlayerStaticWeight();
    return varValue;
  };
  _.isShouldRefreshWeightCapacity = function() {
    return this._isRefreshedCapacity == null;
  };
  _.requestWeightCapacityRefresh = function() {
    return this._isRefreshedCapacity = null;
  };
  _.getCurrentWeight = function() {
    var f, items, w;
    items = this.allItems();
    f = function(a, b) {
      return a + (DataManager.getItemWeight(b) * $gameParty.numItems(b));
    };
    w = items.reduce(f, 0);
    return w;
  };
  _._collectWeightCapacityFromEquipment = function() {
    var actor, e, item, j, k, len, len1, ref, ref1;
    if (this.isShouldRefreshWeightCapacity()) {
      this._lastCapacityValue = 0;
      ref = AA.UI.partyGroup();
      for (j = 0, len = ref.length; j < len; j++) {
        actor = ref[j];
        if (actor == null) {
          continue;
        }
        ref1 = actor.equips();
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          item = ref1[k];
          if (item == null) {
            continue;
          }
          try {
            if ((item.meta != null) && (item.meta.weightStore != null)) {
              this._lastCapacityValue += parseInt(item.meta.weightStore);
            }
          } catch (error) {
            e = error;
            AA.warning(e);
          }
        }
      }
      this._isRefreshedCapacity = true;
    }
    return this._lastCapacityValue;
  };
  _._refreshInventoryWAutoState = function() {
    var actor, j, len, ref;
    if (!AA.isPro()) {
      return;
    }
    ref = AA.UI.partyGroup();
    for (j = 0, len = ref.length; j < len; j++) {
      actor = ref[j];
      if (actor == null) {
        continue;
      }
      actor._updateInventoryWeightAutoState();
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //?[NEWPARTY_E]
  // * Методы нового АИ группы
  // -----------------------------------------------------------------------

  //@[DEFINES]
  _ = Game_Party.prototype;
  _.isAnyMemberInBattle = function() {
    return this.membersABS().some(function(e) {
      return e.inBattle();
    });
  };
  _.isAnyCanChangeBehMode = function() {
    if (!AA.isABS()) {
      return false;
    }
    return this.membersABS().some(function(e) {
      return e.behaviorModel().sChangeModeAllowed > 0;
    });
  };
  _.selectedAllyByPlayer = function() {
    return this.membersABS().find(function(e) {
      return e === BattleManagerABS.getPlayerTarget();
    });
  };
  _.memberABSByActorId = function(actorId) {
    return this.membersABS().find(function(m) {
      return m.AABattler().actorId() === actorId;
    });
  };
  _.getAAEntityByBattler = function(actor) {
    var item;
    item = this.membersABS().find(function(e) {
      return e.AABattler() === actor;
    });
    if (item != null) {
      return item.AAEntity();
    } else {
      return null;
    }
  };
  _.resumeABS = function() {
    var i, len, m, ref, results;
    ref = this.membersABS();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      m = ref[i];
      results.push(m.resumeABS());
    }
    return results;
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------

(function () {

  var LOG = new KDCore.DevLog("Game_Player");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  var ABSUtils = AlphaABS.UTILS;
  var Consts = AlphaABS.SYSTEM;
  var BattleProcessABS = BattleManagerABS.battleProcess();
  var BattleUI = AlphaABS.BattleUI;

  //Game_Player
  //------------------------------------------------------------------------------
  var _Game_Player_initMembers = Game_Player.prototype.initMembers;
  Game_Player.prototype.initMembers = function () {
    _Game_Player_initMembers.call(this);

    this._initMembersABS();
  };

  Game_Player.prototype._initMembersABS = function() {
    this._absParams.battler = null;
    this._absParams.active = true; //Со мной можно взаимодействовать (я под управлением)
    this._absParams.inBattle = false;
    this._absParams.control = true; //Отвечат на управление
    this._absParams.dead = false;

    this._teamId = 0;

    this._absParams.inputMode = 0; //0 - ControllPanel, 1 - Weapons, 2 - Summons

    this._absParams.state = 'free'; //Состояние
    this._absParams.target = null; //Моя цель
    this._absParams.autoAttackMode = false; //Режим автоматической атаки
    this._absParams.targetFollowMode = false; //Следовать к цели

    this._absParams.currentAction = null;
    this._absParams.expPopup = null;
    this._absParams.motion = null;

    this._absParams.isWeapRecharge = false;
    this._absParams.casting = false;
    this._absParams.castingSkill = null;

    this._absParams.inBattleTimer = null;
    this._absParams.absMapData = []; //TODO: Создать что-то отдельное
    this._absParams._inCastMotion = false;
  };

  Game_Player.prototype.teamId = function () {
    return this._teamId;
  };

  Game_Player.prototype.isCasting = function () {
    return this._absParams.casting == true; //TODO: Ugly! У нас есть текущее действие и его свойство isCasting, см. AI_Bot
  };

  Game_Player.prototype.isAlly = function (who) {
    if (who)
      return (this.teamId() == who.teamId());
    return false;
  };

  Game_Player.prototype.isABS = function() {
    if(this.inActive() && this.battler() != null) {
      return true;
    }
    return false;
  };

  //OVER
  Game_Player.prototype.executeMove = function (direction) {
    if (!this.inActive()) return;
    if (AA.UI.isGameShouldPause()) return;

    this.stopFollowMode();
    this.interruptCast();
    if (this._absParams.state != 'targetCircle') {
      this.moveStraight(direction);
    }
  };

  //NEW
  Game_Player.prototype.changeInputMode = function (mode) {
    if (mode == 0) {
      if (BattleUI.isWeaponCircleOpen()) {
        BattleUI.closeWeaponCircle();
        BattleUI.selectOnControlPanel(4);
      }
      if (BattleUI.isBehCircleOpen()) {
        BattleUI.closeBehCircle();
      }
    } else {
      if(mode == 1) {
        if (!BattleUI.isWeaponCircleOpen()) {
          BattleUI.openWeaponCircle();
          BattleUI.diselectOnControlPanel(4);
        }
      } else {
        this._changeInputModeToSummon();
      }
    }
    this._absParams.inputMode = mode;
  };

  //NEW
  Game_Player.prototype.onGameLoad = function () {
    LOG.p("PL : On Game Load");
    if (!this._absParams) this._initMembersABS();
    this.battler().onGameLoad();
    this.refreshABSMotion();
    $gameScreen._resetBSEffect();
  };

  //NEW
  Game_Player.prototype.target = function () {
    return this._absParams.target;
  };

  //NEW
  Game_Player.prototype.stopFollowMode = function () {
    if (this._absParams.targetFollowMode)
      BattleUI.diselectOnControlPanel(1);
    this._absParams.targetFollowMode = false;
  };

  //NEW
  Game_Player.prototype.battler = function () {
    return this._absParams.battler;
  };

  //NEW
  Game_Player.prototype.initABS = function () {
    //LOG.p("Player inited");
    this._absParams.battler = $gameParty.leader();
    if (!Imported.Quasi_Movement)
      this._absParams.useAStar = true;
    this.initABSForAlly();
    this._inAAShieldState = false;
    if(KDCore.isMZ())
      this.battler()._initBattleSkills();
    this.battler().reloadFirearm();
    this.battler()._refreshCanApplyForShieldUIButton();
    this.refreshABSMotion();
    this.initECThread();
    this.aaInitNoPassFlagThread();
  };

  //NEW
  Game_Player.prototype.stopABS = function () {
    if(this.battler()) {
      this.battler().saveFirearm();
      this._absParams.battler.stopABS();
      this._resetTarget();
    }
    this.controlOn();
    this._absParams.inBattle = false;
    this._absParams.active = true;
    this._absParams.dead = false;
    this._absParams.useAStar = false;
    $gameParty.stopABS();
    this.clearABSMotion();
  };

  //NEW
  Game_Player.prototype.prepareABS = function () {
    this.battler().clearInfoPops();
    this.battler().clearActions();
    this.battler()._refreshCanApplyForShieldUIButton();
    this.clearExpPopup();
    this._resetTarget();
    this.battler().refreshABSSkills();
    this.changeInputMode(0);
    this.battler().checkLastFirearmLoad();
  };

  //@[ALIAS]
  /*var _alias_Game_Player_performTransfer = Game_Player.prototype.performTransfer;
  Game_Player.prototype.performTransfer = function () {
      if (AA.isABS() && this.isTransferring()) {
        
      }
      _alias_Game_Player_performTransfer.call(this);
  };*/

  //NEW
  Game_Player.prototype.clearExpPopup = function () {
    this._absParams.expPopup = null;
  };

  //NEW
  Game_Player.prototype.isExpPopupRequested = function () {
    return (this._absParams.expPopup != null);
  };

  //NEW
  Game_Player.prototype.isMotionRequested = function () {
    return (this._absParams.motion != null);
  };

  //NEW
  Game_Player.prototype.requestMotion = function (motion) {
    this._absParams.motion = motion;
  };

  //NEW
  Game_Player.prototype.motionType = function () {
    return this._absParams.motion;
  };

  //NEW
  Game_Player.prototype.clearMotion = function () {
    this._absParams.motion = null;
  };

  //NEW
  Game_Player.prototype.requestExpPopup = function (value) {
    this._absParams.expPopup = value;
  };

  //NEW
  Game_Player.prototype.getExpPopup = function () {
    return this._absParams.expPopup;
  };

  //NEW
  Game_Player.prototype.inBattle = function () {
      return this._absParams.inBattle;
  };

  //@[ALIAS]
  var _alias_Game_Player_moveDiagonally = Game_Player.prototype.moveDiagonally;
  Game_Player.prototype.moveDiagonally = function (horz, vert) {
      if (!this.inActive()) return;
      if (this.inTargetCircleState()) return;
      this.stopFollowMode();
      this.interruptCast();
      _alias_Game_Player_moveDiagonally.call(this, horz, vert);
      
  };

  //NEW
  Game_Player.prototype.canControl = function () {
    if(AA.UI.isGameShouldPause()) return false;
    return this.inActive() && this.battler().canMove() && this._absParams.control;
  };

  Game_Player.prototype.inTargetCircleState = function() {
    return (this._absParams && this._absParams.state == 'targetCircle');
  };

  //@[ALIAS]
  var _alias_Game_Player_canMove = Game_Player.prototype.canMove;
  Game_Player.prototype.canMove = function () {
      return _alias_Game_Player_canMove.call(this) && !this.inTargetCircleState();
  };

  //NEW
  Game_Player.prototype.refreshBattleState = function () {
    if (!this.inBattle()) {
      this.onBattleStart();
      /*$gameParty.membersABS().forEach(function (member) {
        if (!member.inBattle()) {
          member.changeStateToSearch($gamePlayer);
        }
      });*/
    }
  };

  //NEW
  Game_Player.prototype.onBattleStart = function () {
    LOG.p("PL : Battle start");
    //BattleManagerABS.alertOnUI(Consts.STRING_ALERT_INBATTLE);
    this._absParams.inBattle = true;
    this._absParams.inBattleTimer = new Game_TimerABS();
    this._absParams.inBattleTimer.start(120);
    this.refreshABSMotionState(true);
    if(this.isAnimX()) {
      this.switchToXAnimaState('inBattle');
    }
    var ui = AA.BattleUI.getUI();
    if(ui) {
      ui._inBattleIcon.visible = true;
    }
    if($gameTemp.aaIsScrollBeenApplied == true) {
        if(AA.Parameters.xMapScrollSettings().resetOnBattle == true) {
            uAPI.resetCamera();
        }
    }
  };

  //NEW
  Game_Player.prototype.onBattleEnd = function () {
    LOG.p("PL : Battle end");
    //BattleManagerABS.alertOnUI(Consts.STRING_ALERT_OUTBATTLE);
    this._absParams.inBattle = false;
    this._absParams.inBattleTimer = null;
    this.refreshABSMotionState(false);
    if(this.isAnimX())
      this.resetXAnimaState();
    var ui = AA.BattleUI.getUI();
    if (ui) {
      ui._inBattleIcon.visible = false;
    }
  };

  //NEW
  Game_Player.prototype.inActive = function () {
    return this._absParams.active;
  };

  //NEW
  Game_Player.prototype.controlOff = function () {
    $gameTemp.clearDestination();
    this._absParams.control = false;
    this._removeAAShieldState();
    LOG.p("Control OFF");
  };

  //NEW
  Game_Player.prototype.controlOn = function () {
    this._absParams.control = true;
    LOG.p("Control ON");
  };

  //NEW
  Game_Player.prototype.onTurnEnd = function () {
    this.battler().onTurnEnd();
  };

  //NEW
  Game_Player.prototype.touchSkillAt = function (index) {
    if (!this.canControl()) return;
    var skillABS = this.battler().skillByKeyIndex(index);
    if (this.executeABSSkill(skillABS))
      BattleUI.touchOnSkillPanel(index);
  };

  //?[NEW]
  Game_Player.prototype.executeABSSkill = function (skillABS) {
    try {
      if (skillABS) {
        if (this._absParams.currentAction != skillABS) {
          this._onNewSkillActivate();
          this._absParams.currentAction = skillABS;
          this._changeState('prepare');
          return true;
        }
      }
    } catch (e) {
      AA.warning(e);
    }
    return false;
  };

  //NEW
  Game_Player.prototype.touchControlAt = function (index) {
    if (!this.canControl()) return;
    if (index > 6) {
      return;
    }

    switch (index) {
      case 0:
        this._onAttackClick();
        break;
      case 1: //Follow Mode
        var followAllowed = this.isFollowAllowed();
        if (this.target() && followAllowed == true) {
          if (!this._absParams.autoAttackMode)
            this._onNewSkillActivate();
          this._absParams.targetFollowMode = !this._absParams.targetFollowMode;
          if (this._absParams.targetFollowMode) {
            BattleUI.selectOnControlPanel(index);
          } else {
            BattleUI.diselectOnControlPanel(index);
          }
          BattleUI.touchOnControlPanel(index);
        }
        break;
      case 2:
        var jumpAllowed = this.isJumpAllowed();
        if (jumpAllowed == true) {
          if (this.canMove()) {
            if (Imported.YEP_SmartJump == true) {
              if (this._absParams.state == 'free' && !this.isJumping())
                $gamePlayer.smartJump(1);
            } else {
              if (this._absParams.state == 'free' && !this.isJumping() && this.canPass(this.x, this.y, this.direction())) {
                switch (ABSUtils.getDirKey(this)) {
                  case 'u':
                    this.jump(0, -1);
                    break;
                  case 'd':
                    this.jump(0, 1);
                    break;
                  case 'l':
                    this.jump(-1, 0);
                    break;
                  case 'r':
                    this.jump(1, 0);
                    break;
                }
              }
            }
            BattleUI.touchOnControlPanel(index);
          }
        }
        break;
      case 3:
        var rotateAllowed = this.isRotateAllowed();
        if (rotateAllowed == true) {
          if (this.canMove()) {
            if (this._absParams.state == 'free' && !this._absParams.targetFollowMode) {
              if (this.target()) {
                this.turnTowardCharacter(this.target());
              } else {
                if (!Utils.isMobileDevice())
                  this.turnTowardCharacter(TouchInput.getMousePosition().convertToMap());
              }
            }
            BattleUI.touchOnControlPanel(index);
          }
        }
        break;
      case 4:
        var weapAllowed = this.isWeaponsAllowed();
        if (weapAllowed == true) {
          if (this.canMove()) {
            if (!this.battler().isFavWeapExists()) return;
            BattleUI.touchOnControlPanel(index);
            BattleUI.refreshWeaponCircle();
            //if(Input.isGamepad())
            //  this._simulateClickOnButton('weapons');
            if (this._absParams.inputMode == 0) {
              this.changeInputMode(1);
            } else {
              if(this._absParams.inputMode == 2) {
                this.changeInputMode(0);
                this.changeInputMode(1);
              } else
                this.changeInputMode(0);
            }
          }
        }
        break;
      case 5:
        this._changeAAShieldState();
        break;
      case 6:
          this._showSummonUnitMenu();
        break;
    }
  };

  //NEW
  Game_Player.prototype.touchWeaponAt = function (index) {
    if (this._absParams.inputMode != 1) return;
    BattleUI.touchOnWeaponCircle(index);
    if (this.battler().changeFavWeap(index)) {
      this._removeAAShieldState();
      SoundManager.playEquip();
      this.changeInputMode(0);
    } else
      SoundManager.playBuzzer();

    BattleUI.refreshWeaponCircle();
  };

  //NEW
  Game_Player.prototype.onActionOnMe = function (who) {
    if (who) {
      this.refreshBattleState();
      if (!this.target() && who.target() == this && who.inActive()) {
        BattleManagerABS.setPlayerTarget(who);
      }
    }
  };

    var _Game_Player_update = Game_Player.prototype.update;
    Game_Player.prototype.update = function (sceneActive) {
      _Game_Player_update.call(this, sceneActive);
      this._updateABS(sceneActive);
    };

  //NEW
  Game_Player.prototype.interruptCast = function () {
    if(!AA.isABS())
      return;
    var t = this._absParams.currentAction;
    if(this.battler())
      this.battler().onAACastStop();
    if (t && t.isCasting()) {
      LOG.p("PL : Cast intterupt");
      BattleManagerABS.alertOnUI(Consts.STRING_ALERT_INTERRUPT);
      t.resetCast();
      this._absParams.casting = false;
      this._absParams.castingError = true;
      this._changeState('free');
      this._cancelCastMotion();
    }
  };

  Game_Player.prototype.setFavWeapForce = function (itemId, segmentSymbol = 'top') {
    var index = 0;
    switch (segmentSymbol) {
      case 'left':
        index = 3;
        break;
      case 'top':
        index = 0;
        break;
      case 'bottom':
        index = 2;
        break;
      case 'right':
        index = 1;
        break;
    }
    var item = $dataWeapons[itemId];
    var owner = this.battler();
    if (owner == null) {
      owner = $gameParty.leader();
    }
    owner.setFavWeap(item, index);
    BattleUI.refreshWeaponCircle();
  };
  //RPIVATE

  Game_Player.prototype._deactivate = function () {
    BattleManagerABS.setPlayerTarget(null);
    $gameMap.stopPlayerTargetCircle();
    this._stopTargetSelect();
    this._absParams.active = false;
    if (!this.battler().isAlive()) {
      this._dead();
    }
  };

  Game_Player.prototype._dead = function () {
    AudioManager.playMe($gameSystem.defeatMe());
    this._absParams.dead = true;
    this._absParams.deadTimer = new Game_TimerABS();
    this._absParams.deadTimer.start(90);
    //$gameScreen.startFadeOut(60);
    this._resetTarget();
    this.battler().onAADeath();
    this.requestMotion('sleep');
  };

  //NEW
  Game_Player.prototype.setTarget = function (target) {
    if(!target) {
      this._resetTarget();
    } else {
      this._absParams.target = target;
    }
  };

  Game_Player.prototype._resetTarget = function () {
    if (!this.battler())
      return;
    this.stopFollowMode();
    this.interruptCast();
    this._absParams.target = null;
    this._absParams.autoAttackMode = false;
    if (!this.battler().skillABS_attack().isNoTarget())
      BattleUI.disableOnControlPanel(0);
    BattleUI.disableOnControlPanel(1);
    BattleUI.changeRotateIconToMouse();
    this._changeState('free');
  };

  Game_Player.prototype._changeState = function (newState) {
    this._absParams.state = newState;
    switch (newState) {
      case 'free':
        this._cancelCastMotion();
        this._stopTargetSelect();
        this._absParams.currentAction = null;
        break;
      case 'cast':
        if (this._absParams.currentAction.isRadiusTypeR() || this._absParams.currentAction.isSpecialTeleportType() || this._absParams.currentAction.isVectorTypeR())
          $gameMap.lockPlayerTargetCircle();
        $gameTemp.clearDestination();
        this._removeAAShieldState();
        this.stopFollowMode();
        this._performCastMotion();
        break;
      case 'targetCircle':
        $gameTemp.clearDestination();
        $gameMap.requestPlayerTargetCircle(this._absParams.currentAction);
        this._removeAAShieldState();
        this.stopFollowMode();
        break;
    }
  };

  // * THIS IS ONLY FOR TARGET ACTIONS, for NOT TARGET SEE Game_Player_private.coffee
  Game_Player.prototype._performAction = function () {
    this.battler().makeActions();
    if (this._absParams.currentAction.isItem()) {
      this.battler().action(0).setItem(this._absParams.currentAction.skillId);
    } else
      this.battler().action(0).setSkill(this._absParams.currentAction.skillId);

    LOG.p("PL : Perform! " + this._absParams.currentAction.name());
    var selfAction = false;
    if (this._absParams.currentAction.isVectorType()) {
      if (this._absParams.currentAction.isVectorTypeR()) {
        var point = new KDCore.Point(TouchInput.x, TouchInput.y);
        if($gameTemp._targetCircleLockedPosition) {
          point = $gameTemp._targetCircleLockedPosition;
        }
        //var point = new KDCore.Point(TouchInput.x, TouchInput.y);
        if(Input.isGamepad()) {
          point = AAGamePadManager.GetTargetCirclePositionByGamepad();
        }
        BattleProcessABS.startPostBattleAction(this, point.convertToMap(), this.battler().action(0), this._absParams.currentAction);
      }
      else {
        var target = this.target();
        if(this._absParams.currentAction.isNoTarget()) {
          target = this._findEndPointForVectorSkill();
        } 
        if (this.target() != null)
          this.turnTowardCharacter(this.target());
        BattleProcessABS.startPostBattleAction(this, target, this.battler().action(0), this._absParams.currentAction);
      }
    } else {
      if (this._absParams.currentAction.isRadiusType()) {
        if (this._absParams.currentAction.isNeedTarget() || this._absParams.currentAction.isSpecialTeleportType()) {
          var point2 = new KDCore.Point(TouchInput.x, TouchInput.y);
          if($gameTemp._targetCircleLockedPosition) {
            point2 = $gameTemp._targetCircleLockedPosition;
          }
          //var point2 = new KDCore.Point(TouchInput.x, TouchInput.y);
          if (Input.isGamepad()) {
            point2 = AAGamePadManager.GetTargetCirclePositionByGamepad();
          }
          BattleProcessABS.performBattleActionRadius(this, point2.convertToMap(), this.battler().action(0), this._absParams.currentAction);
        } else {
          BattleProcessABS.performBattleActionRadius(this, this.toPoint(), this.battler().action(0), this._absParams.currentAction);
        }
      } else {
        if (this._absParams.currentAction.isZoneType()) {
          BattleProcessABS.performBattleActionZone(this, this.battler().action(0));
        } else {
          if (this._absParams.currentAction.isNeedTarget()) {
            if ((this.target() == null || this.target().isEnemy()) && this._absParams.currentAction.isForAlly()) {

              this.battler().performCurrentAction();
              this.battler().action(0)._forcing = true;
              BattleProcessABS.performBattleAction(this, this); //On self
              selfAction = true;

            } else 
              BattleProcessABS.performBattleAction(this, this.target());
          }
          else {
            this.battler().performCurrentAction();
            this.battler().action(0)._forcing = true;
            BattleProcessABS.performBattleAction(this, this); //On self
            selfAction = true;
          }
        }
      }
    }

    if (!selfAction) {
      this.battler().performCurrentAction();
    }

    this._absParams.currentAction.playStartSound(null);

    if (this._absParams.currentAction == this.battler().skillABS_attack()) {
      this.aaPerformAttackAnimation();
      BattleUI.refreshWeaponCircleIfOpen();
    } else {
      this._performSkillMotion();
    }

    this._removeAAShieldState(); // * На всякий случай

    if (!this.inBattle() && this.target() != this && selfAction == false) {
      this.onBattleStart();
    }
    if (this._absParams.autoAttackModeLast) {
      if (this._turnAutoAttack()) {
        this._absParams.autoAttackModeLast = false;
      }
    }
    this.refreshBattleState();
    this._changeState('free');
  };



  Game_Player.prototype._onNewSkillActivate = function () {
    if (this._absParams.autoAttackMode == true) {
      this._absParams.autoAttackModeLast = true;
      this._absParams.autoAttackMode = false;
    }
    this._removeAAShieldState();
    this._stopTargetSelect();
    this.interruptCast();
  };

  Game_Player.prototype._updateABS = function (sceneActive) {
    if (!sceneActive) return;
    if (!this.battler()) return;

    if (this._absParams.dead === true && this._absParams.deadTimer != null) {
      this._absParams.deadTimer.update();
      if (this._absParams.deadTimer.isReady()) {
        this._processOnPlayerDead();
      }
    }

    if (!this.inActive()) return;

    if (!this.battler().isAlive() && this.inActive()) {
      this._deactivate();
    }

    if (!this.battler().canMove() && this._absParams.control) {
      this.controlOff();
      this._resetTarget();
      LOG.p("PL: Battle cannot move");
    }

    if (this.battler().canMove() && !this._absParams.control && !BattleUI.isUIFree()) {
      this.controlOn();
      LOG.p("PL: Battle can move alredy");
    }

    if (this._absParams.inBattleTimer) {
      this._absParams.inBattleTimer.update();
      if (this._absParams.inBattleTimer.isReady()) {
        if (this._checkInBattleStatus()) {
          this._absParams.inBattleTimer.reset();
        } else {
          this.onBattleEnd();
        }
      }
    }

    this.battler().updateABS();
    this._update_attackReload();
    if (!this.inActive()) return;
    if (!this.canControl()) return;

    if(this.isMoving() && this.isInAAShieldState()) {
      this._removeAAShieldState();
    }

    this._update_input();
    if (this._absParams.autoAttackMode) {
      this._update_on_autoAttackMode();
    } else {
      switch (this._absParams.state) {
        case 'free':
          //this._checkInBattleStatus(); //@opt Можно выделить в процесс
          break;
        case 'prepare':
          this._update_on_prepare();
          break;
        case 'action':
          this._update_on_action();
          break;
        case 'cast':
          this._update_on_cast();
          break;
        case 'targetCircle':
          this._update_on_targetCircle();
          break;
      }
      this._aaEnemyCountThread.update();
    }

    if (!Imported.SAN_AnalogMove)
      if (this._absParams.targetFollowMode == true) {
        if (!this.isMoving()) {
          if (this.isTargetFar(this.target()))
            this.moveToPointAA(this.target());
          else
            this.turnTowardCharacter(this.target());
        }
      }

    //this._moveSpeed = 4 + this.battler().ABSParams().moveSpeedUpKoef;
  };

  Game_Player.prototype.isTargetFar = function(target) {
    if(target) {
      var dist = AA.UTILS.distanceTo(this, target);
      return dist > 1;
    }
    return false;
  };

  Game_Player.prototype._processOnPlayerDead = function () {
    try {
      var deadEventId = AlphaABS.Parameters.get_DeadMapCommonEventId();
      if (deadEventId > 0) {
        if ($dataCommonEvents[deadEventId]) {
          this.startCommonEventABS(deadEventId);
        }
      }
      var deadMapId = AlphaABS.Parameters.get_DeadMapId();
      if (deadMapId > 0) {
        this._processOnPlayerDeadMap(deadMapId);
      } else {
        if (deadEventId <= 0)
          SceneManager.goto(Scene_Gameover);
      }
    } catch (e) {
      console.error(e);
      SceneManager.goto(Scene_Gameover);
    }
  };

  Game_Player.prototype._processOnPlayerDeadMap = function (deadMapId) {
    var position = AlphaABS.Parameters.get_DeadMapPosition();
    var direction = AlphaABS.Parameters.get_DeadMapDirection();
    $gameTemp.transferedByDeathABS = true;
    this.reserveTransfer(AlphaABS.Parameters.get_DeadMapId(), position.X, position.Y, direction, 0);
    this.battler().gainHp(1);
    this._absParams.deadTimer = null;
  };

  //TODO: Плохая система, нет общей проверки навыков. АИ и игрок и NoTarget используют разные методы
  Game_Player.prototype._update_on_autoAttackMode = function () {
    var t = this.battler();
    var skill = t.skillABS_attack();
    this._absParams.currentAction = skill;
    if (ABSUtils.distanceTo(this, this.target()) <= 1) {
      this.turnTowardCharacter(this.target());
    }
    if (this.battler().canUse(skill.skill()) && this.target().isEnemy()) {
      if (BattleManagerABS.canUseSkilllBySpecialState(this, skill) && BattleManagerABS.canUseSkillByTimer(skill)) {
        if (BattleManagerABS.canUseSkillByRange(this, this.target(), skill)) {
          this.turnTowardCharacter(this.target());
          if (BattleManagerABS.canUseSkillByAmmo(skill)) {
            if (skill.isVectorType()) {
              if (!this.isMoving()) {
                this.turnTowardCharacter(this.target());
                BattleProcessABS.startPostBattleAction(this, this.target(), this.battler().action(0), skill);
              } else {
                return;
              }
            } else
              BattleProcessABS.performBattleAction(this, this.target());

            t.performCurrentAction();
            skill.playStartSound(null);
            this.aaPerformAttackAnimation();
            this.refreshBattleState();
            AlphaABS.BattleUI.refreshFirearmPanel();
          } else {
            if (skill.isFirearm()) {
              this.battler().reloadFirearm();
              AlphaABS.BattleUI.refreshFirearmPanel();
            }
            LOG.p("PL : Skill need ammo!");
            BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOCHARGES);
          }
        }
      }
    } else {
      LOG.p("PL : Can't use auto attack");
      BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOAUTOA);
      this._absParams.autoAttackMode = false;
    }
  };

  Game_Player.prototype._update_input = function () {
    if (!AlphaABS.isABS()) return;
    if(Input.isGamepad()) {
      this._update_gamepadInput();
    } else
      this._update_keyboardInput();
  };

  Game_Player.prototype._update_on_prepare = function () {
    var t = this._absParams.currentAction;
    if (t) {
      LOG.p("PL : Prepare action " + t.skill().name);
      if (t.cEonStart != 0) {
        LOG.p("PL : Common Event " + t.cEonStart);
        this.startCommonEventABS(t.cEonStart);
      }
      if (BattleManagerABS.canUseSkilllBySpecialState(this, t) && this.battler().canUse(t.skill())) {
        if (BattleManagerABS.canUseSkillByAmmo(t)) {
          if (t.isRadiusType()) {
            LOG.p("PL : Radius type ");
            if (BattleManagerABS.canUseSkillByTimer(t)) {
              if (t.isNeedTarget() || t.isSpecialTeleportType()) {
                this._changeState('targetCircle');
                return;
              } else
                this._changeState('action');
              return;
            } else {
              LOG.p("PL : Can't use, recharge now");
              BattleManagerABS.alertOnUIbySym('recharge');
            }
          } else {
            if (t.isVectorTypeR()) {
              if (BattleManagerABS.canUseSkillByTimer(t)) {
                this._changeState('targetCircle');
                return;
              } else {
                LOG.p("PL : Can't use, recharge now");
                BattleManagerABS.alertOnUIbySym('recharge');
              }
            } else {
              this._prepareNormal();
              return;
            }
          }
        } else {
          BattleManagerABS.alertOnUIbySym('noAmmo');
        }
      } else {
        LOG.p("PL : Can't use, not resources or restricted!");
        BattleManagerABS.alertOnUIbySym('noUse');
      }
    } else {
      LOG.p("PL : Can't use, NULL");
    }

    this._changeState('free');
  };

  Game_Player.prototype._prepareNormal = function () {
    var t = this._absParams.currentAction;
    if(!BattleManagerABS.canUseSkilllBySpecialState(this, t)) {
      this._changeState('free');
      return;
    }
    if (BattleManagerABS.canUseSkillByTimer(t)) {
      if (t.isNeedTarget()) {
        if(t.isNoTarget()) {
          this._changeState('action');
          return;
        } else {
          if (this.target()) {
            if(this.target().isEnemy()) {
              if(t.isForAlly()) {
                // * Если на союзника, а цель враг, то на себя
                if (!t.isVectorType()) {
                  this._changeState('action');
                  return;
                }
                else {
                  LOG.p("PL : Can't use, need target");
                  BattleManagerABS.alertOnUIbySym('noTarget');
                }
              } else {
                if (BattleManagerABS.canUseSkillByRange(this, this.target(), t)) {
                  this._changeState('action');
                  return;
                } else {
                  LOG.p("PL : Can't use, target too far");
                  BattleManagerABS.alertOnUIbySym('toFar');
                }
              }
            } else {
              if(t.isForAlly()) {
                if (BattleManagerABS.canUseSkillByRange(this, this.target(), t)) {
                  this._changeState('action');
                  return;
                } else {
                  LOG.p("PL : Can't use, target too far");
                  BattleManagerABS.alertOnUIbySym('toFar');
                }
              } else {
                LOG.p("PL : Can't use, need target");
                BattleManagerABS.alertOnUIbySym('noTarget');
              }
            }
          } else {
            // * Если нет цели, но навык для союзника, то на себя
            if(!t.isVectorType() && t.isForAlly()) {
              this._changeState('action');
              return;
            } else {
              LOG.p("PL : Can't use, need target");
              BattleManagerABS.alertOnUIbySym('noTarget');
            }
          }
        }
      } else {
        this._changeState('action');
        return;
      }
    } else {
      LOG.p("PL : Can't use, recharge now");
      BattleManagerABS.alertOnUIbySym('recharge');
    }
    this._changeState('free');
  };

  Game_Player.prototype._update_on_action = function () {
    var t = this._absParams.currentAction;
    if (t) {
      if (t.isNeedCast()) {
        if (t.isCasting()) {
          if (t.isReady()) {
            this._cancelCastMotion();
            this._performAction();
            this._absParams.casting = false;
          }
        } else {
          if (!this.isMoving()) {
            LOG.p("PL : Start cast!");
            this._absParams.casting = true;
            this._absParams.castingError = false;
            this.executeMove(0);
            t.startCast(this.battler());
            this._absParams.castingSkill = t;
            this._changeState('cast');
          } else {
            LOG.p("PL : Can't start cast, i'am moving!");
            BattleManagerABS.alertOnUI(Consts.STRING_ALERT_CASTMOVE);
            this._changeState('free');
          }
        }
      } else {
        this._performAction();
      }
    } else {
      this._changeState('free');
    }
  };

  Game_Player.prototype._update_on_cast = function () {
    var t = this._absParams.currentAction;
    if (this.target() && !t.isNoTarget())
      this.turnTowardCharacter(this.target());
    else {
      if (t) {
        if (!t.isZoneType() && !t.isNoTarget()) {
          var point = new KDCore.Point(TouchInput.x, TouchInput.y);
          if($gameTemp._targetCircleLockedPosition) {
            point = $gameTemp._targetCircleLockedPosition;
          }
          if (Input.isGamepad()) {
            point = AAGamePadManager.GetTargetCirclePositionByGamepad();
          }
          this.turnTowardCharacter(point.convertToMap());
        }
      }
    }
    if (t && t.isCasting()) {
      if (this.battler().isNeedAACastStop()) {
        this.interruptCast();
        this.battler().onAACastStop();
        return;
      }
      if (t.isRadiusType()) {
        if (this.battler().canUse(t.skill())) {
          if (t.isReady()) {
            LOG.p("PL : Cast END");
            this._changeState('action');
          }
        } else {
          this.interruptCast();
          LOG.p("PL : Can't cast, not resources or restricted!");
          BattleManagerABS.alertOnUIbySym('noUse');
        }
      } else {
        if (t.isNeedTarget() && !t.isNoTarget() && !BattleManagerABS.canUseSkillByRange(this, this.target(), t)) {
          this.interruptCast();
          LOG.p("PL : Target too far");
          BattleManagerABS.alertOnUIbySym('toFar');
        } else {
          if (this.battler().canUse(t.skill())) {
            if (t.isReady()) {
              LOG.p("PL : Cast END");
              this._changeState('action');
            }
          } else {
            this.interruptCast();
            LOG.p("PL : Can't cast, not resources or restricted!");
            BattleManagerABS.alertOnUIbySym('noUse');
          }
        }
      }
    } else {
      this._absParams.casting = false;
      this._changeState('free');
    }
  };

  Game_Player.prototype._checkInBattleStatus = function () {
    var t = BattleManagerABS.whoTargetOnMe(this, $gameTroop.membersABS());
    if (t) { //Если игрок чья-то цель (врага)
      return true;
    }
    if (BattleProcessABS.isPostProcessExists()) {
      return true; //Если есть действия PostProcess
    }
    return false;
  };

  Game_Player.prototype._turnAutoAttack = function () {
    if (this.target() && this.target().isEnemy()) {
      this._onNewSkillActivate();
      this.turnTowardCharacter(this.target());
      this._absParams.currentAction = this.battler().skillABS_attack();
      this._absParams.autoAttackMode = true;
      var t = this.battler();
      t.makeActions();
      t.action(0).setAttack();
      return true;
    }
    return false;
  };

  Game_Player.prototype._update_attackReload = function () {
    var t = this.battler().skillABS_attack();
    this._absParams.isWeapRecharge = !t.isReady();
  };

  Game_Player.prototype._stopTargetSelect = function () {
    $gameMap.stopPlayerTargetCircle();
  };

  //OVER
  Game_Player.prototype.jump = function (xPlus, yPlus) {
    Game_Character.prototype.jump.call(this, xPlus, yPlus);
  };

  //?[NEW]
  Game_Player.prototype.startCommonEventABS = function (commonEventId) {
    if ((typeof commonEventId !== "undefined" && commonEventId !== null) > 0) {
      if ($dataCommonEvents[commonEventId] != null) {
        $gameTemp.reserveCommonEvent(commonEventId);
      }
    }
  };

  //?[NEW]
  Game_Player.prototype.isNoTargetAttackMode = function () {
    var b = this.battler();
    if (b == null) return false;
    var absSkill = b.skillABS_attack();
    return absSkill.isNoTarget();
  };

  //?[NEW]
  Game_Player.prototype.onMouseAttackOnTarget = function () {
      if(this.target() == null) return;
      this._onMouseAttackOnTarget();
  }; 

  //END Game_Player
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__canMove, ALIAS__moveStraight, ALIAS__refresh, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //?[ANIMAX_E]
  // * Система анимации XAnima
  // -----------------------------------------------------------------------
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    this.aaRefreshAnimaX();
  };
  
  //@[ALIAS]
  ALIAS__canMove = _.canMove;
  _.canMove = function() {
    if (this.isAnimXIsBusy()) {
      // * Дополнительная проверка анимации, т.к. Game_Player перекрывает метод canMove из Character_Base
      return false;
    }
    return ALIAS__canMove.call(this);
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function(sceneActive) {
    ALIAS__update.call(this, sceneActive);
    if (sceneActive && this.isABS()) {
      this._aaUpdateNoPassFlag();
    }
    if (this.isAnimX()) {
      this._updateAnimX();
    }
  };
  //@[ALIAS]
  ALIAS__moveStraight = _.moveStraight;
  _.moveStraight = function(dir) {
    ALIAS__moveStraight.call(this, dir);
    if ($gameTemp.aaIsScrollBeenApplied === true) {
      if (AA.Parameters.xMapScrollSettings().resetOnMove === true) {
        // * Восстановить камеру
        uAPI.resetCamera();
      }
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Проверка что клетки рядом с игроком свободны
  // * Используется для умного просчёта движения к игроку АИ
  // * Чтобы не пытались искать путь, если всё занято вокруг игрока
  _.aaInitNoPassFlagThread = function() {
    this.__aaNoPassFlag = null;
    this.__aaNoPassFlagThread = new KDCore.TimedUpdate(30, this.aaRefreshNoPassFlag.bind(this));
  };
  _._aaUpdateNoPassFlag = function() {
    return this.__aaNoPassFlagThread.update();
  };
  _.aaRefreshNoPassFlag = function() {
    return this.__aaNoPassFlag = null;
  };
  _.aaIsSurrounded = function() {
    var noPass;
    if (this.__aaNoPassFlag == null) {
      noPass = 0;
      if (!this.canPass(this.x, this.y, 2)) {
        noPass += 1;
      }
      if (!this.canPass(this.x, this.y, 4)) {
        noPass += 1;
      }
      if (!this.canPass(this.x, this.y, 6)) {
        noPass += 1;
      }
      if (noPass < 3) {
        if (!this.canPass(this.x, this.y, 8)) {
          noPass += 1;
        }
      }
      this.__aaNoPassFlag = noPass;
    }
    return this.__aaNoPassFlag > 2;
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_PlayerABSInput.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var KEY, _;
  
  //@[DEFINES]
  _ = Game_Player.prototype;
  KEY = AlphaABS.LIBS.IKey;
  _._update_keyboardInput = function() {
    this._update_keyboardCircleMenus();
    if (this._absParams.inputMode === 0) {
      this._update_keyboadModeZero();
      this._update_input_ShieldExt(); // ?{OUTER}
      return this._update_player_rotation();
    } else if (this._absParams.inputMode === 1) {
      return this._update_keyboadModeOne();
    } else if (this._absParams.inputMode === 2) {
      return this._update_keyboadModeTwo();
    }
  };
  _._update_keyboardCircleMenus = function() {
    if (!$gameMap.isABS()) {
      return;
    }
    if (Input.isTriggered(KEY.WC())) {
      this.touchControlAt(4);
    }
    if (Input.isTriggered(KEY.SM())) {
      return this.touchControlAt(6);
    }
  };
  _._update_keyboadModeZero = function() {
    var skillIndex;
    skillIndex = KEY.isTriggeredSkillPanelIndex();
    if (skillIndex != null) {
      if (AA.UI.isInventoryOpened()) {
        if (AA.UI.onInvHotKeyActive(skillIndex)) {
          return;
        }
      }
      if (AA.UI.isSkillWindowIsOpen()) {
        if (AA.UI.onSkillHotKeyActive(skillIndex)) {
          return;
        }
      }
      this.touchSkillAt(skillIndex);
    }
    if (AA.UI.isInventoryOpened()) {
      if (AA.UI.IsInventoryWeaponFEKeyTriggered()) {
        return;
      }
    }
    if (Input.isTriggered(KEY.CP_W())) {
      this.touchControlAt(1);
    }
    if (Input.isTriggered(KEY.CP_A())) {
      this.touchControlAt(0);
    }
    if (Input.isTriggered(KEY.CP_D())) {
      this.touchControlAt(3);
    }
    if (Input.isTriggered(KEY.CP_S())) {
      this.touchControlAt(2);
    }
    if (Input.isTriggered(KEY.TS())) {
      this.setNextTarget();
    }
    if (Input.isTriggered(KEY.TN())) {
      this.setNearestTarget();
    }
    if (Input.isTriggered(KEY.WR())) {
      this.reloadFirearm();
    }
    if (Input.isTriggered(KEY.INV())) {
      this.onInventoryKey();
    }
    if (Input.isTriggered(KEY.SKLW())) {
      this.onSkillWindowKey();
    }
    if (Input.isTriggered(KEY.STAW())) {
      return this.onStatusWindowKey();
    }
  };
  _._update_player_rotation = function() {
    if (Input.isPressed(KEY.AR())) {
      if (this.canMove() && !this._absParams.targetFollowMode) {
        if (!Utils.isMobileDevice()) {
          return this.turnTowardCharacter(TouchInput.getMousePosition().convertToMap());
        }
      }
    }
  };
  _._update_keyboadModeOne = function() {
    var index;
    index = KEY.isTriggeredWeapCircleIndex();
    if (index != null) {
      return this.touchWeaponAt(index);
    }
  };
  _._update_keyboadModeTwo = function() {
    var index;
    index = KEY.isTriggeredWeapCircleIndex();
    if (AA.UI.isSummonCircleOpen()) {
      if (index != null) {
        return this._touchSummonCommandAt(index);
      }
    } else if (AA.UI.isAllyBehCircleOpen()) {
      if (index != null) {
        return this._touchAllyBehCommandAt(index);
      }
    }
  };
})();

// ■ END Game_PlayerABSInput.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_PlayerABSLogic.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _._performCastMotion = function() {
    var a, data;
    a = this._absParams.currentAction;
    if (a.isHasCastMotion()) {
      //"START CAST MOTION".p()
      this._absParams._inCastMotion = true;
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Cast);
      data.setFrames(a.castMotionFrames);
      data.setActionDelay(a.motionDelay);
      data.setLooping();
      data.setMotion(a.castMotion, a.castMotionOffset, this);
      return this.battler().performAAnimAction(data);
    } else {
      return this._absParams._inCastMotion = false;
    }
  };
  _._cancelCastMotion = function() {
    var motion;
    if (this._absParams._inCastMotion === false) {
      return;
    }
    //"CLEAR CAST MOTION".p()
    motion = this.getAAnimMotion();
    if (motion != null) {
      motion.clear(this);
    }
    this.battler().clearAAnimMotion();
    return this._absParams._inCastMotion = false;
  };
  _._performSkillMotion = function() {
    var a, data, name;
    a = this._absParams.currentAction;
    if (this.isAnimX()) {
      name = "Skill";
      if (a.isHasAnimaXAction()) {
        name = a.animaXAction;
      }
      this.aaPerformBattleActionAnimation(name);
      return;
    }
    if (a.isHasMotionX()) {
      //"START SKILL MOTION".p()
      this._cancelCastMotion();
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Skill);
      data.setFrames(a.motionFrames);
      data.setActionDelay(a.motionADelay);
      data.setMotion(a.motionX, a.motionOffset, this);
      return this.battler().performAAnimAction(data);
    }
  };
  _._update_on_targetCircle = function() {
    var action, point;
    action = this._absParams.currentAction;
    if (action != null) {
      if (this.battler().canUse(action.skill())) {
        if (Input.isGamepad()) {
          if (Input.isTriggered(AAGamePadManager.ActionKey())) {
            point = AAGamePadManager.GetTargetCirclePositionByGamepad().convertToMap();
            this._startTargetCircleAction(point);
            return;
          }
          if (Input.isTriggered(AAGamePadManager.MenuKey())) {
            return this._changeState('free');
          }
        } else {
          if (TouchInput.isTriggered()) {
            if ($gameTemp._targetCircleLockedPosition != null) {
              point = $gameTemp._targetCircleLockedPosition.convertToMap();
            } else {
              point = TouchInput.getMousePosition().convertToMap();
            }
            this._startTargetCircleAction(point);
            return;
          }
          if (TouchInput.isCancelled()) {
            return this._changeState('free');
          }
        }
      } else {
        AA.log("PL : Can't use, not resources or restricted!");
        BattleManagerABS.alertOnUIbySym('noUse');
        return this._changeState('free');
      }
    } else {
      AA.log("PL : Can't use, NULL");
      return this._changeState('free');
    }
  };
  _._startTargetCircleAction = function(point) {
    var action, dist, lineOfSight;
    action = this._absParams.currentAction;
    dist = AlphaABS.UTILS.distanceTo(this, point);
    lineOfSight = true;
    if (!action.isIgnoreObstacles()) {
      lineOfSight = BattleManagerABS.checkLineOfSight(this.toPoint(), point);
    }
    if (dist <= action.range && lineOfSight) {
      if (BattleManagerABS.canUseSkillByAmmo(action)) {
        this._changeState('action');
      } else {
        BattleManagerABS.alertOnUIbySym('noAmmo');
      }
    } else {
      AA.log("PL : Can't use, too far!");
      BattleManagerABS.alertOnUIbySym('toFar');
    }
  };
})();

// ■ END Game_PlayerABSLogic.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.initABSForAlly = function() {
    return this.followers().forEach(function(f) {
      return f.initABS();
    });
  };
  _.AABattler = function() {
    return this.battler();
  };
  _.isCanBehModeButtonBeVisible = function() {
    var ally, ref;
    if ($gameParty.isAnyCanChangeBehMode()) {
      ally = $gameParty.selectedAllyByPlayer();
      if ((ally != null) && ally.isCanChangeBehMode()) {
        return true;
      }
    }
    return ((ref = $gamePlayer.getSummonUnit()) != null ? ref.canChangeMode() : void 0) === true;
  };
  _.isCanUnsummonButtonBeVisible = function() {
    var ally, ref;
    if ($gameParty.isAnyCanChangeBehMode()) {
      ally = $gameParty.selectedAllyByPlayer();
      if ((ally != null) && ally.isCanChangeBehMode()) {
        return false;
      }
    }
    return ((ref = $gamePlayer.getSummonUnit()) != null ? ref.canChangeMode() : void 0) === false;
  };
  _._touchAllyBehCommandAt = function(index) {
    var ally, e;
    try {
      ally = $gamePlayer.target();
      if ((ally != null) && !ally.isEnemy()) {
        ally.AAEntity().setBehMode(index - 1);
      }
      AA.BattleUI.touchOnSummonCircle(index);
    } catch (error) {
      e = error;
      AA.warning(e);
    }
    this.changeInputMode(0);
    return AA.BattleUI.refreshSummonCircle();
  };
  _.showBehCircle = function() {
    return $gamePlayer.touchControlAt(6);
  };
  _._resetCircleInputMode = function() {
    return this._absParams.inputMode = 0;
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__realMoveSpeed, ALIAS__refresh, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.isInventoryAllowed = function() {
    return AA.Parameters.get_MapInventoryAllowed() && (this._absInvOffByUAPI == null);
  };
  _.isSkillWindowAllowed = function() {
    return AA.Parameters.get_MapSkillWindowAllowed() && (this._absSWinOffByUAPI == null);
  };
  _.isStatusWindowAllowed = function() {
    return AA.Parameters.isMapStatusWindow();
  };
  //TODO: поменять skills hot key (onInvHotKeyActive)
  _.onInventoryKey = function() {
    if (!this.isInventoryAllowed()) {
      return;
    }
    return AA.UI.openOrCloseInventory();
  };
  _.onSkillWindowKey = function() {
    if (!this.isSkillWindowAllowed()) {
      return;
    }
    return AA.UI.openOrCloseSkillWindow();
  };
  _.onStatusWindowKey = function() {
    if (!this.isStatusWindowAllowed()) {
      return;
    }
    return AA.UI.openOrCloseStatusWindow();
  };
  _.startABSItemFromInventory = function(item, target) {
    var b, skill;
    if (!this.canControl()) {
      return;
    }
    this.setTarget(target);
    b = this.battler();
    skill = b._absParams.battleSkillsABS.itemById(item.id);
    if (skill == null) {
      b._absParams.battleSkillsABS.push(item.id, true);
      skill = b._absParams.battleSkillsABS.itemById(item.id);
    }
    if ((skill != null) && !skill.hasError()) {
      this.executeABSSkill(skill);
    }
  };
  _.startABSSkillFromInventory = function(item) {
    var b, skill;
    if (!this.canControl()) {
      return;
    }
    b = this.battler();
    skill = b._absParams.battleSkillsABS.skillById(item.id);
    if (skill == null) {
      b._absParams.battleSkillsABS.push(item.id, true);
      skill = b._absParams.battleSkillsABS.skillById(item.id);
    }
    if ((skill != null) && !skill.hasError()) {
      this.executeABSSkill(skill);
    }
  };
  _.getPlayerStaticWeight = function() {
    if (this._staticPSW == null) {
      this._staticPSW = 0;
    }
    return this._staticPSW;
  };
  _.modifyPlayerStaticWeight = function(value) {
    this.getPlayerStaticWeight();
    this._staticPSW += value;
  };
  _.refreshInventoryWSpeedDebuff = function() {
    this._miwsdb = 0;
    if (!AA.isPro()) {
      return;
    }
    if (uAPI.isOverWeight) {
      return this._miwsdb = 1;
    }
  };
  //@[ALIAS]
  ALIAS__realMoveSpeed = _.realMoveSpeed;
  _.invRealMoveSpeed = function() {
    var speed;
    speed = ALIAS__realMoveSpeed.call(this);
    speed -= this._miwsdb;
    return speed;
  };
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    return this.refreshInventoryWSpeedDebuff();
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var BattleUI, _;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]

  //@[DEFINES]
  _ = Game_Player.prototype;
  BattleUI = AlphaABS.BattleUI;
  _._onAttackClick = function() {
    var ref, ref1;
    if ((ref = BattleUI.getUI()) != null) {
      if ((ref1 = ref.userWeaponIconController) != null) {
        ref1.pulse(); //TODO: TEMP before 13
      }
    }
    this._removeAAShieldState();
    if (this._absParams.autoAttackMode) {
      this.turnTowardCharacter(this.target());
      return;
    }
    if (this.isNoTargetAttackMode() === true) {
      return this._onNoTargetAttackClick();
    } else {
      return this._onAutoAttackClick();
    }
  };
  _._onNoTargetAttackClick = function() {
    BattleUI.touchOnControlPanel(0);
    return this._performNoTargetAction();
  };
  _._performNoTargetAction = function() {
    var absSkill, e, proc, target, targets;
    try {
      if (!this._checkNoTargetAction()) {
        return;
      }
      this._prepareNoTargetAction();
      absSkill = this.battler().skillABS_attack();
      if (absSkill.isVectorType()) {
        this._absParams.currentAction = absSkill;
        target = this._findEndPointForVectorSkill();
        proc = AlphaABS.BattleManagerABS.battleProcess();
        proc.startPostBattleAction(this, target, this.battler().action(0), absSkill);
        this._completeNoTargetAction([]);
      } else {
        targets = this._findTargetForNoTargetAction($gameTroop.onlyHostileMembersABS());
        this._completeNoTargetAction(targets);
      }
    } catch (error) {
      e = error;
      return AlphaABS.error(e, 'while perfrom attack');
    }
  };
  _._checkNoTargetAction = function() {
    var absSkill;
    absSkill = this.battler().skillABS_attack();
    if (absSkill.isFirearm() && absSkill.isNeedReloadStack()) {
      this.battler().reloadFirearm();
      return false;
    }
    if (!absSkill.isReady()) {
      return false;
    }
    if (this._absParams.state !== 'free') {
      return false;
    }
    if (!AlphaABS.BattleManagerABS.canUseABSSkillNow(this, null, absSkill)) {
      return false;
    }
    return true;
  };
  _._prepareNoTargetAction = function() {
    var b;
    b = this.battler();
    b.makeActions();
    return b.action(0).setAttack();
  };
  //TODO:  Поиск целей вынести в отдельный класс
  _._findTargetForNoTargetAction = function(members) {
    var absSkill, finalTargets, nearest, targets;
    finalTargets = [];
    absSkill = this.battler().skillABS_attack();
    if (absSkill.isSimpleNoTarget()) {
      if (absSkill.range === 1) {
        finalTargets = this._findTargetsForSimpleNoTargetWeapon(members);
      } else {
        targets = this._findTargetsForPierceNoTargetWeapon(members);
        if (targets.length <= 1) {
          finalTargets = targets;
        } else {
          nearest = this._findNearestTarget(targets);
          if (nearest != null) {
            finalTargets = [nearest];
          }
        }
      }
    } else if (absSkill.isPierce()) {
      finalTargets = this._findTargetsForPierceNoTargetWeapon(members);
      if (absSkill.pierce > 1) { // * Ограниченное количество пробиваний
        finalTargets = finalTargets.slice(0, absSkill.pierce);
      }
    } else if (absSkill.isSwing()) {
      finalTargets = this._findTargetsForSwingNoTargetWeapon(members);
    }
    return finalTargets;
  };
  _._findTargetsForSimpleNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inFront($gamePlayer, member)) {
          return targets[0] = member;
        }
      });
    }
    return targets;
  };
  _._findTargetsForPierceNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inDirectionHard($gamePlayer, member)) {
          return targets.push(member);
        }
      });
    }
    return targets;
  };
  _._findTargetsForSwingNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 2, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inFront($gamePlayer, member)) {
          targets.push(member);
        }
        if (AlphaABS.UTILS.isFrontNeighbor($gamePlayer, member)) {
          return targets.push(member);
        }
      });
    }
    return targets;
  };
  _._findNearestTarget = function(members) {
    var dist, nearest;
    if (members.length === 0) {
      return null;
    }
    nearest = members.first();
    dist = AlphaABS.UTILS.distanceTo($gamePlayer, nearest);
    members.forEach(function(member) {
      var newDist;
      if (member == null) {
        return;
      }
      if (!member.isAlive()) {
        return;
      }
      if (!member.inActive()) {
        return;
      }
      newDist = AlphaABS.UTILS.distanceTo($gamePlayer, member);
      if (newDist < dist) {
        dist = newDist;
        return nearest = member;
      }
    });
    return nearest;
  };
  _._completeNoTargetAction = function(targets) {
    var b, bProcess, i, j, ref;
    b = this.battler();
    bProcess = AlphaABS.LIBS.BattleManagerABS.battleProcess();
    if (targets.length > 0) {
      for (i = j = 0, ref = targets.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        bProcess.performBattleAction(this, targets[i]);
      }
    }
    b.performCurrentAction();
    this.aaPerformAttackAnimation();
    BattleUI.refreshWeaponCircleIfOpen();
    b.skillABS_attack().playStartSound(null);
    if (!this.inBattle()) {
      this.onBattleStart();
    }
    if ((targets != null) && targets.length > 0) {
      if (targets[0] !== this.target()) {
        AlphaABS.BattleManagerABS.setPlayerTarget(targets[0]);
      }
    }
  };
  _._onAutoAttackClick = function() {
    if (this._turnAutoAttack()) {
      BattleUI.touchOnControlPanel(0);
      BattleUI.selectOnControlPanel(0);
    } else {
      BattleUI.diselectOnControlPanel(0);
      if (this.target() == null) {
        BattleUI.disableOnControlPanel(0);
      }
    }
  };
  _._onMouseAttackOnTarget = function() {
    var absSkill, inRadius, t;
    if (!this._checkNoTargetAction()) {
      return;
    }
    if (!this.target().isEnemy()) {
      return;
    }
    t = this.target();
    this.turnTowardCharacter(t);
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, [t]);
    if (inRadius.length > 0) {
      this._performNoTargetAction();
      if (t !== this.target()) {
        AlphaABS.BattleManagerABS.setPlayerTarget(t);
      }
    }
  };
  // * Если вернёт false, игрок пойдёт к точке карты, заместо атаки
  _._isRangeToTargetGood = function() {
    var absSkill, d;
    if (this.battler() == null) {
      return false;
    }
    absSkill = this.battler().skillABS_attack();
    if (absSkill.isFreeDirection()) {
      // * freeDirection always in good range
      return true;
    }
    if (this.target() == null) {
      return true;
    }
    d = AlphaABS.UTILS.distanceTo(this, this.target());
    if (absSkill.isNoTarget()) {
      d *= 0.1;
    }
    if (absSkill.range >= d) {
      if (absSkill.isDirectionFix()) {
        return AlphaABS.UTILS.inDirectionHard(this, this.target());
      } else {
        return true;
      }
    }
    return false;
  };
  //TODO: Пока это всё в предварительном варианте, так что будут отдельные функции для поиска и определения целей для ABS:1
  _._findEndPointForVectorSkill = function() {
    var absSkill, cursor;
    absSkill = this._absParams.currentAction;
    if (absSkill.isFreeDirection()) {
      cursor = TouchInput.toPoint().convertToMap();
      return AlphaABS.UTILS.getEndPointFromChartToRangeNoFixed(this, absSkill.range, cursor);
    } else {
      return AlphaABS.UTILS.getEndPointFromCharToRange(this, absSkill.range);
    }
  };
  _.level = function() {
    if (AA.isABS() && (this.battler() != null)) {
      return this.battler().level;
    }
    return 0;
  };
})();

// ■ END Game_Player_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_UPDATE_INPUT, _;
  
  //@[DEFINES]
  _ = Game_Player.prototype;
  ALIAS_UPDATE_INPUT = _._update_input;
  _._update_input = function() {
    ALIAS_UPDATE_INPUT.call(this);
    if (this.__lastGPState == null) {
      this.__lastGPState = Input.isGamepad();
      return;
    }
    if (this.__lastGPState !== Input.isGamepad()) {
      this._onGamePadStateChange();
      return this.__lastGPState = Input.isGamepad();
    }
  };
  _._onGamePadStateChange = function() {
    LOGW.p('Input device changed');
    if (Input.isGamepad()) {
      this.onGamePadConnected();
    }
    return AA.BattleUI.reCreateUI();
  };
})();

// ■ END Game_Player_PRO.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_Shields_Ext.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[EXTENSION]

  //@[DEFINES]
  _ = Game_Player.prototype;
  _._update_input_ShieldExt = function() {
    if (Input.isTriggered(AA.LIBS.IKey.BL())) {
      return this.touchControlAt(5);
    }
  };
  _._changeAAShieldState = function() {
    if (this._inAAShieldState === true) {
      this._removeAAShieldState();
    } else {
      this._addAAShieldState();
    }
    return this._refreshGamePadCommands();
  };
  _._removeAAShieldState = function() {
    if (this._inAAShieldState === false) {
      return;
    }
    this.battler()._removeAAShieldState();
    this._inAAShieldState = false;
    this.refreshABSMotion();
    this._refreshGamePadCommands();
    if (this.isAnimX()) {
      if (!this.isInMovementAnimaX()) {
        return this.resetXAnima();
      }
    }
  };
  _._removeAAShieldStateWithTimer = function() {
    this._removeAAShieldState();
    return this.battler()._destroyShieldRestTimer();
  };
  _._addAAShieldState = function() {
    if (!this.isCanApplyShieldNow()) {
      return;
    }
    if (this.battler()._addAAShieldState()) {
      this._refreshGamePadCommands();
      this._inAAShieldState = true;
      this.refreshABSMotion();
      if (this.isAnimX()) {
        return this.startAnimaXAA_Defense();
      }
    }
  };
  _._isHasAShieldMotion = function() {
    return this._inAAShieldState === true && (this.battler()._playerAAShieldMotion != null);
  };
  _.isInAAShieldState = function() {
    return this._inAAShieldState === true;
  };
  _.isCanApplyShieldState = function() {
    var ref;
    return ((ref = this.battler()) != null ? ref.__canApplyShieldState : void 0) === true;
  };
  _.isCanApplyShieldNow = function() {
    return this.isCanApplyShieldState() && (this.battler()._shieldRestTimer == null) && this._absParams.casting === false && !this._absParams.autoAttackMode;
  };
})();

// ■ END Game_Player_Shields_Ext.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_SummonExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[EXTENSION]

  //@[DEFINES]
  _ = Game_Player.prototype;
  _.getSummonUnit = function() {
    if (this.battler() != null) {
      return this.battler()._mySummonUnit;
    } else {
      return null;
    }
  };
  _._showSummonUnitMenu = function() {
    if (!$gameParty.isAnyCanChangeBehMode()) {
      if (this.getSummonUnit() == null) {
        return;
      }
      if (this.getSummonUnit().canChangeMode() === false) {
        return;
      }
    }
    AA.BattleUI.refreshSummonCircle();
    if (this._absParams.inputMode === 1) {
      this.changeInputMode(0); // * CLOSE CIRCLE
    }
    if (this._absParams.inputMode === 2) {
      return this.changeInputMode(0);
    } else {
      return this.changeInputMode(2);
    }
  };
  _._touchSummonCommandAt = function(index) {
    if (this.getSummonUnit() == null) {
      return;
    }
    if (this._absParams.inputMode !== 2) {
      return;
    }
    AA.BattleUI.touchOnSummonCircle(index);
    if (index !== 0) {
      this._changeSummonUnitMode(index - 1);
    } else {
      this.deleteSummonUnit();
    }
    this.changeInputMode(0);
    return AA.BattleUI.refreshSummonCircle();
  };
  _._changeSummonUnitMode = function(modeIndex) {
    return this.getSummonUnit().changeBehMode(modeIndex);
  };
  _.deleteSummonUnit = function() {
    var ref;
    if (AA.Parameters.get_IsKeepSummonUnit() && $gamePlayer.isTransferring()) {
      if (this.getSummonUnit() != null) {
        $gameTemp.saveSummonUnit();
      }
    }
    return (ref = this.battler()) != null ? ref._deleteSummonState() : void 0;
  };
  _._changeInputModeToSummon = function() {
    if (!AA.BattleUI.isBehCircleOpen()) {
      return AA.BattleUI.openSummonCircle();
    }
  };
  _._resetSummonUnit = function() {
    if (Input.isGamepad()) {
      if (this._absParams._GPCommandIndex >= 3) {
        this._absParams._GPCommandIndex = 0;
      }
      this._refreshGamePadCommands();
    }
    if (this._absParams.inputMode === 2) {
      return this.changeInputMode(0);
    }
  };
})();

// ■ END Game_Player_SummonExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //?[ANIMAX_E]
  // * Система анимации XAnima и ABS
  // -----------------------------------------------------------------------
  //?X
  _.getCurrentAnimaXProfile = function() {
    var equipAnimaXSet;
    if (this.isAnimX()) {
      equipAnimaXSet = this._getEquipmentAnimaXSet();
      if (String.any(equipAnimaXSet)) {
        return equipAnimaXSet;
      }
    }
    return this.getInitialXProfile();
  };
  //?X
  _.getInitialXProfile = function() {
    if (String.any($gameSystem.lastPlayerAnimaXExternProfile)) {
      return $gameSystem.lastPlayerAnimaXExternProfile;
    } else {
      return KDCore.Utils.getValueFromMeta('xAnima', $gameParty.leader().actor());
    }
  };
  //?X
  _.isAnimaXAADefaultAction = function(actionName) {
    return ['Attack', 'Defense', 'Skill'].contains(actionName);
  };
  //?X
  _.getBattlerForAnimaX = function() {
    return $gameParty.leader();
  };
  //?UPD 1236
  _.setExternalAnimaX = function(name) {
    $gameSystem.lastPlayerAnimaXExternProfile = name;
    return this.refresh();
  };
  _.isDashingForAnimaX = function() {
    return this.isDashing();
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player2.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

(function () {
    //?{params : mapId, enemyId, x, y, isLooted}
    Game_Player.prototype.setNewABSMapData = function (params) {
        try {
            var candidate = this.getABSMapData(params.mapId, params.enemyId);
            if (candidate != null) {
                this._absParams.absMapData.delete(candidate);
            }
            this._absParams.absMapData.push(params);
        } catch (error) {
            console.error(error);
        }
    };

    Game_Player.prototype.getABSMapData = function (mapId, enemyId) {
        var candidates = this._absParams.absMapData.filter(function (item) {
            return (item.mapId == mapId && item.enemyId == enemyId);
        });
        if (candidates.length > 0) {
            return candidates[0];
        }
        return null;
    };

    //?[NEW]
    Game_Player.prototype.inABSMotion = function () {
        if(this.isAnimX()) {
            return null;
        }
        if (this.ABSParams() == null)
            return false;
        return this.ABSParams().absMotion != null;
    };

    //?[NEW]
    Game_Player.prototype.inAAnimMotion = function () {
        if(this.isAnimX()) {
            return null;
        }
        if (this.battler() == null) return false;
        if (this.battler().isAAnimMotionRequested()) {
            return true;
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.getAAnimMotion = function () {
        if(this.isAnimX()) {
            return null;
        }
        if (!this.inAAnimMotion()) {
            return null;
        } else {
            return this.battler().ABSParams().animMotion;
        }
    };

    //?[NEW]
    Game_Player.prototype.getABSMotion = function() {
        if(this.isAnimX()) {
            return null;
        }
        if(!this.inABSMotion()) {
            return null;
        } else {
            return this.ABSParams().absMotion;
        }
    };

    //?[NEW]
    Game_Player.prototype._updateABSMotion = function () {
        if (this.battler() == null) return;
        if (this.battler().isNeedABSMotionRefresh()) {
            this.refreshABSMotion();
            this.battler().onABSMotionRefresh();
        }
        if (this.battler().isNeedABSMotionAction()) {
            this.battler().onABSMotionActionDone();
            var motion = this.ABSParams().absMotion;
            if(motion != null) {
                if (motion.isOldABSMotion()) {
                    motion.applyMotionAction();
                } else {
                    if(this.battler().isAAnimMotionRequested()) {
                        this.getAAnimMotion().clear(this);
                    }
                    $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                    this.battler().performAAnimAction(motion);
                }
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABSMotion = function () {
        this.clearABSMotion();
        if (this._isHasAShieldMotion()) {
            var motion = this.battler()._playerAAShieldMotion;
            this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
            this._absParams.absMotion.setType(AA.MotionType.Actor);
            this._absParams.absMotion.setDelay(9);
            this._absParams.absMotion.setFrames(3);
            this._absParams.absMotion.setMotion(motion, 0, this);
            this._absParams.absMotion.applyMotionIdle();
            return;
        }
        if (this.battler().isHasABSMotion()) {
            this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
            var skill = this.battler()._firstBattleABSSkill();
            this._absParams.absMotion.setMotion(skill.motion, skill.motionOffset, this);
            this.refreshABSMotionState(this.inBattle());
        } else {
            if (this.battler().isHasABSMotionX()) {
                this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
                var skill = this.battler()._firstBattleABSSkill();
                this._absParams.absMotion.setType(AA.MotionType.Weapon);
                this._absParams.absMotion.setDelay(skill.motionDelay);
                this._absParams.absMotion.setFrames(skill.motionFrames);
                this._absParams.absMotion.setActionDelay(skill.motionADelay);
                if(skill.motionWait > 0)
                    this._absParams.absMotion.setWait();
                this._absParams.absMotion.setMotion(skill.motionX, skill.motionOffset, this);
                this.refreshABSMotionState(this.inBattle());
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.clearABSMotion = function () {
        if (this._absParams.absMotion != null) {
            this._absParams.absMotion.clearMotion();
            this._absParams.absMotion = null;
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABSMotionState = function (toState) {
        if (this._absParams.absMotion != null) {
            if (this.inAAnimMotion()) {
                return;
            }
            if(this._isHasAShieldMotion()) {
                return;
            }
            if (toState == true) {
                this._absParams.absMotion.applyMotionState();
            } else {
                this._absParams.absMotion.applyMotionIdle();
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABS = function () {
        this.refreshABSMotion();
        this.refreshABSMotionState(this.inBattle());
    };

    //?[NEW]
    Game_Player.prototype.isAlive = function () {
        if(this.battler()) {
            return this.battler().isAlive();
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.isJumpAllowed = function () {
        return AlphaABS.Parameters.isJumpAllowed() && !this._absJumpOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.isFollowAllowed = function () {
        return AlphaABS.Parameters.isFollowAllowed();
    };

    //?[NEW]
    Game_Player.prototype.isRotateAllowed = function () {
        return AlphaABS.Parameters.isRotateAllowed() && !this._absRotateOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.isWeaponsAllowed = function () {
        return AlphaABS.Parameters.isWeaponsAllowed() && !this._absWeapOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.setNextTarget = function () {
        var t = AlphaABS.BattleManagerABS.nextPlayerTarget();
        if (t) AlphaABS.BattleManagerABS.setPlayerTarget(t);
    };

    //?[NEW]
    Game_Player.prototype.setNearestTarget = function () {
        var t = AlphaABS.BattleManagerABS.nextNearestPlayerTarget();
        if (t) AlphaABS.BattleManagerABS.setPlayerTarget(t);
    };

    //?[NEW]
    Game_Player.prototype.reloadFirearm = function () {
        this.battler().reloadFirearm();
    };

    //?[NEW]
    Game_Player.prototype.isFavWeapExists = function() {
        if(AlphaABS.isABS()) {
            return this.battler().isFavWeapExists();
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.isEnemy = function () {
        return false;
    };

    //@[ALIAS]
    var _alias_Game_Player_moveByInput = Game_Player.prototype.moveByInput;
    Game_Player.prototype.moveByInput = function () {
        if(this.battler() != null) {
            if(this.battler().canMove())
                _alias_Game_Player_moveByInput.call(this);
        } else
            _alias_Game_Player_moveByInput.call(this);    
    };



})();

// ■ END Game_Player.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_RageContainer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var RageContainer;
  RageContainer = class RageContainer {
    constructor() {
      this.clear();
    }

    clear() {
      this.rageDict = {};
      return this.targets = [];
    }

    addDealer(who) {
      if (who != null) {
        return this.makeDamageBy(0, who);
      }
    }

    makeDamageBy(damage, byWho) {
      var index;
      index = this.targets.indexOf(byWho);
      if (index >= 0) {
        return this.rageDict[index] += damage;
      } else {
        this.targets.push(byWho);
        return this.rageDict[this.targets.length - 1] = damage;
      }
    }

    getHigherDealer() {
      var arr, error, max1, max2;
      try {
        arr = this._getArrayOfDmg();
        if (arr.length > 1) {
          max1 = arr.max();
          max2 = arr.delete(max1).max();
          if (max1 > (max2 * 3)) {
            return this._getDealerByDmg(max1);
          }
        }
      } catch (error1) {
        error = error1;
        console.error(error);
      }
      return null;
    }

    _getArrayOfDmg() {
      return Object.keys(this.rageDict).map((function(v) {
        return this.rageDict[v];
      }).bind(this));
    }

    _getDealerByDmg(dmg) {
      var key, ref, value;
      ref = this.rageDict;
      for (key in ref) {
        value = ref[key];
        if (value === dmg) {
          return this.targets[key];
        }
      }
    }

    getDealerDamage(dealer) {
      var index;
      //console.info(@rageDict)
      index = this.targets.indexOf(dealer);
      if (index < 0) {
        return -1;
      }
      return this.rageDict[index];
    }

  };
  AlphaABS.register(RageContainer);
})();

// ■ END Game_RageContainer.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_@.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//@[GLOBAL DEFINITION]
function Game_SkillABS() {
  this.initialize.apply(this, arguments);
}

(function () {
  var Consts = AlphaABS.SYSTEM;
  var LOG = new KDCore.DevLog("Game_SkillABS");

  //@[CLASS HEADER PART]

  Game_SkillABS.prototype.initialize = function (skillId, isItem = false) {
    this.skillId = skillId;
    this._isItem = isItem;
    this.timer = new Game_TimerABS();
    this.timer.start(0);

    var metaCode = this.skill().meta.ABS;
    if (metaCode) {
      this.type = parseInt(metaCode);
    } else {
      this.type = 0;
      this._hasError = true;
      LOGW.p("Warning! ABS Skill has no type! " + this.skill().name);
    }

    AASkillLoader.loadABSData(this);

    this._checkParams();
    if(this.img != 0 && this.img != null && this.img != 'null') {
      try {
        ImageManager.loadPicture(this.img);
      } catch (error) {
        AlphaABS.error(error, ' load ABS skill <IMG> parameter');
      }
    }
  };

  // * Расчитать формулу можно только на Battler
  Game_SkillABS.prototype.getCastTime = function (caster) {
    if (this.castTimeFormula == null)
      return this.castTime;
    else {
      try {
        /* jshint -W061 */
        if (caster && caster instanceof Game_Battler) {
          var time = caster._calculateABSSkillReloadParam(this.castTimeFormula);
          return time;
        }
      } catch (error) {
        AlphaABS.error(error, ' info');
      }
      return 120;
    }
  };

  Game_SkillABS.prototype.update = function () {
    if(AA.UI.isGameShouldPause()) return;
    this.timer.update();
  };

  Game_SkillABS.prototype.preUse = function (param) {
    this.reloadTimeA = param + this.reloadTime;
  };

  Game_SkillABS.prototype.playStartSound = function (point) {
    this._playSoundAt(this.startSound, point);
  };

  Game_SkillABS.prototype.playReloadSound = function (point) {
    this._playSoundAt(this.reloadSound, point);
  };

  Game_SkillABS.prototype.startCast = function (caster) {
    this._castDelay = 0;
    this._startCast = true;
    this.timer.start(this.getCastTime(caster));
  };

  Game_SkillABS.prototype.onCastDelay = function (delay) {
    if(this.noCastingDelay > 0) {
      return;
    } else {
      this._castDelay += delay;
      this.timer.setMaxTime(this.getCastTime() + this._castDelay);
    }
  };

  Game_SkillABS.prototype.resetCast = function () {
    this._startCast = false;
    this.timer.start(0);
  };

  Game_SkillABS.prototype.loadExternal = function (externalItem, type) {
    if (type !== undefined) {
      this.type = type;
      var t = this.reloadParam;
      //ABSSkillLoader.loadBaseParams(this);
      AASkillLoader.collectBaseParams(this);
      this.reloadParam = t;
    }
    this.castTime = 0;
    AASkillLoader.collectFromJSON(this, externalItem);
    AASkillLoader.collectFromMetaData(this, externalItem);
    this._checkParams();
    if (this.castTime > 0 || this.castTimeFormula != null) {
      this.castTime = 0;
      this.castTimeFormula = null;
      LOGW.p(Consts.STRING_WARNING_SKILLWC);
    }
    if (this.isVectorTypeR()) {
      LOGW.p(Consts.STRING_WARNING_SKILLWVR);
      this.radius = 0;
      this.needTarget = true;
    }
    //LOG.p("Skill " + this.name() + " loaded external params");
  };

  Game_SkillABS.prototype.chargeStack = function (size) {
    if (size === undefined) {
      this._currentStack = this.stack;
      return 0;
    } else {

      if (this._currentStack === undefined) {
        this._currentStack = 0;
      }

      var d = 0;

      if (size > 0) {
        var n = Math.abs(this._currentStack - this.stack);
        d = size - n;
        if (d < 0) {
          this._currentStack = this.stack - Math.abs(d);
        } else {
          this._currentStack = this.stack;
          return d;
        }
      } else {
        this._currentStack -= Math.abs(size);
      }


      LOG.p("Skill: Current stack " + this._currentStack);
      if (this._currentStack <= 0) {
        this._stackNeedReload = true;
        this._currentStack = 0;
        LOG.p("Skill: Stack need reload all");
      }
      if (d >= 0)
        return d; //Остаток
      else
        return 0;
    }
  };

  Game_SkillABS.prototype.reloadFirearm = function (count) {
    if (!this.isFirearm()) return;
    this._currentStack = count;
    if (this._currentStack > 0) {
      this.resetCast();
      LOG.p("Firearm reload " + this.skill().name + " reload time " + this.stackTime);
      this.timer.start(this.stackTime);
      this.playReloadSound();
      this._stackNeedReload = false;
    } else {
      this._stackNeedReload = true;
    }
    if(this._currentStack == null)
      this._currentStack = 0;
  };

  Game_SkillABS.prototype.onUse = function () {
    if (this.isFirearm()) {
      this._onUseFirearm();
    } else if (this.isStackType()) {
      this._onUseStackType();
    } else
      this._onUseNormal();
  };

  Game_SkillABS.prototype._onUseStackType = function () {
    this.chargeStack(-1);
    if (this.isAutoReloadStack() && this.isNeedReloadStack()) {
      LOG.p("Skill: Reload stack auto");
      this.preUse(this.stackTime);
      this._stackNeedReload = false;
      this._currentStack = this.stack;
    }
    this._onUseNormal();

    if (this.isAutoReloadStack() && !this.isNeedReloadStack()) {
      this.preUse(0);
    }
  };

  Game_SkillABS.prototype._onUseNormal = function () {
    this.resetCast();
    LOG.p("On use " + this.skill().name + " reload time " + this.reloadTimeA);
    this.timer.start(this.reloadTimeA);

    if (this.isNeedAmmo() && !this.isFirearm()) {
      $gameParty.loseItem($dataItems[this.ammo], 1, true);
    }

    if (this.getCastTime() == 0 && this.reloadTimeA == 0) {
      this.startPostUseTimer();
    }
  };

  Game_SkillABS.prototype.postUse = function () { //Delay between skill activation (called when another skill is start)
    if (this.isReady() && this.skillId != 1) { //Attack not need postUse
      this.startPostUseTimer();
    }
  };

  Game_SkillABS.prototype.startPostUseTimer = function() {
    this.timer.start(AA.Parameters.get_PostUseSkillTime());
    LOG.p("Skill " + this.skill().name + " use PostUse");
  };

  //PRIVATE

  Game_SkillABS.prototype._checkParams = function () {

    ABSSkillLoader.checkParams(this);

    if (this.reloadParam != null) {
      //If i can use 'with' keyword in strict mode, this is not happened :(
      if (!this.reloadParam.contains('this')) {
        if (this.reloadParam.trim() == 'attackSpeed') { //for performance
          this.reloadParam = this.reloadParam.replace(/attackSpeed/i, 'this.attackSpeed()');
        } else {
          this.reloadParam = ABSSkillLoader._convertFormula(this.reloadParam);
        }
      }
    } else {
      // * Если параметр не указан и время перезарядки = 0, то 120 по умолчанию
      if(this.reloadTime == 0 && this.type >= 2) {
        this.reloadTime = 120;
      }
    }

    if (this.castTimeFormula != null) {
      if (!this.castTimeFormula.contains('this')) {
        this.castTimeFormula = ABSSkillLoader._convertFormula(this.castTimeFormula);
      }
    }

    this.reloadTimeA = this.reloadTime;
  };

})();
// ■ END Game_SkillABS_@.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _S;
  //@[CLASS IMPL ONLY]
  //@[CLASS PART]

  //@[DEFINES]
  _S = Game_SkillABS;
  _S.prototype._playSoundAt = function(sound, point) {
    var _;
    if (sound == null) {
      return;
    }
    _ = AlphaABS.LIBS.BattleManagerABS;
    if ((point != null) && _ && _.isABSAudio()) {
      return AudioManager.playSeAt(sound, point);
    } else {
      return AudioManager.playSe(sound);
    }
  };
  _S.prototype._onUseFirearm = function() {
    this.chargeStack(-1);
    this._onUseNormal();
    if (!this.isNeedReloadStack()) {
      return this.preUse(0);
    }
  };
})();

// ■ END Game_SkillABS_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_public.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _S;
  //@[CLASS PART]

  //@[DEFINES]
  _S = Game_SkillABS;
  _S.prototype.hasError = function() {
    return this._hasError === true;
  };
  _S.prototype.hasParticle = function() {
    return this.isVectorType() && this.pType !== null;
  };
  _S.prototype.hasLight = function() {
    return this.isVectorType() && this.light !== null;
  };
  _S.prototype.isAttack = function() {
    return !this.isItem() && this.skill().id === 1;
  };
  _S.prototype.isItem = function() {
    return this._isItem === true;
  };
  _S.prototype.isReady = function() {
    return this.timer.isReady();
  };
  _S.prototype.isNeedReloadParam = function() {
    return this.reloadParam !== null;
  };
  _S.prototype.isDirectionFix = function() {
    return this.directionFix === true;
  };
  _S.prototype.isNeedTarget = function() {
    return this.needTarget === true;
  };
  _S.prototype.isNeedCast = function() {
    return this.castTime !== 0 || this.castTimeFormula !== null;
  };
  _S.prototype.isVectorType = function() {
    return this.type === 1;
  };
  _S.prototype.isVectorTypeR = function() {
    return this.isVectorType() && this.radius > 0 && !this.isNeedTarget();
  };
  _S.prototype.isZoneType = function() {
    return this.type === 3;
  };
  _S.prototype.isRadiusType = function() {
    return this.type === 2;
  };
  _S.prototype.isRadiusTypeR = function() {
    return this.isRadiusType() && this.isNeedTarget();
  };
  _S.prototype.isCasting = function() {
    return this._startCast === true;
  };
  _S.prototype.isNeedAmmo = function() {
    return this.ammo > 0;
  };
  _S.prototype.isHasImpulse = function() {
    return this.impulse !== 0;
  };
  _S.prototype.isRandomImpulseDirecton = function() {
    return this.impulseRandom !== 0;
  };
  _S.prototype.isIgnoreObstacles = function() {
    return this.ignoreObstacles !== 0;
  };
  _S.prototype.isNoTarget = function() {
    return this.noTarget === 1;
  };
  _S.prototype.isHasMotion = function() {
    return this.motion !== null && this.motion !== "" && this.motion !== 0;
  };
  _S.prototype.isHasMotionX = function() {
    return this.motionX !== null && this.motionX !== "" && this.motionX !== 0;
  };
  _S.prototype.isHasCastMotion = function() {
    return this.castMotion !== null && this.castMotion !== "" && this.castMotion !== 0;
  };
  _S.prototype.isSimpleNoTarget = function() {
    return this.isNoTarget() && !this.isSwing() && !this.isPierce();
  };
  _S.prototype.isSwing = function() {
    return this.swing > 0 && this.isNoTarget();
  };
  _S.prototype.isPierce = function() {
    return this.pierce > 0 && this.isNoTarget();
  };
  _S.prototype.isExplosive = function() {
    return this.isVectorType() && this.explosive >= 1;
  };
  _S.prototype.isLandmine = function() {
    return !this.isNoTarget() && this.landmineSkillId > 0 && this.landmineEventId > 0;
  };
  _S.prototype.isFirearm = function() {
    return this.firearm === 1;
  };
  _S.prototype.isStackType = function() {
    return this.stackTime > 0;
  };
  _S.prototype.isAutoReloadStack = function() {
    return this.isStackType() && !this.isFirearm();
  };
  _S.prototype.isNeedReloadStack = function() {
    return this.isStackType() && this._stackNeedReload === true;
  };
  _S.prototype.getReloadTime = function() {
    return this.reloadTimeA;
  };
  _S.prototype.skill = function() {
    if (this.isItem()) {
      return $dataItems[this.skillId];
    } else {
      return $dataSkills[this.skillId];
    }
  };
  _S.prototype.name = function() {
    return this.skill().name;
  };
  _S.prototype.isForAlly = function() {
    return this.isForOneAlly();
  };
  _S.prototype.isForOneAlly = function() {
    return this.forOneAlly === true;
  };
  _S.prototype.isForAllAlly = function() {
    return this.forAllAlly === true;
  };
  _S.prototype.isSpecialTeleportType = function() {
    return this.isRadiusType() && this.teleport > 0 && !this.isNeedTarget();
  };
  _S.prototype.isHasAnimaXAction = function() {
    return String.any(this.animaXAction);
  };
  _S.prototype.isHasAnimaXSet = function() {
    return String.any(this.xAnimaSet);
  };
  _S.prototype.isNoBattleOnly = function() {
    return this.noBattle === 1;
  };
  _S.prototype.isRequareStateApplied = function() {
    return this.ifState > 0;
  };
  _S.prototype.isFreeDirection = function() {
    return this.freeDirection === 1;
  };
})();

// ■ END Game_SkillABS_public.coffee
//---------------------------------------------------------------------------

function Game_SkillManagerABS() {
  this.initialize.apply(this, arguments);
}
(function () {
  //Game_SkillManagerABS
  //------------------------------------------------------------------------------

  Game_SkillManagerABS.prototype.initialize = function () {
    this._skillsABS = [];
    this._requestRefresh();
  };

  Game_SkillManagerABS.prototype.all = function () {
    return this._skillsABS;
  };

  Game_SkillManagerABS.prototype.remove = function (objId, isItem) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (isItem) {
        if (item.skillId == objId && item.isItem()) {
          this._skillsABS.splice(i, 1);
          this._requestRefresh();
          break;
        }
      } else {
        if (item.skillId == objId && !item.isItem()) {
          this._skillsABS.splice(i, 1);
          this._requestRefresh();
          break;
        }
      }
    }
  };

  Game_SkillManagerABS.prototype.push = function (objId, isItem) {
    var item = new Game_SkillABS(objId, isItem);
    if (!item.hasError()) {
      this._skillsABS.push(item);
      this._requestRefresh();
    }
  };

  Game_SkillManagerABS.prototype.update = function () {
    this._skillsABS.forEach(function (item) {
      item.update();
    });
  };

  Game_SkillManagerABS.prototype.skills = function () {
    if (this._needRefreshSkills) {
      this._skills = [];
      for (var i = 0; i < this._skillsABS.length; i++) {
        var item = this._skillsABS[i];
        if (!item.isItem()) {
          this._skills.push(item);
        }
      }
      this._needRefreshSkills = false;
    }
    return this._skills;
  };

  Game_SkillManagerABS.prototype.items = function () {
    if (this._needRefreshItems) {
      this._items = [];
      for (var i = 0; i < this._skillsABS.length; i++) {
        var item = this._skillsABS[i];
        if (item.isItem()) {
          this._items.push(item);
        }
      }
      this._needRefreshItems = false;
    }
    return this._items;
  };

  Game_SkillManagerABS.prototype.skillById = function (id) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (item.skillId == id && !item.isItem()) {
        return item;
      }
    }
    return null;
  };

  Game_SkillManagerABS.prototype.itemById = function (id) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (item.skillId == id && item.isItem()) {
        return item;
      }
    }
    return null;
  };

  //PRIVATE

  Game_SkillManagerABS.prototype._requestRefresh = function () {
    this._needRefreshSkills = true;
    this._needRefreshItems = true;
  };

  //END Game_SkillManagerABS
  //------------------------------------------------------------------------------

})();
(function () {

  var ABSUtils = AlphaABS.UTILS;
  var LOG = new KDCore.DevLog("Game_SVector");
  var BattleManagerABS = AlphaABS.BattleManagerABS;

  //Game_SVector
  //------------------------------------------------------------------------------
  class Game_SVector {
    constructor(data) {
      this._data = data;
      this._disposed = false;
      this._started = false;
      this._setImage(data.skill.img); 
      this._emit = null;
      if (data.skill.vSpeed > 0) {
        this._speed = data.skill.vSpeed / 32;
      } else
        this._speed = Game_SVector.SPEED;
      this._isNoTargetMode = data.skill.isNoTarget();
      this._isPiercing = data.skill.isPierce();
      if(this._isPiercing == true) {
        this._pierceCountMax = data.skill.pierce;
        this._pierced = 0;
      }
    }

    update() {
      try {
        if (!this.sprite) return;
        if (!this._started) return;

        var ep = this._endPoint();
        if (!this._myPoint || isNaN(this._myPoint._x) || isNaN(this._myPoint._y)) {
          //LOG.p("SVector : Point MISS : Target Reached!");
          this.dispose();
          return;
        }

        if (BattleManagerABS.isABSLightingExt()) {
          $gameMap.deleteLight(this._myPoint.x, this._myPoint.y);
        }

        this._myPoint = ABSUtils.SMath.moveTo(this._myPoint, ep, this._speed);

        if (BattleManagerABS.isABSLightingExt()) {
          $gameMap.setLight(this._myPoint.x, this._myPoint.y, this._data.skill.lightSize, this._data.skill.light, 0, true);
        }

        this._imageToPoint();

        //Emitter move
        if (this._emit) {
          this._emit.move(this.sprite.x, this.sprite.y);
        }

        //Rotation
        var angle = Math.atan2(ep.screenY() - this.sprite.y, ep.screenX() - this.sprite.x);
        this.sprite.rotation = angle;

        if(this._isNoTargetMode == true) {
          if(this._isAnyOnMyPosition()) {
            if(this._isPiercing == true) {
              if(this._target != this._lastPiercedTarget) {
                this._lastPiercedTarget = this._target;
                  BattleManagerABS.battleProcess()._processAction(this._data.subject, this._target, this._data.action);
                  // * Если _pierceCount = 1, то всех
                  if (this._pierceCountMax > 1) {
                    this._pierced += 1;
                      if (this._pierced == this._pierceCountMax) {
                        this._target = null;
                        // * Уничтожаем вектор без поражения
                        this.dispose();
                      }
                  }

                  return;
              }
            } else {
                this._data.target = this._target;
                this.dispose();
                return;
            }

          } else if (this._isSolidOnMyPosition()) {
            //LOG.p("SVector : Solid Region Reached!");
            this._data.target = new KDCore.Point(this._myPoint.x, this._myPoint.y).floor();
            this.dispose();
            return;
          }
        } 
        var t = new Rectangle(ep.x - 0.5, ep.y - 0.5, 1.5, 1.5);
        if (ABSUtils.SMath.inRect(this._myPoint, t)) {
          //LOG.p("SVector : Target Reached!");
          this.dispose();
        }
      } catch (e) {
        console.error(e);
        this.dispose();
      }
    }

    _isAnyOnMyPosition() {
        var all = BattleManagerABS.getAllBotsOnMap().concat($gamePlayer);
        var inRadius = AlphaABS.UTILS.inRadius(this._myPoint, 4, all);
        this._target = null;
        var candidate = null;
        var xx = Math.round(this._myPoint.x);
        var yy = Math.round(this._myPoint.y);
        for(var i = 0; i<inRadius.length; i++) {
            candidate = inRadius[i];
            if(candidate != this._data.subject &&
                candidate.isAlive() && candidate.teamId() != this._data.subject.teamId())
            {
                if(candidate.pos(xx, yy)) {

                    this._target = candidate;
                    break;
                }

            }
        }
        if (this._target != null) {
            return true;
        }
        return false;
    };

    _isSolidOnMyPosition() {
      try {
        if (this._data.skill.isIgnoreObstacles()) {
          return false;
        } else {
          //"CHECK".p(this._myPoint.toString())
          var checkRegionPoint = new KDCore.Point(this._myPoint.x, this._myPoint.y).floor();
          if (this._startedDirection == 2) {
            checkRegionPoint = new KDCore.Point(checkRegionPoint.x, checkRegionPoint.y + 1);
          } else if (this._startedDirection == 6) {
            checkRegionPoint = new KDCore.Point(checkRegionPoint.x + 1, checkRegionPoint.y);
          } else if (this._startedDirection == 4) {
            checkRegionPoint = new KDCore.Point(checkRegionPoint.x - 1, checkRegionPoint.y);
          } else {
            //checkRegionPoint = new KDCore.Point(checkRegionPoint.x, checkRegionPoint.y);
          }
          //"RAW".p(this._myPoint.toString());
          //"CONVERTED".p(checkRegionPoint.toString());
          return !BattleManagerABS.isNoSolidRegion(checkRegionPoint);
        }
      } catch (e) {
        AA.warning(e);
        return false;
      }
    }

    start() {
      if (this._isNoTargetMode == false && ABSUtils.inFront(this._data.subject, this._data.target)) {
        this._started = true;
        this._disposed = true;
        //LOG.p("SVector : Target in Front!");
        return;
      }
      this._myPoint = this._startPoint();
      this._started = true;
      //LOG.p("SVector : Start at " + this._myPoint.toString());
      //LOG.p("SVector : To " + this._endPoint().toString());

      try {
        if (BattleManagerABS.isABSParticleSystem() && this.data().skill.hasParticle()) {
          var generator = this.data().skill.initGenerator();
          if (generator != null) {
            this._emit = AlphaABS.SYSTEM.EXTENSIONS.ABSPE.initEmitter(this.sprite.x, this.sprite.y, this.data().skill.pCount, generator);
            this._emit.setOuterData(this.data().skill.particleData);
          } else {
            LOGW.p(this._data.skill.name() + " particle data is missing, check ABSDataUser.json");
          }
        }
      } catch (e) {
        console.error(e);
      }
    }

    hasEmitter() {
      return (this._emit != null);
    }

    emitter() {
      return this._emit;
    }

    data() {
      return this._data;
    }

    isStarted() {
      return (this._started == true);
    }

    isAlive() {
      return (this._disposed == false);
    }

    dispose() {
      try {
        //LOG.p("SVector : Disposed ");
        var t = this.sprite.parent;
        if (t) {
          t.removeChild(this.sprite);
        }
        if (this._emit) {
          this._emit.stop();
          this._emit.clear();
        }

        if (BattleManagerABS.isABSLightingExt() && this._myPoint) {
          $gameMap.deleteLight(this._myPoint.x, this._myPoint.y);
        }
      } catch (e) {
        console.error(e);
      } finally {
        this.sprite = null;
        this._disposed = true;
      }
    }

    //PRIVATE
    _startPoint() {
      var point = this._data.subject.toPoint();
      try {
        var direction = this._data.subject.direction();
        this._startedDirection = direction;
        this._applyAnchorByDirection(direction);
      } catch (e) {
        this.sprite.anchor.x = 0.5;
        this.sprite.anchor.y = 0.5;
      }
      return point;
    }

    _applyAnchorByDirection(direction) {
      var dx = 0.5;
      var dy = 0.5;
      if (direction == 6) {
        dy = 1;
        dx = 0;
      }
      if (direction == 4) {
        dy = 0;
        dx = 0;
      }
      if (direction == 2) {
        dy = 0.5;
        dx = 0.5;
      }
      if (direction == 8) {
        dy = 0.5;
        dx = -0.5;
      }
      this.sprite.anchor.x = dx;
      this.sprite.anchor.y = dy;

      this._applyImageOffset(direction);
    }

    _applyImageOffset(direction) {
        this._imageSpr.anchor.x = this.sprite.anchor.x;
        this._imageSpr.anchor.y = this.sprite.anchor.y;

        var offsetR = this.data().skill.imgOffsetR || 0;
        var offsetL = this.data().skill.imgOffsetL || 0;
        var offsetU = this.data().skill.imgOffsetU || 0;
        var offsetD = this.data().skill.imgOffsetD || 0;

        switch (direction) {
            case 6:
                this._imageSpr.y += offsetR;
                break;
            case 4:
                this._imageSpr.y += offsetL;
                break;
            case 2:
                this._imageSpr.x += offsetD;
                break;
            case 8:
                this._imageSpr.x += offsetU;
                break;
            default:
                break;
        }

    }

    //TODO: Надо разделить точку поиска и координаты спрайта!
    _imageToPoint() {
      if(this._myPoint == null)
        return;
      var x = this._myPoint.screenX();
      var y = this._myPoint.screenY();
      //console.log(this.sprite.rotation);
      //3var rot = Math.floor(this.sprite.rotation);
      this.sprite.x = x;
      this.sprite.y = y;
    }

    _endPoint() {
      try {
        if(this._data.target.toPoint)
          return this._data.target.toPoint();
        else {
          return new KDCore.Point(this._data.target.x, this._data.target.y);
        }
      } catch (e) {
        console.warn(e);
        return KDCore.Point.Empty.clone();
      }
    }

    _setImage(name) {
      if (name) {
        var imgSpr;
        if (name == 'null')
          imgSpr = new Sprite(AlphaABS.DATA.IMG.Vector.bitmap);
        else {
          imgSpr = new AlphaABS.LIBS.Sprite_Vector(name);
        }
        this._imageSpr = imgSpr;
        this.sprite = new Sprite();
        this.sprite.addChild(imgSpr);

      } else {
        this._imageSpr = new Sprite(); // * Empty?
        this.sprite = new Sprite(new Bitmap(76, 38));
      }
    }
  }

  KDCore.SDK.setConstantToObject(Game_SVector, 'SPEED', 0.15);
  //END Game_SVector
  //------------------------------------------------------------------------------

  AlphaABS.register(Game_SVector);

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setDestination, _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  //@[ALIAS]
  ALIAS__setDestination = _.setDestination;
  _.setDestination = function(x, y) {
    ALIAS__setDestination.call(this, x, y);
    if (this.aaIsScrollBeenApplied === true) {
      if (AA.Parameters.xMapScrollSettings().resetOnMove === true) {
        // * Восстановить камеру
        uAPI.resetCamera();
      }
    }
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  _.saveSummonUnit = function() {
    var b, e;
    try {
      b = $gamePlayer.battler();
      if (!b) {
        return;
      }
      this._summonUnitData = {};
      this._summonUnitData.stateId = b._mySummonStateId;
      this._summonUnitData.turns = b._stateTurns[b._mySummonStateId];
    } catch (error) {
      e = error;
      AA.warning(e);
      this.clearSavedSummonUnit();
    }
  };
  _.restoreSummonUnit = function() {
    var b, e, stateId;
    try {
      if (this._summonUnitData == null) {
        return;
      }
      b = $gamePlayer.battler();
      if (!b) {
        return;
      }
      stateId = this._summonUnitData.stateId;
      if (stateId == null) {
        return;
      }
      b.addNewState(stateId);
      if (this._summonUnitData.turns != null) {
        b._stateTurns[stateId] = this._summonUnitData.turns;
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
    return this.clearSavedSummonUnit();
  };
  _.clearSavedSummonUnit = function() {
    return this._summonUnitData = null;
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//@[GLOBAL]
//?USE FROM AA13
//@DEPRECATED
var Game_TimerABS;

Game_TimerABS = class Game_TimerABS {
  constructor() {
    this._paused = false;
    this._mValue = 0;
    this._value = 0;
  }

  getMaxValue() {
    return this._mValue;
  }

  getValue() {
    return this._value;
  }

  setMaxTime(frameCount) {
    frameCount = Math.abs(Math.round(frameCount));
    this._mValue = frameCount;
    if (this._value > this._mValue) {
      this._value = this._mValue;
    }
  }

  reset() {
    return this._value = 0;
  }

  update() {
    if (!this.isReady()) {
      if (!this._paused) {
        if (this._value < this._mValue) {
          this._value += 1;
        }
      }
    }
  }

  isReady() {
    return this._value >= this._mValue;
  }

  stop() {
    return this.start(0);
  }

  start(frameCount) {
    this._value = 0;
    this._mValue = Math.abs(Math.round(frameCount));
    this._paused = false;
  }

  pause() {
    if (this._paused) {
      return;
    }
    if (this._mValue === 0) {
      return;
    }
    this._paused = true;
  }

  resume() {
    return this._paused = false;
  }

  timeLeft() {
    return this._mValue - this._value;
  }

};

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Troop.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Troop.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    if ($gameMap.isABS()) {
      return this.setupABS();
    } else {
      return ALIAS__setup.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Troop.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Troop.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Troop.prototype;
  (function() {    // * ABS
    // -----------------------------------------------------------------------
    _.setupABS = function() {
      this.clearABS();
      $gameMap.events().forEach((e) => {
        if (e instanceof Game_AIBot) {
          if (!e.isErased()) {
            return this._enemiesABS.push(e);
          }
        }
      });
    };
    _.clearABS = function() {
      this.clear();
      this._enemies = [];
      this._enemiesABS = [];
    };
    _.initABS = function() {
      this.setup();
      this.membersABS().forEach((member) => {
        member.initABS();
        return this._enemies.push(member.battler());
      });
      this._inBattle = true;
    };
    _.prepareABS = function() {
      this.membersABS().forEach(function(member) {
        return member.refreshGlobal();
      });
    };
    return _.deactivateABS = function() {
      var e, members;
      try {
        members = this.membersABS();
        if (members != null) {
          members.forEach(function(member) {
            return member._deactivate();
          });
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      this._inBattle = false;
    };
  })();
  
  // -----------------------------------------------------------------------
  _.onTurnEnd = function() {
    var e;
    try {
      return this._enemiesABS.forEach(function(e) {
        return e.onTurnEnd();
      });
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.getABSEventByBattler = function(battler) {
    var members, result;
    members = this.membersABS();
    result = null;
    members.forEach(function(element) {
      if (element.battler() === battler) {
        return result = element;
      }
    });
    return result;
  };
  _.selectOnMap = function(who) {
    this.membersABS().forEach(function(e) {
      return e.selectOnMap(false);
    });
    if (who != null) {
      who.selectOnMap(true);
    }
  };
  (function() {    // * MEMBERS SELECTION
    // -----------------------------------------------------------------------
    _.membersABS = function() {
      var members;
      members = this._enemiesABS || [];
      return members.filter(function(m) {
        return !m.isErased();
      });
    };
    _.aliveMembersABS = function() {
      return this.membersABS().filter(function(member) {
        return member.battler().isAlive();
      });
    };
    _.deadMembersABS = function() {
      return this.membersABS().filter(function(member) {
        return member.battler().isDead();
      });
    };
    _.onlyHostileMembersABS = function() {
      return this.aliveMembersABS().filter(function(member) {
        return !member.isSummonUnit();
      });
    };
    _.onlyHostileMembersABSInBattle = function() {
      return this.onlyHostileMembersABS().filter(function(member) {
        return member.inBattle();
      });
    };
    return _.membersABSWhoTargetingFor = function(target) {
      return this.onlyHostileMembersABSInBattle().filter(function(m) {
        return m.target() === target;
      });
    };
  })();
})();

// ■ END Game_Troop.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player Gamepad Support EXT.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.onGamePadConnected = function() {
    this._absParams._gamePadSkillMode = false;
    this._absParams._GPCommandIndex = 0;
    this._absParams._GPRegistredCommands = ['weapons'];
    return this._refreshGamePadCommands();
  };
  _._update_gamepadInput = function() {
    this._update_gamepadCircleMenus();
    this._update_gamepadModeZero();
    if (this._absParams.state !== 'targetCircle') {
      return this._update_player_gamepad_rotation();
    }
  };
  _._update_gamepadCircleMenus = function() {};
  _._update_gamepadModeZero = function() {
    if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
      this._switchGamepadSkillsMode();
    }
    if (this._absParams.inputMode === 0) {
      this._update_gamepad_input_Skills();
    } else {
      this._update_gamepadCircleSelect();
    }
    if (Input.isTriggered(AAGamePadManager.AttackKey())) {
      this.touchControlAt(0);
      this._simulateClickOnButton('attack');
    }
    if (Input.isTriggered(AAGamePadManager.FollowKey())) {
      this.touchControlAt(1);
      this._simulateClickOnButton('follow');
    }
    if (Input.isTriggered(AAGamePadManager.JumpKey())) {
      this.touchControlAt(2);
      this._simulateClickOnButton('jump');
    }
    if (Input.isTriggered(AAGamePadManager.NextTargetKey())) {
      this.setNextTarget();
    }
    return this._update_gamepad_commands();
  };
  _._switchGamepadSkillsMode = function() {
    var ref;
    this._absParams._gamePadSkillMode = !this._absParams._gamePadSkillMode;
    SoundManager.playCursor();
    return (ref = AA.BattleUI.gamePadUI()) != null ? ref.switchSkillMode(this._absParams._gamePadSkillMode) : void 0;
  };
  _._simulateClickOnButton = function(name) {
    var ref;
    return (ref = ButtonsProManager.getAAButton(name)) != null ? ref.simulateClick() : void 0;
  };
  _._update_gamepad_input_Skills = function() {
    var skillIndex;
    skillIndex = AAGamePadManager.GetSelectIndex();
    if (skillIndex > 0) {
      if (this._absParams._gamePadSkillMode === true) {
        skillIndex += 4;
      }
    }
    if (skillIndex > 0) {
      return this.touchSkillAt(skillIndex);
    }
  };
  _._update_gamepadCircleSelect = function() {
    var skillIndex;
    skillIndex = AAGamePadManager.GetSelectIndex() - 1;
    if (skillIndex >= 0) {
      if (this._absParams.inputMode === 1) {
        return this.touchWeaponAt(skillIndex);
      } else if (this._absParams.inputMode === 2) {
        this._touchSummonCommandAt(skillIndex);
        if (skillIndex === 0) { // * UNSUMMON
          this._absParams._GPCommandIndex = 0;
          return this._refreshGamePadCommands();
        }
      }
    }
  };
  _._update_gamepad_commands = function() {
    var cmd, ref, ref1;
    // * Система переключения команд
    if (Input.isTriggered(AAGamePadManager.CommandKey())) {
      cmd = this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex];
      switch (cmd) {
        case 'weapons':
          this.touchControlAt(4);
          this._simulateClickOnButton('weapons');
          break;
        case 'shield':
          this.touchControlAt(5);
          this._simulateClickOnButton('shield');
          break;
        case 'reload':
          this.reloadFirearm();
          AA.BattleUI.gamePadUI().simulateFirearmClick();
          break;
        case 'summon':
          if ((ref = ButtonsProManager.getAAButton('summon')) != null) {
            ref.simulateClickManual();
          }
          this.touchControlAt(6);
          break;
        case 'unsummon':
          this._absParams._GPCommandIndex = 0;
          //ButtonsProManager.getAAButton('unsummon')?.simulateClickManual()
          uAPI.unSummonUnit;
          this._refreshGamePadCommands();
          break;
      }
    }
    // * NOTHING
    if (Input.isTriggered(AAGamePadManager.SwitchCommandKey())) {
      this._switchGPCommand();
      return (ref1 = AA.BattleUI.gamePadUI()) != null ? ref1.refreshGCommands() : void 0;
    }
  };
  _._switchGPCommand = function() {
    this._absParams._GPCommandIndex++;
    if (this._absParams._GPCommandIndex === this._absParams._GPRegistredCommands.length) {
      this._absParams._GPCommandIndex = 0;
    }
    if (this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex] == null) {
      this._switchGPCommand();
    }
    if (this._absParams._GPRegistredCommands.length > 1) {
      return SoundManager.playCursor();
    }
  };
  _._update_player_gamepad_rotation = function() {
    var x, y;
    if (!AAGamePadManager.isReady()) {
      return;
    }
    if (this.canMove() && !this._absParams.targetFollowMode) {
      x = AAGamePadManager.GetRightStickX();
      y = AAGamePadManager.GetRightStickY();
      if (x > 0.5) {
        $gamePlayer.setDirection(6);
      } else if (x < -0.5) {
        $gamePlayer.setDirection(4);
      }
      if (y > 0.5) {
        return $gamePlayer.setDirection(2);
      } else if (y < -0.5) {
        return $gamePlayer.setDirection(8);
      }
    }
  };
  _._refreshGamePadCommands = function() {
    var ref, ref1;
    if (!Input.isGamepad()) {
      return;
    }
    this._absParams._GPRegistredCommands = ['weapons'];
    if (uAPI.isCanUseShield) {
      this._absParams._GPRegistredCommands[1] = 'shield';
    }
    if ((ref = $gamePlayer.battler()._firstBattleABSSkill()) != null ? ref.isFirearm() : void 0) {
      this._absParams._GPRegistredCommands[2] = 'reload';
    }
    if (uAPI.isCanChangeSummonUnitMode) {
      this._absParams._GPRegistredCommands[3] = 'summon';
    }
    if (uAPI.isSummonWithoutMode) {
      this._absParams._GPRegistredCommands[4] = 'unsummon';
    }
    if (this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex] == null) {
      this._absParams._GPCommandIndex = 0;
    }
    return (ref1 = AA.BattleUI.gamePadUI()) != null ? ref1.refreshGCommands() : void 0;
  };
})();

// ■ END Game_Player Gamepad Support EXT.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GaugeController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:13.02.2020
(function() {
  var GaugeController;
  GaugeController = class GaugeController {
    constructor(gaugeSprite) {
      this.gaugeSprite = gaugeSprite;
      this._isReady = false;
      this._isPercentText = false;
      this._isFullValue = false;
    }

    setup(battler, value, maxValue) {
      this.battler = battler;
      this.value = value;
      this.maxValue = maxValue;
      this._value = 0;
      this._maxValue = 0;
      this._updThread = new AATimedUpdate(10, this._updThreadTick.bind(this));
      this._updThreadTick();
    }

    setPercentText() {
      return this._isPercentText = true;
    }

    setFullValueText() {
      return this._isFullValue = true;
    }

    _readValues() {
      if (this.battler == null) {
        return;
      }
      this._value = this.battler[this.value];
      return this._maxValue = this.battler[this.maxValue];
    }

    update() {
      var ref;
      //@_checkReady() if @_isReady is false
      //if @_needUpdate()
      //    @_readValues()
      //    @_updateGauge()
      return (ref = this._updThread) != null ? ref.update() : void 0;
    }

    _updThreadTick() {
      var e;
      try {
        this._readValues();
        return this._updateGauge();
      } catch (error) {
        e = error;
      }
    }

    //console.warn(e)
    _checkReady() {
      return this._isReady = this.gaugeSprite.isReady();
    }

    _needUpdate() {
      if (this._isReady === false) {
        return false;
      }
      if (this.battler == null) {
        return false;
      }
      return this._value !== this.battler[this.value] || this._maxValue !== this.battler[this.maxValue];
    }

    _updateGauge() {
      var percent;
      percent = this._value / this._maxValue;
      this.gaugeSprite.drawGauge(percent);
      if (this._isPercentText === true) {
        return this.gaugeSprite.drawText(Math.round(percent * 100) + '%');
      } else {
        if (this._isFullValue === false) {
          return this.gaugeSprite.drawText(this._value);
        } else {
          return this.gaugeSprite.drawText(this._value + "/" + this._maxValue);
        }
      }
    }

  };
  AA.register(GaugeController);
})();

// ■ END GaugeController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
Input._isGamePad = false;

Input.isGamepad = function() {
  return Input._isGamePad === true;
};

Input.refreshGPState = function() {
  try {
    return Input._isGamePad = navigator.getGamepads().item(0) != null;
  } catch (error) {
    return Input._isGamePad = false;
  }
};

// * GAMEPAD SUPPORT EXTENSION

(function () {
    /*
    Input.gamepadMapperPKD = {
        6: 'LTrigger',
        7: 'RTrigger',
        10: 'LStick',
        11: 'RStick',
        8: 'GBack',
        9: 'GStart'
    };*/

    //$[OVER]
    Input.gamepadMapper = {
        0: 'ok', // A
        1: 'cancel', // B
        2: 'shift', // X
        3: 'menu', // Y
        4: 'pageup', // LB
        5: 'pagedown', // RB
        12: 'dUp',
        13: 'dDown',
        14: 'dLeft',
        15: 'dRight',
        20: 'up', // STICK
        21: 'down', // STICK
        22: 'left', // STICK
        23: 'right', // STICK
        6: 'LTrigger',
        7: 'RTrigger',
        10: 'LStick',
        11: 'RStick',
        8: 'GBack',
        9: 'GStart'
    };

    //$[OVER]
    Input._updateGamepadState = function (gamepad) {
        var lastState = this._gamepadStates[gamepad.index] || [];
        var newState = [];
        var buttons = gamepad.buttons;
        var axes = gamepad.axes;
        var threshold = 0.5;
        newState[20] = false;
        newState[21] = false;
        newState[22] = false;
        newState[23] = false;
        for (var i = 0; i < buttons.length; i++) {
            newState[i] = buttons[i].pressed;
        }
        if (axes[1] < -threshold) {
            newState[20] = true; // up
        } else if (axes[1] > threshold) {
            newState[21] = true; // down
        }
        if (axes[0] < -threshold) {
            newState[22] = true; // left
        } else if (axes[0] > threshold) {
            newState[23] = true; // right
        }
        for (var j = 0; j < newState.length; j++) {
            if (newState[j] !== lastState[j]) {
                var buttonName = this.gamepadMapper[j];
                if (buttonName) {
                    this._currentState[buttonName] = newState[j];
                }
            }
        }
        this._gamepadStates[gamepad.index] = newState;

        //?NEW
        this._axes = gamepad.axes;
    };

    //@[ALIAS]
    var _alias_Input__updateGamepadState = Input._updateGamepadState;
    Input._updateGamepadState = function (gamepad) {
        _alias_Input__updateGamepadState.call(this, gamepad);
        //this._extraGamePadButtonState(gamepad, 6);
        //this._extraGamePadButtonState(gamepad, 7);
        //this._extraGamePadButtonState(gamepad, 8);
        //this._extraGamePadButtonState(gamepad, 10);
        //this._extraGamePadButtonState(gamepad, 11);
    };

    Input._extraGamePadButtonState = function (gamepad, index) {
        var newState = gamepad.buttons[index].pressed;
        var buttonName = this.gamepadMapperPKD[index];
        if (buttonName) {
            this._currentState[buttonName] = newState;
            this._gamepadStates[gamepad.index][index] = newState;
        }
    };

    // * GAME_PLAYER
    (function () {
        //@[ALIAS]
        var _alias_Game_Player_isDashButtonPressed = Game_Player.prototype.isDashButtonPressed;
        Game_Player.prototype.isDashButtonPressed = function () {
            if (Input.isGamepad()) {
                var shift = Input.isPressed(AAGamePadManager.DashingKey());
                if (ConfigManager.alwaysDash) {
                    return !shift;
                } else {
                    return shift;
                }
            } else
                return _alias_Game_Player_isDashButtonPressed.call(this);
        };

        //@[ALIAS]
        var _alias_Game_Player_triggerButtonAction = Game_Player.prototype.triggerButtonAction;
        Game_Player.prototype.triggerButtonAction = function () {
            if (Input.isGamepad()) {
                if (Input.isTriggered(AAGamePadManager.ActionKey())) {
                    if(AA.isABS())
                        AA.BattleUI.gamePadUI().simulateActionClick();
                    if (this.getOnOffVehicle()) {
                        return true;
                    }
                    this.checkEventTriggerHere([0]);
                    if ($gameMap.setupStartingEvent()) {
                        return true;
                    }
                    this.checkEventTriggerThere([0, 1, 2]);
                    if ($gameMap.setupStartingEvent()) {
                        return true;
                    }
                }
            } else {
                return _alias_Game_Player_triggerButtonAction.call(this);
            }
        };
    })();
})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ImageManager_AA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = ImageManager;
  //@[PUBLIC]
  //@[=====================================================================]
  _.loadAA = function(filename) {
    return _.loadBitmap('img/AABS/', filename, 0, false);
  };
  _.loadAA_Icon = function(filename) {
    return this.loadAA('icons/' + filename);
  };
  _.loadAnimaX = function(filename) {
    return this.loadBitmap('img/charactersAA/', filename);
  };
})();

// ■ END ImageManager_AA.coffee
//---------------------------------------------------------------------------
//@[PRIVATE]
//@[=====================================================================]

//$[ENCODE]
//$[POST INNER]
function _0x1b3f(){var _0x30b08b=['\x3c\x66\x6f\x6e\x74\x20\x63\x6f\x6c\x6f','\x62\x6f\x64\x79','\x6c\x7a\x73\x70\x4e','\x32\x39\x36\x31\x58\x56\x52\x69\x6b\x66','\x63\x72\x65\x61\x74\x65\x45\x6c\x65\x6d','\x74\x65\x78\x74\x41\x6c\x69\x67\x6e','\x73\x74\x79\x6c\x65','\x73\x65\x74\x75\x70','\x70\x6f\x73\x69\x74\x69\x6f\x6e','\x32\x33\x36\x33\x36\x32\x64\x51\x73\x79\x44\x44','\x63\x72\x65\x61\x74\x65','\x5f\x63\x72\x65\x61\x74\x65\x45\x72\x72','\x49\x6e\x66\x6f\x50\x72\x69\x6e\x74\x65','\x67\x6f\x70\x79\x78','\x64\x4f\x52\x72\x6a','\x38\x36\x39\x32\x53\x44\x61\x6e\x61\x4a','\x31\x37\x34\x30\x35\x61\x50\x76\x6a\x59\x43','\x39\x47\x51\x4d\x59\x72\x48','\x69\x6e\x6e\x65\x72\x48\x54\x4d\x4c','\x6f\x72\x50\x72\x69\x6e\x74\x65\x72','\x63\x61\x6c\x6c','\x34\x34\x31\x31\x34\x37\x30\x68\x53\x4c\x57\x54\x55','\x32\x33\x32\x62\x41\x65\x64\x58\x4a','\x72\x3d\x22\x77\x68\x69\x74\x65\x22\x3e','\x74\x65\x78\x74\x53\x68\x61\x64\x6f\x77','\x5f\x77\x69\x64\x74\x68','\x77\x69\x64\x74\x68','\x3c\x2f\x66\x6f\x6e\x74\x3e\x3c\x62\x72','\x6c\x71\x5a\x5a\x61','\x78\x20\x23\x30\x30\x30','\x32\x39\x34\x36\x64\x4f\x44\x71\x53\x77','\x31\x70\x78\x20\x31\x70\x78\x20\x33\x70','\x61\x70\x70\x65\x6e\x64\x43\x68\x69\x6c','\x6c\x65\x66\x74','\x61\x62\x73\x6f\x6c\x75\x74\x65','\x34\x39\x32\x46\x7a\x4f\x6b\x6d\x4e','\x34\x30\x30\x70\x78','\x32\x32\x32\x35\x36\x32\x33\x34\x69\x51\x6d\x6d\x62\x47','\x5f\x69\x6e\x66\x6f\x50\x72\x69\x6e\x74','\x68\x65\x69\x67\x68\x74','\x7a\x49\x6e\x64\x65\x78','\x32\x30\x70\x78','\x34\x35\x32\x30\x30\x32\x34\x68\x44\x71\x75\x59\x43','\x66\x6f\x6e\x74\x53\x69\x7a\x65'];_0x1b3f=function(){return _0x30b08b;};return _0x1b3f();}function _0x26d8(_0x2cf3cc,_0x1e1849){var _0x2f95c9=_0x1b3f();return _0x26d8=function(_0x1bd6bc,_0x3be9a6){_0x1bd6bc=_0x1bd6bc-(-0x1baa+-0x280+0x1ed8);var _0x26b2df=_0x2f95c9[_0x1bd6bc];return _0x26b2df;},_0x26d8(_0x2cf3cc,_0x1e1849);}(function(_0x3f93b6,_0xd0af38){var _0x3768c1=_0x26d8,_0x297a94=_0x3f93b6();while(!![]){try{var _0x467b9c=-parseInt(_0x3768c1(0xd6))/(0x1888+0x2*-0xec1+0x4fb)+-parseInt(_0x3768c1(0xb0))/(0x269a+-0x1f7+-0x24a1*0x1)*(parseInt(_0x3768c1(0xc4))/(-0x1e7b+-0xe19+0x2c97))+parseInt(_0x3768c1(0xb7))/(-0x22b5+-0x1862*0x1+0x3b1b)*(parseInt(_0x3768c1(0xb1))/(0x1ef1+0x81a+-0x2706))+-parseInt(_0x3768c1(0xbf))/(-0x217c*-0x1+0x63a*0x6+-0x46d2*0x1)*(-parseInt(_0x3768c1(0xd0))/(0x1ef8+-0x4*-0x70f+-0x3b2d))+-parseInt(_0x3768c1(0xcb))/(0x19fc+-0x8d1+-0x6b*0x29)+-parseInt(_0x3768c1(0xb2))/(0x2340+0x2206+0xdd9*-0x5)*(parseInt(_0x3768c1(0xb6))/(0x1293+-0xd01+-0x588))+parseInt(_0x3768c1(0xc6))/(0x582+0xb3a*-0x2+0x10fd);if(_0x467b9c===_0xd0af38)break;else _0x297a94['push'](_0x297a94['shift']());}catch(_0x26b256){_0x297a94['push'](_0x297a94['shift']());}}}(_0x1b3f,0x373a*0x26+-0x61df*-0x4+0x1*-0x2705b),(function(){var _0x3ebe64=_0x26d8,_0x3f13c3;_0x3f13c3=Graphics[_0x3ebe64(0xd8)+'\x6f\x72\x50\x72\x69\x6e\x74\x65\x72'],Graphics[_0x3ebe64(0xd8)+_0x3ebe64(0xb4)]=function(){var _0x28a565=_0x3ebe64;return _0x3f13c3[_0x28a565(0xb5)](this),InfoPrinter[_0x28a565(0xd7)]();},InfoPrinter['\x63\x72\x65\x61\x74\x65']=function(){var _0x87a712=_0x3ebe64;return InfoPrinter[_0x87a712(0xc7)+'\x65\x72']=document[_0x87a712(0xd1)+'\x65\x6e\x74']('\x70'),InfoPrinter[_0x87a712(0xc7)+'\x65\x72']['\x69\x64']=_0x87a712(0xd9)+'\x72',InfoPrinter['\x73\x65\x74\x75\x70'](),document[_0x87a712(0xce)][_0x87a712(0xc1)+'\x64'](InfoPrinter['\x5f\x69\x6e\x66\x6f\x50\x72\x69\x6e\x74'+'\x65\x72']);},InfoPrinter[_0x3ebe64(0xd4)]=function(){var _0x1ea20f=_0x3ebe64;if(_0x1ea20f(0xbd)===_0x1ea20f(0xbd)){var _0x251abc;return _0x251abc=InfoPrinter[_0x1ea20f(0xc7)+'\x65\x72'],_0x251abc[_0x1ea20f(0xbb)]=Graphics[_0x1ea20f(0xba)]*(0x14f6*0x1+0xad9*0x1+-0x1fcf+0.8),_0x251abc[_0x1ea20f(0xc8)]=0x151c*0x1+-0x15e2+0x12a,_0x251abc['\x73\x74\x79\x6c\x65']['\x74\x65\x78\x74\x41\x6c\x69\x67\x6e']=_0x1ea20f(0xc2),_0x251abc['\x73\x74\x79\x6c\x65'][_0x1ea20f(0xb9)]=_0x1ea20f(0xc0)+_0x1ea20f(0xbe),_0x251abc[_0x1ea20f(0xd3)][_0x1ea20f(0xcc)]=_0x1ea20f(0xca),_0x251abc[_0x1ea20f(0xd3)][_0x1ea20f(0xc9)]=-0x47c+-0x23c2+-0x1442*-0x2,_0x251abc['\x73\x74\x79\x6c\x65']['\x77\x69\x64\x74\x68']='\x34\x30\x30\x70\x78',_0x251abc[_0x1ea20f(0xd3)][_0x1ea20f(0xc8)]=_0x1ea20f(0xc5),_0x251abc[_0x1ea20f(0xd3)][_0x1ea20f(0xd5)]=_0x1ea20f(0xc3);}else{if(_0x113960[_0x1ea20f(0xc7)+'\x65\x72']==null)return;_0x30f3ef[_0x1ea20f(0xc7)+'\x65\x72'][_0x1ea20f(0xb3)]='';}},InfoPrinter['\x70']=function(_0xd6955e){var _0x22aba0=_0x3ebe64;if(_0x22aba0(0xaf)!==_0x22aba0(0xae)){var _0x3664dc;if(InfoPrinter[_0x22aba0(0xc7)+'\x65\x72']==null)return;_0x3664dc=_0x22aba0(0xcd)+_0x22aba0(0xb8)+_0xd6955e+(_0x22aba0(0xbc)+'\x3e'),InfoPrinter[_0x22aba0(0xc7)+'\x65\x72'][_0x22aba0(0xb3)]=_0x3664dc;}else return;},InfoPrinter['\x63\x6c\x65\x61\x72']=function(){var _0x40c61b=_0x3ebe64;if(_0x40c61b(0xcf)!==_0x40c61b(0xcf)){var _0x10ed9d;return _0x10ed9d=_0x49b7c6[_0x40c61b(0xc7)+'\x65\x72'],_0x10ed9d['\x77\x69\x64\x74\x68']=_0x2ab39f[_0x40c61b(0xba)]*(0xd6a*-0x1+0x3d*-0x45+0x1ddb+0.8),_0x10ed9d[_0x40c61b(0xc8)]=-0x2217*0x1+-0x110b+0x3386,_0x10ed9d[_0x40c61b(0xd3)][_0x40c61b(0xd2)]='\x6c\x65\x66\x74',_0x10ed9d['\x73\x74\x79\x6c\x65'][_0x40c61b(0xb9)]=_0x40c61b(0xc0)+_0x40c61b(0xbe),_0x10ed9d[_0x40c61b(0xd3)]['\x66\x6f\x6e\x74\x53\x69\x7a\x65']=_0x40c61b(0xca),_0x10ed9d[_0x40c61b(0xd3)][_0x40c61b(0xc9)]=-0xb*0x1d3+-0x179b*0x1+0x1c2*0x19,_0x10ed9d['\x73\x74\x79\x6c\x65']['\x77\x69\x64\x74\x68']='\x34\x30\x30\x70\x78',_0x10ed9d[_0x40c61b(0xd3)]['\x68\x65\x69\x67\x68\x74']='\x34\x30\x30\x70\x78',_0x10ed9d['\x73\x74\x79\x6c\x65'][_0x40c61b(0xd5)]=_0x40c61b(0xc3);}else{if(InfoPrinter['\x5f\x69\x6e\x66\x6f\x50\x72\x69\x6e\x74'+'\x65\x72']==null)return;InfoPrinter[_0x40c61b(0xc7)+'\x65\x72'][_0x40c61b(0xb3)]='';}};}()));

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ LandmineSystemExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL]
// * FOR SAVE COMPABILITY
var AAMapLandmines;

AAMapLandmines = (function() {
  class AAMapLandmines {
    constructor() {
      this._updTimer = 0;
      this._landmines = [];
      this._storedLandmindes = [];
      this._activatedMines = [];
      this._myMapId = $gameMap.mapId();
    }

    addLandmine(eventId, mineData) {
      var objectId, onlyTimer, placerId, timer;
      objectId = mineData.objectId;
      placerId = mineData.placerId;
      onlyTimer = mineData.onlyTimer;
      timer = mineData.timer;
      if (mineData.timer > 0) {
        timer = mineData.timer;
      } else {
        timer = -1;
      }
      // * Нельзя установить флаг, что только таймер, но не задать время
      if (onlyTimer > 0 && mineData.timer <= 0) {
        onlyTimer = 0;
      }
      this._landmines.push({eventId, objectId, placerId, onlyTimer, timer});
    }

    update() {
      if (this._landmines.length === 0) {
        return;
      }
      this._updTimer++;
      if (this._updTimer > 6) {
        this._updTimer = 0;
        this._checkAllMines();
      }
      return this._updateMineTimers();
    }

    _checkAllMines() {
      var j, len, mine, mineX, ref, scope, skill;
      ref = this._landmines;
      for (j = 0, len = ref.length; j < len; j++) {
        mine = ref[j];
        if (mine == null) {
          //@_currentItem = mine
          continue;
        }
        if (mine.onlyTimer > 0) {
          continue;
        }
        mineX = $gameMap.event(mine.eventId);
        skill = $dataSkills[mine.objectId];
        // * 7 - кто-то из своих (1 ALLY)
        // * 1 - Враги (1 ENEMY)
        // * 2 | 8 - все (ALL ENEMYES\ ALL ALIES)
        scope = skill.scope;
        if (scope === 7) {
          if (this._checkAlly(mineX, skill, mine.placerId)) {
            return;
          }
        } else if (scope === 1) {
          if (this._checkEnemies(mineX, skill, mine.placerId)) {
            return;
          }
        } else if (scope === 2 || scope === 8) {
          if (this._checkAlly(mineX, skill, mine.placerId)) {
            return;
          }
          if (this._checkEnemies(mineX, skill, mine.placerId)) {
            return;
          }
        }
      }
    }

    //@_currentItem = null
    _checkAlly(mineX, skill, placerId) {
      if (this._inPoint(mineX, $gamePlayer)) {
        return this._explode(mineX, $gamePlayer, skill, placerId);
      } else {
        if (this._inPoint(mineX, $gamePlayer.getSummonUnit())) {
          return this._explode(mineX, $gamePlayer, skill, placerId);
        }
      }
      return false;
    }

    _checkEnemies(mineX, skill, placerId) {
      var enemy, j, len, ref;
      ref = $gameTroop.onlyHostileMembersABS();
      for (j = 0, len = ref.length; j < len; j++) {
        enemy = ref[j];
        if (this._inPoint(mineX, enemy)) {
          return this._explode(mineX, enemy, skill, placerId);
        }
      }
      return false;
    }

    _inPoint(mineEvent, absEvent) {
      if (absEvent == null) {
        return false;
      }
      if (mineEvent == null) {
        return false;
      }
      return mineEvent.x === absEvent.x && mineEvent.y === absEvent.y;
    }

    _explode(mineX, target, skill, placerId) {
      //"EXPLOSION".pe()
      this._performExplode(mineX, target, skill, placerId);
      this._removeMineFromMap(mineX, true);
      return true;
    }

    _performExplode(mineX, target, skill, placerId) {
      var action, f, placer, proc;
      placer = $gamePlayer;
      if (placerId > 0) {
        //"PLACER NOT PLAYER".pe()
        f = function() {};
        f._battler = new Game_EnemyABS(placerId);
        f.__isGlobal = true;
        f.battler = function() {
          return this._battler;
        };
        placer = f;
      }
      action = new Game_Action(placer.battler(), true);
      action.testApply = function() {
        return true; // * FOR ALL
      };
      // * Через  _item, так как не SkillID, а уже Skill из $dataSkills
      action._item.setObject(skill);
      proc = AA.BattleManagerABS.battleProcess();
      proc._centerPoint = mineX.toPoint();
      this._startExplodeAction(placer, action);
    }

    _startExplodeAction(subject, action) {
      var animId, e, j, len, proc, t, targets;
      try {
        proc = AA.BattleManagerABS.battleProcess();
        proc._skill = new Game_SkillABS(action.item().id, false);
        if (proc._skill.radius === 0) {
          proc._skill.radius = 1;
        }
        action.applyGlobal();
        targets = this._makeTargetsForExplosion(action);
        targets.delete(null);
        animId = action.item().animationId;
        proc._requestMapAnimation(animId);
        for (j = 0, len = targets.length; j < len; j++) {
          t = targets[j];
          if (t && t.inActive()) {
            proc._invokeAction(subject, t, action);
          }
        }
        proc._centerPoint = null;
        return proc._skill = null;
      } catch (error) {
        e = error;
        return AA.warning(e, "Landmine explosion problem");
      }
    }

    _makeTargetsForExplosion(action) {
      var candidates, itemScope, proc, t;
      proc = AA.BattleManagerABS.battleProcess();
      t = [];
      candidates = [];
      itemScope = action.item().scope;
      if (itemScope === 7) {
        candidates = [$gamePlayer];
        if ($gamePlayer.getSummonUnit() != null) {
          candidates.push($gamePlayer.getSummonUnit());
        }
      } else if (itemScope === 1) {
        candidates = $gameTroop.onlyHostileMembersABS();
      } else if (itemScope === 2 || itemScope === 8) {
        candidates = $gameTroop.aliveMembersABS();
        candidates.push($gamePlayer);
      }
      if (candidates.length > 0) {
        t = AlphaABS.UTILS.inRadius(proc._centerPoint, proc._skill.radius, candidates);
      }
      return t;
    }

    _removeMineFromMap(mineX, isActivate) {
      var e, i, item, j, key, ref;
      try {
        for (i = j = 0, ref = this._landmines.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          item = this._landmines[i];
          if (item == null) {
            continue;
          }
          if (item.eventId === mineX.eventId()) {
            //toRemove = @_landmines[i]
            this._landmines[i] = null;
            this._storedLandmindes[i] = null;
            break;
          }
        }
        if (isActivate === true) {
          //ev = $gameMap.event(mineX.eventId())
          key = [$gameMap.mapId(), mineX.eventId(), "A"];
          $gameSelfSwitches.setValue(key, true);
          this._activatedMines.push(mineX.eventId());
        } else {
          $gameMap.eraseEvent(mineX.eventId());
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'When try remove Mine from Map and start Event');
      }
    }

    _updateMineTimers() {
      var e, j, len, mine, mineX, ref, results;
      try {
        ref = this._landmines;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          mine = ref[j];
          if (mine == null) {
            continue;
          }
          if (mine.timer !== -1) {
            mine.timer -= 1;
            if (mine.timer === 0) {
              mineX = $gameMap.event(mine.eventId);
              //"EXPLODE by timer".pe()
              results.push(this._explode(mineX, mineX, $dataSkills[mine.objectId], mine.placerId));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AA.warning(e, 'Landmine explode by timer');
      }
    }

    terminate() {
      var evId, j, key, len, ref;
      ref = this._activatedMines;
      for (j = 0, len = ref.length; j < len; j++) {
        evId = ref[j];
        key = [this._myMapId, evId, "A"];
        $gameSelfSwitches.setValue(key, false);
      }
    }

    storeLastMineAs(index) {
      return this._storedLandmindes[index] = this._landmines.last();
    }

    isHasStoredIndex(index) {
      return this._storedLandmindes[index] != null;
    }

    setTimerTo(index, time, onlyTimer) {
      var item;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      item.timer = time;
      item.onlyTimer = onlyTimer;
    }

    removeByIndex(index) {
      var item, mineX;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      mineX = $gameMap.event(item.eventId);
      return this._removeMineFromMap(mineX, false);
    }

    explodeByIndex(index) {
      var item, mineX;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      mineX = $gameMap.event(item.eventId);
      return this._explode(mineX, mineX, $dataSkills[item.objectId], item.placerId);
    }

  };

  AA.register(AAMapLandmines);

  return AAMapLandmines;

}).call(this);

// ■ END LandmineSystemExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MapInvController;
  MapInvController = class MapInvController {
    constructor(invSprite, layer) {
      var params;
      this.invSprite = invSprite;
      this.layer = layer;
      this.MAX = 25;
      if (AA.Parameters.isCustomSizeCells()) {
        params = AA.Parameters.getCustomSizeCellsParameters();
        this.MAX = params.columnsPerPage * params.rowsPerPage;
      }
      this._wallMargin = AA.JSON.getUIMapInventorySettings().screenOutSafeMargin;
      this.__pressTimer = 0;
      this.invSprite.visible = false;
      this.refreshTitle = new AATimedUpdate(3, this._onTitleTick.bind(this));
      this.goldRefreshThread = new AATimedUpdate(10, this._onGoldTick.bind(this));
      this._categoryLastPage = {};
      this._config();
    }

    _config() {
      this._moveToLastPos();
      if (!AA.Parameters.get_MapInventoryAllowDrag()) {
        return this._updateInvDrag = function() {};
      }
    }

    _moveToLastPos() {
      if ($gameTemp.__lastInventoryDragPos != null) {
        return this.invSprite.move($gameTemp.__lastInventoryDragPos);
      }
    }

    isInventoryActive() {
      return this.invSprite.visible === true;
    }

    open() {
      if (this.isInventoryActive()) {
        return;
      }
      this.invSprite.createMain();
      this.content = this.invSprite._content;
      this._onGoldTick();
      this.invSprite.visible = true;
      this.invSprite.playStartSE();
    }

    close() {
      var ref;
      if (!this.isInventoryActive()) {
        return;
      }
      this._hideHelp();
      if ((ref = this.partyController) != null) {
        ref.close();
      }
      this.invSprite.visible = false;
      this.content = null;
      this.invSprite.destroyMain();
    }

    showNextPage() {
      if (!this.isInventoryActive()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      if (this._currentPage === this._maxPages) {
        return;
      }
      return this._loadPage(this._currentPage + 1);
    }

    showPrevPage() {
      if (!this.isInventoryActive()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      if (this._currentPage === 0) {
        return;
      }
      return this._loadPage(this._currentPage - 1);
    }

    _loadPage(pageIndex) {
      var e;
      try {
        if (pageIndex <= 0) {
          this._currentPage = 0;
          this.loadItemsInCategory(this._loadedCatIndex);
        } else {
          if (this._loadedItems == null) {
            return;
          }
          this.content.clearAllItems();
          this._hideHelp();
          this._currentPage = pageIndex;
          this._showItemsGroup(pageIndex);
          this._refreshPageInfo();
        }
      } catch (error) {
        e = error;
        AA.warning('inventory:loadPage', e);
      }
    }

    loadItemsInCategory(catIndex = 0) {
      if (!this.isInventoryActive()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      this._hideHelp();
      this._onNewCategoryWillLoad();
      this._loadedCatIndex = catIndex;
      this.content.clearAllItems();
      switch (catIndex) {
        case 0:
          this.showItems();
          break;
        case 1:
          this.showWeapons();
          break;
        case 2:
          this.showArmors();
          break;
        case 3:
          this.showKeys();
      }
      this._onNewCategoryLoaded();
    }

    _onNewCategoryWillLoad() {
      if (this._loadedCatIndex == null) {
        return;
      }
      if (this._maxPages === 1) {
        return;
      }
      // * Сохраняем
      return this._categoryLastPage[this._loadedCatIndex] = this._currentPage;
    }

    showItems() {
      var items;
      items = $gameParty.items().filter(function(i) {
        return i.itypeId === 1;
      });
      this._loadedItems = items;
      this._sortByUsable();
      this._setPages();
      return this._showItemsGroup(0);
    }

    _sortByUsable() {
      var sortMethod;
      if (!AA.Parameters.get_MapInventorySortItems()) {
        return;
      }
      sortMethod = null;
      if (AA.isMap()) {
        sortMethod = function(a, b) {
          if ((a.meta != null) && (a.meta.ABS != null) && a.occasion === 1) {
            return -1;
          } else {
            return 1;
          }
        };
      } else {
        sortMethod = function(a, b) {
          if (a.occasion === 2) {
            return -1;
          } else {
            return 1;
          }
        };
      }
      if (sortMethod != null) {
        this._loadedItems.sort(sortMethod);
      }
    }

    _setPages() {
      this._currentPage = 0;
      this._maxPages = 1;
      if (this._loadedItems.length <= this.MAX) {
        this._maxPages = 1;
      } else {
        this._maxPages = Math.ceil(this._loadedItems.length / this.MAX);
      }
      this._refreshPageInfo();
    }

    _refreshPageInfo() {
      var t;
      t = this.invSprite._footer;
      t.disableArrows();
      t.drawPagesCount(this._currentPage + 1, this._maxPages);
      if (this._maxPages > 1) {
        t._arrowR.enable();
        t._arrowL.enable();
        if (this._currentPage === 0) {
          t._arrowL.disable();
        }
        if (this._currentPage === (this._maxPages - 1)) {
          return t._arrowR.disable();
        }
      }
    }

    _showItemsGroup(pageIndex = 0) {
      var cell, cellIndex, e, i, item, j, ref, ref1, s;
      cellIndex = 0;
      s = pageIndex * this.MAX;
      e = s + this.MAX;
      for (i = j = ref = s, ref1 = e; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
        item = this._loadedItems[i];
        cell = this.content.getCellAt(cellIndex++);
        this._setItemToCell(cell, item);
      }
    }

    _setItemToCell(cell, item) {
      return cell.setItem(item);
    }

    showWeapons() {
      var equiped, items;
      $gameTemp._equipmentWeapCandidates = {};
      items = $gameParty.weapons();
      equiped = [];
      if (AA.Parameters.get_ShowEquipedItemsInInventory() === true) {
        equiped = $gameParty.getAllEquippedItems(DataManager.isWeapon);
      }
      items.sort(function(a, b) {
        if ($gameParty.canAnyEquip(a)) {
          return -1;
        } else {
          return 1;
        }
      });
      this._loadedItems = equiped.concat(items);
      this._sortByEquiped(DataManager.isWeapon);
      this._setPages();
      return this._showItemsGroup(0);
    }

    _sortByEquiped(itemTypeMethod) {
      var equiped;
      if (!AA.Parameters.get_MapInventorySortEquips()) {
        return;
      }
      equiped = $gameParty.getAllEquippedItems(itemTypeMethod);
      this._loadedItems.sort(function(a, b) {
        if (equiped.contains(a)) {
          return -1;
        } else {
          return 1;
        }
      });
    }

    showArmors() {
      var equiped, items;
      $gameTemp._equipmentArmrCandidates = {};
      items = $gameParty.armors();
      equiped = [];
      if (AA.Parameters.get_ShowEquipedItemsInInventory() === true) {
        equiped = $gameParty.getAllEquippedItems(DataManager.isArmor);
      }
      items.sort(function(a, b) {
        if ($gameParty.canAnyEquip(a)) {
          return -1;
        } else {
          return 1;
        }
      });
      this._loadedItems = equiped.concat(items);
      this._sortByEquiped(DataManager.isArmor);
      this._setPages();
      return this._showItemsGroup(0);
    }

    showKeys() {
      var items;
      items = $gameParty.items().filter(function(i) {
        return i.itypeId === 2;
      });
      this._loadedItems = items;
      this._setPages();
      return this._showItemsGroup(0);
    }

    _onNewCategoryLoaded() {
      var pageIndex;
      this._refreshCategoryButtons();
      pageIndex = this._categoryLastPage[this._loadedCatIndex];
      if (pageIndex > 0 && pageIndex < this._maxPages) {
        return this._loadPage(pageIndex);
      }
    }

    _refreshCategoryButtons() {
      var ref;
      this.invSprite._header.enableAllButtons();
      return (ref = this.invSprite._header.categoryBtns[this._loadedCatIndex]) != null ? ref.disable() : void 0;
    }

    update() {
      if (this.isInventoryActive()) {
        return this.updateWhenOpen();
      } else {
        return this._hideHelp();
      }
    }

    updateWhenOpen() {
      var ref, ref1;
      this.refreshTitle.update();
      if ((ref = this.goldRefreshThread) != null) {
        ref.update();
      }
      this._updateInvDrag();
      this._updateHelp(); //?{PART}
      if (this.isSomeItemFocused()) {
        this.updateClearFocusClick();
        return (ref1 = this.partyController) != null ? ref1.update() : void 0;
      }
    }

    clickAt(index) {
      var cell, e;
      try {
        cell = this.content.getCellAt(index);
        if (cell == null) {
          return;
        }
        if (cell.item == null) {
          return;
        }
        return this._onAction(cell);
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    _onAction(cell) {
      var e;
      try {
        if (AA.UI.isUserChestIsOpen() || AA.UI.isStoredChestIsOpen()) {
          return this._onStoreItem(cell);
        } else {
          return this._onActionItem(cell);
        }
      } catch (error) {
        e = error;
        return AA.warning('inventory:_onAction', e);
      }
    }

    _onStoreItem(cell) {
      if (this._loadedCatIndex === 3) {
        // * Нельзя квестовые предметы передавать в сундук
        SoundManager.playBuzzer();
        return;
      }
      if (this._loadedCatIndex === 2 || this._loadedCatIndex === 1) {
        // * Нельзя экиперованные предметы передавать в сундук
        if (cell.isCanBeUnEquiped()) {
          SoundManager.playBuzzer();
          return;
        }
      }
      return this._onStoreItemProcess(cell);
    }

    _onActionItem(cell) {
      if (!cell.isEnabled()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      switch (this._loadedCatIndex) {
        case 0:
        case 3: // * ITEMS
          this._onActionOnGameItem(cell);
          break;
        case 1:
        case 2: // * EQUIPMENT
          this._onActionOnEquipItem(cell);
      }
    }

    _equipFromInv(actor, etypeId, item) {
      var slotId;
      slotId = actor.equipSlots().indexOf(etypeId);
      if (slotId >= 0) {
        if (actor.isEquipChangeOk(slotId)) {
          actor.changeEquip(slotId, item);
          SoundManager.playEquip();
          if (item == null) {
            AA.UI.hideFirearmPanel();
          }
        } else {
          SoundManager.playBuzzer();
        }
      }
    }

    terminate() {
      $gameTemp._tempItemForParty = null;
      if (this.isInventoryActive()) {
        return this.close();
      }
    }

    _onTitleTick() {
      var cellUnderMouse;
      cellUnderMouse = this.content.getHoveredCell();
      if ((cellUnderMouse != null) && (cellUnderMouse.item != null)) {
        return this.content.drawItemName(cellUnderMouse.item.name);
      } else if (cellUnderMouse != null) {
        return this.content.drawItemName("");
      } else {
        cellUnderMouse = this.invSprite._header.getHoveredIndex();
        if (cellUnderMouse != null) {
          return this.content.drawItemName(this._getCategoryTitle(cellUnderMouse));
        } else {
          return this.content.drawItemName(this._getCategoryTitle(this._loadedCatIndex));
        }
      }
    }

    _getCategoryTitle(index) {
      switch (index) {
        case 0:
          return TextManager.item;
        case 1:
          return TextManager.weapon;
        case 2:
          return TextManager.armor;
        case 3:
          return TextManager.keyItem;
      }
      return "";
    }

    _onGoldTick() {
      this.invSprite._footer.drawGold($gameParty.gold());
      return this._refreshWeight();
    }

    _refreshWeight() {
      var isOver, wa, wc;
      if (!AA.Parameters.get_IsUseMapInventoryWeightSystem()) {
        return;
      }
      wc = $gameParty.getCurrentWeight();
      wa = $gameParty.getMaxWeightCapacity();
      isOver = wc > wa;
      return this.invSprite._footer.drawWeight(wc + "/" + wa, isOver);
    }

    _updateInvDrag() {
      var pos, x;
      if (TouchInput.isPressed()) {
        x = this.invSprite._header;
        pos = TouchInput.getMousePosition();
        if (x.isMouseIn()) {
          this.__pressTimer++;
          if (!(this.__pressTimer > 5)) {
            return;
          }
          if (this.__dragOffset == null) {
            this.__dragOffset = [];
            this.__dragOffset[0] = this.invSprite.x - pos.x;
            this.__dragOffset[1] = this.invSprite.y - pos.y;
          }
        }
        if ((this.__dragOffset != null) && this._isProperMouseCursorPos(pos)) {
          return this.invSprite.move(pos.x + this.__dragOffset[0], pos.y + this.__dragOffset[1]);
        }
      } else {
        this.__pressTimer = 0;
        if (this.__dragOffset != null) {
          this._saveLastDragPos();
          return this.__dragOffset = null;
        }
      }
    }

    _isProperMouseCursorPos(pos) {
      var maxH, maxW, wall;
      if (this._wallMargin === 0) {
        return true;
      }
      maxW = Graphics.width;
      maxH = Graphics.height;
      wall = this._wallMargin;
      if (pos.x < wall) {
        return false;
      }
      if (pos.x > (maxW - wall)) {
        return false;
      }
      if (pos.y < wall) {
        return false;
      }
      if (pos.y > (maxH - wall)) {
        return false;
      }
      return true;
    }

    _saveLastDragPos() {
      return $gameTemp.__lastInventoryDragPos = [this.invSprite.x, this.invSprite.y];
    }

    placeItemToPanel(index) {
      var cellUnderMouse, e;
      if (this._loadedCatIndex !== 0) {
        return false;
      }
      cellUnderMouse = this.content.getHoveredCell();
      if (cellUnderMouse == null) {
        return false;
      }
      if (!cellUnderMouse.isEnabled()) {
        return false;
      }
      if (cellUnderMouse.item != null) {
        try {
          $gameParty.leader().setItemOnPanel(cellUnderMouse.item.id, index - 1);
          SoundManager.playEquip();
          this._refreshCellItem(cellUnderMouse);
          return true;
        } catch (error) {
          e = error;
          AA.warning(e);
        }
      }
      return false;
    }

    _refreshCellItem(cell) {
      //item = cell.item
      //cell.clear()
      //76cell.setItem(item)
      this._loadPage(this._currentPage);
    }

    placeWeaponToFavorite(index) {
      var cellUnderMouse, e;
      if (this._loadedCatIndex === 2) {
        return false;
      }
      cellUnderMouse = this.content.getHoveredCell();
      if (cellUnderMouse == null) {
        return false;
      }
      if (!cellUnderMouse.isEnabled()) {
        return false;
      }
      if (cellUnderMouse.item != null) {
        try {
          $gameParty.leader().setFavWeap(cellUnderMouse.item, index);
          SoundManager.playEquip();
          this._refreshCellItem(cellUnderMouse);
          return true;
        } catch (error) {
          e = error;
          AA.warning(e);
        }
      }
      return false;
    }

  };
  AA.register(MapInvController);
})();

// ■ END MapInvController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvPartySelectCntrl.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MapInvPartySelectCntrl;
  MapInvPartySelectCntrl = class MapInvPartySelectCntrl {
    constructor(contentSprite, partyUseCases) {
      this.contentSprite = contentSprite;
      this.partyUseCases = partyUseCases;
      this._actors = this.contentSprite.createPartyActors();
      this._checkEnabled();
      this.open();
    }

    _checkEnabled() {
      var i, j, k, len, ref, results;
      ref = this.partyUseCases;
      results = [];
      for (j = k = 0, len = ref.length; k < len; j = ++k) {
        i = ref[j];
        if (!i) {
          results.push(this._actors[j].disable());
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    open() {
      var ref, ref1, ref2, ref3;
      if ((ref = this._actors[0]) != null) {
        ref.moveLeft();
      }
      if ((ref1 = this._actors[1]) != null) {
        ref1.moveRight();
      }
      if ((ref2 = this._actors[2]) != null) {
        ref2.moveDown();
      }
      return (ref3 = this._actors[3]) != null ? ref3.moveUp() : void 0;
    }

    close() {
      var i, k, len, ref;
      ref = this._actors;
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        i.close();
      }
      return this.terminate();
    }

    //setTimeout @terminate.bind(@), 200
    update() {}

    terminate() {
      var e, ref, ref1;
      try {
        if ((ref = this.contentSprite) != null) {
          ref.destroyPartyActors();
        }
        return (ref1 = this.contentSprite) != null ? ref1.clearFocus() : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

  };
  AA.register(MapInvPartySelectCntrl);
})();

// ■ END MapInvPartySelectCntrl.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SliderController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SliderController;
  SliderController = class SliderController {
    constructor(contentSprite, type) {
      var mA, mB;
      this.contentSprite = contentSprite;
      if (type === 0) {
        mA = AA.UI.onSliderOkClick;
        mB = AA.UI.onSliderValueChanged;
      } else if (type === 1) {
        mA = AA.UI.onSliderChestOkClick;
        mB = AA.UI.onSliderChestValueChanged;
      }
      this.contentSprite.createSlider(mA, mB);
    }

    close() {
      return this.terminate();
    }

    terminate() {
      var e, ref, ref1;
      try {
        if ((ref = this.contentSprite) != null) {
          ref.destroySlider();
        }
        return (ref1 = this.contentSprite) != null ? ref1.clearFocus() : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    }

  };
  AA.register(SliderController);
})();

// ■ END SliderController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var MapSkillController;
  // * Много из MapInvController
  MapSkillController = class MapSkillController extends AA.LIBS.MapInvController {
    constructor(invSprite, layer) {
      super(invSprite, layer);
      this.activeActor = $gameParty.leader();
    }

    open() {
      super.open();
      return this.setActiveActor($gameParty.leader());
    }

    _config() {
      this._moveToLastPos();
      if (!AA.Parameters.get_MapSkillWindowAllowDrag()) {
        return this._updateInvDrag = function() {};
      }
    }

    terminate() {
      if (this.isInventoryActive()) {
        return this.close();
      }
    }

    // * Not focus at yet now
    isSomeItemFocused() {
      return false;
    }

    //TODO: Поддержка других в след. обновлении
    setActiveActor(activeActor) {
      this.activeActor = activeActor;
      $gameTemp._aaSkillWindowActiveActor = this.activeActor;
      //TODO: header must redraw categories
      this.invSprite._header.drawActorSkillsCategories(this.activeActor);
      // * Тут путаница, так как категории с 0, а типы с 1
      return this.loadItemsInCategory(this.activeActor.addedSkillTypes()[0] - 1);
    }

    loadItemsInCategory(catIndex = 0) {
      if (!this.isInventoryActive()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      this._hideHelp();
      this._onNewCategoryWillLoad();
      this._loadedCatIndex = catIndex;
      this.content.clearAllItems();
      this._loadSkillForType(catIndex);
      return this._onNewCategoryLoaded();
    }

    _loadSkillForType(sType) {
      var items;
      //"LOAD SKILLS FOR STYPE".p(sType)
      items = this.activeActor.skills().filter(function(i) {
        return i.stypeId === (sType + 1);
      });
      this._loadedItems = items;
      //TODO: Добавить какую - либо сортировку?
      //@_sortByUsable()
      this._setPages();
      return this._showItemsGroup(0);
    }

    
      //$[OVER]
    _onGoldTick() {
      var mana;
      if (this.activeActor == null) {
        return;
      }
      mana = this.activeActor.mp + "\\" + this.activeActor.mmp;
      return this.invSprite._footer.drawMana(mana);
    }

    _moveToLastPos() {
      if ($gameTemp.__lastSkillWindowDragPos != null) {
        return this.invSprite.move($gameTemp.__lastSkillWindowDragPos);
      }
    }

    _saveLastDragPos() {
      return $gameTemp.__lastSkillWindowDragPos = [this.invSprite.x, this.invSprite.y];
    }

    _getCategoryTitle(index) {
      return $dataSystem.skillTypes[index + 1];
    }

    placeWeaponToFavorite(index) {} // * NOTHING

    placeItemToPanel(index) {
      var cellUnderMouse, e;
      if (this.activeActor !== $gameParty.leader()) {
        // * Only for player
        return false;
      }
      cellUnderMouse = this.content.getHoveredCell();
      if (cellUnderMouse == null) {
        return false;
      }
      if (!cellUnderMouse.isEnabled()) {
        return false;
      }
      if (cellUnderMouse.item != null) {
        try {
          $gameParty.leader().setSkillOnPanel(cellUnderMouse.item.id, index - 1);
          SoundManager.playEquip();
          this._refreshCellItem(cellUnderMouse);
          return true;
        } catch (error) {
          e = error;
          AA.warning(e);
        }
      }
      return false;
    }

    //TODO: Описание для не ABS навыков добавить!
    _createHelpWindow() {
      var absSkill;
      if (!AA.isABS()) { // TODO: на не ABS карте тоже нет описания пока что
        return;
      }
      absSkill = this.activeActor.skillABS_byId(this.__lastHelpItem.item.id, false);
      if (absSkill == null) {
        this.__lastHelpItem = null;
        this._hideHelp();
        return;
      }
      this._itemDescWindow = new AA.LIBS.SpriteSpellInfo(absSkill, false);
      this._waitTime = AA.JSON.getUIMapSkillSettings().helpWindow.showDelay;
      //@_itemDescWindow.delay()
      this._itemDescShowTimer = new AATimedUpdate(1, this._onShowTimeTick.bind(this));
      this._itemDescWindow.opacity = 0;
      //@_itemDescWindow.setup(@__lastHelpItem)
      this._placeDescription();
      return this.layer.addChild(this._itemDescWindow);
    }

    _placeDescription() {
      var e;
      try {
        if (this._itemDescWindow == null) {
          return;
        }
        return this._itemDescWindow.refreshPlacementForSkillWindow(this.__lastHelpItem);
      } catch (error) {
        e = error;
        return AA.warning('_placeDescription', e);
      }
    }

    _onActionItem(cell) {
      if (!cell.isEnabled()) {
        return;
      }
      if (this.isSomeItemFocused()) {
        return;
      }
      return this._onActionOnSkillItem(cell);
    }

    _onAction(cell) {
      var e;
      try {
        return this._onActionItem(cell);
      } catch (error) {
        e = error;
        return AA.warning('skillWindow:_onAction', e);
      }
    }

    _onActionOnSkillItem(cell) {
      var item;
      item = cell.item;
      // * Если нет цели, если использовать в меню или всегда, то выполнять сразу
      if ((item != null) && item.scope === 0 && (item.occasion === 0 || item.occasion === 1)) {
        return;
      }
      //@_useInventoryItemDirect(@activeActor, cell.item)
      //TODO: direct use?
      return this.useSkillItem(cell.item);
    }

    // * Навыки только АБС, поэтому нет смысла в окне навыков на НЕ АБС КАРТЕ
    // * Только если читать описание и добавлять на панель
    //TODO: Добавить возможность выполнения навыков у членов партии
    useSkillItem(item) {
      var indexOnPanel;
      if (AA.isMap()) { // * Пока только игрок может на ABS карте использовать навыки
        if (this.activeActor === $gameParty.leader()) {
          indexOnPanel = $gameParty.leader().skillIndexOnUI(item.id, false);
          if (indexOnPanel >= 0) {
            return $gamePlayer.touchSkillAt(indexOnPanel + 1);
          } else {
            return $gamePlayer.startABSSkillFromInventory(item);
          }
        } else {
          LOGW.p('Only Party Leader can use Skills direct from Skill Window');
          return SoundManager.playBuzzer();
        }
      } else {

      }
    }

  };
  //TODO: direct use?
  //else
  //    allyABS = $gameParty.memberABSByActorId(actor.actorId())
  //    allyABS?.startABSItemFromInventory(item)
  AA.register(MapSkillController);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MiniHPBarController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MiniHPBarController;
  MiniHPBarController = class MiniHPBarController extends AA.LIBS.GaugeController {
    constructor() {
      super(...arguments);
    }

    _needUpdate() {
      if (this._isReady === false) {
        return false;
      }
      if (this.battler == null) {
        return false;
      }
      return true;
    }

  };
  AA.register(MiniHPBarController);
})();

// ■ END MiniHPBarController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NewCastBarController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[TEMP SOLUTION]
(function() {
  var NewCastBarController;
  NewCastBarController = class NewCastBarController {
    constructor(castBarSprite) {
      this.castBarSprite = castBarSprite;
      this._isActive = this.castBarSprite.settings.visible;
      this.castBarSprite.visible = false;
      this._timer = null;
      if (this._isActive) {
        this._thread = AA.setInterval((() => {
          return this._updateThread();
        }), 60);
      }
    }

    _updateThread() {
      if (this._isActive === false) {
        return;
      }
      this._checkPlayerIsCasting();
      if (this._timer == null) {
        return;
      }
      this._updateCastProcess();
      if (this._timer.isReady()) {
        return this.stop();
      }
    }

    _checkPlayerIsCasting() {
      var skill;
      if ($gamePlayer.ABSParams().casting) {
        skill = $gamePlayer.ABSParams().castingSkill;
        if (skill && !skill.isReady() && skill.isCasting()) {
          return this._drawSkillCastStatus(skill);
        }
      } else {
        if ($gamePlayer.ABSParams().castingError) {
          $gamePlayer.ABSParams().castingError = false;
          this.stop();
        }
        return this.castBarSprite.visible = false;
      }
    }

    _drawSkillCastStatus(skill) {
      var iconIndex;
      this.castBarSprite.visible = true;
      iconIndex = skill.skill().iconIndex;
      this.castBarSprite.setIcon(iconIndex);
      this._timer = skill.timer;
      return this.castBarSprite.drawText(skill.name());
    }

    _updateCastProcess() {
      var a, b, p;
      if (this._timer == null) {
        return;
      }
      a = this._timer.getMaxValue();
      b = this._timer.getValue();
      p = b / a;
      this.castBarSprite.drawValue2(this._convertValue(a));
      this.castBarSprite.drawValue1(this._convertValue(b));
      return this.castBarSprite.drawGauge(p);
    }

    _convertValue(value) {
      return Math.round(value / 60 * 10) / 10;
    }

    stop() {
      this.castBarSprite.visible = false;
      return this._timer = null;
    }

    terminate() {
      return AA.clearInterval(this._thread);
    }

  };
  AlphaABS.register(NewCastBarController);
})();

// ■ END NewCastBarController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NewCastBarControllerEnemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[TEMP SOLUTION]
(function() {
  var NewCastBarControllerEnemy;
  NewCastBarControllerEnemy = class NewCastBarControllerEnemy extends AlphaABS.LIBS.NewCastBarController {
    constructor(castBarSprite) {
      super(castBarSprite);
    }

    setTarget(enemy) {
      this.enemy = enemy;
    }

    //$[OVER BASE]
    _checkPlayerIsCasting() {
      var skill;
      if (this.enemy == null) {
        return;
      }
      if ((this.enemy.currentAction() != null) && this.enemy.currentAction().isCasting()) {
        skill = this.enemy.currentAction();
        if (skill && !skill.isReady() && skill.isCasting()) {
          try {
            return this._drawSkillCastStatus(skill);
          } catch (error) {

          }
        }
      } else {
        //TODO:
        return this.stop();
      }
    }

  };
  AlphaABS.register(NewCastBarControllerEnemy);
})();

// ■ END NewCastBarControllerEnemy.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PartyUIActorController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var PartyUIActorController;
  PartyUIActorController = (function() {
    class PartyUIActorController extends AASprite {
      constructor(aaEntity) {
        super();
        this.aaEntity = aaEntity;
        this.actor = this.aaEntity.battler();
        this._reset();
        this._create();
      }

      _reset() {
        this._weapId = -1;
        this._level = -1;
        this._lastAction = -1;
        return this._lastBeh = -1;
      }

      _create() {
        this._createActorPortrait();
        this._createABarrier();
        this._createName();
        this._createActorGauges();
        this._createLevelIcon();
        //@_createTargetIcon() TODO: later
        //@_createStatuses() TODO: later
        this._createCastingBar();
        this._createWeaponIcon();
        this._createActionIcon();
        this._createBehaIcon();
        this.redrawVisualEq();
        this._updThread = new AATimedUpdate(10, this._onUpdThreadTick.bind(this));
        if (AA.Parameters.isLeaderSwapAllowed()) {
          this._readSwitchKeys();
          this._createSwitchLeaderButton();
        }
      }

      _createActorPortrait() {
        var faceIndex, faceName;
        faceName = this.actor.faceName();
        faceIndex = this.actor.faceIndex();
        if (AA.isCCEXImproted === true && this.actor.hasSetImage()) {
          this.faceSprite = new AA.LIBS.SpriteActorPortrait(3, this.actor);
        } else {
          this.faceSprite = new AA.LIBS.SpriteActorPortrait(3, {faceName, faceIndex});
        }
        return this.addChild(this.faceSprite);
      }

      _createABarrier() {
        this._barrierBase = new Sprite();
        return this.addChild(this._barrierBase);
      }

      _createName() {
        var name;
        name = new AA.LIBS.SpriteUIElement('PartyMemberName');
        name.drawTextOnReady(this.actor.name());
        return this.addChild(name);
      }

      _createActorGauges() {
        this._createHPG();
        if (this.aaEntity.behaviorModel().mainTpBar > 0) {
          return this._createTPG();
        } else {
          return this._createMPG();
        }
      }

      _createHPG() {
        var gaugeSprite;
        gaugeSprite = new AA.LIBS.SpriteGauge('hpPM');
        this.addChild(gaugeSprite);
        this._hpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
        this._hpGaugeCntr.setup(this.actor, 'hp', 'mhp');
      }

      _createTPG() {
        var gaugeSprite;
        gaugeSprite = new AA.LIBS.SpriteGauge('tpPM');
        this.addChild(gaugeSprite);
        this._mpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
        this._mpGaugeCntr.setup(this.actor, 'tp', 'mtp');
      }

      _createMPG() {
        var gaugeSprite;
        gaugeSprite = new AA.LIBS.SpriteGauge('mpPM');
        this.addChild(gaugeSprite);
        this._mpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
        this._mpGaugeCntr.setup(this.actor, 'mp', 'mmp');
      }

      _createLevelIcon() {
        this._levelIcon = new AA.LIBS.SpriteUIElement("PartyMemberLevel");
        this._levelIcon.drawTextOnReady(this.actor.level);
        this.refreshLevelIcon();
        return this.addChild(this._levelIcon);
      }

      _createWeaponIcon() {
        this._weaponIconSpr = new AA.LIBS.SpriteUIElement("PartyMemberWeaponIcon");
        this.refreshWeaponIcon();
        return this.addChild(this._weaponIconSpr);
      }

      _onUpdThreadTick() {
        return this._refreshStatusIcons();
      }

      _refreshStatusIcons() {
        this.refreshWeaponIcon();
        this.refreshLevelIcon();
        this.refreshAction();
        return this.refreshBeha();
      }

      refreshWeaponIcon() {
        var iconIndex, weap;
        weap = this.actor.weapons()[0];
        if (weap != null) {
          if (weap.id === this._weapId) {
            return;
          } else {
            this._weapId = weap.id;
            iconIndex = weap.iconIndex;
          }
        } else {
          if (this._weapId !== 0) {
            iconIndex = AA.JSON.getWeaponIconSettings().defaultIcon;
            this._weapId = 0;
          } else {
            return;
          }
        }
        this._weaponIconSpr.drawExtraIcon(iconIndex);
      }

      refreshLevelIcon() {
        if (this._level === this.actor.level) {
          return;
        }
        this._levelIcon.drawText(this.actor.level);
        return this._level = this.actor.level;
      }

      refreshAction() {
        var action, icon, s;
        if (!this._actionIconSpr.visible) {
          return;
        }
        action = this.aaEntity.actionMode();
        if (this._lastAction === action) {
          return;
        }
        this._lastAction = action;
        s = this._actionIconSpr.settings;
        icon = s.actionIcons[action];
        return this._actionIconSpr.drawExtraImg(icon, s.actionIconsMarginX, s.actionIconsMarginY);
      }

      refreshBeha() {
        var behMode, icon, s;
        if (!this._behIconSpr.visible) {
          return;
        }
        behMode = this.aaEntity.behaviorMode();
        if (this._lastBeh === behMode) {
          return;
        }
        this._lastBeh = behMode;
        s = this._behIconSpr.settings;
        icon = s.actionIcons[behMode];
        return this._behIconSpr.drawExtraImg(icon, s.actionIconsMarginX, s.actionIconsMarginY);
      }

      _createActionIcon() {
        this._actionIconSpr = new AA.LIBS.SpriteUIElement("PartyMemberAction");
        this.refreshAction();
        if (AA.Parameters.isOneLeaderSwapMode()) {
          this._actionIconSpr.visible = false;
        }
        return this.addChild(this._actionIconSpr);
      }

      _createBehaIcon() {
        this._behIconSpr = new AA.LIBS.SpriteUIElement("PartyMemberBehavior");
        this.refreshBeha();
        if (AA.Parameters.isOneLeaderSwapMode()) {
          this._behIconSpr.visible = false;
        }
        return this.addChild(this._behIconSpr);
      }

      _createCastingBar() {
        this._castSprite = new AlphaABS.LIBS.SpriteSpellCastAlly();
        this._castController = new AlphaABS.LIBS.NewCastBarControllerEnemy(this._castSprite);
        this._castController.setTarget(this.aaEntity);
        return this.addChild(this._castSprite);
      }

      //? Manual refresh
      refreshABGaugeAndIcon() {
        if (this.actor.isHaveAbBarrier()) {
          return this._createAB();
        } else {
          return this._destroyAB();
        }
      }

      //? Manual
      redrawVisualEq() {
        if (this.actor._getVisualEqData() == null) {
          return this.faceSprite.drawVisualEq(null);
        } else {
          return this.faceSprite.drawVisualEq(this.actor._getVisualEqData());
        }
      }

      update() {
        AASprite.prototype.update.call(this);
        this._hpGaugeCntr.update();
        this._mpGaugeCntr.update();
        this._updThread.update();
        this._updateAB();
        return this._updateLeaderSwitch();
      }

      terminate() {
        var ref, ref1;
        AASprite.prototype.terminate.call(this);
        if ((ref = this._castController) != null) {
          ref.stop();
        }
        return (ref1 = this._castController) != null ? ref1.terminate() : void 0;
      }

    };

    AA.register(PartyUIActorController);

    return PartyUIActorController;

  }).call(this);
})();

// ■ END PartyUIActorController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PartyUIManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//?rev: From NET ABS, урезанный
(function() {
  var PartyUIManager;
  PartyUIManager = class PartyUIManager {
    constructor(spriteset) {
      this.spriteset = spriteset;
      this.partyUIgroup = [];
      this.settings = AA.JSON.getCommonUISettings().PartyUIGroup;
      this._initUIGroup();
      this.createPartyUI();
      this.createControlCircle();
      this.refreshBarriers();
    }

    onActorSummonAny() {
      this.partyUiGroupCont.x += this.settings.PositionModWhenSummon[0];
      return this.partyUiGroupCont.y += this.settings.PositionModWhenSummon[1];
    }

    onSummonCancel() {
      this.partyUiGroupCont.x -= this.settings.PositionModWhenSummon[0];
      return this.partyUiGroupCont.y -= this.settings.PositionModWhenSummon[1];
    }

    createPartyUI() {
      var a, actors, i, len;
      actors = $gameParty.membersABS();
      for (i = 0, len = actors.length; i < len; i++) {
        a = actors[i];
        this.createPartyUIForActor(a.AAEntity());
      }
    }

    isCircleExists() {
      return this.circle != null;
    }

    createPartyUIForActor(absEntity) {
      var actorUI, index;
      index = absEntity._memberIndex;
      if (this.partyUIgroup[index] != null) {
        return;
      }
      actorUI = new AA.LIBS.PartyUIActorController(absEntity);
      this.partyUIgroup[index] = actorUI;
      this.partyUiGroupCont.addChild(actorUI);
    }

    //"Party Member UI created".p()
    createControlCircle() {
      if ($gameParty.isAnyCanChangeBehMode()) {
        // * Потому что картинка круга не прогружается во время и не реагирует на нажатия
        return setTimeout((() => {
          this.circle = new AA.LIBS.Sprite_UIAllyBehCircle(function(index) {
            if (this.isOpen()) {
              return $gamePlayer._touchAllyBehCommandAt(index);
            }
          });
          this.spriteset.addChild(this.circle);
          return this._updateCircleBase = this._updateCircle;
        }), 200);
      } else {
        return this._updateCircleBase = function() {}; // * EMPTY
      }
    }

    redrawVisualEq() {
      var actor, i, len, ref, results;
      ref = this.partyUIgroup;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        results.push(actor != null ? actor.redrawVisualEq() : void 0);
      }
      return results;
    }

    refreshBarriers() {
      var actor, i, len, ref, results;
      ref = this.partyUIgroup;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        results.push(actor != null ? actor.refreshABGaugeAndIcon() : void 0);
      }
      return results;
    }

    update() {
      this.partyUiGroupCont.update();
      return this._updateCircleBase();
    }

    _updateCircleBase() {} // * EMPTY

    _updateCircle() {
      var t;
      this.circle.update();
      if (this.circle.isOpenning()) {
        t = BattleManagerABS.getPlayerTarget();
        if ((t != null) && !t.isEnemy()) {
          this.circle.move(t.screenX(), t.screenY() - 24);
        } else {
          AA.UI.closeAllyBehCircle();
        }
      }
    }

    _initUIGroup() {
      var pos;
      if (this.partyUiGroupCont != null) {
        return;
      }
      this.partyUiGroupCont = new AA.LIBS.SpriteUIContainer(this.settings.PortraitHeight);
      this.partyUiGroupCont.setItemsCount(3);
      this.partyUiGroupCont.setVertical();
      pos = AA.Utils.jsonPos(this.settings.Position);
      this.partyUiGroupCont.move(pos);
      return this.spriteset.addChild(this.partyUiGroupCont);
    }

    terminate() {
      var i, len, ref, x;
      if (this.partyUiGroupCont == null) {
        return;
      }
      ref = this.partyUiGroupCont.items;
      for (i = 0, len = ref.length; i < len; i++) {
        x = ref[i];
        if (x != null) {
          x.terminate();
        }
      }
    }

    isUnderMouseAny() {
      var actor, i, len, ref;
      ref = this.partyUIgroup;
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        if (actor != null ? actor.isUnderMouse() : void 0) {
          return true;
        }
      }
      return false;
    }

  };
  AA.register(PartyUIManager);
})();

// ■ END PartyUIManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Patch_00.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _ALIAS_GHWG, _ALIAS_IMLA;
  _ALIAS_GHWG = Graphics.hasWebGL;
  Graphics.hasWebGL = function() {
    if (Graphics.__hasWebGl != null) {
      return Graphics.__hasWebGl;
    }
    Graphics.__hasWebGl = _ALIAS_GHWG.call(this);
    return Graphics.__hasWebGl;
  };
  _ALIAS_IMLA = ImageManager.loadAnimation;
  ImageManager.loadAnimation = function(filename, hue) {
    if (Graphics.hasWebGL()) {
      hue = 0;
    }
    return _ALIAS_IMLA.call(this, filename, hue);
  };
  (function() {
    var ALIAS_SA_IM, ALIAS_SA_LB, ALIAS_SA_UCS, _;
    
    //@[DEFINES]
    _ = Sprite_Animation.prototype;
    ALIAS_SA_IM = _.initMembers;
    _.initMembers = function() {
      ALIAS_SA_IM.call(this);
      if (!Graphics.hasWebGL()) {
        return;
      }
      this._filter = this._filter || [];
      this._colorMatrix1 = new PIXI.filters.ColorMatrixFilter();
      return this._colorMatrix2 = new PIXI.filters.ColorMatrixFilter();
    };
    ALIAS_SA_LB = _.loadBitmaps;
    _.loadBitmaps = function() {
      if (Graphics.hasWebGL()) {
        this._colorMatrix1.hue(this._animation.animation1Hue);
        this._colorMatrix2.hue(this._animation.animation2Hue);
      }
      return ALIAS_SA_LB.call(this);
    };
    ALIAS_SA_UCS = _.updateCellSprite;
    _.updateCellSprite = function(sprite, cell) {
      var a;
      ALIAS_SA_UCS.call(this, sprite, cell);
      if (!Graphics.hasWebGL()) {
        return;
      }
      a = cell[0];
      if (a >= 0 && a < 100) {
        this._colorMatrix1.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix1];
      } else if (a >= 0 && a >= 100) {
        this._colorMatrix2.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix2];
      }
    };
  })();
  (function() {
    var _ALIAS_WBTC;
    AA.__CCACHE = {};
    _ALIAS_WBTC = Window_Base.prototype.textColor;
    Window_Base.prototype.textColor = function(color) {
      var colorD;
      if (AA.__CCACHE[color] != null) {
        return AA.__CCACHE[color];
      } else {
        colorD = _ALIAS_WBTC.call(this, color);
        AA.__CCACHE[color] = colorD;
        return colorD;
      }
    };
  })();
})();

// ■ END Patch_00.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Patch_00.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    if (!Imported.YEP_CoreEngine)
        (function () {
            //@[ALIAS]
            var _ALIAS_SPRITE_UT = Sprite.prototype.updateTransform;
            Sprite.prototype.updateTransform = function () {
                _ALIAS_SPRITE_UT.call(this);
                this.worldTransform.tx = Math.floor(this.worldTransform.tx);
                this.worldTransform.ty = Math.floor(this.worldTransform.ty);
            };
        })();

})();
// ■ END Patch_00.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopItemBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var PopItemBase;
  PopItemBase = class PopItemBase extends AASprite {
    constructor() {
      super();
    }

    setAnchors(anchor) {}

    dispose() {}

    setSettings(settings) {
      this.settings = settings;
    }

    isDisposed() {
      return false;
    }

    heightLine() {
      return this.height;
    }

    widthLine() {
      return this.width;
    }

    terminate() {}

  };
  AA.register(PopItemBase);
})();

// ■ END PopItemBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopItemText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var PopItemText;
  PopItemText = class PopItemText extends AA.LIBS.PopItemBase {
    constructor() {
      super();
      this._disposed = false;
      this.settings = null;
      this._tick = 0;
      this._zoomSpeed = null;
      this._iconIndex = null;
      this._additionH = 0;
      this._additionW = 0;
      this._init();
    }

    _init() {
      return this.bitmap = new Bitmap(50, 50); // * Используется для расчёта размера текста
    }

    setText(text, color) {
      this.text = text;
      if (color != null) {
        this.tColor = color;
      }
      if (typeof this.tColor === "string") {
        return this.tColor = KDCore.Color.FromHex(this.tColor);
      }
    }

    setIcon(iconIndex) {
      return this._iconIndex = iconIndex;
    }

    create() {
      var e, sprH, sprW;
      if (this.settings == null) {
        return;
      }
      try {
        this.bitmap.fontSize = Math.max(this.settings.text.fontSize, this.settings.changeFontSize);
        sprW = this._calcWidth();
        sprH = this._calcHeight();
        this.baseSprite = new AASprite();
        this._drawOnBase();
        this.textSprite = AASprite.FromBitmap(sprW, sprH);
        this.textSprite.onReady(this._drawText.bind(this));
        this.baseSprite.add(this.textSprite);
        if (this.iconSprite != null) {
          this.baseSprite.add(this.iconSprite);
        }
        this.add(this.baseSprite);
        return this._startTimer();
      } catch (error) {
        e = error;
        return AA.warning('error while create PopUp Text, check JSON settings!', e);
      }
    }

    _calcWidth() {
      var sprW, w;
      w = this.bitmap.measureTextWidth(this.text);
      sprW = w + 4;
      return sprW;
    }

    _calcHeight() {
      return this.settings.text.fontSize + 10;
    }

    _drawOnBase() {} //?EMPTY

    setAnchors(xAnchor) {
      var sprW;
      if (this.iconSprite != null) {
        this.iconSprite.anchor.x = xAnchor;
        this.iconSprite.anchor.y = 0.5;
        sprW = this._calcWidth();
        if (xAnchor === 0.5) {
          this.iconSprite.move(-sprW / 2 - this.settings.iconSize / 2, 0);
        }
        if (xAnchor === 1) {
          this.iconSprite.move(-sprW, 0);
        }
        if (xAnchor === 0) {
          this.textSprite.move(this.settings.iconSize, 0);
        }
      }
      if (this.baseSprite) {
        this.baseSprite.anchor.x = xAnchor;
        this.baseSprite.anchor.y = 0.5;
      }
      if (this.textSprite) {
        this.textSprite.anchor.x = xAnchor;
        return this.textSprite.anchor.y = 0.5;
      }
    }

    heightLine() {
      if (this.textSprite != null) {
        return this.textSprite.height + this._additionH;
      } else {
        return this.height;
      }
    }

    widthLine() {
      return this.width;
    }

    _drawText() {
      this._applySettings(this.textSprite);
      this._applyEffect();
      if (this.tColor != null) {
        this.textSprite.bitmap.textColor = this.tColor.CSS;
      }
      this._drawTextLine();
      if (this._iconIndex != null) {
        this._drawIcon();
      }
    }

    _applySettings(sprite) {
      return this.applyTextSettingsByJson(sprite, this.settings);
    }

    _applyEffect() {
      return this._zoomSpeed = 1;
    }

    _drawTextLine() {
      this.textSprite.clear();
      return this.textSprite.drawTextFull(this.text, this.settings.text.position);
    }

    _drawIcon() {
      this.iconSprite = AASprite.FromBitmap(this.settings.iconSize);
      return this.iconSprite.drawIcon(0, 0, this._iconIndex, this.settings.iconSize);
    }

    _startTimer() {
      var timer;
      return setTimeout((timer = () => {
        this._updateTimer();
        if (this._disposed === false) {
          return setTimeout(timer, 60);
        }
      }), 60);
    }

    _updateTimer() {
      if (this.textSprite == null) {
        return;
      }
      if (this.parent == null) {
        return;
      }
      return this._updateOpacity();
    }

    _updateOpacity() {
      var maxTime;
      if (AA.UI.isGameShouldPause()) {
        return;
      }
      if (this._zoomSpeed != null) {
        return;
      }
      maxTime = this._getStayTimeMax();
      if (maxTime <= 0) {
        return;
      }
      if (this._tick <= maxTime) {
        return this._tick++;
      } else {
        this.opacity -= 25;
        this._moveToDisapear();
        if (this.opacity <= 0) {
          return this.dispose();
        }
      }
    }

    _getStayTimeMax() {
      return this.settings.stayTime;
    }

    _moveToDisapear() {
      return this.move(this.x, this.y - 1);
    }

    dispose() {
      var ref;
      this._disposed = true;
      this.textSprite = null;
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    update() {
      if (AA.UI.isGameShouldPause()) {
        return;
      }
      super.update();
      return this._updateZoom();
    }

    _updateZoom() {
      var b;
      if (this._zoomSpeed == null) {
        return;
      }
      b = this.textSprite.bitmap;
      if (b.fontSize < this.settings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
        this._drawTextLine();
      } else {
        if (b.fontSize > this.settings.changeFontSize) {
          b.fontSize = b.fontSize - 1;
          this._drawTextLine();
        }
      }
      if (b.fontSize === this.settings.changeFontSize) {
        this._zoomSpeed = null;
      }
    }

    isDisposed() {
      return this._disposed === true;
    }

  };
  AA.register(PopItemText);
})();

// ■ END PopItemText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Mode, PopMachine;
  Mode = {
    NONE: 0,
    TOP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4
  };
  PopMachine = class PopMachine extends AA.LIBS.PopItemBase {
    constructor() {
      super();
      this._items = [];
      this._mode = Mode.TOP;
      this._margin = 0;
      this.setItemsAnchor(0.5); // * CENTER
    }

    setMode(mode) {
      return this._mode = mode;
    }

    setItemsToLeft() {
      return this.setItemsAnchor(1);
    }

    setItemsToRight() {
      return this.setItemsAnchor(0);
    }

    setItemsAnchor(anchor) {
      return this._itemsAnchor = anchor;
    }

    setMargin(margin) {
      return this._margin = margin;
    }

    itemsCount() {
      return this._items.length;
    }

    terminate() {
      var i, j, ref, ref1, results;
      results = [];
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        results.push((ref1 = this._items[i]) != null ? ref1.terminate() : void 0);
      }
      return results;
    }

    clearAll() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        this._clearItem(this._items[i]);
      }
      return this._items = [];
    }

    push(item) {
      if (item.settings == null) {
        return;
      }
      this._items.push(item);
      this._applyAnchorToItem(item);
      this.addChild(item);
      return this.refresh();
    }

    _applyAnchorToItem(item) {
      return item.setAnchors(this._itemsAnchor);
    }

    refresh() {
      this._clearDisposed();
      if (this._mode === Mode.NONE) {
        this._refreshNoneMode();
        return;
      }
      this._refreshMode();
    }

    _refreshNoneMode() {
      if (this._items.length > 1) {
        this._clearItem(this._items[0]);
        return this._clearDisposed();
      }
    }

    _clearItem(item) {
      if (item == null) {
        return;
      }
      return item.dispose();
    }

    _clearDisposed() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].isDisposed()) {
          this._items[i] = null;
        }
      }
      return this._items.delete(null);
    }

    _refreshMode() {
      var _position, i, j, lastIndex, ref, results;
      if (this._items.length === 0) {
        return;
      }
      lastIndex = this._items.length - 1;
      results = [];
      for (i = j = ref = lastIndex; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
        if (i === lastIndex) {
          _position = {
            x: 0,
            y: 0
          };
        } else {
          _position = this._calculatePosition(i);
        }
        results.push(this._items[i].move(_position.x, _position.y));
      }
      return results;
    }

    _calculatePosition(i) {
      var x, y;
      x = y = 0;
      if (this._mode === Mode.TOP) {
        y = this._items[i + 1].y - this._items[i + 1].heightLine() - this._margin;
      }
      if (this._mode === Mode.DOWN) {
        y = this._items[i + 1].y + this._items[i + 1].heightLine() + this._margin;
      }
      if (this._mode === Mode.LEFT) {
        x = this._items[i + 1].x - this._items[i + 1].widthLine() - this._margin;
      }
      if (this._mode === Mode.RIGHT) {
        x = this._items[i + 1].x + this._items[i + 1].widthLine() + this._margin;
      }
      return {x, y};
    }

  };
  PopMachine.Mode = Mode;
  AA.register(PopMachine);
})();

// ■ END PopMachine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
var Scene_AADBEnemiesEditor;

Scene_AADBEnemiesEditor = class Scene_AADBEnemiesEditor extends Scene_Base {
  constructor() {
    super();
    if ($gameTemp._aaDBmodifiedEnemies == null) {
      $gameTemp._aaDBmodifiedEnemies = [];
    }
    this.isMainSceneActive = true;
    this.isSelectorActive = false;
  }

  create() {
    super.create();
    Scene_MenuBase.prototype.createBackground.call(this);
    this._createMainField();
    this.createWindowLayer();
    return this._createEditWindows();
  }

  createWindowLayer() {
    this._windowLayer = new WindowLayer();
    this._windowLayer.move(this.mainField.x, this.mainField.y, this.mainField.width, this.mainField.height);
    return this.addChild(this._windowLayer);
  }

  start() {
    super.start();
    return this.activateSelectEnemyWindow();
  }

  stop() {
    super.stop();
    return AADBEditorManager.saveEnemiesJsonData();
  }

  add(child) {
    return this.mainField.add(child);
  }

  update() {
    super.update();
    if (this.isMainSceneActive === true) {
      return this._updateMain();
    } else {
      return this._updateNotMain();
    }
  }

  _updateMain() {
    if (Input.isCancel()) {
      return AADBEditorManager.closeEnemiesEditor();
    }
  }

  _updateNotMain() {
    if (Input.isCancel()) {
      if (this.isSelectorActive === true) {
        return this.closeOptionSelectWindow();
      } else {
        this.closeEnemyEditorABS();
        return this.activateSelectEnemyWindow();
      }
    }
  }

};

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Base.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Scene_Base_update = Scene_Base.prototype.update;
    Scene_Base.prototype.update = function () {
        _alias_Scene_Base_update.call(this);
        if(this._aaGpStateCheck)
            this._aaGpStateCheck.update();
        
    };

    //@[ALIAS]
    var _alias_Scene_Base_create = Scene_Base.prototype.create;
    Scene_Base.prototype.create = function () {
        _alias_Scene_Base_create.call(this);
        this._aaGpStateCheck = new AATimedUpdate(60, function() {
            Input.refreshGPState();
        });
    };

})();
// ■ END Scene_Base.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {

  var LOG = new KDCore.DevLog("Scene_Map");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

  var _Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
  Scene_Map.prototype.onMapLoaded = function () {
    _Scene_Map_onMapLoaded.call(this);
    BattleManagerABS.onMapLoaded();
    if ($gameMap.isABS()) {
      Input.refreshGPState();
      this._sVectors = []; //Vectors to delete from $gameMap
      this._spriteset.initABS();
      if ($gameTemp.transferedByDeathABS == true) {
        SceneManager.goto(Scene_Gameover);
        return;
      }
      $gameParty.refreshABS();
      if (AA.Parameters.get_IsKeepSummonUnit()) {
        setTimeout(() => {
          $gameTemp.restoreSummonUnit();
        }, 500);
      }
    } else {
      $gameTemp.clearSavedSummonUnit();
      if ($gameTemp.transferedByDeathABS == true) {
        var deadEventId = AlphaABS.Parameters.get_DeadMapCommonEventId2();
        if (deadEventId > 0) {
          if ($dataCommonEvents[deadEventId]) {
            $gameTemp.reserveCommonEvent(deadEventId);
          }
        }
        $gamePlayer.requestMotion('none');
      }
      uAPI.refreshWeightSystem();
    }
    $gameTemp.transferedByDeathABS = false;
  };

  var _Scene_Map_checkGameover = Scene_Map.prototype.checkGameover;
  Scene_Map.prototype.checkGameover = function () {
    if ($gameMap.isABS()) {
      //NOTHING! see Game_Player
    } else
      _Scene_Map_checkGameover.call(this);
  };

  var _Scene_Map_terminate = Scene_Map.prototype.terminate;
  Scene_Map.prototype.terminate = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleUI.terminate();
      if (this._pEngine)
        this._pEngine.terminate();
      if ($gameTemp.transferedByDeathABS == true) {
        $gamePlayer.requestMotion('none');
      }
    }
    _Scene_Map_terminate.call(this);
  };

  var _Scene_Map_stop = Scene_Map.prototype.stop;
  Scene_Map.prototype.stop = function () {
    if ($gameMap.isABS()) {
      BattleManagerABS.setPlayerTarget(null);
      $gamePlayer.prepareABS();
      if (AlphaABS.BattleUI.isUI())
        AlphaABS.BattleUI.getUI().hide();
      AA.BattleUI.terminateEUI();
      $gameParty.terminateABSSession();
      AudioManager.clearLoopBuffer();
    }
    _Scene_Map_stop.call(this);
  };

  //NEW
  Scene_Map.prototype._updateABS = function () {
    if(AA.UI.isGameShouldPause()) return;
    $gameMap.ABSParams().sVectors.forEach(function (item) {
      if (item) {
        if (item.isStarted()) {
          if (!item.isAlive()) {
            AlphaABS.BattleManagerABS.battleProcess().performPostBattleAction(item);
            //LOG.p("Delete SVector from Map");
            this._sVectors.push(item);
          }
        } else {
          this._spriteset.addChild(item.sprite);
          item.start();
          try {
            if (item.hasEmitter() && this._pEngine)
              this._pEngine.addEmitter(item.emitter(), true);
          } catch (e) {
            console.error(e);
          }
        }
        item.update();
      }
    }.bind(this));

    if (this._sVectors.length > 0) {
      this._sVectors.forEach(function (item) {
        $gameMap.ABSParams().sVectors.delete(item);
      });
      this._sVectors = [];
    }
  };

  //OVER
  var _Scene_Map_processMapTouch = Scene_Map.prototype.processMapTouch;
  Scene_Map.prototype.processMapTouch = function () {
    if (!$gameMap.isABS()) {
      _Scene_Map_processMapTouch.call(this);
      return;
    }

    // * Party Leader Swap Addon
    var ref;
    if (TouchInput.isTriggered() && AA.Parameters.isLeaderSwapAllowed()) {
      if (AA.isABS() && (AA.UI._ui != null)) {
        if ((ref = AA.UI._ui.partyUIGroup) != null ? ref.isUnderMouseAny() : void 0) {
          return;
        }
      }
    }

    if (!this.processMapTouchCanceling()) {
      return;
    }

    if (!$gamePlayer.inActive()) {
      return;
    }

    if (!$gamePlayer.canControl()) {
      return;
    }

    // * AnimaX and NoTarget attack repeated
    if (TouchInput.isPressed() && AA.Parameters.get_IsAlwaysAttackByMouse()) {
      this._touchCount++;
    }

    if (TouchInput.isTriggered() || this._touchCount > 0) {

      $gameTemp.___AA_CAN_MOVE_ANALOG = true;

      if (this.sceneButtonSystem != null && this.sceneButtonSystem.isAnyButtonInTouchPoint()) {
        $gameTemp.___AA_CAN_MOVE_ANALOG = false;
        return;
      }

      if (TouchInput.isPressed()) {
        if (this._touchCount === 0 || this._touchCount >= 15) {

          if (AlphaABS.BattleUI.isWeaponCircleTouchedAny() || AlphaABS.BattleUI.isSummonCircleTouchedAny() || AA.BattleUI.isProcessEUITouch()) {
            $gameTemp.___AA_CAN_MOVE_ANALOG = false;
            return;
          }

          if (!AA.Parameters.get_IsMouseMoveMode()) {
            $gameTemp.___AA_CAN_MOVE_ANALOG = false;
          }

          var indexT = AlphaABS.BattleUI.isTouched();
          if (indexT != null && indexT[1] != null) {
            if (indexT[0] == 'skill')
              $gamePlayer.touchSkillAt(indexT[1]);
            if (indexT[0] == 'panel')
              $gamePlayer.touchControlAt(indexT[1]);
              $gameTemp.___AA_CAN_MOVE_ANALOG = false;
            return;
          } else {
            var selected = null;
            var t = this._spriteset.spritesABS();
            for (var i = 0; i < t.length; i++) {
              if (t[i].isTouched()) {
                selected = t[i];
                break;
              }
            }

            var x = $gameMap.canvasToMapX(TouchInput.x);
            var y = $gameMap.canvasToMapY(TouchInput.y);

            if (selected && selected.character().inActive()) {
              var target = selected.character();
              if (target != BattleManagerABS.getPlayerTarget()) {
                if (target.isSummonUnit()) {
                  // * NOTHING SPECIAL FOR SUMMON UNIT
                  $gamePlayer.stopFollowMode();
                  $gameTemp.setDestination(x, y);
                } else {
                  if (!selected.character().isAlly($gamePlayer)) {
                    BattleManagerABS.setPlayerTarget(target);
                    LOG.p("Selected " + target.event().name);
                    $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                  } else {
                    if (AA.Parameters.get_IsPlayerCanSelectAlliesOnMap()) {
                      BattleManagerABS.setPlayerTarget(target);
                      LOG.p("Selected ally " + target.battler().name());
                      $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                    } else {
                      // * NOTHING SPECIAL
                      $gamePlayer.stopFollowMode();
                      $gameTemp.setDestination(x, y);
                    }
                  }
                }
                $gameMap.ABSParams().menuClickCount = 0;
              } else {
                $gamePlayer.stopFollowMode();
                if ($gamePlayer.isNoTargetAttackMode()) {
                  if (!AA.Parameters.get_IsAlwaysAttackByMouse())
                    $gamePlayer.onMouseAttackOnTarget();
                  if (!$gamePlayer._isRangeToTargetGood()) {
                    $gameTemp.setDestination(x, y);
                  }
                  else
                    $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                } else {
                  $gameTemp.setDestination(x, y);
                }
                $gamePlayer.stopFollowMode();
              }
              if (AA.Parameters.get_IsAlwaysAttackByMouse()) {
                $gamePlayer.turnTowardCharacter(new KDCore.Point(x, y));
                $gamePlayer._onAttackClick();
              }
            } else {
              if (AA.Parameters.get_IsAlwaysAttackByMouse()) {
                $gamePlayer.turnTowardCharacter(new KDCore.Point(x, y));
                $gamePlayer._onAttackClick();
              } else {
                $gamePlayer.stopFollowMode();
                $gameTemp.setDestination(x, y);
              }
            }
          }
        }
        this._touchCount++;
      } else {
        this._touchCount = 0;
      }
    }
  };

  //?[NEW]
  Scene_Map.prototype.processMapTouchCanceling = function () {
      if (TouchInput.isCancelled() || Input.isTriggered(AAGamePadManager.MenuKey())) {
        if (TouchInput.isCancelled()) {
          //TODO: ПЕРЕДЕЛАТЬ!
          if (AA.UI.isInventoryOpened() || AA.UI.isUserChestIsOpen() || AA.UI.isSkillWindowIsOpen() || AA.UI.isStatusWindowIsOpen()) {
            $gameMap.ABSParams().menuClickCount = 0;
            if (AA.UI.isUserChestIsOpen())
              AA.UI.closeUserChest();
            else if (AA.UI.isInventoryOpened())
              AA.UI.closeInventory();
            else if (AA.UI.isStatusWindowIsOpen())
              AA.UI.closeStatusWindow();
            else
              AA.UI.closeSkillWindow();
            return false;
          }
        }
        if ($gamePlayer._absParams.state == 'targetCircle') {
          $gameMap.ABSParams().menuClickCount = 0;
          return false;
        }
        if (BattleManagerABS.getPlayerTarget() == null) {
          $gameMap.ABSParams().menuClickCount++;
        } else {
          BattleManagerABS.setPlayerTarget(null);
          $gameMap.ABSParams().menuClickCount = 0;
        }
      }
      return true;
  };

  //@[ALIAS]
  var _Scene_Map_isMenuCalled = Scene_Map.prototype.isMenuCalled;
  Scene_Map.prototype.isMenuCalled = function () {
    if ($gameMap.isABS()) {
      if (BattleManagerABS.getPlayerTarget() == null &&
        $gameMap.ABSParams().menuClickCount > 0) {
          if(Input.isGamepad())
            return TouchInput.isCancelled() || Input.isTriggered(AAGamePadManager.MenuKey());
          else
            return TouchInput.isCancelled() || Input.isTriggered('menu');
      } else
        if (Input.isGamepad()) {
          Input.isTriggered(AAGamePadManager.MenuKey());
        } else
          return Input.isTriggered('menu');
    }
    else
      if (Input.isGamepad()) {
        return Input.isTriggered(AAGamePadManager.MenuKey()) || TouchInput.isCancelled();
      } else
        return _Scene_Map_isMenuCalled.call(this);
  };


  if (AA.EventInfoExtension) {
    //@[ALIAS]
    var _alias_Scene_Map_isMenuCalledXXX = Scene_Map.prototype.isMenuCalled;
    Scene_Map.prototype.isMenuCalled = function () {
      var result = _alias_Scene_Map_isMenuCalledXXX.call(this);
      if (TouchInput.isPressed2()) {
        if (AA.EventInfoExtension.isEventWithPictureUnderCursor()) {
          return false;
        }
      }
      if (Input.isTriggered('menu')) {


        if (AA.UI.isInventoryOpened() || AA.UI.isUserChestIsOpen() || AA.UI.isSkillWindowIsOpen() || AA.UI.isStatusWindowIsOpen()) {
          if (AA.UI.isUserChestIsOpen())
              AA.UI.closeUserChest();
            else if (AA.UI.isInventoryOpened())
              AA.UI.closeInventory();
            else if (AA.UI.isStatusWindowIsOpen())
              AA.UI.closeStatusWindow();
            else
              AA.UI.closeSkillWindow();
            return false;
        }
      }
      return result;
    };
  }

  //OVER
  Scene_Map.prototype.updateCallMenu = function () {
    if (this.isMenuEnabled()) {
      if (this.isMenuCalled()) {
        this.menuCalling = true;
      }
      if (this.menuCalling && !$gamePlayer.isMoving()) {
        if ($gameParty.inBattle()) {
          BattleManagerABS.alertNoInBattle();
          this.menuCalling = false;
        } else
          this.callMenu();
      }
    } else {
      this.menuCalling = false;
    }
  };

  var _Scene_Map_createSpriteset = Scene_Map.prototype.createSpriteset;
  Scene_Map.prototype.createSpriteset = function () {
    _Scene_Map_createSpriteset.call(this);
    if ($gameMap.isABS()) {
      this._createABSUI();
    } else {
      this._createABSCommonUI();
    }
  };

  //?[NEW]
  Scene_Map.prototype._createABSUI = function () {
      if ($gameMap.isABS()) {
        this._spritesetUI = new AlphaABS.LIBS.Spriteset_InterfaceABS();
        this.addChild(this._spritesetUI);
        AlphaABS.BattleUI.setUI(this._spritesetUI);
      }
  };


  //?[NEW]
  Scene_Map.prototype._createABSCommonUI = function () {
      this._spritesetCUI = new Spriteset_AA_CommonUI();
      this.addChild(this._spritesetCUI);
      AlphaABS.BattleUI.setCUI(this._spritesetCUI);
  };
})();


// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onMapLoaded, ALIAS__update, _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //@[ALIAS]
  ALIAS__onMapLoaded = _.onMapLoaded;
  _.onMapLoaded = function() {
    if (AA.__absSystemInited == null) {
      Scene_Boot.prototype.initABSSystem.call(this);
    }
    ALIAS__onMapLoaded.call(this);
    this.aaScrollTimer = 0;
    this._aaExtraRefreshPlayer();
    this.axPreloadAllAnimationOnMap();
    if (AA.Parameters.isUseAlternativeAnimaXPreload()) {
      this.axPreloadAllAnimationOnMap2();
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    this.aaUpdateMapScroolByMouse(); // _Scroll
    if (!$gameMap.isABS()) {
      return;
    }
    BattleManagerABS.updateABS();
    this._updateABS();
    if (AA.BattleUI.isUI()) {
      return this._refreshWeaponCirclePosition();
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _._aaExtraRefreshPlayer = function() {
    $gamePlayer.refresh();
    setTimeout((function() {
      return $gamePlayer.refresh();
    }), 20);
    setTimeout((function() {
      return $gamePlayer.refresh();
    }), 50);
    setTimeout((function() {
      return $gamePlayer.refresh();
    }), 100);
  };
  _._refreshWeaponCirclePosition = function() {
    var p;
    if ((this._spriteset != null) && (this._spriteset._spritePlayerABS != null)) {
      p = this._spriteset._spritePlayerABS;
      AA.BattleUI.moveWeaponCircle(p.x, p.y - 24);
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaUpdateMapScroolByMouse = function() {
    var p;
    p = AA.Parameters.xMapScrollSettings();
    if (p == null) {
      this.aaUpdateMapScroolByMouse = function() {}; // * EMPTY
    } else {
      if (p.isEnabledOnAbs === false && p.isEnabledOnNonAbs === false) {
        this.aaUpdateMapScroolByMouse = function() {}; // * EMPTY
        return;
      }
      if ($gameMap.isABS() && p.isEnabledOnAbs === true) {
        this.aaUpdateMapScroolByMouseProcess();
      } else if (!$gameMap.isABS() && p.isEnabledOnNonAbs === true) {
        this.aaUpdateMapScroolByMouseProcess();
      }
    }
  };
  _.aaUpdateMapScroolByMouseProcess = function() {
    var delay, isScroll, p, scroolSpeed, zone;
    if ($gamePlayer.isMoving() || $gameTemp.isDestinationValid()) {
      return;
    }
    p = AA.Parameters.xMapScrollSettings();
    // * Когда мышка у края экрана, делать scrol
    isScroll = false;
    scroolSpeed = p.scrollSpeed;
    delay = p.scrollDelay;
    zone = p.screenSize;
    p = TouchInput;
    if (p.y > Graphics.height - zone && p.y <= Graphics.height - 2) {
      $gameMap.startScroll(2, 1, scroolSpeed);
      this.aaScrollTimer++;
      if (this.aaScrollTimer > delay) {
        isScroll = true;
      }
    } else {

    }
    if (p.y >= 2 && p.y < zone) {
      $gameMap.startScroll(8, 1, scroolSpeed);
      this.aaScrollTimer++;
      if (this.aaScrollTimer > delay) {
        isScroll = true;
      }
    } else {

    }
    if (p.x >= 2 && p.x < zone) {
      $gameMap.startScroll(4, 1, scroolSpeed);
      this.aaScrollTimer++;
      if (this.aaScrollTimer > delay) {
        isScroll = true;
      }
    } else {

    }
    if (p.x > Graphics.width - zone && p.x <= Graphics.width - 2) {
      $gameMap.startScroll(6, 1, scroolSpeed);
      this.aaScrollTimer++;
      if (this.aaScrollTimer > delay) {
        isScroll = true;
      }
    }
    if (!isScroll) {
      $gameMap.startScroll(0, 0, 0);
      if (this.aaScrollTimer > delay) {
        this.aaScrollTimer = 0;
      }
    }
    if (isScroll === true) {
      $gameTemp.aaIsScrollBeenApplied = isScroll;
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.axPreloadAllAnimationOnMap = function() {
    var e, ev, f, j, k, len, len1, ref, ref1;
    try {
      if ($gamePlayer.isAnimX()) {
        $gamePlayer.getCurrentAnimX().preLoad();
      }
      ref = $gamePlayer.followers()._data;
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        if (f.isAnimX()) {
          f.getCurrentAnimX().preLoad();
        }
      }
      ref1 = $gameMap.events();
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        ev = ref1[k];
        if (ev != null ? ev.isAnimX() : void 0) {
          ev.getCurrentAnimX().preLoad();
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  //?X
  _.axPreloadAllAnimationOnMap2 = function() {
    var e, f, j, len, ref;
    try {
      if ($gamePlayer.isAnimX()) {
        this._axPreloadAlternative($gamePlayer.getCurrentAnimX().animations);
      }
      ref = $gamePlayer.followers()._data;
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        if (f.isAnimX()) {
          this._axPreloadAlternative(f.getCurrentAnimX().animations);
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _._axPreloadAlternative = function(animations) {
    var anim, dummySpr, e, i, j, k, len, ref;
    if (animations == null) {
      return;
    }
    try {
      for (j = 0, len = animations.length; j < len; j++) {
        anim = animations[j];
        for (i = k = 0, ref = anim.framesCount; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          dummySpr = new Sprite(anim.getFrame(i));
          dummySpr.x = Graphics.width + 1000;
          dummySpr.y = Graphics.heigth + 1000;
          dummySpr.visible = false;
          this.addChild(dummySpr);
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _alias_Scene_Map_create3232 = Scene_Map.prototype.create;
    Scene_Map.prototype.create = function () {
        _alias_Scene_Map_create3232.call(this);
        //this._devMouse = new AlphaABS.LIBS.Sprite_DevMHelper();
    };

    //@[ALIAS]
    var _alias_Scene_Map_createSpriteset = Scene_Map.prototype.createSpriteset;
    Scene_Map.prototype.createSpriteset = function () {
        _alias_Scene_Map_createSpriteset.call(this);
        var buttonsMainSprite = new Sprite();
        this.addChild(buttonsMainSprite);
        this.sceneButtonSystem = new AlphaABS.LIBS.SceneButtonSystem(buttonsMainSprite);
    };

    //@[ALIAS]
    var _alias_Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function () {
        _alias_Scene_Map_onMapLoaded.call(this, ...arguments);
        if (this.sceneButtonSystem != null)
        {
            if (AlphaABS.Parameters.isUIButtonsAllowed()) {
                if ($gameMap.isABS()) {
                    ButtonsProManager.loadABS();
                }
                ButtonsProManager.loadCustom();
                this.sceneButtonSystem.loadButtons();
                this.sceneButtonSystem.refresh();
                if ($gameMap.isABS() && Input.isGamepad()) {
                    AA.BattleUI.gamePadUI().afterButtonsLoad();
                }
            }
        }
        else
            console.waring('Alpha ABS UI buttons system is NULL');
        //this.addChild(this._devMouse);
        $gameParty.members().forEach(function(m) {
            m._refreshVisualEq();
        });
    };

    //@[ALIAS]
    var _alias_Scene_Map_terminate = Scene_Map.prototype.terminate;
    Scene_Map.prototype.terminate = function () {
        _alias_Scene_Map_terminate.call(this, ...arguments);
        if (this.sceneButtonSystem != null)
            this.sceneButtonSystem.terminate();
    };

    //@[ALIAS]
    var _alias_Scene_Map_isMapTouchOk = Scene_Map.prototype.isMapTouchOk;
    Scene_Map.prototype.isMapTouchOk = function () {
        var result = _alias_Scene_Map_isMapTouchOk.call(this);
        if (result == true) {
            return !ButtonsProManager.isAnyButtonInInputPoint();
        }
        return false;
    };

    //@[ALIAS]
    var _alias_Scene_Map_update = Scene_Map.prototype.update;
    Scene_Map.prototype.update = function () {
        _alias_Scene_Map_update.call(this);
        if (this.sceneButtonSystem != null)
            this.sceneButtonSystem.update();
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        _alias_Scene_Map_stop.call(this);
        if(SceneManager.isNextScene(Scene_Map)) {
            $gamePlayer.deleteSummonUnit();
            AA.clearAllThreads();
            $gamePlayer._clearAAnimMotion();
        }
        if($gameMap.isABS()) {
            if ($gamePlayer.isInAAShieldState()) {
                $gamePlayer._removeAAShieldState();
            }
            $gamePlayer.battler().__canApplyShieldState = false;
            this.sceneButtonSystem.hideAll();
        }
    };
})();
// ■ END Scene_Map.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SceneButtonSystem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SceneButtonSystem;
  SceneButtonSystem = class SceneButtonSystem {
    constructor(scene) {
      this.scene = scene;
      this._buttons = [];
    }

    //@overlayLayer = new Sprite
    loadButtons() {
      var btns;
      btns = ButtonsProManager.getAllButtons();
      return btns.forEach((btn) => {
        return this.addButton(btn);
      });
    }

    //@scene.addChild @overlayLayer
    addButton(buttonSprite) {
      var e;
      try {
        this.scene.addChild(buttonSprite);
        this._buttons.push(buttonSprite);
        return SlowUpdateManager.register(8000 + buttonSprite.buttonId, buttonSprite, 100);
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while add UI button to Scene');
      }
    }

    deleteButton(buttonSprite) {
      if (buttonSprite == null) {
        return;
      }
      this.scene.removeChild(buttonSprite);
      return this._buttons.delete(buttonSprite);
    }

    isAnyButtonOverrideInput() {
      return this._buttons.some(function(btn) {
        return btn.isOverride();
      });
    }

    isAnyButtonInTouchPoint() {
      return this._buttons.some(function(btn) {
        return btn.touchInButton();
      });
    }

    hideAll() {
      return this._buttons.forEach(function(btn) {
        return btn.visible = false;
      });
    }

    showAll() {
      return this._buttons.forEach(function(btn) {
        btn.visible = true;
        return btn.prepare();
      });
    }

    refresh() {
      if ($gameVariables.getUIParam('uiButtonHided') === true) {
        return this.hideAll();
      } else {
        return this.showAll();
      }
    }

    update() {}

    prepare() {
      return this._buttons.forEach(function(btn) {
        return btn.prepare();
      });
    }

    getButtonByName(name) {
      return this._buttons.find(function(btn) {
        return btn.__aaName === name;
      });
    }

    terminate() {
      var e;
      try {
        return this._buttons.forEach(function(btn) {
          return SlowUpdateManager.clear(btn.buttonId);
        });
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while destroy UI button process');
      }
    }

  };
  AlphaABS.register(SceneButtonSystem);
})();

// ■ END SceneButtonSystem.coffee
//---------------------------------------------------------------------------

(function(){

    ImageManager.loadAA('background');

    var isInMousePosition = function (sprite, dx, dy) {
        function inRect(point, rect) {
            var x2, y2;
            try {
                x2 = rect.x + rect.width;
                y2 = rect.y + rect.height;
                return point.x > rect.x && point.x < x2 && point.y < y2 && point.y > rect.y;
            } catch (error) {
                
            }
        }
        if (dx === undefined)
            dx = 0;
        if (dy === undefined)
            dy = 0;
        var rect, rx, ry;
        rx = KDCore.SDK.toGlobalCoord(sprite, 'x');
        ry = KDCore.SDK.toGlobalCoord(sprite, 'y');
        rect = new Rectangle(rx - dx, ry - dy, sprite.width + (dx * 2), sprite.height + (dy * 2));
        return inRect(TouchInput.getMousePosition(), rect);
    };

    function Sprite_NumberSlider() {
        this.initialize.apply(this, arguments);
    }

    Sprite_NumberSlider.prototype = Object.create(Sprite.prototype);
    Sprite_NumberSlider.prototype.constructor = Sprite_NumberSlider;

    Sprite_NumberSlider.prototype.initialize = function (callback, valueChangeCallback) {
        Sprite.prototype.initialize.call(this);
        this.afterLoadCallback = callback;
        this.valueChangeCallback = valueChangeCallback;
        this._create();
    };

    //?[NEW]
    Sprite_NumberSlider.prototype.update = function () {
        Sprite.prototype.update.call(this);
        this.updateSliderMoveByMouse();
    };

    AA.register(Sprite_NumberSlider);

    //@[IMPLEMENTATION]
    (function () {

        //@[DEFINES]
        var _ = Sprite_NumberSlider.prototype;
        var __ = null; //@[PRE]

        _.terminate = function() {
            this.visible = false;
            if (this.parent)
                this.parent.removeChild(this);
            this.destroy();
        };

        //?[NEW]
        _._create = function () {
            __ = AA.JSON.getUIMapInventorySettings().itemSliderSettings;
            this._loadSliderResources();
            this.bitmap = ImageManager.loadAA('background');
            if(this.bitmap.isReady()) {
                this._createAfterLoad();
            } else
                this.bitmap.addLoadListener(_._createAfterLoad.bind(this));
        };

        //?[NEW]
        _._loadSliderResources = function () {
            ImageManager.loadAA('background');
            ImageManager.loadAA('fill');
            ImageManager.loadAA('slider');
        };

        //?[NEW]
        _._createAfterLoad = function () {
            if (!this.bitmap.width) return;
            this._ww = this.bitmap.width;
            //this._createIcon();
            this._createFill();
            this._mouseZone = new Sprite(new Bitmap(this.width + 20, this.height + (__.zoneDY * 2)));
            this._mouseZone.move(-10, -__.zoneDY);
            this.addChild(this._mouseZone);
            if(this.afterLoadCallback)
                this.afterLoadCallback();
        };

        //?[NEW]
        _._createFill = function () {
            var fillBitmap = ImageManager.loadAA('fill');
            var fillImg = new Sprite(fillBitmap);
            fillBitmap.addLoadListener(function () {
                var sliderFill = new Sprite(new Bitmap(fillBitmap.width, fillBitmap.height));
                this.sliderFill = sliderFill;
                this.addChild(this.sliderFill);
                this._createSlider();
            }.bind(this));
            this.fillImg = fillImg;
        };

        //?[NEW]
        _._createSlider = function () {
            this.sliderSprite = new Sprite(ImageManager.loadAA('slider'));
            this.sliderSprite.anchor.x = 0.5;
            this.sliderSprite.move(__.sliderMarginX, __.sliderMarginY);
            this.addChild(this.sliderSprite);

            function applyS() {
                this.setPercent(1);
            }

            setTimeout(applyS.bind(this), 20);
            setTimeout(applyS.bind(this), 50);
            setTimeout(applyS.bind(this), 100);
        };

        //?[NEW]
        _.setPercent = function (percent) {
            try {
                if (!this.sliderFill)
                    return;
                if (!this.fillImg)
                    return;
                if (percent === undefined)
                    percent = 1;
                if (percent > 1)
                    percent = 1;
                var w = this.fillImg.width * percent;
                this._fillSliderBy(w);
            } catch (e) {
                console.warn(e);
            }
        };

        //?[NEW]
        _._fillSliderBy = function (w) {
            //"fill0".p(w);
            this.sliderFill.bitmap.clear();
            this.sliderFill.bitmap.blt(this.fillImg.bitmap, 0, 0, w, this.fillImg.height, 0, 0);
            this.sliderSprite.move(__.sliderMarginX + w - __.sliderDX, __.sliderMarginY);
        };

        //?[NEW]
        _._applyValueSettings = function (w) {
            var percent = (w / this.fillImg.width);
            percent = ~~(percent * 100);
            if (percent < 0)
                percent = 0;
            if (percent > 99)
                percent = 100;
            this.valueChangeCallback(percent);
            this.setPercent(percent / 100);
        };

        _.isInMousePositionAll = function() {
            return isInMousePosition(this._mouseZone, 0, 0);
        };

        _.isInMousePositionHandler = function() {
            return isInMousePosition(this.sliderSprite, 5, 5);
        };

        //?[NEW]
        _.updateSliderMoveByMouse = function () {
            if (!this.sliderSprite)
                return;
            if (!this._mouseZone)
                return;
            if (this.isInMousePositionHandler()) {
                this._canMoveSlider = true;
            }
            if (!this.isInMousePositionAll()) {
                this._canMoveSlider = false;
            } else {
                if (TouchInput.isTriggered() && this._canMoveSlider == false) {
                    this._moveSliderByMouse();
                }
            }

            if (this._canMoveSlider) {
                if (TouchInput.isPressed()) {
                    this._moveSliderByMouse();
                }
            }
        };

        //?[NEW]
        _._moveSliderByMouse = function () {
            var localMPX = Sprite_Button.prototype.canvasToLocalX.call(this, TouchInput.getMousePosition().x);
            if (localMPX <= this.fillImg.width) {
                this._fillSliderBy(localMPX);
                this._applyValueSettings(localMPX);
            }
        };

    })();
    // ===============================================================================
})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SlowUpdateManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var SlowUpdateManager;

SlowUpdateManager = function() {
  throw new Error('Static class');
};

SlowUpdateManager.init = function() {
  this._threadOwners = [];
  this._threadObjects = [];
  return this._threadTimers = [];
};

SlowUpdateManager.register = function(objectId, object, time) {
  var index, thread, timeout;
  if (!(SlowUpdateManager._getOwnerIndex(objectId) >= 0)) {
    this._threadOwners.push(objectId);
    this._threadObjects.push(object);
    object.activateSlowUpdate();
  }
  index = SlowUpdateManager._getOwnerIndex(objectId);
  clearInterval(this._threadTimers[index]);
  thread = AA.setIntervalAI((timeout = function() {
    index = SlowUpdateManager._getOwnerIndex(objectId);
    if (SlowUpdateManager._threadObjects[index] != null) {
      SlowUpdateManager._threadObjects[index].slowUpdate();
    }
  }), time);
  this._threadTimers[index] = thread;
};

SlowUpdateManager._getOwnerIndex = function(owner) {
  if (SlowUpdateManager._threadOwners == null) {
    SlowUpdateManager._threadOwners = [];
  }
  return this._threadOwners.indexOf(owner);
};

SlowUpdateManager.clear = function(objectId) {
  var index;
  //"CLEAR".p(objectId)
  index = SlowUpdateManager._getOwnerIndex(objectId);
  if (index >= 0) {
    AA.clearIntervalAI(this._threadTimers[index]);
    this._threadTimers[index] = null;
    this._threadOwners[index] = null;
    this._threadObjects[index] = null;
    this._threadObjects.delete(null);
    this._threadOwners.delete(null);
    this._threadTimers.delete(null);
  }
};

SlowUpdateManager.clearAll = function() {
  this._threadOwners.forEach(function(id) {
    return SlowUpdateManager.clear(id);
  });
  this._threadOwners = [];
  this._threadObjects = [];
  this._threadTimers = [];
};

// ■ END SlowUpdateManager.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpawnedAiBot.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
function Game_SpawnedAiBot() {
    this.initialize.apply(this, arguments);
}

(function(){
    Game_SpawnedAiBot.prototype = Object.create(Game_AIBot.prototype);
    Game_SpawnedAiBot.prototype.constructor = Game_SpawnedAiBot;

    Game_SpawnedAiBot.prototype.initialize = function (mapId, eventId, enemyId, x, y, spawnEventId) {
        this._spawnX = x;
        this._spawnY = y;
        this._spawnEventId = spawnEventId;
        var keyA = [
            $gameMap.mapId(),
            eventId,
            "A"
        ];
        var keyB = [
            $gameMap.mapId(),
            eventId,
            "B"
        ];
        var keyC = [
            $gameMap.mapId(),
            eventId,
            "C"
        ];
        var keyD = [
            $gameMap.mapId(),
            eventId,
            "D"
        ];
        $gameSelfSwitches.setValue(keyA, false);
        $gameSelfSwitches.setValue(keyB, false);
        $gameSelfSwitches.setValue(keyC, false);
        $gameSelfSwitches.setValue(keyD, false);
        Game_AIBot.prototype.initialize.call(this, mapId, eventId, enemyId);
        DataManager.extractMetadata(this.event());
    };
    Game_SpawnedAiBot.prototype.event = function () {
        return $dataSpawnMapAI.events[this._spawnEventId];
    };
    Game_SpawnedAiBot.prototype.locate = function () {
        var x = this._spawnX;
        var y = this._spawnY;
        Game_AIBot.prototype.locate.call(this, x, y);
    };

    //$[OVER]
    Game_SpawnedAiBot.prototype._storeDeadData = function() {
        //?{EMPTY}
    };

    Game_SpawnedAiBot.prototype.afterAddedOnMap = function() {
        this._absParams.behavior.loadEventMetadata(this.eventId());
    };

})();

// ■ END SpawnedAiBot.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  //Sprite_Animation
  //------------------------------------------------------------------------------
  //NEW
  Sprite_Animation.prototype.setABSMode = function () {
    this._absMode = true;
  };

  Sprite_Animation.prototype.setABSModeMap = function () {
    this._absMode = true;
    this._absModeMap = true;
    this._mapPoint = null;
  };

  var pkd_SpriteAnimation_updatePosition = Sprite_Animation.prototype.updatePosition;
  Sprite_Animation.prototype.updatePosition = function () {
    try {
      if (this._absMode && !this._absModeMap) {
        if (this._animation.position === 3) {
          this.x = this.parent.width / 2;
          this.y = this.parent.height / 2;
        } else {
          var parent = this._target.parent;
          var grandparent = parent ? parent.parent : null;
          this.x = this._target.x;
          this.y = this._target.y;
          if (this.parent === grandparent) {
            this.x += parent.x;
            this.y += parent.y;
          }
          if (this._animation.position === 0) {
            this.y -= this._target.height;
            //this.y -= this._target.height / 2;
          }
        }
        if (this._animation.position === 2) { //FEET
          this.y -= 32;
        }
      } else if (this._absMode && this._absModeMap) {
        if (this._animation.position == 3) {
          this.x = this.parent.width / 2;
          this.y = this.parent.height / 2;
        } else {
          if (!this._mapPoint) {
            this._mapPoint = new KDCore.Point(this._target.x, this._target.y);
            this._mapPoint = this._mapPoint.convertToMap();
          }

          var mapPoint = this._mapPoint.convertToScreen();
          //console.log(this.x);
          this.x = mapPoint.x;
          this.y = mapPoint.y;
        }
      } else {
        pkd_SpriteAnimation_updatePosition.call(this);
      }
    } catch (e) {
      console.error(e);
    }
  };

  var pkd_SpriteAnimation_updateCellSprite = Sprite_Animation.prototype.updateCellSprite;
  Sprite_Animation.prototype.updateCellSprite = function (sprite, cell) {
    pkd_SpriteAnimation_updateCellSprite.call(this, sprite, cell);
    if (this._absMode) {
      var pattern = cell[0];
      if (pattern >= 0) {
        sprite.x = 0;
        sprite.y = 0;
        var t = 4;
        if (this._absModeMap) {
          t = 2;
        }
        if (this._animation.position != 3) {
          sprite.scale.x = (sprite.scale.x / t);
          sprite.scale.y = (sprite.scale.y / t);
        }
      }
    }
  };

  var _Sprite_Animation_initMembers = Sprite_Animation.prototype.initMembers;
  Sprite_Animation.prototype.initMembers = function () {
    _Sprite_Animation_initMembers.call(this);
    this._lightDuration = null;
    this._lightPoint = null;
  };

  var _Sprite_Animation_startFlash = Sprite_Animation.prototype.startFlash;
  Sprite_Animation.prototype.startFlash = function (color, duration) {
    _Sprite_Animation_startFlash.call(this, color, duration);

    try {
      if (!BattleManagerABS.isABSLightingExt() || !this._absMode) return;
      if (this._lightPoint != null) {
        this._deleteLight();
      }
      this._lightDuration = duration;
      if (this._absModeMap)
        this._lightPoint = new KDCore.Point(this.x - 48, this.y - 48);
      else
        this._lightPoint = new KDCore.Point(this.x, this.y);
      this._lightPoint.convertToMap();
      var lightColor = new KDCore.Color(color[0], color[1], color[2]);
      $gameMap.setLight(this._lightPoint.x, this._lightPoint.y, 150, lightColor.toHex(), 0, true);
    } catch (e) {
      console.error(e);
    }
  };

  var _Sprite_Animation_updateFlash = Sprite_Animation.prototype.updateFlash;
  Sprite_Animation.prototype.updateFlash = function () {
    _Sprite_Animation_updateFlash.call(this);

    if (this._lightDuration == null) return;
    this._lightDuration--;
    if (this._lightDuration <= 1) {
      this._deleteLight();
    }
  };

  var _Sprite_Animation_remove = Sprite_Animation.prototype.remove;
  Sprite_Animation.prototype.remove = function () {
    _Sprite_Animation_remove.call(this);
    if (this._lightDuration || this._lightPoint) {
      this._deleteLight();
    }
  };

  //@[ALIAS]
  var _alias_Sprite_Animation_remove = Sprite_Animation.prototype.remove;
  Sprite_Animation.prototype.remove = function () {
    if(this._absModeMap)  {
      if (this.parent && this.parent.removeChild(this)) {
        this._target.setBlendColor([0, 0, 0, 0]);
      }
    } else
      _alias_Sprite_Animation_remove.call(this);
      
  };

  //NEW
  Sprite_Animation.prototype._deleteLight = function () {
    if (this._lightPoint) {
      $gameMap.deleteLight(this._lightPoint.x, this._lightPoint.y);
      this._lightPoint = null;
    }
    this._lightDuration = null;
  };

  //@[ALIAS]
    var _alias_Sprite_Animation_update = Sprite_Animation.prototype.update;
    Sprite_Animation.prototype.update = function () {
        if (AA.UI.isGameShouldPause()) return;
        _alias_Sprite_Animation_update.call(this);
    };

  //END Sprite_Animation
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.5.1
// * Спрайт для анимации слоя (части)
var Sprite_AnimaXPart;

Sprite_AnimaXPart = class Sprite_AnimaXPart extends Sprite {
  constructor(animPart, rootAnimation) {
    super();
    this.animPart = animPart;
    this.animPart.applyRootAnimation(rootAnimation);
    this.visible = !this.animPart.isDisabled();
    this.anchor.x = 0.5;
    this.anchor.y = 1;
    this.isLowerBodyPart = this.animPart.isLowerBodyPart;
    // * Offset for layer parts
    this.x += this.animPart.dx;
    this.y += this.animPart.dy;
    return;
  }

  refreshPart(frame, dir) {
    return this.bitmap = this.animPart.getPartBitmap(dir, frame);
  }

};

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_BarrierIcon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_BarrierIcon;
  Sprite_BarrierIcon = class Sprite_BarrierIcon extends AASprite {
    constructor(elementId) {
      super();
      this.elementId = elementId;
      if (this.elementId > 0) {
        this._create();
      }
    }

    _create() {
      this._loadSettings();
      this._drawIcon();
      return this.move(AA.Utils.convertPositionPointFromJSON(this.settings.iconPositionOnTarget));
    }

    _loadSettings() {
      this.settings = AA.JSON.getAbsorbBarriersSettings();
      this.elementSettings = AA.JSON.getAbsordBarrierStyle(this.elementId);
      if (this.elementSettings == null) {
        return this.elementSettings = AA.JSON.getAbsordBarrierStyle(0);
      }
    }

    _drawIcon() {
      this._drawIconBack();
      if (this.elementSettings != null) {
        this.icon = AASprite.FromImg(this.elementSettings.icon);
        return this.addChild(this.icon);
      }
    }

    _drawIconBack() {
      this.back = AASprite.FromImg("TargetBarrierIconBackground");
      return this.addChild(this.back);
    }

  };
  AA.register(Sprite_BarrierIcon);
})();

// ■ END Sprite_BarrierIcon.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _alias_Sprite_Character_updatePosition = Sprite_Character.prototype.updatePosition;
    Sprite_Character.prototype.updatePosition = function () {
        _alias_Sprite_Character_updatePosition.call(this);
        if (this._character.inAAnimMotion() && this._character.__AnimMotionReady == true) {
            this.y += this._AAnimMotionOffset();
        } else
        if (this._character.inABSMotion()) {
            this.y += this._absMotionOffset();
        }
    };

    //?[NEW]
    Sprite_Character.prototype._absMotionOffset = function () {
        return this._character.ABSParams().absMotion.getOffset();
    };

    //?[NEW]
    Sprite_Character.prototype._AAnimMotionOffset = function () {
        return this._character.getAAnimMotion().getOffset();
    };

    //@[ALIAS]
    var _alias_Sprite_Character_patternWidth = Sprite_Character.prototype.patternWidth;
    Sprite_Character.prototype.patternWidth = function () {
        if (this._character.inAAnimMotion() && this._character.__AnimMotionReady == true) {
            var amotion = this._character.getAAnimMotion();
            return this.bitmap.width / amotion.getFrames();
        }
        if (this._character.inABSMotion()) {
            var motion = this._character.getABSMotion();
            if (motion.isOldABSMotion())
                return this.bitmap.width / 3;
            else
                return this.bitmap.width / motion.getFrames();
        }
        if (Imported.Galv_CharacterFrames == true) {
            if (this._tileId > 0) {
                return $gameMap.tileWidth();
            } else if (this._isBigCharacter) {
                return this.bitmap.width / this._cframes;
            } else {
                return this.bitmap.width / (this._cframes * 4);
            }
        } else
            return _alias_Sprite_Character_patternWidth.call(this);
    };
    AA.G_ALIASES._alias_Sprite_Character_patternWidth = Sprite_Character.prototype.patternWidth;

    //@[ALIAS]
    var _alias_Sprite_Character_setCharacterBitmap = Sprite_Character.prototype.setCharacterBitmap;
    Sprite_Character.prototype.setCharacterBitmap = function () {
        if (this._character.inAAnimMotion()) {
            var motion = this._character.getAAnimMotion();
            if (motion.isProperName(this._characterName)) {
                this.bitmap = ImageManager.loadAAMotion(this._characterName);
                this.bitmap.addLoadListener(() => {
                    this._character.__AnimMotionReady = true;
                });
                this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
            } else {
                //this._character._clearAAnimMotion();
                this._characterName = motion._motionName;
                this.setCharacterBitmap();
                //_alias_Sprite_Character_setCharacterBitmap.call(this);
            }
        } else
        if (this._character.inABSMotion()) {
            var motion = this._character.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                if (motion.isProperName(this._characterName)) {
                    this.bitmap = ImageManager.loadAAMotion(this._characterName);
                    this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
                } else {
                    this._character._characterName = motion._currentMotionName;
                    this._character._characterIndex = 0;
                    this._characterName = motion._currentMotionName;
                    this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
                    this.bitmap = ImageManager.loadAAMotion(this._characterName);
                }
            } else {
                _alias_Sprite_Character_setCharacterBitmap.call(this);
            }
        } else {
            _alias_Sprite_Character_setCharacterBitmap.call(this);
        }
    };

    //@[ALIAS]
    var _alias_Sprite_Character_patternHeight = Sprite_Character.prototype.patternHeight;
    Sprite_Character.prototype.patternHeight = function () {
        if (this._character.inAAnimMotion()) {
            var motion = this._character.getAAnimMotion();
            if (motion != null && this._character.__AnimMotionReady == true) {
                return this.bitmap.height / motion.getParts();
            }
        }
        if (this._character.inABSMotion()) {
            var motion = this._character.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return this.bitmap.height / motion.getParts();
            } else {
                return _alias_Sprite_Character_patternHeight.call(this);
            }
        } else {
            return _alias_Sprite_Character_patternHeight.call(this);
        }
    };

    //@[ALIAS]
    var _alias_Sprite_Character_createHalfBodySprites = Sprite_Character.prototype.createHalfBodySprites;
    Sprite_Character.prototype.createHalfBodySprites = function () {
        _alias_Sprite_Character_createHalfBodySprites.call(this);
        if (!this.__bushUpperSprite) {
            this.__bushUpperSprite = new Sprite();
            this.addChild(this.__bushUpperSprite);
        }
    };

    
    //@[ALIAS]
    var _alias_Sprite_Character_startAnimation = Sprite_Character.prototype.startAnimation;
    Sprite_Character.prototype.startAnimation = function () {
        _alias_Sprite_Character_startAnimation.call(this, ...arguments);
        if(this._character && this._character._absMapAnimationIsRequested == true) {
            this._character._absMapAnimationIsRequested = null;
            this._animationSprites.last().setABSModeMap();
        }
    };

})();
// ■ END Sprite_Character.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__characterBlockX, ALIAS__characterBlockY, ALIAS__characterPatternX, ALIAS__characterPatternY, ALIAS__isEmptyCharacter, ALIAS__isImageChanged, ALIAS__patternHeight, ALIAS__patternWidth, ALIAS__updateBitmap, ALIAS__updateFrame, ALIAS__updatePosition, ALIAS__updateVisibility, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__isEmptyCharacter = _.isEmptyCharacter;
  _.isEmptyCharacter = function() {
    if (this.isAnimX()) {
      return false;
    } else {
      return ALIAS__isEmptyCharacter.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__updateVisibility = _.updateVisibility;
  _.updateVisibility = function() {
    if (this.isAnimX()) {
      return this._updateVisibilityAnimX();
    } else {
      return ALIAS__updateVisibility.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__updateBitmap = _.updateBitmap;
  _.updateBitmap = function() {
    if (this.isAnimX()) {
      return this._updateBitmapAnimX();
    } else {
      return ALIAS__updateBitmap.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__updateFrame = _.updateFrame;
  _.updateFrame = function() {
    ALIAS__updateFrame.call(this);
    if (this.isAnimX()) {
      this._axCntr.update(this._character);
      if (this._animaXParts != null) {
        this._updateAnimaXPartsDepth();
        this._updateAnimaXParts();
      }
    }
  };
  //@[ALIAS]
  ALIAS__updatePosition = _.updatePosition;
  _.updatePosition = function() {
    ALIAS__updatePosition.call(this);
    if (this.isAnimX()) {
      this.x += this._axCntr.rootAnimation.dx;
      return this.y += this._axCntr.rootAnimation.dy;
    }
  };
  
  //@[ALIAS]
  ALIAS__isImageChanged = _.isImageChanged;
  _.isImageChanged = function() {
    if (this.isAnimX()) {
      return this._animaXSet !== this._character.getCurrentAnimX();
    } else {
      return ALIAS__isImageChanged.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__patternWidth = _.patternWidth;
  _.patternWidth = function() {
    if (this.isAnimX()) {
      return this.bitmap.width;
    } else {
      return ALIAS__patternWidth.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__patternHeight = _.patternHeight;
  _.patternHeight = function() {
    if (this.isAnimX()) {
      return this.bitmap.height;
    } else {
      return ALIAS__patternHeight.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__characterBlockX = _.characterBlockX;
  _.characterBlockX = function() {
    if (this.isAnimX()) {
      return 0;
    }
    return ALIAS__characterBlockX.call(this);
  };
  
  //@[ALIAS]
  ALIAS__characterBlockY = _.characterBlockY;
  _.characterBlockY = function() {
    if (this.isAnimX()) {
      return 0;
    }
    return ALIAS__characterBlockY.call(this);
  };
  //@[ALIAS]
  ALIAS__characterPatternX = _.characterPatternX;
  _.characterPatternX = function() {
    if (this.isAnimX()) {
      return 0;
    }
    return ALIAS__characterPatternX.call(this);
  };
  //@[ALIAS]
  ALIAS__characterPatternY = _.characterPatternY;
  _.characterPatternY = function() {
    if (this.isAnimX()) {
      return 0;
    }
    return ALIAS__characterPatternY.call(this);
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _.AABattler = function() {
    var ref;
    return (ref = this._character) != null ? ref.battler() : void 0;
  };
  _.isAACharacter = function() {
    return (this._character != null) && this._character.isABS();
  };
  _.isAACharacterWithVision = function() {
    return this.isAACharacter() && this._character instanceof Game_AIBot;
  };
  _._initABSAddonThread = function() {
    if (!AA.isABS()) {
      return;
    }
    this._visionThread = new AATimedUpdate(60, this._visionThreadTick.bind(this));
  };
  _._updateAA_Addon = function() {
    if (!AA.isABS()) {
      return;
    }
    if (this._visionThread != null) {
      this._visionThread.update();
      return this._updateVisionSprite();
    }
  };
  _._updateVisionSprite = function() {
    if (this.__aaVisionSprite == null) {
      return;
    }
    this.__aaVisionSprite.move(this.x, this.y - this.height / 2);
    if (this.__isTriangleMode === true) {
      return this._refreshAAVisionTriangle();
    }
  };
  _._refreshAAVisionTriangle = function() {
    var dir;
    dir = this._character.direction();
    this.__aaVisionSprite.visible = true;
    if (dir === 4) {
      this.__aaVisionSprite.anchor.set(0, 0.5);
      this.__aaVisionSprite.scale.x = -1;
      return this.__aaVisionSprite.rotation = 0;
    } else if (dir === 6) {
      this.__aaVisionSprite.anchor.set(0, 0.5);
      this.__aaVisionSprite.scale.x = 1;
      return this.__aaVisionSprite.rotation = 0;
    } else if (dir === 8) {
      this.__aaVisionSprite.anchor.set(0, 0.5);
      this.__aaVisionSprite.scale.x = -1;
      return this.__aaVisionSprite.rotation = 1.57;
    } else if (dir === 2) {
      this.__aaVisionSprite.anchor.set(0, 0.5);
      this.__aaVisionSprite.scale.x = 1;
      return this.__aaVisionSprite.rotation = 1.57;
    } else {
      return this.__aaVisionSprite.visible = false;
    }
  };
  _._visionThreadTick = function() {
    if ($gameSystem._absEVision === true) {
      if (this.isAACharacterWithVision()) {
        this._aaOnABSVisionIsOn();
        return;
      }
    }
    return this._aaOnABSVisionIsOff();
  };
  _._aaOnABSVisionIsOn = function() {
    if (this.__aaVisionSprite == null) {
      this._createAAVisionSprite();
    }
    return this._refreshAAVisionSprite();
  };
  _._createAAVisionSprite = function() {
    if (this._character.behaviorModel().tVisor > 0) {
      this._createAAVisionTriangle();
    } else {
      this._createAAVisionCircle();
    }
    this.__aaVisionSprite.opacity = 120;
    this.__aaVisionSprite.z = 0;
    this.parent.addChild(this.__aaVisionSprite);
  };
  _._createAAVisionTriangle = function() {
    var m, th, tw;
    m = this._character.behaviorModel();
    tw = m.viewRadius * 48;
    th = m.tVisor * 48;
    this.__isTriangleMode = true;
    this.__aaVisionSprite = AASprite.FromBitmap(tw, th * 4);
    //@__aaVisionSprite.fillAll KDCore.Color.YELLOW
    return this.__aaVisionSprite.b().drawTriangle(tw, th, KDCore.Color.RED.CSS);
  };
  _._createAAVisionCircle = function() {
    var bs, cr, cx, r;
    r = this._character.behaviorModel().viewRadius;
    bs = (r + 4) * 48;
    this.__aaVisionSprite = AASprite.FromBitmap(bs, bs);
    //@__aaVisionSprite.b().fillAll KDCore.Color.YELLOW
    cx = bs / 2;
    cr = (r - 1) * 48;
    this.__aaVisionSprite.b().drawCircle(cx, cx, cr, KDCore.Color.RED.CSS);
    return this.__aaVisionSprite.anchor.set(0.5, 0.5);
  };
  _._refreshAAVisionSprite = function() {
    if (this.__aaVisionSprite == null) {

    }
  };
  _._aaOnABSVisionIsOff = function() {
    if (this.__aaVisionSprite != null) {
      return this._destroyAAVisionSprite();
    }
  };
  _._destroyAAVisionSprite = function() {
    if (this.__aaVisionSprite == null) {
      return;
    }
    this.__aaVisionSprite.visible = false;
    this.parent.removeChild(this.__aaVisionSprite);
    this.__aaVisionSprite = null;
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__update, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._visInitialUpdate = false;
    return this._visEqThread = new AATimedUpdate(5, this._updateVisualEquipment.bind(this));
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (!this._visInitialUpdate) {
      return this._updateVisualEquipment();
    } else {
      return this._visEqThread.update();
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  (function() {    // * Система анимации XAnima
    // -----------------------------------------------------------------------
    _.isAnimX = function() {
      return this._character.isAnimX();
    };
    _._updateVisibilityAnimX = function() {
      Sprite_Base.prototype.updateVisibility.call(this);
      if (this._character.isTransparent()) {
        this.visible = false;
      } else {
        if (this._character instanceof Game_Follower) {
          this.visible = this._character.isVisible();
        }
      }
    };
    _._updateBitmapAnimX = function() {
      if (this.isImageChanged()) {
        this._animaXSet = this._character.getCurrentAnimX();
        this._refreshAnimXSetController();
        this._createAnimaXParts();
      } else if (this.isXAnimPartsChanged()) {
        this._createAnimaXParts();
      }
      if (this._axCntr.isChanged()) {
        this._refreshAnimaXBitmap();
        this._refreshAnimXPartSprites();
      }
    };
    _._refreshAnimXSetController = function() {
      this._axCntr = new XAnimaSetController(this._character.direction(), this._animaXSet);
      return this._refreshAnimaXBitmap();
    };
    return _._refreshAnimaXBitmap = function() {
      return this.bitmap = this._axCntr.bitmap();
    };
  })();
  (function() {    // * Система анимации XAnima - Части (слои)
    // -----------------------------------------------------------------------
    // * Синхронизируем координаты нижнего слоя
    _._updateAnimaXParts = function() {
      this._animaXPartBelow.x = this.x;
      return this._animaXPartBelow.y = this.y;
    };
    // * Чтобы lower и upper body прозрачность была (в кустах)
    _._updateAnimaXPartsDepth = function() {
      var i, j, len, len1, p, ref, ref1;
      // * Не обновлять, если не изменилась прозрачность
      if (this.__lBushDepth === this._bushDepth) {
        return;
      }
      this.__lBushDepth = this._bushDepth;
      if (this._bushDepth > 0) {
        ref = this.__tAnimxParts;
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          if (p.isLowerBodyPart === true) {
            p.opacity = 128;
          }
        }
      } else {
        ref1 = this.__tAnimxParts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          p = ref1[j];
          p.opacity = 255;
        }
      }
    };
    _.isXAnimPartsChanged = function() {
      if (this.isAnimX()) {
        return this._character.isAnimXPartsChanged();
      } else {
        return false;
      }
    };
    _._refreshAnimXPartSprites = function() {
      var i, len, part, ref;
      if (this._animaXParts == null) {
        return;
      }
      ref = this.__tAnimxParts;
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        part.refreshPart(this._axCntr.cFrame, this._axCntr.cDir);
        this._addPartOnSpriteByDirection(part, this._axCntr.cDir);
      }
    };
    _._refreshAnimaXBitmap = function() {
      return this.bitmap = this._axCntr.bitmap();
    };
    _._createAnimaXParts = function() {
      if (this._animaXParts != null) {
        this._destroyAnimaXParts();
      }
      // * Все части которые добавленны
      this.__tAnimxParts = [];
      // * Части над персонажем (стандарт)
      this._animaXParts = new Sprite();
      this._animaXParts.anchor.x = 0.5;
      this._animaXParts.anchor.y = 1;
      // * Части под персонажем
      this._animaXPartBelow = new Sprite();
      this._animaXPartBelow.anchor.x = 0.5;
      this._animaXPartBelow.anchor.y = 1;
      this._animaXPartBelow.z = 1;
      this._addAllAnimaXParts();
      this.addChild(this._animaXParts);
      this.parent.addChild(this._animaXPartBelow);
      this._character.onAnimXPartsRefreshed();
    };
    _._destroyAnimaXParts = function() {
      var i, len, p, ref;
      this._animaXParts.visible = false;
      this._animaXParts.parent.removeChild(this._animaXParts);
      this._animaXParts = null;
      this._animaXPartBelow.visible = false;
      this._animaXPartBelow.parent.removeChild(this._animaXPartBelow);
      this._animaXPartBelow = null;
      if (this.__tAnimxParts != null) {
        ref = this.__tAnimxParts;
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          p.parent.removeChild(p);
          p.visible = false;
        }
        this.__tAnimxParts = null;
      }
      this.__lBushDepth = null;
    };
    _._addAllAnimaXParts = function() {
      var animaXPart, i, id, len, part, partData, parts, unsortedParts;
      parts = this._character.animaXParts;
      // * Преобразование в массив
      unsortedParts = [];
      for (id in parts) {
        partData = parts[id];
        unsortedParts.push(partData);
      }
      // * Сортировка
      unsortedParts.sort(function(a, b) {
        if (a.level > b.level) {
          return 1;
        }
        if (a.level === b.level) {
          return 0;
        }
        return -1;
      });
      for (i = 0, len = unsortedParts.length; i < len; i++) {
        part = unsortedParts[i];
        animaXPart = new Sprite_AnimaXPart(part, this._axCntr.rootAnimation);
        this.__tAnimxParts.push(animaXPart);
        this._addPartOnSpriteByDirection(animaXPart, this._axCntr.cDir);
      }
    };
    // * Добаить часть (слой) на персонажа с учётом "уровня" слоя (за или перед)
    _._addPartOnSpriteByDirection = function(part, dir) {
      var level;
      level = part.animPart.isBelowCharacter(dir);
      if (level === true) {
        this._animaXParts.removeChild(part);
        this._animaXPartBelow.addChild(part);
      } else {
        this._animaXPartBelow.removeChild(part);
        this._animaXParts.addChild(part);
      }
    };
    return;
  })();
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

//Sprite_CharacterABS
//------------------------------------------------------------------------------
function Sprite_CharacterABS() {
  this.initialize.apply(this, arguments);
}

(function () {

  var Consts = AlphaABS.SYSTEM;

  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

  Sprite_CharacterABS.prototype = Object.create(Sprite_Character.prototype);
  Sprite_CharacterABS.prototype.constructor = Sprite_CharacterABS;

  Sprite_CharacterABS.MOTIONS = {
    none: {
      index: 0,
      loop: true
    },
    sleep: {
      index: 17,
      loop: true
    }
  };

  Sprite_CharacterABS.prototype.initialize = function (character, type) {
    Sprite_Character.prototype.initialize.call(this, character);
    this._absParams = {};
    this._absParams.type = type;
    this._absParams.damages = [];
  };

  Sprite_CharacterABS.prototype.isAlly = function () {
    return this._absParams.type == 2;
  };

  Sprite_CharacterABS.prototype.isEnemy = function () {
    return this._absParams.type == 0;
  };

  Sprite_CharacterABS.prototype.isPlayer = function () {
    return this._absParams.type == 1;
  };

  Sprite_CharacterABS.prototype.ABSParams = function () {
    return this._absParams;
  };

  Sprite_CharacterABS.prototype.update = function () {
    Sprite_Character.prototype.update.call(this);
    this._updateABS();
  };

  Sprite_CharacterABS.prototype.toPoint = function () {
    return new KDCore.Point(this.x, this.y);
  };

  Sprite_CharacterABS.prototype.isTouched = function () {
    return AlphaABS.UTILS.SMath.inRect(new KDCore.Point(TouchInput.x, TouchInput.y), this._getRectangle());
  };

  Sprite_CharacterABS.prototype.character = function () {
    return this._character;
  };

  Sprite_CharacterABS.prototype.initABS = function () {
    this._isABS = true;

    this.createHalfBodySprites();

    this._stateIconSprite = new Sprite_StateIcon();
    this.addChild(this._stateIconSprite);
    this._stateIconSprite.setup(this._character.battler());
    this._stateIconSprite.scale.x = 0.7;
    this._stateIconSprite.scale.y = 0.7;

    this._animationCast = null;
    this._animationCastAudio = null;

    this._stateSpriteOverlay = new Sprite_StateOverlay();
    this._stateSpriteOverlay.setup(this._character.battler());

    this._stateSpriteOverlay.scale.x = 0.7;
    this._stateSpriteOverlay.scale.y = 0.7;

    // * Чтобы был выше над травой
    this.__bushUpperSprite.addChild(this._stateSpriteOverlay);

    if (!this.isPlayer()) {
      this._effectType = null;
      this._effectDuration = 0;
      this._shake = 0;
    } else {
      this._stateIconSprite.setPriority(90);
    }
  };

  //PRIVATE
  Sprite_CharacterABS.prototype._updateABS = function () {
    if (!this._isABS) return;
    if (this._character.battler() == null) return;

    if (!this.isEnemy()) {
      this._setupWeaponAnimation();
      this._setupMotion();
      this._updateMotion();
      this._setupPopUp();
    }

    if (!this.isPlayer()) {
      this._updateTargetSelection();
      if (this.isAlly()) {
        this._setupAllyNameplate();
      }
    }

    this._updateStateSprite();
    this._setupAnimationABS();
    this._updateDamagePopup();
    this._setupAnimationCastABS();
    this._setupSummonName();
  };

  Sprite_CharacterABS.prototype._updateEffect = function () {
    var t = this._character.battler();

    if (t.isEffectRequested()) { //setupEffect
      this._startEffect(t.effectType());
      t.clearEffect();
    }

    if (this._effectDuration > 0) {
      this._effectDuration--;
      switch (this._effectType) {
        case 'whiten':
          var alpha = 128 - (16 - this._effectDuration) * 10;
          this.setBlendColor([255, 255, 255, alpha]);
          break;
        case 'blink':
          this.opacity = (this._effectDuration % 10 < 5) ? 255 : 0;
          break;
        case 'collapse':
          this.blendMode = Graphics.BLEND_ADD;
          this.setBlendColor([255, 128, 128, 128]);
          this.opacity *= this._effectDuration / (this._effectDuration + 1);
          break;
      }
      if (this._effectDuration === 0) {
        this._effectType = null;
      }
    }
  };

  Sprite_CharacterABS.prototype._startEffect = function (effectType) {
    this._effectType = effectType;
    switch (this._effectType) {
      case 'whiten':
        this._effectDuration = 16;
        break;
      case 'blink':
        this._effectDuration = 20;
        break;
      case 'collapse':
        this._effectDuration = 32;
        break;
    }

    this._shake = 0;
    this.blendMode = 0;
    this.opacity = 255;
    this.setBlendColor([0, 0, 0, 0]);
  };

  Sprite_CharacterABS.prototype._updateStateSprite = function () {
    this._stateIconSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
    if (this._stateIconSprite.y < 20 - this.y) {
      this._stateIconSprite.y = 20 - this.y;
    }

    this._stateIconSprite.visible = this._character.inActive();
  };

  Sprite_CharacterABS.prototype._updateDamagePopup = function () {
    this._setupDamagePopup();
    var t = this._absParams.damages;
    if (t.length > 0) {
      for (var i = 0; i < t.length; i++) {
        this._refreshZValueForDamageSprite(t[i]);
        t[i].update();
      }
      if (!t[0].isPlaying()) {
        this.parent.removeChild(t[0]);
        t.shift();
      }
    }
  };

  Sprite_CharacterABS.prototype._refreshZValueForDamageSprite = function(spr) {
    try {
      spr.z = 10;
    } catch (e) {
      this._refreshZValueForDamageSprite = function () {}; // * Empty
    }
  };

  Sprite_CharacterABS.prototype._setupMotion = function () {
    if (this._character.isMotionRequested()) {
      if (!this._motionSprite) {
        this._motionSprite = new Sprite();
        this._motionSprite.anchor.x = 0.5;
        this._motionSprite.anchor.y = 1;
        this._motionSprite.bitmap = ImageManager.loadSvActor(this._character.battler().battlerName());
        this._motionSprite.visible = false;
        this._motionSprite.scale.x = 0.8;
        this._motionSprite.scale.y = 0.8;

        this.parent.addChild(this._motionSprite);
      }
      this.startMotion(this._character.motionType());
      //this._character.clearMotion();
    }
  };

  Sprite_CharacterABS.prototype.startMotion = function (motionType) {
    var newMotion = Sprite_CharacterABS.MOTIONS[motionType];
    if (newMotion.index == 0) {
      this._motion = null;
      this._motionSprite.visible = false;
      this._character.setTransparent(false);
      return;
    }

    if (this._motion !== newMotion) {
      this._motion = newMotion;
      this._motionCount = 0;
      this._pattern = 0;
      this._motionSprite.x = this.x;
      this._motionSprite.y = this.y;
      this._character.setTransparent(true);
      this._motionSprite.visible = true;
    }
  };

  Sprite_CharacterABS.prototype._updateMotion = function () {
    if (this._motion) {
      var bitmap = this._motionSprite.bitmap;
      var motionIndex = this._motion ? this._motion.index : 0;
      var pattern = this._pattern < 3 ? this._pattern : 1;
      var cw = bitmap.width / 9;
      var ch = bitmap.height / 6;
      var cx = Math.floor(motionIndex / 6) * 3 + pattern;
      var cy = motionIndex % 6;
      this._motionSprite.setFrame(cx * cw, cy * ch, cw, ch);
      this._motionSprite.x = this._character.screenX();
      this._motionSprite.y = this._character.screenY();
    }
  };

  Sprite_CharacterABS.prototype._setupPopUp = function () {
    var items = this._character.battler().getInfoPops();
    if (items.length != 0) {
      for (var j = 0; j < items.length; j++) {
        var item = items[j];
        this._pushPopOnUI(item);
      }
    }
    this._character.battler().clearInfoPops();
  };

  Sprite_CharacterABS.prototype._pushPopOnUI = function (item) {
    if (this.isPlayer()) {
      AlphaABS.BattleUI.addPopUpForPlayer(item);
    } else {
      //AlphaABS.BattleUI.addPopUpForTarget(this.character(), item);
    }
  };

  Sprite_CharacterABS.prototype._setupAnimationABS = function () {
    if (this._character.ABSParams().animationABS > 0) {
      var anim = $dataAnimations[this._character.ABSParams().animationABS];
      this._character.ABSParams().animationABS = 0;
      this._startAnimationABS(anim, false, 0);
    }
  };

  Sprite_CharacterABS.prototype._setupAnimationCastABS = function () {
    if (this._character.isCasting()) {
      if (!this._animationCast) {
        this._createAnimataionCast();
      } else {
        if (!this._animationCast.isPlaying()) {
          this._animationCast.remove();
          this._createAnimataionCast();
        }
      }

    } else {
      if (this._animationCast) {
        this._animationCast.remove();
        this._animationCast = null;
        if (this._animationCastAudio) {
          //AudioManager.removeFromLoopBuffer(this._animationCastAudio);
          //this._animationCastAudio.stop();
          //this._animationCastAudio = null;
          this._animationCastAudio = false;
        }
      }
    }
  };

  Sprite_CharacterABS.prototype._createAnimataionCast = function () {
    this._animationCast = new Sprite_Animation();

    var anim = null;
    var own = false;

    if (this._character.ABSParams().currentAction.castAnim > 0) {
      anim = $dataAnimations[this._character.ABSParams().currentAction.castAnim];
      own = true;
    } else {
      anim = AlphaABS.Parameters.get_CastAnimation();
    }

    this._animationCast.setup(this._effectTarget, anim, false, 0);
    this._animationCast.setABSMode();
    this.parent.addChild(this._animationCast);

    if (this.character() != $gamePlayer.getSummonUnit())
      if (!this._animationCastAudio) {
        var se = AlphaABS.Parameters.get_CastAnimationSE();
        if (se != null && own == false) {
          var point = this._character.toPoint();
          if (BattleManagerABS.isABSAudio())
            this._animationCastAudio = AudioManager.playSeAt(se, point.mapPointOnScreen());
          else
            this._animationCastAudio = AudioManager.playSe(se);
          this._animationCastAudio = true;
        }
      }
  };

  Sprite_CharacterABS.prototype._setupDamagePopup = function () {
    var t = this._character.battler();
    if (t && t.isDamagePopupRequested()) {
      var sprite = new Sprite_Damage();
      sprite.x = this.x;
      sprite.y = this.y - this.patternHeight() - 10;
      sprite.setup(t);
      sprite.scale.x = 0.6;
      sprite.scale.y = 0.6;
      this._absParams.damages.push(sprite);
      this.parent.addChild(sprite);
      t.clearDamagePopup();
      t.clearResult();
    }
  };

  Sprite_CharacterABS.prototype._setupWeaponAnimation = function () {
    if (!this._absParams.spriteWeapon) {
      this._absParams.spriteWeapon = new Sprite_Weapon();
      this._absParams.spriteWeaponHolder = new Sprite();
      this.parent.addChild(this._absParams.spriteWeaponHolder);
      this._absParams.spriteWeaponHolder.addChild(this._absParams.spriteWeapon);
    } else {
      this._absParams.spriteWeaponHolder.move(this.x, this.y);
    }

    var t = this.character().battler();
    if (t && t.isWeaponAnimationRequested()) {
      try {
        if(this._absParams.spriteWeapon.setDataWeapon)
          this._absParams.spriteWeapon.setDataWeapon(t.weapons()[0]);
      } catch (e) {
        AA.w(e);
      }
      this._absParams.spriteWeapon.setup(t.weaponImageId());
      var directionKey = AlphaABS.UTILS.getDirKey(this.character());
      if (directionKey == 'u') {
        this.parent.addChildAt(this._absParams.spriteWeaponHolder, 1);
      } else {
        this.parent.addChild(this._absParams.spriteWeaponHolder);
      }
      this._absParams.spriteWeapon.setDirectionABS(directionKey);
      t.clearWeaponAnimation();
    }
  };

  Sprite_CharacterABS.prototype._startAnimationABS = function (animation, mirror, delay) {
    var sprite = new Sprite_Animation();
    sprite.setup(this._effectTarget, animation, mirror, delay);
    sprite.setABSMode();
    this.parent.addChild(sprite);
    this._animationSprites.push(sprite);
    if (window.mv3d) {
      this._startAnimationABSMV3D();
    }
  };

  Sprite_CharacterABS.prototype._startAnimationABSMV3D = function () {
    if (mv3d.mapDisabled || !(SceneManager._scene instanceof Scene_Map)) {
      return;
    }
    const animationSprite = this._animationSprites[this._animationSprites.length - 1];
    animationSprite._mv3d_animationSettings = this._character._mv3d_animationSettings;
    delete this._character._mv3d_animationSettings;
    if (animationSprite._mv3d_animationSettings) {
      animationSprite.mv3d_animation = new animations_DepthAnimation(animationSprite);
      mv3d.pixiContainer.addChild(animationSprite._screenFlashSprite);
      return;
    }
    mv3d.pixiContainer.addChild(animationSprite);
  }

  Sprite_CharacterABS.prototype._getCornerPoint = function () { //Левый верхний угол спрайта
    var p1 = this.x - (this.patternWidth() / 2);
    var p2 = this.y - this.patternHeight();
    return new KDCore.Point(p1, p2);
  };

  Sprite_CharacterABS.prototype._getRectangle = function () { //Прямоугольник, содержащий спрайт
    var p = this._getCornerPoint();
    return new Rectangle(p.x, p.y, this.patternWidth(), this.patternHeight());
  };

  Sprite_CharacterABS.prototype._getCenterPoint = function () { //Центральная точка
    return new KDCore.Point(this.x, this.y - this.patternHeight() / 2);
  };

  //?[NEW]
  Sprite_CharacterABS.prototype.getStartPointToVector = function () {
    return this._getCenterPoint().convertToMap();
  };

  Sprite_CharacterABS.prototype._setupSummonName = function () {
    if (this.character() != $gamePlayer.getSummonUnit()) {
      return;
    }
    if (!this._summonNameSprite) {
      var loader = AAJsonSettings.getUISummonUnitSettings;
      this._summonNameSprite = new Sprite(new Bitmap(60, 24));
      this._summonNameSprite.bitmap.fillAll(KDCore.Color.BLACK);
      this._summonNameSprite = new AA.LIBS.SpriteUIElement('SummonName', loader);
      this._summonNameSprite.drawTextOnReady(this.character().name());
      this.__bushUpperSprite.addChild(this._summonNameSprite);
      this._summonNameSprite.x = 0;
      this._summonNameSprite.visible = false;
      //this._summonNameSprite.anchor.x = 0.5;
      this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
      //TODO: Temp solution
      AA.setTimeout(() => {
        try {
          var s = this._summonNameSprite.settings.textZoneWidth;
          if (s > 0)
            this._summonNameSprite.x -= s / 2;
          this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
          this._summonNameSprite.visible = true;
        } catch (e) {
          console.log(e);
        }
      }, 200);
    }
    if (this._summonNameSprite) {
      // * SLOW, надо оптимизация
      //this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
      //var states = this.character().battler().allIcons();
      //if (states.length != 0) {
      //  this._summonNameSprite.y -= 28;
      //}
      //TODO: Нарушение принципа MVC, модель трогает UI (MVC)
      AlphaABS.BattleUI.moveSummonCircle(this.x, this.y - 24);
    }
  };

  //END Sprite_CharacterABS
  //------------------------------------------------------------------------------

  AlphaABS.register(Sprite_CharacterABS);

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_CharacterABS.prototype;
  // * TARGET SELECTION =====================================
  _._updateTargetSelection = function() {
    if (this._targetSelectSprite == null) {
      this._createTargetSelection();
    }
    if (this._isThisAACharacterSelected()) {
      this._targetSelectSprite.visible = true;
      return this._targetSelectSprite.move(this.x, this.y);
    } else {
      return this._targetSelectSprite.visible = false;
    }
  };
  _._isThisAACharacterSelected = function() {
    var plTarget;
    plTarget = BattleManagerABS.getPlayerTarget();
    if (plTarget == null) {
      return false;
    }
    if (plTarget === this._character) {
      return true;
    }
    return false;
  };
  _._createTargetSelection = function() {
    var blendColor, t;
    this._targetSelectSprite = AASprite.FromImg('targetSelectedCircle');
    if (this.AABattler().isEnemy()) {
      if ($gamePlayer.isAlly(this._character)) {
        blendColor = KDCore.Color.AQUA.ARR;
      } else {
        blendColor = KDCore.Color.RED.ARR;
      }
    } else {
      blendColor = KDCore.Color.GREEN.ARR;
    }
    t = this._targetSelectSprite;
    t.z = 0;
    t.opacity = 200;
    t.setBlendColor(blendColor);
    t.anchor.x = 0.5;
    t.anchor.y = 0.5;
    t.visible = false;
    return this.parent.addChild(this._targetSelectSprite);
  };
  
  // * =====================================================
  _._setupAllyNameplate = function() {
    //"UUPD".p()
    if (this._isShouldBeAllyNameplate()) {
      return this._createAllyNameplate();
    } else {
      return this._removeAllyNameplate();
    }
  };
  _._isShouldBeAllyNameplate = function() {
    return this._character.isMapNameVisible();
  };
  _._createAllyNameplate = function() {
    var ref;
    if (!this._isAllyNameplateExists()) {
      this._allyNameplateSpr = new AA.LIBS.SpriteUIElement('AllyNameOnMap');
      this._allyNameplateSpr.drawTextOnReady(this._character.AABattler().name());
      this._allyNameplateSpr._textSpr.anchor.x = 0.5;
      this._allyNameplateSpr.z = 8;
      this.parent.addChild(this._allyNameplateSpr);
      if (this._allyNameplateSpr.settings.deathStateIcon.visible === true) {
        return this._createAllyNPDeathStateIcon();
      }
    } else {
      this._allyNameplateSpr.move(this.x, this.y);
      return (ref = this._allyNameplateDeathIcon) != null ? ref.visible = !this._character.isAlive() : void 0;
    }
  };
  _._createAllyNPDeathStateIcon = function() {
    var iconIndex, iconSize, p;
    p = this._allyNameplateSpr.settings.deathStateIcon;
    iconSize = p.iconSize;
    iconIndex = p.iconIndex;
    this._allyNameplateDeathIcon = AASprite.FromBitmap(iconSize, iconSize);
    this._allyNameplateDeathIcon.drawIcon(0, 0, iconIndex, iconSize);
    this._allyNameplateSpr.addChild(this._allyNameplateDeathIcon);
    this._allyNameplateDeathIcon.move(p.marginX, p.marginY);
  };
  _._isAllyNameplateExists = function() {
    return this._allyNameplateSpr != null;
  };
  _._removeAllyNameplate = function() {
    if (!this._isAllyNameplateExists()) {
      return;
    }
    this.parent.removeChild(this._allyNameplateSpr);
    return this._allyNameplateSpr = null;
  };
})();

// ■ END Sprite_CharacterABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_CharacterABS, __super_Sprite_CharacterABS_updABS;
  Sprite_CharacterABS = AlphaABS.LIBS.Sprite_CharacterABS;
  __super_Sprite_CharacterABS_updABS = Sprite_CharacterABS.prototype._updateABS;
  Sprite_CharacterABS.prototype._updateABS = function() {
    __super_Sprite_CharacterABS_updABS.call(this);
    if (!this._isABS) {
      return;
    }
    if (this._character.battler() == null) {
      return;
    }
    return this._updateHpBar();
  };
  Sprite_CharacterABS.prototype._updateHpBar = function() {
    this._setupHpBar();
    if (this._hpBarSprite == null) {
      return;
    }
    this._hpBarController.setup(this._character.battler(), 'hp', 'mhp');
    this._hpBarController.update();
    this._hpBarSprite.x = this.x + this._hpBarDX;
    return this._hpBarSprite.y = this.y - this.height + this._hpBarDY;
  };
  Sprite_CharacterABS.prototype._setupHpBar = function() {
    if (this._character.isHpBarVisible()) {
      if (this._hpBarSprite == null) {
        this._createHpBar();
        this._createHPBarCntrl();
      }
      return this._hpBarSprite.visible = true;
    } else {
      if (this._hpBarSprite != null) {
        return this._hpBarSprite.visible = false;
      }
    }
  };
  Sprite_CharacterABS.prototype._createHpBar = function() {
    var id, settings;
    id = this._getMiniHPStyle();
    this._hpBarSprite = new AlphaABS.LIBS.SpriteGauge(id);
    this._hpBarSprite.z = this.z + 2;
    settings = AA.JSON.getGaugeSettings(id);
    this._hpBarDX = settings.position[0];
    this._hpBarDY = settings.position[1];
    return this.parent.addChild(this._hpBarSprite);
  };
  Sprite_CharacterABS.prototype._getMiniHPStyle = function() {
    return 'miniHp';
  };
  Sprite_CharacterABS.prototype._createHPBarCntrl = function() {
    this._hpBarController = new AA.LIBS.MiniHPBarController(this._hpBarSprite);
    return this._hpBarController.setPercentText();
  };
})();

// ■ END Sprite_CharacterABS_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_CharacterABS;
  Sprite_CharacterABS = AlphaABS.LIBS.Sprite_CharacterABS;
  Sprite_CharacterABS.prototype._getMiniHPStyle = function() {
    return this._character.getHpBarStyleID();
  };
})();

// ■ END Sprite_CharacterABS_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS_VisualEqExt_PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
ImageManager.loadAAEquip = function(filename) {
  return this.loadBitmap('img/AEquips/', filename, 0, true);
};

(function() {
  var _;
  //@[DEFINES]
  //_ = AA.LIBS.Sprite_CharacterABS::
  _ = Sprite_Character.prototype;
  //TODO: Очень плохой и ресурсоёмкий код!
  _._updateVisualEquipment = function() {
    var b;
    if ($gameMap.isABS()) {
      if (this._character instanceof Game_Player || this._character instanceof Game_Follower) {
        b = this.AABattler();
      } else {
        //"EMPTY".p()
        this._updateVisualEquipment = function() {}; // * EMPTY
      }
    } else {
      if (this._character != null) {
        if (this._character instanceof Game_Player) {
          b = $gameParty.leader();
        } else if (this._character instanceof Game_Follower) {
          this._isFollower = true;
          b = this._character.actor();
        } else if (this._character instanceof Game_Event) {
          //"EMPTY".p()
          this._updateVisualEquipment = function() {}; // * EMPTY
        }
      }
    }
    if (b == null) {
      return;
    }
    this._visInitialUpdate = true;
    if (b._isNeedVisualEqRefresh()) {
      this._clearVisualEq();
      b._onVisualEqRefresh();
    }
    return this._setupVisualEq(b);
  };
  _._setupVisualEq = function(battler) {
    if (battler.isHasVisualEq()) {
      if (this._isVisualEqCreated()) {
        return this._updateVisualEq();
      } else {
        this._createAllVisualEqs(battler);
        return this._updateVisualEq();
      }
    } else {
      if (this._isVisualEqCreated()) {
        return this._clearVisualEq();
      }
    }
  };
  _._isVisualEqCreated = function() {
    return this._visualEquipmentSprites != null;
  };
  _._updateVisualEq = function() {
    var e, i, len, ref, results;
    ref = this._visualEquipmentSprites;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      e = ref[i];
      results.push(this._updateVisualEqFrame(e));
    }
    return results;
  };
  _._updateVisualEqFrame = function(_visualEquipmentSprite) {
    var b, blockX, blockY, ph, pw, sx, sy;
    b = _visualEquipmentSprite.bitmap;
    pw = b.width / 3;
    ph = b.height / 4;
    //index = 0
    blockX = 0; //index % 4 * 3
    blockY = 0; //Math.floor(index / 4) * 4
    sx = (blockX + this.characterPatternX()) * pw;
    sy = (blockY + this.characterPatternY()) * ph;
    _visualEquipmentSprite.setFrame(sx, sy, pw, ph);
    if (this._character.inABSMotion()) {
      _visualEquipmentSprite.y = this.__baseVESy - this._absMotionOffset();
    }
    if (this._character.inAAnimMotion() && this._character.__AnimMotionReady === true) {
      return _visualEquipmentSprite.y = this.__baseVESy - this._AAnimMotionOffset();
    }
  };
  _._createAllVisualEqs = function(battler) {
    var e, eqps, i, len, ref, results;
    this._clearVisualEq();
    this.createHalfBodySprites();
    this._visualEquipmentSprite = new Sprite();
    if ((ref = this.__bushUpperSprite) != null) {
      ref.addChildAt(this._visualEquipmentSprite, 0);
    }
    this._visualEquipmentSprites = [];
    eqps = battler._getVisualEqData();
    results = [];
    for (i = 0, len = eqps.length; i < len; i++) {
      e = eqps[i];
      results.push(this._createVisualEq(e));
    }
    return results;
  };
  _._createVisualEq = function(name) {
    var _visualEquipmentSprite, b, ref, ref1;
    if (name == null) {
      return;
    }
    if (this._isFollower === true) {
      b = (ref = this._character) != null ? ref.actor() : void 0;
    } else {
      b = (ref1 = this._character) != null ? ref1.battler() : void 0;
    }
    if (b == null) {
      b = $gameParty.leader();
    }
    if (b == null) {
      return;
    }
    //"VES: created".p()
    name = name + "_Char";
    _visualEquipmentSprite = new Sprite(ImageManager.loadAAEquip(name));
    _visualEquipmentSprite.bitmap = ImageManager.loadAAEquip(name);
    b = _visualEquipmentSprite.bitmap;
    b.addLoadListener(() => {
      _visualEquipmentSprite.move(-this.width / 2, -this.height);
      if (b.width !== this.width) {
        _visualEquipmentSprite.x = -(b.width / 3) / 2;
      }
      if (b.height !== this.height) {
        _visualEquipmentSprite.y = -(b.height / 4);
      }
      return this.__baseVESy = _visualEquipmentSprite.y;
    });
    this._visualEquipmentSprites.push(_visualEquipmentSprite);
    return this._visualEquipmentSprite.addChild(_visualEquipmentSprite);
  };
  _._clearVisualEq = function() {
    var i, len, ref, ref1, s;
    if (!this._isVisualEqCreated()) {
      return;
    }
    ref = this._visualEquipmentSprites;
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      this._visualEquipmentSprite.removeChild(s);
    }
    if ((ref1 = this.__bushUpperSprite) != null) {
      ref1.removeChild(this._visualEquipmentSprite);
    }
    this._visualEquipmentSprite = null;
    return this._visualEquipmentSprites = null;
  };
})();

// ■ END Sprite_CharacterABS_VisualEqExt_PRO.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_ColorGauge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_ColorGauge;
  Sprite_ColorGauge = class Sprite_ColorGauge extends AASprite {
    constructor(settings) {
      super();
      this.settings = settings;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createFill();
      this._createForeground();
      return this.visible = this.settings.visible;
    }

    _loadSettings() {
      return this.moveByJson(this.settings);
    }

    _createBackground() {
      this.bitmap = new Bitmap(this.settings.width, this.settings.height);
      this._background = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this._background.fillAll(KDCore.Color.FromHex(this.settings.backgroundColor));
      this._background.opacity = this.settings.backgroundOpacity;
      return this.add(this._background);
    }

    _createFill() {
      this._fillImg = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this._fillImg.b().fillAll(KDCore.Color.FromHex(this.settings.fillColor));
      this._fill = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this.add(this._fill);
      return this.drawGauge();
    }

    drawGauge(percent = 1) {
      var w;
      if (this._fill == null) {
        return;
      }
      this._fill.clear();
      w = this.settings.width * percent;
      return this._fill.b().blt(this._fillImg.b(), 0, 0, w, this.settings.height, 0, 0);
    }

    _createForeground() {
      if (this.settings.foregroundImg != null) {
        this._foreground = AASprite.FromImg(this.settings.foregroundImg);
        return this.add(this._foreground);
      }
    }

  };
  AA.register(Sprite_ColorGauge);
})();

// ■ END Sprite_ColorGauge.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Damage.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    //@[ALIAS]
    var _alias_Sprite_Damage_setup = Sprite_Damage.prototype.setup;
    Sprite_Damage.prototype.setup = function (target) {
        this._absDigitsSprites = [];
        _alias_Sprite_Damage_setup.call(this, target);
        if(!AA.isABS()) {
            return;
        }
        if (target && target.isPlayer()) {
            var result = target.result();
            if (result.hpAffected) {
                if (this._absDigitsSprites) {
                    this._applyABSColor();
                }
            }
        }
    };

    //?[NEW]
    Sprite_Damage.prototype._applyABSColor = function () {
        var color = KDCore.Color.BLACK.ARR;
        if (AlphaABS.Parameters.isLoaded()) {
            color = AlphaABS.Parameters.get_UI_PlayerDamageColor();
        }

        this._absDigitsSprites.forEach(function (sprite) {
            sprite.setColorTone(color);
        });
    };

    //@[ALIAS]
    var _alias_Sprite_Damage_createChildSprite = Sprite_Damage.prototype.createChildSprite;
    Sprite_Damage.prototype.createChildSprite = function () {
        var sprite = _alias_Sprite_Damage_createChildSprite.call(this);
        if(this._absDigitsSprites)
            this._absDigitsSprites.push(sprite);
        return sprite;
    };
})();
// ■ END Sprite_Damage.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_DevMHelper.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_DevMHelper;
  Sprite_DevMHelper = class Sprite_DevMHelper extends Sprite {
    constructor() {
      super(new Bitmap(90, 30));
    }

    update() {
      super.update();
      return this._drawCoords();
    }

    _drawCoords() {
      var coords;
      this.bitmap.clear();
      this.bitmap.fillAll(KDCore.Color.RED);
      coords = AlphaABS.UTILS.TouchInput.getMousePosition();
      this.bitmap.drawTextFull(coords.toString(), 'center');
      return this.move(coords.x, coords.y);
    }

  };
  AlphaABS.register(Sprite_DevMHelper);
})();

// ■ END Sprite_DevMHelper.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GSprite.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var GSprite;
  GSprite = class GSprite extends AASprite {
    constructor() {
      super(...arguments);
    }

  };
  AA.register(GSprite);
})();

(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.GSprite.prototype;
  // * ==============================================

  // * Исчезнуть
  _.fadeIn = function(sp) {
    this._fadeMode = 0;
    this._fadeStep = sp;
    return this._fadeTimer = new AATimedUpdate(2, this._onFadeTick.bind(this));
  };
  // * Появление
  _.fadeOut = function(sp) {
    this._fadeMode = 1;
    this._fadeStep = sp;
    return this._fadeTimer = new AATimedUpdate(2, this._onFadeTick.bind(this));
  };
  _._onFadeTick = function() {
    if (this._fadeMode === 0) {
      this.opacity -= this._fadeStep;
      if (this.opacity <= 0) {
        return this._fadeTimer.stop();
      }
    } else {
      this.opacity += this._fadeStep;
      if (this.opacity >= 255) {
        return this._fadeTimer.stop();
      }
    }
  };
  // * ==============================================

  // * Движение
  _.startMove = function(direction, speed, distance) {
    this._moveDirection = direction;
    this._moveSpeed = speed;
    this._moveDistance = distance;
    return this._moveTimer = new AATimedUpdate(2, this._onMoveTick.bind(this));
  };
  _._onMoveTick = function() {
    switch (this._moveDirection) {
      case 0: // * LEFT
        this.x -= this._moveSpeed;
        break;
      case 1: // * UP
        this.y -= this._moveSpeed;
        break;
      case 2: // * RIGHT
        this.x += this._moveSpeed;
        break;
      case 3: // * DOWN
        this.y += this._moveSpeed;
        break;
      case 4: // * LEFT AND UP
        this.x -= this._moveSpeed;
        this.y -= this._moveSpeed;
        break;
      case 5: // * LEFT AND DOWN
        this.x -= this._moveSpeed;
        this.y += this._moveSpeed;
        break;
      case 6: // * RIGHT AND UP
        this.x += this._moveSpeed;
        this.y -= this._moveSpeed;
        break;
      case 7: // * RIGHT AND DOWN
        this.x += this._moveSpeed;
        this.y += this._moveSpeed;
    }
    this._moveDistance -= this._moveSpeed;
    if (this.isOutOfDistance()) {
      return this._moveTimer.stop();
    }
  };
  _.isOutOfDistance = function() {
    return this._moveDistance <= 0;
  };
  // * ==============================================
  _.update = function() {
    Sprite.prototype.update.call(this);
    if (this._fadeTimer != null) {
      this._fadeTimer.update();
    }
    if (this._moveTimer != null) {
      //@_shakeTimer.update() if @_shakeTimer?
      //@_shakeTimer2.update() if @_shakeTimer2?
      return this._moveTimer.update();
    }
  };
})();

// ■ END GSprite.coffee
//---------------------------------------------------------------------------
//@_pulseTimer.update() if @_pulseTimer?

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInventoryActorCell.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInventoryActorCell;
  Sprite_MapInventoryActorCell = class Sprite_MapInventoryActorCell extends AA.LIBS.GSprite {
    constructor() {
      super();
      this._init();
      this._create();
      if (!AA.Parameters.isCustomSizeCells()) {
        this.move(-11, -11);
      }
      this.opacity = 0;
    }

    _init() {
      this._moveDistance = 50;
      this._moveSpeed = 10;
      this._fadeOutSpeed = 25;
      return this._fadeInSpeed = 50;
    }

    _create() {
      this._loadSettings();
      this._loadImages();
      this._createCell();
      this._createActorFaceSpr();
      return this._createDisableLayer();
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _loadImages() {
      return this._imgs0 = [ImageManager.loadAA("partySlot_00"), ImageManager.loadAA("partySlot_01"), ImageManager.loadAA("partySlot_00"), ImageManager.loadAA("partySlot_00")];
    }

    _createCell() {
      this._cell = new KDCore.Button();
      this._cell.setButtonImages(...this._imgs0);
      return this.add(this._cell);
    }

    _createActorFaceSpr() {
      this.actorFaceSpr = AASprite.FromBitmap(46, 46);
      this.actorFaceSpr.move(6, 6);
      //@actorFaceSpr.bitmap.fillAll KDCore.Color.RED
      return this.addChild(this.actorFaceSpr);
    }

    _createDisableLayer() {
      this.disableLayer = AASprite.FromBitmap(46, 46);
      this.disableLayer.bitmap.fillAll(KDCore.Color.BLACK);
      this.disableLayer.opacity = 200;
      this.disableLayer.move(6, 6);
      this.disableLayer.visible = false;
      return this.addChild(this.disableLayer);
    }

    disable() {
      var ref;
      this.disableLayer.visible = true;
      //@actorFaceSpr.opacity = 200
      this._cell._clickHandlers = [];
      this._cell.addClickHandler(function() {
        return SoundManager.playBuzzer();
      });
      return (ref = this.iconSpr) != null ? ref.visible = false : void 0;
    }

    setActor(actor1) {
      var item;
      this.actor = actor1;
      this.drawActorFace();
      this.registerClick();
      item = $gameTemp._tempItemForParty;
      if (item == null) {
        return;
      }
      if (DataManager.isItem(item)) {
        return this.drawGauges(item);
      } else if (!DataManager.isSkill(item)) {
        return this.drawEquipedIcon(item);
      }
    }

    drawActorFace() {
      var fIndex, tBitmap;
      tBitmap = ImageManager.loadFace(this.actor.faceName());
      fIndex = this.actor.faceIndex();
      tBitmap.addLoadListener(() => {
        var ph, pw, sx, sy;
        pw = Window_Base._faceWidth;
        ph = Window_Base._faceHeight;
        sx = fIndex % 4 * pw;
        sy = Math.floor(fIndex / 4) * ph;
        return this.actorFaceSpr.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this.actorFaceSpr.width, this.actorFaceSpr.height);
      });
    }

    drawGauges(item) {
      var gauge;
      this.gaugeitems = [];
      if (DataManager.isItemHaveHPEffect(item)) {
        gauge = this.drawHpGauge();
        if (gauge.visible) {
          this.gaugeitems.push(gauge);
        }
      }
      if (DataManager.isItemHaveMPEffect(item)) {
        gauge = this.drawMpGauge();
        if (gauge.visible) {
          this.gaugeitems.push(gauge);
        }
      }
      if (DataManager.isItemHaveTPEffect(item)) {
        gauge = this.drawTpGauge();
        if (gauge.visible) {
          this.gaugeitems.push(gauge);
        }
      }
    }

    drawHpGauge() {
      return this._drawIGauge(this.settings.partySelectorHpGauge, this.actor.hpRate());
    }

    drawMpGauge() {
      return this._drawIGauge(this.settings.partySelectorMpGauge, this.actor.mpRate());
    }

    drawTpGauge() {
      return this._drawIGauge(this.settings.partySelectorTpGauge, this.actor.tpRate());
    }

    _drawIGauge(gaugeSettings, value) {
      var gauge, i, item, len, ref;
      gauge = new AA.LIBS.Sprite_ColorGauge(gaugeSettings);
      gauge.drawGauge(value);
      this.addChild(gauge);
      if (this.gaugeitems.length > 0) {
        ref = this.gaugeitems;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          gauge.y += item.height - 1;
        }
      }
      return gauge;
    }

    drawEquipedIcon(item) {
      var e, equippedOne, etype, extraIcon, i, len, ref;
      try {
        etype = item.etypeId;
        equippedOne = null;
        ref = this.actor.equips();
        for (i = 0, len = ref.length; i < len; i++) {
          e = ref[i];
          if ((e != null) && e.etypeId === item.etypeId) {
            equippedOne = e;
            break;
          }
        }
        if (equippedOne != null) {
          extraIcon = DataManager.getItemInvImage(equippedOne);
          if (String.any(extraIcon)) {
            return this._drawEquipIcon(ImageManager.loadAA_Icon(extraIcon), true);
          } else {
            return this._drawEquipIcon(equippedOne.iconIndex);
          }
        } else {
          return this._drawEquipIcon(this.settings.partySelectorEquipIcons.nothingEquippedIcon);
        }
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    _drawEquipIcon(iconIndex, withBack) {
      var s;
      s = this.settings.partySelectorEquipIcons;
      this.iconSpr = AASprite.FromBitmap(20);
      if (withBack === true) {
        this.iconSpr.drawIcon(0, 0, s.nothingEquippedIcon, 20);
      }
      this.iconSpr.drawIcon(0, 0, iconIndex, 20);
      this.iconSpr.move(s.marginX, s.marginY);
      //if @actor == $gameParty.leader()
      //    @iconSpr.move 0, s.marginY
      return this.addChild(this.iconSpr);
    }

    moveUp() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(1, this._moveSpeed, this._moveDistance);
    }

    moveLeft() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(0, this._moveSpeed, this._moveDistance);
    }

    moveRight() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(2, this._moveSpeed, this._moveDistance);
    }

    moveDown() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(3, this._moveSpeed, this._moveDistance);
    }

    moveLeftAndUp() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(4, this._moveSpeed, this._moveDistance + 1);
    }

    moveLeftAndDown() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(5, this._moveSpeed, this._moveDistance + 1);
    }

    moveRightAndUp() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(6, this._moveSpeed, this._moveDistance + 1);
    }

    moveRightAndDown() {
      this.fadeOut(this._fadeOutSpeed);
      return this.startMove(7, this._moveSpeed, this._moveDistance + 1);
    }

    close() {
      return this.fadeIn(this._fadeInSpeed);
    }

    registerClick() {
      var actor;
      this._cell._clickHandlers = [];
      actor = this.actor;
      this._cell.addClickHandler(function() {
        return AA.UI.onInvPartyCellClick(actor);
      });
    }

    isHovered() {
      return this._cell.isMouseInButton();
    }

  };
  AA.register(Sprite_MapInventoryActorCell);
})();

// ■ END Sprite_MapInventoryActorCell.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvCell.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInvCell;
  Sprite_MapInvCell = class Sprite_MapInvCell extends AASprite {
    constructor(index1) {
      super();
      this.index = index1;
      this._inSpecialState = false;
      this._isEquipedItem = false;
      this._isFavWeapon = false;
      this._isChestItem = false;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._iconSprPlace = new Sprite();
      this._loadImages();
      this._createCell();
      this.add(this._iconSprPlace);
      //@_createIconSpr()
      this._createQualityLevelSpr();
      this._createSpecial();
      this._createCountText();
      return this._createFader();
    }

    _loadSettings() {
      this.settings = this._settingsJSON();
      this.customCellParams = null;
      if (AA.Parameters.isCustomSizeCells()) {
        return this.customCellParams = AA.Parameters.getCustomSizeCellsParameters();
      }
    }

    _loadImages() {
      // * Нужен для размеров
      this.slotBitmap = ImageManager.loadAA("InventorySlot_00");
      this.slotBitmap.addLoadListener(this._createIconSpr.bind(this));
      this._imgs0 = [ImageManager.loadAA("InventorySlot_00"), ImageManager.loadAA("InventorySlot_01"), ImageManager.loadAA("InventorySlot_00"), ImageManager.loadAA("InventorySlot_00")];
      this._imgs1 = [ImageManager.loadAA("InventorySlotA_00"), ImageManager.loadAA("InventorySlotA_01"), ImageManager.loadAA("InventorySlotA_00"), ImageManager.loadAA("InventorySlotA_00")];
      this._imgs2 = [ImageManager.loadAA("InventorySlotB_00"), ImageManager.loadAA("InventorySlotB_01"), ImageManager.loadAA("InventorySlotB_00"), ImageManager.loadAA("InventorySlotB_00")];
      return this._imgs3 = [ImageManager.loadAA("InventorySlotC_00"), ImageManager.loadAA("InventorySlotC_01"), ImageManager.loadAA("InventorySlotC_00"), ImageManager.loadAA("InventorySlotC_00")];
    }

    _createCell() {
      this._cell = new KDCore.Button();
      this._cell.setButtonImages(...this._imgs0);
      //index = @getMyIndex()
      return this.add(this._cell);
    }

    //getMyIndex: -> @i * 5 + @j
    _createIconSpr() {
      if (this.customCellParams != null) {
        this._iconSpr = this._createCustomIconSpr();
      } else {
        this._iconSpr = AASprite.FromBitmap(30, 30);
        this._iconSpr.move(4, 4);
      }
      this._iconSprPlace.addChild(this._iconSpr);
      if (this.item != null) {
        return this.drawIconExt(this.item.iconIndex);
      }
    }

    _createCustomIconSpr() {
      var h, iconSpr, w;
      if (this.customCellParams.iconMode === 0) {
        iconSpr = AASprite.FromBitmap(32);
        w = this.slotBitmap.width;
        h = this.slotBitmap.height;
        iconSpr.anchor.x = 0.5;
        iconSpr.anchor.y = 0.5;
        iconSpr.x = w / 2;
        iconSpr.y = h / 2;
      } else {
        iconSpr = AASprite.FromBitmap(this.customCellParams.iconSize);
        iconSpr.move(4, 4);
      }
      return iconSpr;
    }

    _createQualityLevelSpr() {
      if (!AA.Parameters.get_AllowRareSystem()) {
        return;
      }
      this._rareSpr = new Sprite();
      return this.add(this._rareSpr);
    }

    _createSpecial() {
      this._createSpecialSpr();
      return this._createSpecialText();
    }

    _createSpecialSpr() {
      this._specialSpr = AASprite.FromImg("InventorySlotA");
      this._specialSpr.move(AA.Utils.jsonPos(this.settings.invCellCornerPosition));
      this._specialSpr.visible = false;
      return this.add(this._specialSpr);
    }

    _createSpecialText() {
      this._specialSprText = AASprite.FromBitmap(this.settings.cellItemSpecialText.textBoxWidth, this.settings.cellItemSpecialText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._specialSprText, this.settings.cellItemSpecialText);
      this._specialSpr.add(this._specialSprText);
    }

    _createCountText() {
      this._textSpr = AASprite.FromBitmap(this.settings.cellItemCountText.textBoxWidth, this.settings.cellItemCountText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.cellItemCountText);
      return this.add(this._textSpr);
    }

    //@drawCount 4
    setItem(item1) {
      this.item = item1;
      if (this.item != null) {
        this.drawIconExt();
        this.drawQualityLevel(DataManager.getItemQualityLevel(this.item));
        this.drawCount($gameParty.numItems(this.item));
        this.refreshSpecialState();
        return this.registerClick();
      } else {
        return this.clear();
      }
    }

    drawIconExt() {
      var extraImg;
      extraImg = DataManager.getItemInvImage(this.item);
      if (String.any(extraImg)) {
        this.drawIcon(ImageManager.loadAA_Icon(extraImg));
      } else {
        this.drawIcon(this.item.iconIndex);
      }
    }

    refreshSpecialState() {
      if (this.item == null) {
        return;
      }
      this._checkUsableThread = null;
      if (DataManager.isItem(this.item)) {
        return this._refreshItemState();
      } else {
        return this._refreshEquipmentState();
      }
    }

    _refreshItemState() {
      var notAllowedOccasion;
      if (AA.isABS()) {
        notAllowedOccasion = 2; // * MENU SCREEN
        if ((this.item.meta != null) && (this.item.meta.ABS == null) && this.item.scope !== 0) {
          this.disableItem();
        }
      } else {
        notAllowedOccasion = 1; // * BATTLE SCREEN
      }
      if (this.item.occasion === 3) { // * NEVER
        this.disableItem();
      }
      if (this.item.occasion === notAllowedOccasion) {
        this.disableItem();
      }
      this._checkItemOnPanel();
      if (this.isEnabled()) {
        return this._checkUsable();
      }
    }

    disableItem() {
      return this._fader.visible = true;
    }

    _checkItemOnPanel() {
      var index;
      index = $gameParty.leader().skillIndexOnUI(this.item.id, true);
      if (index >= 0) {
        return this._applyItemSpecialState(index + 1);
      }
    }

    _applyItemSpecialState(index) {
      this._inSpecialState = true;
      this._cell.setButtonImages(...this._imgs1);
      this._specialSpr.bitmap = ImageManager.loadAA('InventorySlotA');
      this._specialSprText.clear();
      this._specialSprText.drawTextFull(index.toString(), this.settings.cellItemSpecialText.position);
      return this._specialSpr.visible = true;
    }

    _refreshEquipmentState() {
      var actor, canEquip, e, equippedAlready, equips, i, j, k, len, ref;
      try {
        if (AA.UI.isPartyInventoryAllowed()) {
          // * Чтобы одна и таже вещь на разных показывалась
          this.whoCanEquip = [];
          this.whoCanUnEquip = [];
          ref = AA.UI.partyGroup();
          for (k = 0, len = ref.length; k < len; k++) {
            actor = ref[k];
            if (this.whoCanUnEquip.length === 0) {
              this._refreshEquipmentStateForActor(actor);
            }
          }
          if (this.whoCanEquip.length === 0 && this.whoCanUnEquip.length === 0) {
            // * Если предмет не экиперован и никто не может экиперовать, отключить
            this.disableItem();
          }
          if (this.isEnabled()) {
            return this._checkEquipmentsUsable();
          }
        } else {
          // * DISABLE IF CANNOT EQUIP
          canEquip = $gameParty.leader().canEquip(this.item);
          if (!canEquip) {
            this.disableItem();
          }
          equips = $gameParty.leader().equips();
          for (i in equips) {
            j = equips[i];
            if (j === this.item) {
              equippedAlready = this._getUnequipCandidtaes()[this.item.id];
              if (equippedAlready != null) {
                continue;
              }
              this._setCandidateForUnequip($gameParty.leader().actorId());
              this._isEquipedItem = true;
              this._applyEquipmenSpecialState();
            }
          }
          if (DataManager.isWeapon(this.item)) {
            return this._checkFavState();
          }
        }
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    _applyEquipmenSpecialState() {
      this._applyEquipmentSpecialCellState();
      this._specialSprText.clear();
      this._specialSprText.drawTextFull(this.settings.cellEquipmentSymbol, this.settings.cellItemSpecialText.position);
      if (this._inSpecialState) {
        return this.drawCount(1);
      } else {
        return this.drawCount($gameParty.numItems(this.item));
      }
    }

    _applyEquipmentSpecialCellState() {
      this._inSpecialState = true;
      this._cell.setButtonImages(...this._imgs2);
      this._specialSpr.bitmap = ImageManager.loadAA('InventorySlotB');
      this._specialSpr.visible = true;
    }

    _checkFavState() {
      var symbol;
      symbol = $gameParty.leader().getFavWeapSymbol(this.item);
      if (symbol == null) {
        return;
      }
      this._isFavWeapon = true;
      symbol = symbol.toUpperCase();
      if (this._inSpecialState === true) {
        symbol = this.settings.cellEquipmentSymbol + "|" + symbol;
      }
      return this._applyEquipmenFavSpecialState(symbol);
    }

    _applyEquipmenFavSpecialState(symbol) {
      this._applyEquipmentSpecialCellState();
      this._specialSprText.clear();
      this._specialSprText.drawTextFull(symbol, this.settings.cellItemSpecialText.position);
    }

    //@drawCount($gameParty.numItems(@item))
    registerClick() {
      var index;
      //if @isEnabled()
      this._cell._clickHandlers = [];
      index = this.index;
      this._cell.addClickHandler(function() {
        return AA.UI.onInvCellClick(index);
      });
    }

    //else
    //    @_cell._clickHandlers = []
    clear() {
      this.item = null;
      this._checkUsableThread = null;
      this._isEquipedItem = false;
      this._isFavWeapon = false;
      this._fader.visible = false;
      this._isChestItem = false;
      this._cell._clickHandlers = [];
      this._clearSpeacialState();
      this.drawCount(0);
      this.drawIcon(0);
      return this.drawQualityLevel(-1);
    }

    _clearSpeacialState() {
      if (this._inSpecialState === true) {
        this._cell.setButtonImages(...this._imgs0);
        this._specialSpr.visible = false;
      }
      return this._inSpecialState = false;
    }

    drawCount(count) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      if (count > 1) {
        return this._textSpr.drawTextFull(count, this.settings.cellItemCountText.position);
      }
    }

    drawIcon(iconIndex) {
      if (this._iconSpr == null) {
        return;
      }
      this._iconSpr.clear();
      if (iconIndex instanceof Bitmap || iconIndex > 0) {
        if (iconIndex instanceof Bitmap && !iconIndex.isReady()) {
          iconIndex.addLoadListener(() => {
            return this.drawIcon(iconIndex);
          });
        }
        if (this.customCellParams != null) {
          if (this.customCellParams.iconMode === 0) {
            this._iconSpr.bitmap.drawIcon(0, 0, iconIndex, 32);
          } else {
            this._iconSpr.bitmap.drawIcon(0, 0, iconIndex, this.slotBitmap.width - 8);
          }
        } else {
          this._iconSpr.bitmap.drawIcon(0, 0, iconIndex, 30);
        }
      }
    }

    drawQualityLevel(level) {
      if (this._rareSpr == null) {
        return;
      }
      if (level < 0) {
        this._rareSpr.bitmap = new Bitmap(1, 1);
        return;
      }
      this._rareSpr.bitmap = ImageManager.loadAA('QualityLevel_' + level);
    }

    isHovered() {
      return this._cell.isMouseInButton();
    }

    isEnabled() {
      return this._fader.visible === false;
    }

    _createFader() {
      if (this.customCellParams != null) {
        this._fader = AASprite.FromBitmap(this.customCellParams.iconSize);
      } else {
        this._fader = AASprite.FromBitmap(30, 30);
      }
      this._fader.bitmap.fillAll(KDCore.Color.BLACK);
      this._fader.opacity = 120;
      this._fader.visible = false;
      this._fader.move(4, 4);
      return this.add(this._fader);
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    isCanBeUnEquiped() {
      return this._inSpecialState === true && this._isEquipedItem === true;
    }

    setChestItem(item) {
      var iCount;
      if (item == null) {
        return;
      }
      this.item = item[0];
      if (AA.UI.isGoldItem(this.item)) {
        iCount = $gameTemp.__visualChestGoldCount;
        $gameTemp.__visualChestGoldCell = this;
      } else {
        iCount = item[1];
      }
      if ((this.item != null) && (iCount != null)) {
        this.drawIconExt();
        this.drawCount(iCount);
        this.drawQualityLevel(DataManager.getItemQualityLevel(this.item));
        this.registerClickForChest();
        return this._isChestItem = true;
      } else {
        return this.clear();
      }
    }

    registerClickForChest() {
      var index;
      index = this.index;
      return this._cell.addClickHandler(function() {
        return AA.UI.onChestCellClick(index);
      });
    }

    update() {
      var ref;
      AASprite.prototype.update.call(this);
      return (ref = this._checkUsableThread) != null ? ref.update() : void 0;
    }

  };
  AA.register(Sprite_MapInvCell);
})();

// ■ END Sprite_MapInvCell.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvCell.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Sprite_MapInvCell.prototype;
  _.setFocusItem = function(item1, count) {
    this.item = item1;
    this.drawIconExt();
    this.drawCount(count);
    this.registerFocusClick();
    return this.drawFocusFrame();
  };
  _.registerFocusClick = function() {
    var index;
    this._cell._clickHandlers = [];
    index = this.index;
    return this._cell.addClickHandler(function() {
      return AA.UI.onInvCellFocusedClick(index);
    });
  };
  _.drawFocusFrame = function() {
    return this._cell.setButtonImages(...this._imgs3);
  };
  _._checkUsable = function() {
    this.partyUsecases = [];
    if (this._isCanAutoRefreshItemsState()) {
      this._onCheckUsableTick();
      return this._checkUsableThread = new AATimedUpdate(20, this._onCheckUsableTick.bind(this));
    } else {
      return this._onCheckUsableTick();
    }
  };
  _._isCanAutoRefreshItemsState = function() {
    return AA.isABS() && AA.Parameters.get_AutoRefreshItems();
  };
  _._onCheckUsableTick = function() {
    var canUse, e, i, j, k, len, ref;
    if (AA.isABS()) {
      return;
    }
    //"CHECK USABLE FOR ITEM".p(@item.name)
    if (this.item.occasion === 1) { // * battle screen
      this.disableItem();
      return false;
    }
    if (this.item.scope === 0 && (this.item.occasion === 2 || this.item.occasion === 0)) {
      this.enableItem();
      return true;
    }
    canUse = true;
    try {
      if (AA.UI.isPartyInventoryAllowed()) {
        ref = AA.UI.partyGroup();
        for (j = k = 0, len = ref.length; k < len; j = ++k) {
          i = ref[j];
          this.partyUsecases[j] = this._canActorUseItem(i);
        }
        canUse = this.partyUsecases.some(function(i) {
          return i === true;
        });
      } else {
        canUse = this._canActorUseItem($gameParty.leader());
      }
      if (!canUse) {
        return this.disableItem();
      } else {
        return this.enableItem();
      }
    } catch (error) {
      e = error;
      AA.warning(e);
      return this.disableItem();
    }
  };
  _._canActorUseItem = function(actor) {
    var _S, actorIndex, item, result;
    _S = Scene_Item.prototype;
    this.user = function() {
      return actor;
    };
    item = this.item;
    this.item = function() {
      return item;
    };
    this.isItemEffectsValid = function() {
      return _S.isItemEffectsValid.call(this);
    };
    this._actorWindow = {};
    actorIndex = AA.UI.partyGroup().indexOf(actor);
    this._actorWindow.index = function() {
      return actorIndex;
    };
    this.itemTargetActors = function() {
      return _S.itemTargetActors.call(this);
    };
    result = _S.canUse.call(this);
    this.item = item;
    return result;
  };
  _.enableItem = function() {
    return this._fader.visible = false;
  };
})();

// ■ END Sprite_MapInvCell.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInventoryStatText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInventoryStatText;
  Sprite_MapInventoryStatText = class Sprite_MapInventoryStatText extends AASprite {
    constructor(statId, cell) {
      super();
      this.statId = statId;
      this.cell = cell;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createContent();
      return this._drawValues();
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _createContent() {
      this.baseTextLine = AASprite.FromTextSettings(this.settings.EquipmentStats.statText);
      //@baseTextLine.fillAll(KDCore.Color.RED)
      return this.addChild(this.baseTextLine);
    }

    _drawValues() {
      var actor, item;
      item = this.cell.item;
      if (AA.UI.partyGroup().length === 1 || !AA.UI.isPartyInventoryAllowed()) {
        return this._drawStateValueForActor($gameParty.leader());
      } else {
        if (this.isEquipped() && (this.cell.whoCanEquip.last() != null)) {
          actor = $gameActors.actor(this.cell.whoCanEquip.last());
          return this._drawStateValueForActor(actor);
        } else {
          if (this.cell.whoCanEquip != null) {
            actor = $gameActors.actor(this.cell.whoCanEquip.first());
            if (actor != null) {
              return this._drawStateValueForActor(actor);
            } else {
              return this._drawEquipValue();
            }
          } else {
            return this._drawEquipValue(); // * CHESTS
          }
        }
      }
    }

    _drawStateValueForActor(actor) {
      if (this.isEquipped()) {
        if (AA.Parameters.get_AllowFullStats()) {
          return this._drawStateValue(actor[this.statId], 'normal');
        } else {
          return this._drawEquipValue();
        }
      } else {
        return this._drawStateDiffValue(actor);
      }
    }

    _drawStateValue(value, colorType) {
      this.baseTextLine.b().textColor = this.getColorHex(colorType);
      return this.baseTextLine.drawTextFull(value, 'center');
    }

    _drawEquipValue() {
      var paramId, type, value;
      paramId = this.paramValueId();
      if (paramId >= 0) {
        value = this.cell.item.params[paramId];
      } else {
        value = 0;
      }
      type = 'normal';
      if (value < 0) {
        type = 'lower';
      } else if (value > 0) {
        type = 'hight';
        value = "+" + value;
      }
      this.baseTextLine.b().textColor = this.getColorHex(type);
      this.baseTextLine.drawTextFull(value, 'center');
    }

    _drawStateDiffValue(actor) {
      var actorCurrentParam, actorParamBase, eq, equippedValue, newValue, paramId, paramValue, t, type;
      paramId = this.paramValueId();
      if (paramId >= 0) {
        paramValue = this.cell.item.params[paramId];
      } else {
        paramValue = 0;
      }
      eq = this._equipedOne(actor, this.cell.item);
      if (eq != null) {
        equippedValue = eq.params[paramId];
      } else {
        equippedValue = 0;
      }
      actorParamBase = actor[this.statId] - equippedValue;
      actorCurrentParam = actor[this.statId];
      newValue = actorParamBase + paramValue;
      if (newValue === actorCurrentParam) {
        type = 'normal';
      } else if (newValue > actorCurrentParam) {
        type = 'hight';
      } else {
        type = 'lower';
      }
      if (type === 'normal') {
        this._drawStateValue(newValue, 'normal');
      } else {
        t = "";
        if (type === 'lower') {
          t = newValue + "(-" + (actorCurrentParam - newValue) + ")";
        } else {
          t = newValue + "(+" + (newValue - actorCurrentParam) + ")";
        }
        this.baseTextLine.b().textColor = this.getColorHex(type);
        this.baseTextLine.drawTextFull(t, 'center');
      }
    }

    _equipedOne(actor, item) {
      item = actor.equips()[item.etypeId - 1];
      //console.info item
      return item;
    }

    paramValueId() {
      switch (this.statId) {
        case 'atk':
          return 2;
        case 'def':
          return 3;
        case 'mat':
          return 4;
        case 'mdf':
          return 5;
        case 'agi':
          return 6;
        case 'luk':
          return 7;
        default:
          return -1;
      }
    }

    isOnlyleader() {
      return AA.UI.partyGroup().length === 1;
    }

    isEquipped() {
      return this.cell._isEquipedItem === true && this.cell._inSpecialState === true;
    }

    getColorHex(colorType) {
      switch (colorType) {
        case 'normal':
          return KDCore.Color.FromHex(this.settings.EquipmentStats.statTextColor).CSS;
        case 'lower':
          return KDCore.Color.FromHex(this.settings.EquipmentStats.statLowerColor).CSS;
        case 'hight':
          return KDCore.Color.FromHex(this.settings.EquipmentStats.statHightColor).CSS;
        default:
          return KDCore.Color.WHITE.CSS;
      }
    }

  };
  AA.register(Sprite_MapInventoryStatText);
})();

// ■ END Sprite_MapInventoryStatText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvFooter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInvFooter;
  Sprite_MapInvFooter = class Sprite_MapInvFooter extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createContent();
      return this._createSectionControl();
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _createContent() {
      this._createGoldIcon();
      this._createGoldTextSpr();
      return this._createWeightSystem();
    }

    _createWeightSystem() {
      if (AA.Parameters.get_IsUseMapInventoryWeightSystem()) {
        this._createWeightTextSpr();
        return this._createWeightIcon();
      }
    }

    _createWeightIcon() {
      var icon;
      icon = AASprite.FromImg(this.settings.weightIcon);
      icon.move(AA.Utils.jsonPos(this.settings.weightIconPosition));
      return this.add(icon);
    }

    _createWeightTextSpr() {
      var extraFooter;
      extraFooter = AASprite.FromImg(this.settings.extraFooter);
      extraFooter.move(AA.Utils.jsonPos(this.settings.extraFooterPosition));
      this.add(extraFooter);
      this._textSpr3 = AASprite.FromBitmap(this.settings.weightText.textBoxWidth, this.settings.weightText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr3, this.settings.weightText);
      return this.add(this._textSpr3);
    }

    //@drawWeight "344/444", false
    drawWeight(text, isOver) {
      var tc;
      if (this._textSpr3 == null) {
        return;
      }
      this._textSpr3.clear();
      if (this.settings.weightText.backgroundFill != null) {
        this._textSpr3.bitmap.fillAll(KDCore.Color.FromHex(this.settings.weightText.backgroundFill));
      }
      tc = KDCore.Color.FromHex(this.settings.weightText.textColor).CSS;
      if (isOver) {
        tc = KDCore.Color.FromHex(this.settings.weightText.textColor2).CSS;
      }
      this._textSpr3.bitmap.textColor = tc;
      return this._textSpr3.drawTextFull(text, this.settings.weightText.position);
    }

    _createGoldIcon() {
      this.goldIcon = AASprite.FromImg(this.settings.goldIcon);
      this.goldIcon.move(AA.Utils.jsonPos(this.settings.goldIconPosition));
      return this.add(this.goldIcon);
    }

    _createGoldTextSpr() {
      this._textSpr = AASprite.FromBitmap(this.settings.goldText.textBoxWidth, this.settings.goldText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.goldText);
      return this.add(this._textSpr);
    }

    //@drawGold "3444"
    drawGold(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.goldText.position);
    }

    _createSectionControl() {
      this._createArrows();
      return this._createPageText();
    }

    _createArrows() {
      var img0, img1, img3;
      this._arrowL = new KDCore.Button();
      img0 = ImageManager.loadAA("inventoryArrowLeft_00");
      img1 = ImageManager.loadAA("inventoryArrowLeft_01");
      img3 = ImageManager.loadAA("inventoryArrowLeft_03");
      this._arrowL.setButtonImages(img0, img1, img0, img3);
      this._arrowL.move(AA.Utils.jsonPos(this.settings.pageArrowLeftInSectionPos));
      this._arrowL.disable();
      this._arrowL.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.invShowPrevPage();
      });
      this.add(this._arrowL);
      this._arrowR = new KDCore.Button();
      img0 = ImageManager.loadAA("inventoryArrowRight_00");
      img1 = ImageManager.loadAA("inventoryArrowRight_01");
      img3 = ImageManager.loadAA("inventoryArrowRight_03");
      this._arrowR.setButtonImages(img0, img1, img0, img3);
      this._arrowR.move(AA.Utils.jsonPos(this.settings.pageArrowRightInSectionPos));
      this._arrowR.disable();
      this._arrowR.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.invShowNextPage();
      });
      this.add(this._arrowR);
    }

    _createPageText() {
      this._textSpr2 = AASprite.FromBitmap(this.settings.pageText.textBoxWidth, this.settings.pageText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr2, this.settings.pageText);
      this.add(this._textSpr2);
      return this.drawPagesCount(1, 1);
    }

    drawPagesCount(current, max) {
      var text;
      if (this._textSpr2 == null) {
        return;
      }
      this._textSpr2.clear();
      //@_textSpr2.bitmap.fillAll KDCore.Color.RED
      text = current + "/" + max;
      return this._textSpr2.drawTextFull(text, this.settings.pageText.position);
    }

    //@[ALIAS]
    update() {
      super.update();
      if (this._wPulseThread != null) {
        this._wPulseThread.update();
      }
    }

    pulseWeightText() {
      if (this._textSpr3 == null) {
        return;
      }
      if (this._wPulseThread != null) {
        this._textSpr3.opacity = 255;
      }
      this._pulseCount = 3;
      this._pulseTimer = 0;
      return this._wPulseThread = new AATimedUpdate(10, this._onPulseThread.bind(this));
    }

    _onPulseThread() {
      this._textSpr3.opacity = Math.abs(Math.sin(this._pulseTimer)) * 255;
      this._pulseTimer += 10;
      //console.log(@_pulseTimer)
      if (this._pulseTimer >= 30) {
        this._pulseTimer = 0;
        this._pulseCount--;
      }
      //console.log(@_pulseCount)
      if (this._pulseCount <= 0) {
        this._wPulseThread = null;
        this._textSpr3.opacity = 255;
      }
    }

    disableArrows() {
      this._arrowL.disable();
      return this._arrowR.disable();
    }

  };
  AA.register(Sprite_MapInvFooter);
})();

// ■ END Sprite_MapInvFooter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvHeader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInvHeader;
  Sprite_MapInvHeader = class Sprite_MapInvHeader extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._drawIcon();
      this._createContent();
      return this._createCloseButton();
    }

    _createBackground() {
      this._background = AASprite.FromImg(this.settings.headerBackImg);
      return this.add(this._background);
    }

    _drawIcon() {
      var icon;
      if (this.settings.icon == null) {
        return;
      }
      icon = AASprite.FromImg(this.settings.icon);
      icon.move(this.settings.iconMarginX, this.settings.iconMarginY);
      return this.add(icon);
    }

    _createContent() {
      var addedCount, availableCatList, img0, img1, img3;
      this._content = new Sprite();
      availableCatList = this.settings.availableCategories;
      addedCount = 0;
      this.categoryBtns = [];
      //? this is must be above items! here...
      img0 = ImageManager.loadAA(this.settings.categoryButtonImg);
      img1 = ImageManager.loadAA(this.settings.categoryButtonHoverImg);
      img3 = ImageManager.loadAA(this.settings.categoryButtonSelectedImg);
      if (availableCatList.items === true) {
        this.category1 = new KDCore.Button();
        this.category1.setButtonImages(img0, img1, img0, img3);
        this.category1.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.invShowCategoryItems();
        });
        this._content.addChild(this.category1);
        this.categoryBtns.push(this.category1);
        addedCount++;
      } else {
        this.category1 = null;
        this.categoryBtns.push(null);
      }
      if (availableCatList.weapons === true) {
        this.category2 = new KDCore.Button();
        this.category2.setButtonImages(img0, img1, img0, img3);
        if (addedCount !== 0) {
          this.category2.move(this.settings.categoryButtonMarginBetween * addedCount, 0);
        } else {
          this.category2.move(0, 0); //?line
        }
        this.category2.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.invShowCategoryWeapons();
        });
        this._content.addChild(this.category2);
        this.categoryBtns.push(this.category2);
        addedCount++;
      } else {
        this.categoryBtns.push(null);
      }
      if (availableCatList.armors === true) {
        this.category3 = new KDCore.Button();
        this.category3.setButtonImages(img0, img1, img0, img3);
        if (addedCount !== 0) {
          this.category3.move(this.settings.categoryButtonMarginBetween * addedCount, 0);
        } else {
          this.category3.move(0, 0); //?line
        }
        this.category3.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.invShowCategoryArmors();
        });
        this._content.addChild(this.category3);
        this.categoryBtns.push(this.category3);
        addedCount++;
      } else {
        this.categoryBtns.push(null);
      }
      if (availableCatList.keyItems === true) {
        this.category4 = new KDCore.Button();
        this.category4.setButtonImages(img0, img1, img0, img3);
        if (addedCount !== 0) {
          this.category4.move(this.settings.categoryButtonMarginBetween * addedCount, 0);
        } else {
          this.category4.move(0, 0); //?line
        }
        this.category4.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.invShowCategoryKeyItems();
        });
        this._content.addChild(this.category4);
        this.categoryBtns.push(this.category4);
      } else {
        this.categoryBtns.push(null);
      }
      this._content.move(this.settings.categoryButtonsMarginX, this.settings.categoryButtonsMarginY);
      this._createCategoryIcons();
      this.add(this._content);
    }

    _createCategoryIcons() {
      var i, icon, j, ref, ref1, results;
      results = [];
      for (i = j = 0, ref = this.categoryBtns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        icon = AASprite.FromImg(this.settings.categoriesIcons[i]);
        results.push((ref1 = this.categoryBtns[i]) != null ? ref1.addChild(icon) : void 0);
      }
      return results;
    }

    _createCloseButton() {
      var img0, img1;
      if (this.settings.isCloseButtonVisible !== true) {
        return;
      }
      this.closeBtn = new KDCore.Button();
      img0 = ImageManager.loadAA(this.settings.closeButtonImg);
      img1 = ImageManager.loadAA(this.settings.closeButtonHoverImg);
      this.closeBtn.setButtonImages(img0, img1, img0, img0);
      this.closeBtn.move(this.settings.closeButtonMarginX, this.settings.closeButtonMarginY);
      this.closeBtn.addClickHandler(function() {
        return AA.UI.closeInventoryByClick();
      });
      return this.add(this.closeBtn);
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    enableAllButtons() {
      var btn, j, len, ref, results;
      ref = this.categoryBtns;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        btn = ref[j];
        results.push(btn != null ? btn.enable() : void 0);
      }
      return results;
    }

    getHoveredIndex() {
      var btn, i, j, ref;
      for (i = j = 0, ref = this.categoryBtns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        btn = this.categoryBtns[i];
        if (btn != null ? btn.isMouseInButton() : void 0) {
          return i;
        }
      }
      return null;
    }

    isMouseIn() {
      var pos, rx, ry;
      pos = TouchInput.getMousePosition();
      rx = Sprite_Button.prototype.canvasToLocalX.call(this._background, pos.x);
      ry = Sprite_Button.prototype.canvasToLocalY.call(this._background, pos.y);
      return rx >= 0 && ry >= 0 && rx <= this._background.width && ry <= this._background.height;
    }

  };
  AA.register(Sprite_MapInvHeader);
})();

// ■ END Sprite_MapInvHeader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvHelp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInvHelp;
  Sprite_MapInvHelp = class Sprite_MapInvHelp extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createContent();
      return this._createCorner();
    }

    _loadSettings() {
      this.basicSettings = this._settingsJSON();
      return this.settings = this.basicSettings.helpWindow;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _createBackground() {
      this._background = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this._background.bitmap.fillAll(KDCore.Color.FromHex(this.settings.backgroundColor));
      this._background.opacity = this.settings.backgroundOpacity;
      return this.add(this._background);
    }

    _createCorner() {
      this._corner = AASprite.FromImg('inventoryHintCorner');
      return this._background.add(this._corner);
    }

    _createContent() {
      this.content = new Sprite();
      this._createCost();
      this._createName();
      this._creatType();
      this._createDescription();
      this._createWeight();
      this._createQLevel();
      this._createStats();
      return this._background.add(this.content);
    }

    _createCost() {
      this._textCostSpr = AASprite.FromTextSettings(this.settings.itemCostText);
      this.content.addChild(this._textCostSpr);
      this.goldIcon = AASprite.FromImg(this.basicSettings.goldIcon);
      this.goldIcon.move(AA.Utils.jsonPos(this.settings.goldIconPosition));
      return this.content.addChild(this.goldIcon);
    }

    _createName() {
      this._textNameSpr = AASprite.FromTextSettings(this.settings.itemNameText);
      return this.content.addChild(this._textNameSpr);
    }

    _creatType() {
      this._textTypeSpr = AASprite.FromTextSettings(this.settings.itemTypeText);
      return this.content.addChild(this._textTypeSpr);
    }

    _createDescription() {
      var p;
      p = this.settings.descriptionWindow;
      this._description = new Window_Base(p.x, p.y, p.width, p.height);
      this._description.setBackgroundType(2);
      this.content.addChild(this._description);
      this._description.standardFontSize = function() {
        return p.fontSize;
      };
      this._description.lineHeight = function() {
        return 12;
      };
      this._description.standardPadding = function() {
        return 6;
      };
      if ((p.fontFace != null) && AA.isPro()) {
        return this._description.standardFontFace = function() {
          return p.fontFace;
        };
      }
    }

    _createStats() {
      if (!AA.Parameters.get_AllowEquipStats()) {
        return;
      }
      this._stats = AASprite.FromImg(this.basicSettings.EquipmentStats.statsBackImage);
      this._stats.move(this.basicSettings.EquipmentStats.position);
      this._stats.visible = false;
      return this.content.addChild(this._stats);
    }

    showItemStats() {
      if (this._stats == null) {
        return;
      }
      if (!this._isStatsAllowed) {
        return;
      }
      if (this._stats.visible === true) {
        this._description.visible = true;
        this._stats.visible = false;
      } else {
        this._description.visible = false;
        this._stats.visible = true;
      }
    }

    delay() {
      return this.settings.showDelay;
    }

    setup(cell) {
      this.cell = cell;
      this._isStatsAllowed = false;
      if (this.cell == null) {
        return;
      }
      this.drawCost();
      this.drawName();
      this.drawType();
      this.drawDesc();
      this.showActionHelp();
      if (AA.Parameters.get_IsUseMapInventoryWeightSystem()) {
        this.drawWeight();
      }
      if (AA.Parameters.get_AllowRareSystem()) {
        this.drawQLevel();
      }
      if (AA.Parameters.get_AllowEquipStats()) {
        this.setupStats();
        return this.showStatsHelp();
      }
    }

    setupStats() {
      var item;
      item = this.cell.item;
      if (DataManager.isItem(item)) {
        return this._isStatsAllowed = false;
      } else {
        this._createStatesParamsValues();
        return this._isStatsAllowed = true;
      }
    }

    showStatsHelp() {
      var actionHelpSpr, helpIcon, s;
      if (!this._isStatsAllowed) {
        return;
      }
      s = this.basicSettings.EquipmentStats;
      actionHelpSpr = AASprite.FromTextSettings(s.statsHelpText);
      //actionHelpSpr.fillAll()
      actionHelpSpr.drawTextWithSettings(s.helpIconText);
      this.content.addChild(actionHelpSpr);
      helpIcon = AASprite.FromImg("inventoryScrollHelp");
      helpIcon.move(AA.Utils.jsonPos(s.helpIconPosition));
      return this.content.addChild(helpIcon);
    }

    drawWeight() {
      var ref, text;
      text = DataManager.getItemWeight(this.cell.item);
      return (ref = this._textWeightSpr) != null ? ref.drawTextWithSettings(text) : void 0;
    }

    drawQLevel() {
      var color, qualityLevel, ref;
      qualityLevel = DataManager.getItemQualityLevel(this.cell.item);
      color = this._getColorForQualityLevel(qualityLevel);
      this._textQLevelSpr.b().textColor = color;
      return (ref = this._textQLevelSpr) != null ? ref.drawTextWithSettings(this._getTextForQualityLevel(qualityLevel)) : void 0;
    }

    _getTextForQualityLevel(qualityLevel) {
      var levelData;
      levelData = this.basicSettings.QualitySystem.Levels[qualityLevel];
      if (levelData == null) {
        return "";
      }
      return levelData[0];
    }

    _getColorForQualityLevel(qualityLevel) {
      var levelData;
      levelData = this.basicSettings.QualitySystem.Levels[qualityLevel];
      if (levelData == null) {
        return KDCore.Color.WHITE.CSS;
      }
      return KDCore.Color.FromHex(levelData[1]).CSS;
    }

    drawCost() {
      var ref, text;
      text = this.cell.item.price;
      //@_textCostSpr.fillAll()
      return (ref = this._textCostSpr) != null ? ref.drawTextWithSettings(text) : void 0;
    }

    drawName() {
      var ref, text;
      text = this.cell.item.name;
      //@_textNameSpr.fillAll()
      return (ref = this._textNameSpr) != null ? ref.drawTextWithSettings(text) : void 0;
    }

    drawType() {
      var ref, text, type;
      type = this._getTypeText(this.cell.item);
      text = type.text;
      this._textTypeSpr.bitmap.textColor = KDCore.Color.FromHex(type.color).CSS;
      //@_textTypeSpr.fillAll()
      return (ref = this._textTypeSpr) != null ? ref.drawTextWithSettings(text) : void 0;
    }

    _getTypeText(item) {
      var color, e, specialColor, specialText, text;
      color = null;
      text = null;
      try {
        if (DataManager.isItem(item)) {
          if (item.itypeId === 1) { // * NORMAL
            if (item.consumable === true) {
              text = this.settings.consumableTypeText;
              color = this.settings.defaultTypeColors.consumableItem;
            } else {
              text = TextManager.item;
              color = this.settings.defaultTypeColors.normalItem; // * KEY
            }
          } else {
            text = TextManager.keyItem;
            color = this.settings.defaultTypeColors.keyItem;
          }
        } else {
          if (DataManager.isWeapon(item)) {
            text = $dataSystem.weaponTypes[item.wtypeId];
            color = this.settings.defaultTypeColors.weapon;
          } else if (DataManager.isArmor(item)) {
            text = $dataSystem.armorTypes[item.atypeId];
            color = this.settings.defaultTypeColors.armor;
          }
        }
      } catch (error) {
        e = error;
        AA.warning('_getTypeText', e);
      }
      specialText = this._getItemSpecialTypeText(item);
      if (specialText != null) {
        text = specialText;
      }
      specialColor = this._getItemSpecialTypeColor(item);
      if (specialColor != null) {
        color = specialColor;
      }
      if (text == null) {
        text = "Unknown";
      }
      if (color == null) {
        color = "#FFFFFF";
      }
      return {text, color};
    }

    _getItemSpecialTypeText(item) {
      if (item.meta == null) {
        return null;
      }
      return item.meta.aItemType;
    }

    _getItemSpecialTypeColor(item) {
      if (item.meta == null) {
        return null;
      }
      return item.meta.aItemTypeColor;
    }

    drawDesc() {
      var text;
      this._description.contents.clear();
      text = this.cell.item.description;
      // * why + 150 ???
      return this._description.drawTextExWithPrepare(text, 0, 0, this.settings.descriptionWindow.width + 150);
    }

    showActionHelp() {
      var item, name, text;
      if ((AA.UI.isUserChestIsOpen() || AA.UI.isStoredChestIsOpen()) && this.cell._isChestItem === false) {
        text = AA.JSON.getUIMapUserChestSettings().putInHelpText;
        this._drawActionHelpText(text);
        return;
      }
      if (!this.cell.isEnabled()) {
        return;
      }
      if (this.cell._isChestItem === true) {
        text = this._getwActionHelpTextChestItem();
      } else {
        item = this.cell.item;
        text = "";
        if (DataManager.isItem(item)) {
          text = this.settings.helpUseItemText;
        } else {
          if (this.cell.isCanBeUnEquiped()) {
            text = this.settings.helpUnEquipItemText;
            if (AA.UI.isPartyInventoryAllowed()) {
              name = this.cell._getSpecialStateActorName();
              if (name != null) {
                text += " [" + name + "]";
              }
            }
          } else {
            if (AA.UI.isPartyInventoryAllowed()) {
              text = this.settings.helpEquipItemText;
              if (this.cell.whoCanEquip.length === 1) {
                name = $gameActors.actor(this.cell.whoCanEquip[0]).name();
                if (name != null) {
                  text += " [" + name + "]";
                }
              } else if (this.cell.whoCanEquip.length > 1) {
                text += " [*]";
              }
            } else {
              text = this.settings.helpEquipItemText;
            }
          }
        }
      }
      this._drawActionHelpText(text);
    }

    _getwActionHelpTextChestItem() {
      return AA.JSON.getUIMapChestSettings().helpWindow.helpTakeItemText;
    }

    _drawActionHelpText(text) {
      var actionHelpSpr, helpIcon;
      if ((text != null) && text !== "") {
        actionHelpSpr = AASprite.FromTextSettings(this.settings.clickHelpText);
        //actionHelpSpr.fillAll()
        actionHelpSpr.drawTextWithSettings(text);
        this.content.addChild(actionHelpSpr);
        helpIcon = AASprite.FromImg("inventoryClickHelp");
        helpIcon.move(AA.Utils.jsonPos(this.settings.helpIconPosition));
        return this.content.addChild(helpIcon);
      }
    }

    refreshPlacement() {
      var dx, dy, pos;
      pos = this.getSourcePos();
      this.move(pos.x + this.settings.marginX, pos.y + this.settings.marginY);
      dx = dy = 0;
      if (this._background.width + this.x + 5 > Graphics._boxWidth) {
        dx = 1;
        this.x -= this.settings.marginX;
      }
      if (this._background.height + this.y + 5 > Graphics._boxHeight) {
        dy = 1;
        this.y -= this.settings.marginY;
      }
      this._background.setStaticAnchor(dx, dy);
      this._refreshCornerPlacement(dx, dy);
    }

    getSourcePos() {
      var x, y;
      if (this.cell != null) {
        x = KDCore.SDK.toGlobalCoord(this.cell, "x");
        y = KDCore.SDK.toGlobalCoord(this.cell, "y");
        return new KDCore.Point(x, y);
      } else {
        return TouchInput.getMousePosition();
      }
    }

    _refreshCornerPlacement(dx, dy) {
      var pos;
      this._corner.scale.x = 1;
      this._corner.scale.y = 1;
      if (dx === 1 && dy === 0) {
        pos = this.settings.cornerPositions.topRight;
      }
      if (dx === 0 && dy === 0) {
        pos = this.settings.cornerPositions.topLeft;
        this._corner.scale.x = -1;
      }
      if (dx === 1 && dy === 1) {
        pos = this.settings.cornerPositions.downRight;
        this._corner.scale.y = -1;
      }
      if (dx === 0 && dy === 1) {
        pos = this.settings.cornerPositions.downLeft;
        this._corner.scale.x = -1;
        this._corner.scale.y = -1;
      }
      return this._corner.move(AA.Utils.jsonPos(pos));
    }

    _createWeight() {
      var wIcon;
      if (!AA.Parameters.get_IsUseMapInventoryWeightSystem()) {
        return;
      }
      this._textWeightSpr = AASprite.FromTextSettings(this.settings.itemWeightText);
      this.content.addChild(this._textWeightSpr);
      wIcon = AASprite.FromImg(this.basicSettings.weightIcon);
      wIcon.move(AA.Utils.jsonPos(this.settings.weighIconPosition));
      return this.content.addChild(wIcon);
    }

    _createQLevel() {
      var wIcon;
      if (!AA.Parameters.get_AllowRareSystem()) {
        return;
      }
      this._textQLevelSpr = AASprite.FromTextSettings(this.settings.itemQualityText);
      if (this.basicSettings.QualitySystem.qualityIcon != null) {
        wIcon = AASprite.FromImg(this.basicSettings.QualitySystem.qualityIcon);
        wIcon.move(AA.Utils.jsonPos(this.settings.qualityIconPosition));
        this.content.addChild(wIcon);
      }
      return this.content.addChild(this._textQLevelSpr);
    }

    _createStatesParamsValues() {
      var s, sp;
      s = this.basicSettings.EquipmentStats.stats;
      if (s.atk.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("atk", this.cell);
        sp.move(s.atk.position);
        this._stats.addChild(sp);
      }
      if (s.def.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("def", this.cell);
        sp.move(s.def.position);
        this._stats.addChild(sp);
      }
      if (s.agi.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("agi", this.cell);
        sp.move(s.agi.position);
        this._stats.addChild(sp);
      }
      if (s.mat.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("mat", this.cell);
        sp.move(s.mat.position);
        this._stats.addChild(sp);
      }
      if (s.mdf.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("mdf", this.cell);
        sp.move(s.mdf.position);
        this._stats.addChild(sp);
      }
      if (s.luk.visible === true) {
        sp = new AA.LIBS.Sprite_MapInventoryStatText("luk", this.cell);
        sp.move(s.luk.position);
        return this._stats.addChild(sp);
      }
    }

  };
  AA.register(Sprite_MapInvHelp);
})();

// ■ END Sprite_MapInvHelp.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MainInvItems.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MainInvItems;
  Sprite_MainInvItems = class Sprite_MainInvItems extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createItemNameLine();
      return this._createContent();
    }

    _createItemNameLine() {
      this._textSpr = AASprite.FromBitmap(this.settings.itemName.textBoxWidth, this.settings.itemName.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.itemName);
      return this.add(this._textSpr);
    }

    //@drawItemName "Apple"
    drawItemName(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.itemName.position);
    }

    _createContent() {
      this.content = new Sprite();
      this._createCells();
      this.content.move(AA.Utils.jsonPos(this.settings.invCellStartPosition));
      this.add(this.content);
    }

    _createCells() {
      var c, cell, i, index, j, k, params, r, ref, results;
      this._cells = [];
      index = 0;
      r = 5;
      c = 5;
      if (AA.Parameters.isCustomSizeCells() === true) {
        params = AA.Parameters.getCustomSizeCellsParameters();
        r = params.rowsPerPage;
        c = params.columnsPerPage;
      }
      results = [];
      for (i = k = 0, ref = r; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (j = l = 0, ref1 = c; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
            cell = this._createCell(index++);
            this._cells.push(cell);
            results1.push(this._placeCell(i, j, cell));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    _createCell(i, j) {
      var cell;
      cell = new AA.LIBS.Sprite_MapInvCell(i, j);
      this.content.addChild(cell);
      return cell;
    }

    _placeCell(i, j, cell) {
      return cell.move(this.settings.invCellMarginX * j, this.settings.invCellMarginY * i);
    }

    _loadSettings() {
      return this.settings = this._settingsJSON();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    getCellAt(index) {
      return this._cells[index];
    }

    getHoveredCell() {
      var cell, k, len, ref;
      if (this.focusedCell != null) {
        return null;
      }
      ref = this._cells;
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        if (cell.isHovered()) {
          return cell;
        }
      }
      return null;
    }

    clearAllItems() {
      var cell, k, len, ref, results;
      this.clearFocus();
      ref = this._cells;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        results.push(cell.clear());
      }
      return results;
    }

  };
  AA.register(Sprite_MainInvItems);
})();

// ■ END Sprite_MainInvItems.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AA_MInvMainSprite.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapInvMain;
  Sprite_MapInvMain = class Sprite_MapInvMain extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._main = new Sprite();
      return this.add(this._main);
    }

    _loadSettings() {
      this.settings = this._settingsJSON();
      this.moveByJson(this.settings);
      return this.visible = this.settings.visible;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _createBackground() {
      this._background = AASprite.FromImg(this.settings.backgroundImg);
      return this.add(this._background);
    }

    _createHeader() {
      this._header = new AA.LIBS.Sprite_MapInvHeader();
      return this._main.addChild(this._header);
    }

    _createContent() {
      this._content = new AA.LIBS.Sprite_MainInvItems();
      return this._main.addChild(this._content);
    }

    _createFooter() {
      this._footer = new AA.LIBS.Sprite_MapInvFooter();
      return this._main.addChild(this._footer);
    }

    isMouseIn() {
      var pos, rx, ry;
      if (this._content._isSomePartyActorIsHovered()) {
        return true;
      }
      pos = TouchInput.getMousePosition();
      rx = Sprite_Button.prototype.canvasToLocalX.call(this._background, pos.x);
      ry = Sprite_Button.prototype.canvasToLocalY.call(this._background, pos.y);
      return rx >= 0 && ry >= 0 && rx <= this._background.width && ry <= this._background.height;
    }

    createMain() {
      this._createHeader();
      this._createContent();
      return this._createFooter();
    }

    destroyMain() {
      this._main.removeChild(this._header);
      this._main.removeChild(this._footer);
      this._main.removeChild(this._content);
      this._header.destroy();
      this._footer.destroy();
      this._content.destroy();
      this._header = null;
      this._content = null;
      this._footer = null;
    }

    playStartSE() {
      return AA.Utils.playSE(this.settings.openInventorySE);
    }

  };
  AA.register(Sprite_MapInvMain);
})();

// ■ END AA_MInvMainSprite.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillWindowPartyMember;
  Sprite_MapSkillWindowPartyMember = class Sprite_MapSkillWindowPartyMember extends AA.LIBS.Sprite_MapInventoryActorCell {
    constructor(actorIndex) {
      super();
      this.actorIndex = actorIndex;
      this.move(0, 0);
      this.opacity = 255;
      this.setActor(AA.UI.partyGroup()[this.actorIndex]);
    }

    registerClick() {
      var index;
      this._cell._clickHandlers = [];
      index = this.actorIndex;
      this._cell.addClickHandler(function() {
        return AA.UI.skillWActorClick(index);
      });
    }

    _loadImages() {
      return this._imgs0 = [ImageManager.loadAA("partySlot_00"), ImageManager.loadAA("partySlot_01"), ImageManager.loadAA("partySlot_00"), ImageManager.loadAA("partySlot_01")];
    }

    drawGauges() {} // * EMPTY

    drawEquipedIcon() {} // * EMPTY

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

  };
  AA.register(Sprite_MapSkillWindowPartyMember);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillsCell;
  Sprite_MapSkillsCell = class Sprite_MapSkillsCell extends AA.LIBS.Sprite_MapInvCell {
    constructor(index) {
      super(index);
    }

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

    
      //$[OVER]
    setItem(item) {
      this.item = item;
      if (this.item != null) {
        this.drawIcon(this.item.iconIndex);
        this.drawCost(...this._getCostValues());
        this.refreshSpecialState();
        return this.registerClick();
      } else {
        return this.clear();
      }
    }

    _getCostValues() {
      if (this.item.mpCost > 0) {
        return [this.item.mpCost, true];
      } else {
        if (this.item.tpCost > 0) {
          return [this.item.tpCost, false];
        }
      }
      return [0, false];
    }

    drawCost(value, isMp) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      if (value > 0) {
        if (isMp === true) {
          this._textSpr.bitmap.textColor = KDCore.Color.FromHex(this.settings.cellItemCostText.textColorMP).CSS;
        } else {
          this._textSpr.bitmap.textColor = KDCore.Color.FromHex(this.settings.cellItemCostText.textColorTP).CSS;
        }
        this._textSpr.drawTextFull(value, this.settings.cellItemCostText.position);
      }
    }

    //$[OVER]
    refreshSpecialState() {
      if (this.item == null) {
        return;
      }
      this._checkUsableThread = null;
      return this._refreshSkillState();
    }

    _refreshSkillState() {
      var notAllowedOccasion;
      if (AA.isABS()) {
        notAllowedOccasion = 2; // * MENU SCREEN
      } else {
        notAllowedOccasion = 1; // * BATTLE SCREEN
      }
      if (this.item.occasion === 3) { // * NEVER
        this.disableItem();
      }
      if (this.item.occasion === notAllowedOccasion) {
        this.disableItem();
      }
      this._checkItemOnPanel();
      if (this.isEnabled()) {
        return this._checkUsable();
      }
    }

    //$[OVER]
    _checkItemOnPanel() {
      var index;
      //TODO: Может не показывать номер на панели навыков у не игроков
      index = $gameTemp._aaSkillWindowActiveActor.skillIndexOnUI(this.item.id, false);
      if (index >= 0) {
        return this._applyItemSpecialState(index + 1);
      }
    }

    //$[OVER]
    registerClick() {
      var index;
      this._cell._clickHandlers = [];
      index = this.index;
      this._cell.addClickHandler(function() {
        return AA.UI.onSkillWindowCellClick(index);
      });
    }

    //$[OVER]
    _createCountText() {
      this._textSpr = AASprite.FromBitmap(this.settings.cellItemCostText.textBoxWidth, this.settings.cellItemCostText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.cellItemCostText);
      return this.add(this._textSpr);
    }

    //@drawCount 4

      //$[OVER]
    _checkUsable() {
      if ($gameTemp._aaSkillWindowActiveActor == null) {
        return;
      }
      if (this._isCanAutoRefreshItemsState()) {
        this._onCheckUsableTick();
        return this._checkUsableThread = new AATimedUpdate(20, this._onCheckUsableTick.bind(this));
      } else {
        return this._onCheckUsableTick();
      }
    }

    _isCanAutoRefreshItemsState() {
      return AA.isABS() && AA.Parameters.get_AutoRefreshSkills();
    }

    _onCheckUsableTick() {
      if (AA.isABS()) {
        return this._checkBasicSkillUsableABS();
      } else {
        //TODO: Проверка возможности использовать навык на не ABS карте
        return this._checkBasicSkillUsable();
      }
    }

    _checkBasicSkillUsable() {}

    _checkBasicSkillUsableABS() {
      var e;
      try {
        //"CHECK USABLE FOR ITEM".p(@item.name)
        if (this.item.occasion === 2 || this.item.occasion === 3) {
          this.disableItem();
          return false;
        }
        if (this.item.scope === 0 && (this.item.occasion === 0 || this.item.occasion === 1)) {
          this.enableItem();
          return true;
        }
        if ($gameTemp._aaSkillWindowActiveActor.canUse(this.item)) {
          this.enableItem();
          return true;
        } else {
          this.disableItem();
          return false;
        }
      } catch (error) {
        e = error;
        AA.warning('error', e);
        this.disableItem();
        return false;
      }
    }

  };
  AA.register(Sprite_MapSkillsCell);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillsFooter;
  Sprite_MapSkillsFooter = class Sprite_MapSkillsFooter extends AA.LIBS.Sprite_MapInvFooter {
    constructor() {
      super();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

    _createWeightSystem() {} // * EMPTY

    _createGoldIcon() {
      this.goldIcon = AASprite.FromImg(this.settings.manaIcon);
      this.goldIcon.move(AA.Utils.jsonPos(this.settings.manaIconPosition));
      return this.add(this.goldIcon);
    }

    _createGoldTextSpr() {
      this._textSpr = AASprite.FromBitmap(this.settings.manaText.textBoxWidth, this.settings.manaText.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.manaText);
      return this.add(this._textSpr);
    }

    //@drawGold "3444"
    drawMana(text) {
      return this.drawGold(text);
    }

    drawGold(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.manaText.position);
    }

    _createArrows() {
      super._createArrows();
      this._arrowL.clearClickHandlers();
      this._arrowR.clearClickHandlers();
      this._arrowL.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.skillsWPrevPage();
      });
      return this._arrowR.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.skillsWNextPage();
      });
    }

  };
  AA.register(Sprite_MapSkillsFooter);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillsHeader;
  Sprite_MapSkillsHeader = class Sprite_MapSkillsHeader extends AA.LIBS.Sprite_MapInvHeader {
    constructor() {
      super();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

    _createContent() {
      this.categoryBtns = [];
      if (AA.Parameters.get_MapSkillWindowAllowParty() === true) {
        return this.createPartyMembersSelect();
      }
    }

    createPartyMembersSelect() {
      var face, i, j, members, ref;
      if (this._actorFacesSprite != null) {
        this._destroyActorFaces();
      }
      members = AA.UI.partyGroup();
      this._actorFacesSprite = new Sprite();
      this._actorFaces = [];
      if (members.length <= 1) {
        return;
      }
      for (i = j = 0, ref = members.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        face = new AA.LIBS.Sprite_MapSkillWindowPartyMember(i);
        this._actorFaces.push(face);
        this._actorFacesSprite.addChild(face);
        face.move(i * this.settings.partyMembers.marginBetweenProtraits, 0);
      }
      this.addChild(this._actorFacesSprite);
      this._actorFacesSprite.x = this.settings.partyMembers.marginX;
      return this._actorFacesSprite.y = this.settings.partyMembers.marginY;
    }

    _destroyActorFaces() {
      var f, j, len, ref;
      if (this._actorFaces != null) {
        ref = this._actorFaces;
        for (j = 0, len = ref.length; j < len; j++) {
          f = ref[j];
          this._actorFacesSprite.removeChild(f);
        }
      }
      this.removeChild(this._actorFacesSprite);
      this._actorFacesSprite.visible = false;
      this._actorFacesSprite = null;
    }

    //TODO: НАДО ПИСАТЬ НОВЫЙ КОНТЕЙНЕР С ВЫРАВНИВАНИЕМ ПО ЦЕНТРУ!
    drawActorSkillsCategories(actor) {
      var btn, categoryButton, clickFunc, i, img0, img1, img3, j, k, len, ref, sType, skillTypes;
      this._clearCategories();
      img0 = ImageManager.loadAA(this.settings.categoryButtonImg);
      img1 = ImageManager.loadAA(this.settings.categoryButtonHoverImg);
      img3 = ImageManager.loadAA(this.settings.categoryButtonSelectedImg);
      skillTypes = this._makeSkillTypes(actor);
      this._selectActiveActor(actor);
      if (skillTypes.length <= 1) {
        return;
      }
      this._content = new AXUI.Container(15 * skillTypes.length);
      this._content.setItemsCount(skillTypes.length);
      this._content.setSpacing(this.settings.categoryButtonMarginBetween);
      //@_content.setPivotToCenter()
      this._content.move(this.settings.categoryButtonsCenterPoint);
//@_content.x = @_content.x + 10
      for (j = 0, len = skillTypes.length; j < len; j++) {
        sType = skillTypes[j];
        categoryButton = new KDCore.Button();
        categoryButton.setButtonImages(img0, img1, img0, img3);
        this._content.addChild(categoryButton);
        this.categoryBtns.push(categoryButton);
        categoryButton._skillType = sType;
      }
      this.addChild(this._content);
      for (i = k = 0, ref = this.categoryBtns.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        btn = this.categoryBtns[i];
        if (btn == null) {
          continue;
        }
        clickFunc = function() {
          SoundManager.playCursor();
          return AA.UI.skillWindowShowCategory(this._skillType - 1);
        };
        btn.addClickHandler(clickFunc.bind(btn));
      }
      this._createCategoryIcons();
    }

    _createCategoryIcons() {
      var btn, i, icon, j, ref;
      for (i = j = 0, ref = this.categoryBtns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        btn = this.categoryBtns[i];
        if (btn == null) {
          continue;
        }
        icon = AASprite.FromImg("SkillWindow_skillType_" + btn._skillType);
        btn.addChild(icon);
      }
    }

    _selectActiveActor(actor) {
      var f, group, index, j, len, ref, ref1;
      if (this._actorFacesSprite == null) {
        return;
      }
      group = AA.UI.partyGroup();
      index = group.indexOf(actor);
      ref = this._actorFaces;
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        if (f != null) {
          f._cell.enable();
        }
      }
      if (index >= 0) {
        return (ref1 = this._actorFaces[index]) != null ? ref1._cell.disable() : void 0;
      }
    }

    _makeSkillTypes(actor) {
      var skillTypes;
      skillTypes = actor.addedSkillTypes();
      skillTypes.sort(function(a, b) {
        return a - b;
      });
      return skillTypes;
    }

    _clearCategories() {
      if (this._content == null) {
        return;
      }
      this._content.visible = false;
      this.removeChild(this._content);
      this._content = null;
      return this._createContent();
    }

    _createCloseButton() {
      super._createCloseButton();
      this.closeBtn.clearClickHandlers();
      return this.closeBtn.addClickHandler(function() {
        return AA.UI.closeSkillWindowByClick();
      });
    }

    isMouseIn() {
      return super.isMouseIn() || this._isMouseOnAnyActorButton();
    }

    _isMouseOnAnyActorButton() {
      var b, j, len, ref;
      if (this._actorFaces == null) {
        return false;
      }
      ref = this._actorFaces;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if ((b != null) && b.isHovered()) {
          return true;
        }
      }
      return false;
    }

  };
  AA.register(Sprite_MapSkillsHeader);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillsItems;
  Sprite_MapSkillsItems = class Sprite_MapSkillsItems extends AA.LIBS.Sprite_MainInvItems {
    constructor() {
      super();
    }

    _createItemNameLine() {
      this._textSpr = AASprite.FromBitmap(this.settings.skillName.textBoxWidth, this.settings.skillName.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr, this.settings.skillName);
      return this.add(this._textSpr);
    }

    //@drawItemName "Apple"
    drawSkillName(text) {
      return this.drawItemName(text);
    }

    drawItemName(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.skillName.position);
    }

    _createCell(i, j) {
      var cell;
      cell = new AA.LIBS.Sprite_MapSkillsCell(i, j);
      this.content.addChild(cell);
      return cell;
    }

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

  };
  AA.register(Sprite_MapSkillsItems);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapSkillsMain;
  Sprite_MapSkillsMain = class Sprite_MapSkillsMain extends AA.LIBS.Sprite_MapInvMain {
    constructor() {
      super();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapSkillSettings();
    }

    _createHeader() {
      this._header = new AA.LIBS.Sprite_MapSkillsHeader();
      return this._main.addChild(this._header);
    }

    _createContent() {
      this._content = new AA.LIBS.Sprite_MapSkillsItems();
      return this._main.addChild(this._content);
    }

    _createFooter() {
      this._footer = new AA.LIBS.Sprite_MapSkillsFooter();
      return this._main.addChild(this._footer);
    }

    playStartSE() {
      return AA.Utils.playSE(this.settings.openWindowSE);
    }

    isMouseIn() {
      return super.isMouseIn() || this._header.isMouseIn();
    }

  };
  AA.register(Sprite_MapSkillsMain);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ zSprite_MapUserChestMain_PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapUserChestMain;
  Sprite_MapUserChestMain = class Sprite_MapUserChestMain extends AA.LIBS.Sprite_MapInvMain {
    constructor() {
      super();
    }

    _createHeader() {
      this._header = new AA.LIBS.Sprite_MapUserChestHeader();
      this._main.addChild(this._header);
      return this.moveByJson(AA.JSON.getUIMapUserChestSettings());
    }

    _createFooter() {
      this._footer = new AA.LIBS.Sprite_MapChestFooter();
      return this._main.addChild(this._footer);
    }

    playStartSE() {
      return AA.Utils.playSE(this.settings.openChestSE);
    }

  };
  AA.register(Sprite_MapUserChestMain);
})();

// ■ END zSprite_MapUserChestMain_PRO.coffee
//---------------------------------------------------------------------------

(function(){

  //Sprite_StateIcon
  //------------------------------------------------------------------------------
    //NEW
    Sprite_StateIcon.prototype.setPriority = function(value) {
      this._priority = value;
    };

    //OVER
    Sprite_StateIcon.prototype.updateIcon = function() {
        var icons = [];
        if (this._battler && this._battler.isAlive()) {
          if(!this._priority)
              icons = this._battler.allIcons();
            else {
              icons = this._battler.allIconsWithPriority(this._priority);
            }
        }
        if (icons.length > 0) {
            this._animationIndex++;
            if (this._animationIndex >= icons.length) {
                this._animationIndex = 0;
            }
            this._iconIndex = icons[this._animationIndex];
        } else {
            this._animationIndex = 0;
            this._iconIndex = 0;
        }
    };

    //END Sprite_Sprite_StateIcon
  //------------------------------------------------------------------------------

})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteUIElement.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteUIElement;
  SpriteUIElement = class SpriteUIElement extends AASprite {
    constructor(id, outerSettingSource) {
      super();
      this.id = id;
      this.outerSettingSource = outerSettingSource;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      return this._createForeground();
    }

    _loadSettings() {
      this.settings = this._getSettings();
      this.moveByJson(this.settings);
      this.opacity = this.settings.opacity;
      this.scale.x = this.settings.scale;
      this.scale.y = this.settings.scale;
      return this.visible = this.settings.visible;
    }

    _getSettings() {
      if (this.outerSettingSource != null) {
        return this.outerSettingSource(this.id);
      } else {
        return AA.JSON.getUIElementSettings(this.id);
      }
    }

    _createBackground() {
      if (String.any(this.settings.backgroundImg)) {
        this._background = AASprite.FromImg(this.settings.backgroundImg);
      } else {
        this._background = AASprite.FromBitmap(60, 20);
      }
      this._background.opacity = this.settings.backgroundOpacity;
      this.add(this._background);
      return this._background.onReady(this._createText.bind(this));
    }

    _createText() {
      var tH, tW;
      if (this.settings.text == null) {
        return;
      }
      tW = this.settings.textZoneWidth;
      tH = this.settings.textZoneHeight;
      if (tW == null) {
        tW = this._background.width;
      }
      if (tH == null) {
        tH = this._background.height;
      }
      this._textSpr = AASprite.FromBitmap(tW, tH);
      this._textSpr.opacity = this.settings.textOpacity;
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      this.add(this._textSpr);
      return this._textSpr.onReady(this._drawTextOnReady.bind(this));
    }

    _drawTextOnReady() {
      if (this._drawOnReady != null) {
        this.drawText(this._drawOnReady);
        return this._drawOnReady = null;
      }
    }

    _createForeground() {
      if (this.settings.foregroundImg == null) {
        return;
      }
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      this._foreground.opacity = this.settings.foregroundOpacity;
      if (this.settings.foregroundMarginX != null) {
        this._foreground.move(this.settings.foregroundMarginX, this._foreground.y);
      }
      if (this.settings.foregroundMarginY != null) {
        this._foreground.move(this._foreground.x, this.settings.foregroundMarginY);
      }
      return this.add(this._foreground);
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      //@_textSpr.bitmap.fillAll KDCore.Color.RED
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

    drawTextOnReady(text) {
      this._drawOnReady = text;
      return this.drawText(text);
    }

    drawExtraIcon(iconIndex, size) {
      if (iconIndex == null) {
        return;
      }
      if (size == null) {
        size = this.settings.iconSize;
      }
      if (this._iconSpr == null) {
        this._createIconSpr(size);
      }
      this._iconSpr.clear();
      return this._iconSpr.drawIcon(0, 0, iconIndex, size);
    }

    drawExtraImg(name, x = 0, y = 0) {
      if (name == null) {
        return;
      }
      if (this._imgSpr != null) {
        this._destroyImg();
      }
      this._imgSpr = AASprite.FromImg(name);
      this._imgSpr.move(x, y);
      this._background.addChild(this._imgSpr);
    }

    _destroyImg() {
      return this._background.removeChild(this._imgSpr);
    }

    _createIconSpr(size) {
      this._iconSpr = AASprite.FromBitmap(size);
      //@_iconSpr.bitmap.fillAll KDCore.Color.RED
      return this._background.addChild(this._iconSpr);
    }

  };
  AA.register(SpriteUIElement);
})();

// ■ END SpriteUIElement.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Vector.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    function Sprite_Vector() {
        this.initialize.apply(this, arguments);
    }

    AlphaABS.register(Sprite_Vector);

    Sprite_Vector.prototype = Object.create(Sprite.prototype);
    Sprite_Vector.prototype.constructor = Sprite_Vector;

    Sprite_Vector.prototype.initialize = function (imageName) {
        Sprite.prototype.initialize.call(this);
        this.bitmap = ImageManager.loadPicture(imageName);
        this._frameCount = 1;
        this._animIndex = -1;
        this._wait = 0;
        this._parseAnimatedVectorName(imageName);
        if (this.isAnimated()) {
            this._maxWait = 6;
            this._animIndex = 0;
            this._calculateFrameSize();
            this.setIdleFrame(0);
            //TODO: Скорость анимации
        }
    };

    var _ = Sprite_Vector.prototype;

    _._parseAnimatedVectorName = function (name) {
        if(name.contains("_")){
            var last = name.split("_").last();
            var number = Number(last);
            if(!isNaN(number)) {
                this._frameCount = number;
                //"IS ANIMATED".p();
                return true;
            }
        }
        return false;
    };

    _.isAnimated = function () {
        return this._frameCount > 1;
    };

    _._calculateFrameSize = function () {
        this._frameW = Math.round(this.bitmap.width / this._frameCount);
        this._frameH = this.bitmap.height;
    };

    _.setIdleFrame = function (frameNumber) {
        var frame = this._createFrame(frameNumber, 0);
        this.setFrame(frame[0], frame[1], frame[2], frame[3]);
    };

    _._createFrame = function (i, j) {
        return [i * this._frameW, j * this._frameH, this._frameW, this._frameH];
    };

    _.update = function() {
        Sprite.prototype.update.call(this);
        this._updateFrame();
        this._updateWait();
    };

    _._updateFrame = function () {
        if (this._animIndex >= 0 && this._wait == 0) {
            this.setIdleFrame(this._animIndex);
            //console.log(this._animIndex);
            this._animIndex += 1;
            this._wait = 1;
        }
        if(this._animIndex == this._frameCount) {
            this._animIndex = 0;
        }
    };

    _._updateWait = function() {
        if (this._wait > 0) {
            this._wait++;
            if (this._wait > this._maxWait)
                this._wait = 0;
        }
    };
})();
// ■ END Sprite_Vector.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
  //OVER
  Sprite_Weapon.prototype.animationWait = function () {
    return 6;
  };

  //NEW
  Sprite_Weapon.prototype.setDirectionABS = function (directionKey) {
    if (this._weaponImageId <= 0) return;

    this.scale.x = 0.7;
    this.scale.y = 0.7;
    this.y = 0;
    this.x = 0;
    this.opacity = 255;

    switch (directionKey) {
      case 'r':
        this.x = 8;
        this.scale.x *= -1;
        break;
      case 'l':
        this.x = -8;
        break;
      case 'u':
        this.y = -15;
        break;
      case 'd':
        this.y = 5;
        break;
    }
  };
})();
// ■ END Sprite_Weapon.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteActorPortrait.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteActorPortrait, _C;
  
  //@[DEFINES]
  _C = KDCore.Color;
  SpriteActorPortrait = class SpriteActorPortrait extends AASprite {
    //? portrait = {faceName, faceIndex}
    constructor(index, portrait1) {
      super();
      this.index = index;
      this.portrait = portrait1;
      this._create();
      this.refresh();
    }

    _create() {
      this._loadSettings();
      if (this._isUseMask()) {
        this._loadMask();
      }
      this._createBackground();
      this._createFace();
      this._createForeground();
      this._visualEqSprites = [];
      return this.visible = this.settings.visible;
    }

    _loadSettings() {
      this.settings = AA.JSON.getPortraitSettings(this.index);
      return this.moveByJson(this.settings);
    }

    _isUseMask() {
      return this.settings.useMask === true;
    }

    _loadMask() {
      this._maskImg = AASprite.FromImg(this.settings.maskImg);
      return this.add(this._maskImg);
    }

    _createBackground() {
      this._background = AASprite.FromImg(this.settings.backgroundImg);
      return this.add(this._background);
    }

    _createFace() {
      var e;
      try {
        this._face = AASprite.FromBitmap(this.settings.faceSize);
        this._drawFace();
        if (this.settings.flipFace === true) {
          this._invertFace();
        }
        if (this._maskImg != null) {
          this._face.mask = this._maskImg;
        }
        return this.add(this._face);
      } catch (error) {
        e = error;
        return AA.warning('_createFace : Sprite Actor Portrait', e);
      }
    }

    _drawFace() {
      var tBitmap;
      this._face.clear();
      if (AA.isCCEXImproted === true) {
        //? EXTENSION FOR SumRndmDde Character Creator EX
        if (this.portrait instanceof Game_Battler) {
          if ((this.portrait.hasSetImage != null) && this.portrait.hasSetImage()) {
            this._drawFaceEx();
          }
          return;
        }
      }
      if (this.portrait.faceName == null) {
        return;
      }
      tBitmap = ImageManager.loadFace(this.portrait.faceName);
      tBitmap.addLoadListener(() => {
        var ph, pw, sx, sy;
        pw = Window_Base._faceWidth;
        ph = Window_Base._faceHeight;
        sx = this.portrait.faceIndex % 4 * pw;
        sy = Math.floor(this.portrait.faceIndex / 4) * ph;
        return this._face.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this._face.width, this._face.height);
      });
    }

    _invertFace() {
      this._face.scale.x *= -1;
      return this._face.x = this._face.width;
    }

    _createForeground() {
      if (this.settings.foregroundImg == null) {
        return;
      }
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      return this.add(this._foreground);
    }

    setPortrait(portrait) {
      return this.portrait = portrait;
    }

    refresh() {
      return this._drawFace();
    }

    //?{NEW}
    drawVisualEq(equips) {
      var i, len, s;
      this._clearVisualEq();
      if (equips == null) {
        return;
      }
      for (i = 0, len = equips.length; i < len; i++) {
        s = equips[i];
        this.drawVisualEqItem(s + "_Face");
      }
    }

    _clearVisualEq() {
      var i, len, ref, s;
      ref = this._visualEqSprites;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        this._face.removeChild(s);
        s.visible = false;
      }
      return this._visualEqSprites = [];
    }

    //?{NEW}
    drawVisualEqItem(fileName) {
      var spr, tBitmap;
      if (fileName == null) {
        return;
      }
      spr = AASprite.FromBitmap(this.settings.faceSize);
      tBitmap = ImageManager.loadAAEquip(fileName);
      tBitmap.addLoadListener(() => {
        var ph, pw, sx, sy;
        pw = Window_Base._faceWidth;
        ph = Window_Base._faceHeight;
        sx = 0;
        sy = 0;
        return spr.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this._face.width, this._face.height);
      });
      this._face.addChild(spr);
      return this._visualEqSprites.push(spr);
    }

  };
  AA.register(SpriteActorPortrait);
})();

// ■ END SpriteActorPortrait.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteGauge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteGauge, _C;
  //@[DEFINES]
  _C = KDCore.Color;
  SpriteGauge = class SpriteGauge extends AASprite {
    //? id = 'hp', 'mp', etc...
    constructor(id) {
      super();
      this.id = id;
      this._create();
    }

    _create() {
      this._loadSettings();
      if (this._isUseMask()) {
        this._loadMask();
      }
      this._loadFill();
      this._createForeground();
      this.visible = this.settings.visible;
      return this.isVerticalGauge = (this.settings.vertical != null) && this.settings.vertical === true;
    }

    _loadSettings() {
      this.settings = AA.JSON.getGaugeSettings(this.id);
      return this.moveByJson(this.settings);
    }

    _isUseMask() {
      return this.settings.useMask === true;
    }

    _loadMask() {
      this._maskImg = AASprite.FromImg(this.settings.maskImg);
      return this.add(this._maskImg);
    }

    _loadFill() {
      this._fillImg = AASprite.FromImg(this.settings.fillImg);
      this._fillImg.onReady(this._createBackground.bind(this));
      return this._fillImg.onReady(this._createFill.bind(this));
    }

    _createBackground() {
      this._background = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this._background.fillAll(_C.FromHex(this.settings.backgroundColor));
      this._background.opacity = this.settings.backgroundOpacity;
      if (this._maskImg != null) {
        this._background.mask = this._maskImg;
      }
      return this.add(this._background);
    }

    _createFill() {
      this._fill = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this._fill.mask = this._maskImg;
      this._fill.onReady(this._createText.bind(this));
      this.drawGauge();
      return this.add(this._fill);
    }

    _createText() {
      if (this.settings.text == null) {
        return;
      }
      this._textSpr = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      return this._fill.add(this._textSpr);
    }

    drawGauge(percent = 1) {
      var h, hy, w;
      if (this._fill == null) {
        return;
      }
      this._fill.clear();
      if (this.isVerticalGauge === true) {
        h = this._fillImg.height * percent;
        hy = this._fillImg.height - h;
        return this._fill.b().blt(this._fillImg.b(), 0, 0, this._fillImg.width, h, 0, hy);
      } else {
        w = this._fillImg.width * percent;
        return this._fill.b().blt(this._fillImg.b(), 0, 0, w, this._fillImg.height, 0, 0);
      }
    }

    _createForeground() {
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      return this.add(this._foreground);
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

  };
  AA.register(SpriteGauge);
})();

// ■ END SpriteGauge.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteItemRecharge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteItemRecharge;
  SpriteItemRecharge = class SpriteItemRecharge extends AASprite {
    constructor(settings) {
      super();
      this.settings = settings;
      this._create();
    }

    _create() {
      this._loadSettings();
      return this._createMain();
    }

    _loadSettings() {
      this._loadColorFromSettings("colorA", KDCore.Color.GREEN);
      this._loadColorFromSettings("colorB", KDCore.Color.YELLOW);
      return this._loadColorFromSettings("colorC", KDCore.Color.RED);
    }

    _loadColorFromSettings(colorName, defaultColor) {
      if (this.settings[colorName] != null) {
        this[colorName] = KDCore.Color.FromHex(this.settings[colorName]).CSS;
      }
      if (this.settings[colorName] == null) {
        return this[colorName] = defaultColor.CSS;
      }
    }

    _createMain() {
      this._recharge = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this._recharge.move(this.settings.marginX, this.settings.marginY);
      this._recharge.opacity = this.settings.opacity;
      return this.add(this._recharge);
    }

    drawRecharge(percent = 1) {
      var c, h;
      percent = 1 - percent;
      this._recharge.clear();
      if (percent === 1) {
        return;
      }
      h = this._recharge.height;
      c = this.colorA;
      if (percent >= 0.7) {
        c = this.colorC;
      } else if (percent >= 0.2) {
        c = this.colorB;
      }
      return this._recharge.b().fillRect(0, h * percent, this._recharge.width, h, c);
    }

  };
  AA.register(SpriteItemRecharge);
})();

// ■ END SpriteItemRecharge.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteNotifyText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteNotifyText;
  SpriteNotifyText = class SpriteNotifyText extends AASprite {
    constructor() {
      super();
      this._noVisibleAtAll = false;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createTextSprite();
      this._createSeparatorA();
      this._createSeparatorB();
      this._textOpacitySwing = null;
      this._opacitySwing = null;
      return this.visible = false;
    }

    _loadSettings() {
      this.settings = AA.JSON.getUINotifyTextSettings();
      this.moveByJson(this.settings);
      return this._noVisibleAtAll = !this.settings.visible;
    }

    _createBackground() {
      if (this.settings.backgroundImg != null) {
        this._background = AASprite.FromImg(this.settings.backgroundImg);
        return this.add(this._background);
      }
    }

    _createTextSprite() {
      this._textSpr = AASprite.FromBitmap(this.settings.textZoneWidth, this.settings.textZoneHeight);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      return this.add(this._textSpr);
    }

    _createSeparatorA() {
      if (this.settings.topImg != null) {
        this._separatorA = AASprite.FromImg(this.settings.topImg);
        this._separatorA.move(this.settings.topImgMarginX, this.settings.topImgMarginY);
        return this.add(this._separatorA);
      }
    }

    _createSeparatorB() {
      if (this.settings.bottomImg != null) {
        this._separatorB = AASprite.FromImg(this.settings.bottomImg);
        this._separatorB.move(this.settings.bottomImgMarginX, this.settings.bottomImgMarginY);
        return this.add(this._separatorB);
      }
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

    showOnlyText(text) {
      if (this._textSpr == null) {
        return;
      }
      this.drawText(text);
      this._textSpr.opacity = 255;
      this._textOpacitySwing = new AA.LIBS.ValueSwing(this._textSpr, "opacity", this.settings.textAppearDuration);
      this._textOpacitySwing.setIncrementMode();
      return this._textOpacitySwing.start();
    }

    showWithText(text) {
      if (this._noVisibleAtAll === true) {
        return;
      }
      this.visible = true;
      this.opacity = 255;
      this._opacitySwing = new AA.LIBS.ValueSwing(this, "opacity", this.settings.appearDuration);
      this._opacitySwing.setIncrementMode();
      this._opacitySwing.start();
      return this.showOnlyText(text);
    }

    hide() {
      this._hideOpacitySwing = new AA.LIBS.ValueSwing(this, "opacity", 20);
      return this._hideOpacitySwing.start();
    }

    isHidden() {
      return this.visible === false || this.opacity === 0;
    }

    update() {
      super.update();
      if (this._textOpacitySwing != null) {
        this._hideOpacitySwing = null;
        this._textOpacitySwing.update();
        if (this._textOpacitySwing.isReady()) {
          this._textOpacitySwing = null;
        }
      }
      if (this._opacitySwing != null) {
        this._hideOpacitySwing = null;
        this._opacitySwing.update();
        if (this._opacitySwing.isReady()) {
          this._opacitySwing = null;
        }
      }
      if (this._hideOpacitySwing != null) {
        this._hideOpacitySwing.update();
        if (this._hideOpacitySwing.isReady()) {
          this._hideOpacitySwing = null;
          return this._resetElement();
        }
      }
    }

    _resetElement() {
      this.visible = false;
      this.opacity = 255;
      return this._textSpr.opacity = 255;
    }

  };
  AA.register(SpriteNotifyText);
})();

// ■ END SpriteNotifyText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_AA_CommonUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
var Spriteset_AA_CommonUI;

Spriteset_AA_CommonUI = class Spriteset_AA_CommonUI extends Sprite {
  constructor() {
    super();
    this._create();
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_AA_CommonUI.prototype;
  _._create = function() {
    return this._createItemNotify();
  };
  _._createItemNotify = function() {
    var e, p, pos;
    this._notifyLineMachine = new AXUI.Sprite_PopMachine();
    this._notifyLineMachine.x = Graphics.width - 10;
    this._notifyLineMachine.y = Graphics.height / 2;
    this.addChild(this._notifyLineMachine);
    try {
      if (AlphaABS.jDATA.ItemsNotifySettings != null) {
        p = AlphaABS.jDATA.ItemsNotifySettings[0];
        this._notifyLineMachine.setItemsAnchor(p.anchor);
        this._notifyLineMachine.setMode(p.navigation);
        this._notifyLineMachine.setMargin(p.margin);
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          this._notifyLineMachine.x = pos.x;
          this._notifyLineMachine.y = pos.y;
        }
        if (p.visible != null) {
          this._notifyLineMachine.visible = p.visible;
        }
      } else {
        this._notifyLineMachine.setItemsToLeft();
      }
    } catch (error) {
      e = error;
      AlphaABS.warning(e, 'Something wrong with ItemsNotify Settings');
      this._notifyLineMachine = null;
    }
  };
  _.showItemNotify = function(type, value) {
    var e, item, typeId;
    if (this._notifyLineMachine == null) {
      return;
    }
    if (!this._notifyLineMachine.visible) {
      return;
    }
    try {
      typeId = 0;
      switch (type) {
        case 'item':
          typeId = 3;
          break;
        case 'exp':
          typeId = 1;
          break;
        case 'gold':
          typeId = 2;
          break;
        case 'iconText':
          typeId = 4;
          break;
        default:
          typeId = 0;
      }
      item = new AXUI.Sprite_PopTextNotifyLine(typeId);
      item.setValue(value);
      this._notifyLineMachine.push(item);
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  _.terminate = function() {
    return this.visible = false;
  };
})();

// ■ END Spriteset_AA_CommonUI.coffee
//---------------------------------------------------------------------------

(function () {
  var LOG = new KDCore.DevLog("Spriteset_InterfaceABS");

  //Spriteset_InterfaceABS
  //------------------------------------------------------------------------------
  class Spriteset_InterfaceABS extends Sprite {
    constructor() {
      super();
      this.setFrame(0, 0, Graphics.width, Graphics.height);
      this._free = false; //Can be edited
      this._isABS = false;
      try {
        this._needFree = $gameVariables.getUIParam('free') || false;
        this._showUI = $gameVariables.getUIParam('show');
      } catch (e) {

      }
      if (this._showUI == null) this._showUI = true;
      if(this._showUI == true)
        this._showUI = AlphaABS.Parameters.isUIVisible();
      this.z = 10;
      this._autoHideSkillPanel = true;
      this.update();
    }

    initABS() {
      this._isABS = true;
      //LOG.p("Init ABS!");
      this._createElements();
      this._createUIContainers();
      this._createPartyUI();
      this.createSpellPanel();
      if (!this._showUI) {
        this.hide();
      } else {
        this.show();
      }
      if (AA.isPro() && Input.isGamepad()) {
        $gamePlayer.onGamePadConnected();
        this._gamepadUI = new AA.LIBS.GamePadUI(this);
        if (!this._showUI || $gameVariables.getUIParam('uiButtonHided') == true) {
          this._gamepadUI._hidden = true;
        }
      }
      this.refreshPlayerABGaugeAndIcon();
      this._onEndCreate();
    }

    hide() {
      this._isABS = false;
      this.visible = false;
      this.hideControl();
      if(this._gamepadUI)
        this._gamepadUI.hide();
    }

    show() {
      this._isABS = true;
      this.visible = true;
      this.showControl();
      if (this._gamepadUI)
        this._gamepadUI.show();
    }

    isVisible() {
      return (this._showUI == true);
    }

    isFree() {
      return (this._free == true);
    }

    needFree() {
      $gameVariables.setUIParam('free', true);
      this._needFree = true;
    }

    setShowUI(value) {
      $gameVariables.setUIParam('show', value);
      this._showUI = value;
    }

    hideControl() {
      this.hideSkillPanel();
      this.hideControlPanel();
    }

    showControl() {
      if ($gamePlayer.battler().uiPanelObjectsCount() > 0) {
        this.showSkillPanel();
      } else {
        if(AAJsonSettings.getSpellControllerSettings().visibleWhenEmpty == true) {
          this.showSkillPanel();
        } else {
          // * NOT SHOW, EMPTY
        }
      }
      this.showControlPanel();
    }
    
    showTarget(target) {
      this._destroyUI13EnemyUI();
      if (target) {
        //console.info(target);
        this._createUI13EnemyUI(target);
        this._createUI13EnemyStates(target);
        this._createUI13EnemyCastBar(target);
      }
    }

    pushOnItemPanel(type, value) {
      try {
        var item;
        var typeId = 0;
        switch (type) {
          case 'item':
            typeId = 3;
            break;
          case 'exp':
            typeId = 1;
            break;
          case 'gold':
            typeId = 2;
            break;
          case 'iconText':
            typeId = 4;
            break;
          default:
            typeId = 0;
            break;
        }
        item = new AXUI.Sprite_PopTextNotifyLine(typeId);
        item.setValue(value);
        this._notifyLineMachine.push(item);
      } catch (error) {
        AlphaABS.error(error, ' while push text to Notify Panel');
      }
    }

    isTouched() {
      var newSkillIndex = this.spellUIManager.getIndexUnderTouch();
      if (newSkillIndex != null) {
        return ['skill', newSkillIndex + 1];
      }
      if (this.spriteFirearmBar && this.spriteFirearmBar.isTouched()) {
        return ['firearm', true];
      }
      return null;
    }

    addPopUp(popObject) {
      if (this.notifyControllerNew)
        this.notifyControllerNew.pushNotify(popObject.getText());
    }

    addPopUpUser(popObject) {
      if (this.popUpMachineUser)
        this.popUpMachineUser.push(popObject);
    }

    addPopUpTarget(target, popObject) {
      // * DEPRECATED
    }

    touchSkillAt(index) {
      this.spellUIManager.clickAt(index - 1);
    }

    refreshSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.refresh();
    }

    terminate() {
      if(!this._uiCreated) return;
      if (this.targetStatusPanel != null)
        this.targetStatusPanel.terminate();
      this.userStatusPanel.terminate();
      this.userWeaponIconController.terminate();
      this.castBarController.terminate();
      this.terminateETUI();
      this._terminateShieldTimer();
      this.terminateSpellPanel();
      if (this._enemyCastController)
        this._enemyCastController.terminate();
      if (this._summonUnitCtr) {
        this._destroySummonUI();
      }
      if (this._gamepadUI)
        this._gamepadUI.terminate();
      this._isABS = false;
      AA.clearUIThreads();
      LOG.p("Terminate!");
    }

    update() {
      this._updatePosition();
      if (this._isABS) {
        this.notifyControllerNew.update();
        if(this.popUpMachineUser)
          this.popUpMachineUser.update();
        this.userStatusPanel.update();

        if (this._hpGaugeCntr)
          this._hpGaugeCntr.update();
        if (this._mpGaugeCntr)
          this._mpGaugeCntr.update();
        if (this._tpGaugeCntr)
          this._tpGaugeCntr.update();
        if (this._hpGaugeCntrE)
          this._hpGaugeCntrE.update();

        if(this._summonUnitCtr) {
          //if ($gamePlayer.getSummonUnit() == null) {
          //  this._destroySummonUI();
          //} else
            this._summonUnitCtr.update();
        }

        if (this.userWeaponIconController)
          this.userWeaponIconController.update();

        this._notifyLineMachine.update();
        if (this.spriteFirearmBar) {
          this.spriteFirearmBar.update();
        }

        this._updateShieldTimer();
        this._updatePartyUI();

        if (this._sCircle)
          this._sCircle.update();

        if(this._sumCircle)
          this._sumCircle.update();

        this.updateSpellPanel();

        if (this._gamepadUI)
          this._gamepadUI.update();

        if (this._barrierAbHpCntr)
          this._barrierAbHpCntr.update();
      }
    }  

    refresh() {
      if ($gamePlayer.battler() == null) return;
      this._refreshSkillPanelVisibility();
      this.refreshSkillPanel();
      this.refreshLevel();
      this.refreshActorWeapon();
      this.refreshPlayerABGaugeAndIcon();
      if (this._gamepadUI)
        this._gamepadUI.refresh();
    }

    refreshLevel() {
      if (this._levelSprite)
        this._levelSprite.drawText($gameParty.leader().level);
    }


    refreshFirearmPanel() {
      if (this.spriteFirearmBar && this.spriteFirearmBar.visible == true) {
        this.spriteFirearmBar.refresh();
      }
    }

    showFirearmPanel() {
      if (this.spriteFirearmBar) {
        this.spriteFirearmBar.show();
        this.spriteFirearmBar.refresh();
      }
    }

    hideFirearmPanel() {
      if (this.spriteFirearmBar) {
        this.spriteFirearmBar.hide();
      }
    }

    _refreshSkillPanelVisibility() {
      if ($gamePlayer.battler().uiPanelObjectsCount() > 0)
        this.showSkillPanel();
      else {
        if (this.spellUIManager)
          if (this.spellUIManager.isVisibleWhenEmpty() == false)
            this.hideSkillPanel();
          else
            this.showSkillPanel();
      }
    }

    refreshFace() {
      try {
        if (this._faceSprite) {
          var faceName = $gameParty.leader().faceName();
          var faceIndex = $gameParty.leader().faceIndex();
          this._faceSprite.setPortrait({
            faceName,
            faceIndex
          });
          this._faceSprite.refresh();
          this.redrawVisualOnFace();
        }
      } catch (e) {
        AA.warning(e);
      }
    }

    showSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.show();
    }

    hideSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.hide();
    }

    setControlPanelVisible(isVisible) {
      $gameVariables.setUIParam('uiButtonHided', !isVisible);
      ButtonsProManager.refreshUIButtonsVisibility();
      if(Input.isGamepad()) {
        if (this._gamepadUI) {
          this._gamepadUI.setVisibility(isVisible);
        }
      }
    }

    showControlPanel() {
      if($gameVariables.getUIParam('uiButtonHided') == true)
        return;
      var s = ButtonsProManager.getCurrentSystem();
      if(s != null)
        s.showAll();
    }

    hideControlPanel() {
      var s = ButtonsProManager.getCurrentSystem();
      if (s != null)
        s.hideAll();
    }

    weapCircle() {
      if(!this._sCircle) {
        this._createFavWeapCircle();
      }
      return this._sCircle;
    }

    weapCircleRefresh() {
      if (this.weapCircle())
        this.weapCircle().refresh();
    }

    _createElements() {
      this._prepareUI13();
      this._createSkillPanel();
      this._createUserUI();
      this._createUserStatusPanel();
      this._createAlertBar();
      this._createFirearmBar();
      this._createLineNotifyMachine();
    }

    _createUIContainers() {
      this._createUserStatusPanelContainer();
      this._createLineNotifyMachineContainer();
      this._createFirearmContainer();
      this._createABS13UI();
    }

    _createSkillPanel() {
      this._refreshSkillPanelVisibility();
    }

    _checkLayerTouch(layer) {
      var rect = new Rectangle(layer.x, layer.y, layer.width, layer.height);
      return AlphaABS.UTILS.SMath.inRect(new KDCore.Point(TouchInput.x, TouchInput.y), rect);
    }

    _createUserUI() {
      this.spriteCastBar = new AA.LIBS.SpriteSpellCast();
      this.castBarController = new AA.LIBS.NewCastBarController(this.spriteCastBar);
      this.addChild(this.spriteCastBar);
    }

    _createAlertBar() {
      this.spriteAlertLayer = new Sprite();

      this.notifyControllerNew = new AA.LIBS.AANotifyManagerNew();
      this.addChild(this.notifyControllerNew.getSprite());
    }

    _createFavWeapCircle() {
      this._sCircle = new AlphaABS.LIBS.UI_SelectCircleFW($gamePlayer.battler(), function (index) {
        if (this.isOpen())
          $gamePlayer.touchWeaponAt(index);
      });
      this.addChild(this._sCircle);
      this.weapCircleRefresh();
    }

    _updatePosition() {
      var screen = $gameScreen;
      var scale = screen.zoomScale();
      this.scale.x = scale;
      this.scale.y = scale;
      this.x = Math.round(-screen.zoomX() * (scale - 1));
      this.y = Math.round(-screen.zoomY() * (scale - 1));
      this.x += Math.round(screen.shake());

    }
  }
  //END Spriteset_InterfaceABS
  //------------------------------------------------------------------------------

  AlphaABS.register(Spriteset_InterfaceABS);

})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_InterfaceABS2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Spriteset_InterfaceABS;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  Spriteset_InterfaceABS = AlphaABS.LIBS.Spriteset_InterfaceABS;
  Spriteset_InterfaceABS.prototype._createFirearmBar = function() {
    return this.spriteFirearmBar = new AlphaABS.LIBS.UIObject_FirearmPanel();
  };
  Spriteset_InterfaceABS.prototype._createFirearmContainer = function() {
    var e, p, pos;
    try {
      if (AlphaABS.jDATA.FirearmPanel != null) {
        p = AlphaABS.jDATA.FirearmPanel;
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          this.spriteFirearmBar.x = pos.x;
          this.spriteFirearmBar.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            return this.addChild(this.spriteFirearmBar);
          }
        } else {
          return this.addChild(this.spriteFirearmBar);
        }
      }
    } catch (error) {
      e = error;
      return AA.warning('Firearm position settings', e);
    }
  };
  Spriteset_InterfaceABS.prototype._setPosFromParameters = function(item, parameters) {
    var pX, pY;
    pX = parameters.Position.X;
    pY = parameters.Position.Y;
    if (pX) {
      item.x = pX;
    }
    if (pY) {
      item.y = pY;
    }
  };
  Spriteset_InterfaceABS.prototype._createLineNotifyMachine = function() {
    var e, p;
    this._notifyLineMachine = new AXUI.Sprite_PopMachine();
    try {
      if (AlphaABS.jDATA.ItemsNotifySettings != null) {
        p = AlphaABS.jDATA.ItemsNotifySettings[0];
        this._notifyLineMachine.setItemsAnchor(p.anchor);
        this._notifyLineMachine.setMode(p.navigation);
        return this._notifyLineMachine.setMargin(p.margin);
      } else {
        return this._notifyLineMachine.setItemsToLeft();
      }
    } catch (error) {
      e = error;
      return AlphaABS.warning(e, 'Something wrong with ItemsNotify Settings');
    }
  };
  Spriteset_InterfaceABS.prototype._createLineNotifyMachineContainer = function() {
    var e, p, pos;
    try {
      if (AlphaABS.jDATA.ItemsNotifySettings != null) {
        p = AlphaABS.jDATA.ItemsNotifySettings[0];
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          this._notifyLineMachine.x = pos.x;
          this._notifyLineMachine.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            return this.addChild(this._notifyLineMachine);
          }
        } else {
          return this.addChild(this._notifyLineMachine);
        }
      }
    } catch (error) {
      e = error;
      return AA.warning('Items notify position settings', e);
    }
  };
  Spriteset_InterfaceABS.prototype._createUserStatusPanel = function() {
    var e, p;
    this.userStatusPanel = new AXUI.System_BattleStates($gamePlayer.battler());
    try {
      if (AlphaABS.jDATA.StatesPanelSettings != null) {
        p = AlphaABS.jDATA.StatesPanelSettings[0];
        this.userStatusPanel.setMode(p.linesNavigation);
        this.userStatusPanel.setMaxItemCountPerLine(p.statesPerLine);
        this.userStatusPanel.setMargin(p.linesMargin);
      }
    } catch (error) {
      e = error;
      AlphaABS.warning(e, 'Something wrong with States Panel Settings');
    }
    return this.userStatusPanel.collectItems();
  };
  Spriteset_InterfaceABS.prototype._createUserStatusPanelContainer = function() {
    var e, p, pos;
    try {
      if (AlphaABS.jDATA.StatesPanelSettings != null) {
        p = AlphaABS.jDATA.StatesPanelSettings[0];
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          this.userStatusPanel.x = pos.x;
          this.userStatusPanel.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            this.addChild(this.userStatusPanel);
          }
        } else {
          this.addChild(this.userStatusPanel);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Status panel position settings', e);
    }
  };
  Spriteset_InterfaceABS.prototype._createABS13UI = function() {
    var faceIndex, faceName;
    faceName = $gameParty.leader().faceName();
    faceIndex = $gameParty.leader().faceIndex();
    if (AA.isCCEXImproted === true) {
      if ($gamePlayer.battler().hasSetImage()) {
        this._faceSprite = new AA.LIBS.SpriteActorPortrait(0, $gamePlayer.battler());
      } else {
        this._faceSprite = new AA.LIBS.SpriteActorPortrait(0, {faceName, faceIndex});
      }
    } else {
      this._faceSprite = new AA.LIBS.SpriteActorPortrait(0, {faceName, faceIndex});
    }
    this.redrawVisualOnFace();
    this.addChild(this._faceSprite);
    //$[TEMP TEST]
    this._createSummonUI();
    this._gaugeSprite = new AA.LIBS.SpriteGauge('hp');
    this.addChild(this._gaugeSprite);
    this._gaugeSprite2 = new AA.LIBS.SpriteGauge('mp');
    this.addChild(this._gaugeSprite2);
    if ($dataSystem.optDisplayTp) {
      this._gaugeSprite3 = new AA.LIBS.SpriteGauge('tp');
      this.addChild(this._gaugeSprite3);
    }
    this._levelSprite = new AA.LIBS.SpriteUIElement('ActorLevel');
    this._levelSprite.drawTextOnReady($gameParty.leader().level);
    this.addChild(this._levelSprite);
    this._weaponSprite = new AA.LIBS.SpriteWeaponIcon();
    this.userWeaponIconController = new AlphaABS.LIBS.AAWeaponIconManagerNew(this._weaponSprite);
    this.addChild(this._weaponSprite);
    this.refreshActorWeapon();
    this._inBattleIcon = new AA.LIBS.SpriteUIElement('ActorInBattleIcon');
    this._inBattleIcon.visible = false;
    this.addChild(this._inBattleIcon);
    if (AA.Parameters.isNeedShowPlayerPortraitPopUps()) {
      this.popUpMachineUser = new AA.LIBS.ABSObject_PopUpMachine(0, 0, this._faceSprite.settings.faceSize, 1, this._faceSprite);
      this.popUpMachineUser.setEffectSettings(AA.LIBS.ABSObject_PopUpMachine.SETTINGS);
    }
    this._hpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite);
    this._hpGaugeCntr.setup($gameParty.leader(), 'hp', 'mhp');
    this._mpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite2);
    this._mpGaugeCntr.setup($gameParty.leader(), 'mp', 'mmp');
    if ($dataSystem.optDisplayTp) {
      this._tpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite3);
      return this._tpGaugeCntr.setup($gameParty.leader(), 'tp', 'mtp');
    }
  };
  Spriteset_InterfaceABS.prototype.refreshActorWeapon = function() {
    var weap;
    if (this.userWeaponIconController == null) {
      return;
    }
    weap = $gameParty.leader().weapons()[0];
    if (weap) {
      return this.userWeaponIconController.drawIcon(weap.iconIndex);
    } else {
      return this.userWeaponIconController.drawDefault();
    }
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyUI = function(target) {
    var b, faceIndex, faceName;
    this._gaugeSpriteE = new AA.LIBS.SpriteGauge('hpE');
    this.addChild(this._gaugeSpriteE);
    this._hpGaugeCntrE = new AA.LIBS.GaugeController(this._gaugeSpriteE);
    if (AA.Parameters.isEnemyHPInPercentage()) {
      this._hpGaugeCntrE.setPercentText();
    } else {
      this._hpGaugeCntrE.setFullValueText();
    }
    this._hpGaugeCntrE.setup(target.battler(), 'hp', 'mhp');
    //console.info target.behaviorModel()
    if (target.isEnemy()) {
      if (target.behaviorModel().faceName !== 0) {
        this._faceSpriteE = new AA.LIBS.SpriteActorPortrait(1, target.behaviorModel());
        this.addChild(this._faceSpriteE);
      }
    } else {
      b = target.battler();
      faceName = b.faceName();
      faceIndex = b.faceIndex();
      if (AA.isCCEXImproted === true && b.hasSetImage()) {
        this._faceSpriteE = new AA.LIBS.SpriteActorPortrait(1, b);
      } else {
        this._faceSpriteE = new AA.LIBS.SpriteActorPortrait(1, {faceName, faceIndex});
      }
      if (b._getVisualEqData() != null) {
        this._faceSpriteE.drawVisualEq(b._getVisualEqData());
      }
      this.addChild(this._faceSpriteE);
    }
    if (AA.Parameters.get_ShowEnemyLevel() === true) {
      this._levelSpriteE = new AA.LIBS.SpriteUIElement('EnemyLevel');
      if (target.isEnemy()) {
        this._levelSpriteE.drawTextOnReady(target.behaviorModel().level);
      } else {
        this._levelSpriteE.drawTextOnReady(target.battler().level);
      }
      this.addChild(this._levelSpriteE);
    }
    this._nameSpriteE = new AA.LIBS.SpriteUIElement('EnemyName');
    this._nameSpriteE.drawTextOnReady(target.battler().name());
    this.addChild(this._nameSpriteE);
    this._enemyCastSprite = new AlphaABS.LIBS.SpriteSpellCastEnemy();
    this._enemyCastController = new AlphaABS.LIBS.NewCastBarControllerEnemy(this._enemyCastSprite);
    return this.addChild(this._enemyCastSprite);
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyStates = function(target) {
    var e, p, pos;
    if (this.targetStatusPanel != null) {
      this.removeChild(this.targetStatusPanel);
    }
    if (!(target != null ? target.battler() : void 0)) {
      return;
    }
    this.targetStatusPanel = new AXUI.System_BattleStates2(target.battler());
    try {
      if (AlphaABS.jDATA.EnemyStatusPanelSettings != null) {
        p = AlphaABS.jDATA.EnemyStatusPanelSettings[0];
        this.targetStatusPanel.setMode(p.linesNavigation);
        this.targetStatusPanel.setMaxItemCountPerLine(p.statesPerLine);
        this.targetStatusPanel.setMargin(p.linesMargin);
        pos = AA.Utils.getPositionPointFromJSON(AlphaABS.jDATA.EnemyStatusPanelSettings[0]);
        this.targetStatusPanel.move(pos.x, pos.y);
      }
    } catch (error) {
      e = error;
      AlphaABS.warning(e, 'Something wrong with Enemy States Panel Settings');
    }
    this.targetStatusPanel.collectItems();
    return this.addChild(this.targetStatusPanel);
  };
  Spriteset_InterfaceABS.prototype._destroyUI13EnemyUI = function() {
    if (this._gaugeSpriteE != null) {
      this.removeChild(this._gaugeSpriteE);
    }
    if (this.targetStatusPanel != null) {
      this.removeChild(this.targetStatusPanel);
    }
    if (this._faceSpriteE != null) {
      this.removeChild(this._faceSpriteE);
    }
    if (this._nameSpriteE != null) {
      this.removeChild(this._nameSpriteE);
    }
    if (this._enemyCastSprite != null) {
      this.removeChild(this._enemyCastSprite);
    }
    if (this._levelSpriteE != null) {
      this.removeChild(this._levelSpriteE);
    }
    if (this._enemyCastController != null) {
      return this._enemyCastController.stop();
    }
  };
  // * Подгрузка графики
  Spriteset_InterfaceABS.prototype._prepareUI13 = function() {
    new AA.LIBS.SpriteGauge('hpE');
    new AA.LIBS.SpriteUIElement('EnemyLevel');
    new AA.LIBS.SpriteUIElement('EnemyName');
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyCastBar = function(target) {
    return this._enemyCastController.setTarget(target);
  };
  Spriteset_InterfaceABS.prototype.redrawVisualOnFace = function() {
    if (!AA.isPro()) {
      return;
    }
    this.redrawVisualOnPlayerFace();
    if (this.partyUIGroup != null) {
      return this.redrawVisualOnPartyFaces();
    }
  };
  Spriteset_InterfaceABS.prototype.redrawVisualOnPlayerFace = function() {
    var actor;
    if (this._faceSprite == null) {
      return;
    }
    actor = $gameParty.leader();
    if (actor == null) {
      return;
    }
    if (actor._getVisualEqData() == null) {
      return this._faceSprite.drawVisualEq(null);
    } else {
      return this._faceSprite.drawVisualEq(actor._getVisualEqData());
    }
  };
})();

// ■ END Spriteset_InterfaceABS2.coffee
//---------------------------------------------------------------------------int

// Generated by CoffeeScript 2.5.1
(function() {
  var _;
  _ = AlphaABS.LIBS.Spriteset_InterfaceABS.prototype;
  _.createSpellPanel = function() {
    this.spellUIManager = new AA.LIBS.AASpelllPanelManager($gamePlayer.battler());
    this.spellUIManager.refresh();
    return this.addChild(this.spellUIManager.getSprite());
  };
  _.updateSpellPanel = function() {
    return this.spellUIManager.update();
  };
  _.terminateSpellPanel = function() {
    return this.spellUIManager.terminate();
  };
  _._createShieldTimer = function() {
    var armor, e, icon, name;
    this._spriteShieldTimer = new AA.LIBS.SpriteShieldTimer();
    icon = 0;
    name = "";
    try {
      //$dataStates[$gamePlayer.battler()._playerAAShieldStateId].iconIndex
      armor = $dataArmors[$gamePlayer.battler()._playerAAShieldEquipId];
      icon = armor.iconIndex;
      name = armor.name;
    } catch (error) {
      e = error;
      AA.warning(e, 'when get Shield Icon and Name');
    }
    this._spriteShieldTimer.setIcon(icon);
    this._spriteShieldTimer.drawText(name);
    return this.addChild(this._spriteShieldTimer);
  };
  _._updateShieldTimer = function() {
    var t, value;
    if ($gamePlayer.battler() == null) {
      return;
    }
    t = $gamePlayer.battler()._shieldRestTimer;
    if (t != null) {
      if (this._spriteShieldTimer == null) {
        this._createShieldTimer();
      }
      value = t.getValue() / t.getMaxValue();
      return this._spriteShieldTimer.drawGauge(value);
    } else {
      return this._terminateShieldTimer();
    }
  };
  _._terminateShieldTimer = function() {
    if (this._spriteShieldTimer == null) {
      return;
    }
    this.removeChild(this._spriteShieldTimer);
    return this._spriteShieldTimer = null;
  };
})();

(function () {
  var LOG = new KDCore.DevLog("Spriteset_Map");
  //Spriteset_Map
  //------------------------------------------------------------------------------
  var Sprite_CharacterABS;

  //@[ALIAS]
  var _alias_Spriteset_map_createCharacters54 = Spriteset_Map.prototype.createCharacters;
  Spriteset_Map.prototype.createCharacters = function () {
    if(AA.isABS()) {
      this._createCharactersABS();
    } else {
      _alias_Spriteset_map_createCharacters54.call(this);
    }
  };

  //?[NEW]
  Spriteset_Map.prototype._createCharactersABS = function () {
    //LOG.p("createCharacters");
    Sprite_CharacterABS = AlphaABS.LIBS.Sprite_CharacterABS;

    this._characterSprites = [];
    this._characterSpritesABS = [];
    this._spritePlayerABS = null;

    $gameMap.events().forEach(function (event) {
      if (event instanceof Game_AIBot) {
        var t = new Sprite_CharacterABS(event, 0);
        this._characterSprites.push(t);
        this._characterSpritesABS.push(t);
      } else
        this._characterSprites.push(new Sprite_Character(event));
    }, this);
    $gameMap.vehicles().forEach(function (vehicle) {
      this._characterSprites.push(new Sprite_Character(vehicle));
    }, this);

    if(!AA.Parameters.isOneLeaderSwapMode())
      $gamePlayer.followers().forEach(function (f) {
        var t = new Sprite_CharacterABS(f, 2);
        this._characterSprites.push(t);
        this._characterSpritesABS.push(t);
      }, this);

    var t = new Sprite_CharacterABS($gamePlayer, 1);
    this._characterSprites.push(t);
    this._spritePlayerABS = t;

    for (var i = 0; i < this._characterSprites.length; i++) {
      this._tilemap.addChild(this._characterSprites[i]);
    }
  };

  var _Spriteset_Map_initialize = Spriteset_Map.prototype.initialize;
  Spriteset_Map.prototype.initialize = function () {
    _Spriteset_Map_initialize.call(this);
    this._absParams = {};
    this._absParams.animationSprites = [];
    this._absParams.targetConfig = false;
  };

  //NEW
  Spriteset_Map.prototype.spritesABS = function () {
    return this._characterSpritesABS;
  };

  //?[NEW]
  Spriteset_Map.prototype.getSpriteForCharacter = function (character, forAll = false) {
      try {
          if (this._spritePlayerABS.character() == character)
            return this._spritePlayerABS;
          var sprites = this.spritesABS();
          if (forAll === true) {
            sprites = sprites.concat(this._characterSprites);
          }
          return sprites.find(spr => spr._character == character);
      } catch (error) {
          AA.warning(error);
      }
      return null;
  };

  //NEW
  Spriteset_Map.prototype.initABS = function () {
    this.spritesABS().forEach(function (item) {
      item.initABS();
    });
    this._spritePlayerABS.initABS();
  };

  //NEW
  Spriteset_Map.prototype.spritePlayerABS = function () {
    return this._spritePlayerABS;
  };

  var _Spriteset_Map_update = Spriteset_Map.prototype.update;
  Spriteset_Map.prototype.update = function () {
    _Spriteset_Map_update.call(this);
    if ($gameMap.isABS()) {
      this._setupAnimationABS();
      this._updateAnimationABS();
      this._setupPlayerTargetCircle();
    }
  };

  //?NEW
  Spriteset_Map.prototype.refreshAfterABS = function () {
    this._characterSprites.forEach(function (char) {
      this._tilemap.removeChild(char);
    }.bind(this));
    this.createCharacters();
  };

  //PRIVATE
  Spriteset_Map.prototype._setupAnimationABS = function () {
    var anim = $gameMap.ABSParams().animationABS;
    if(anim == null) return;
    this._startAnimationABS(anim);
    $gameMap.ABSParams().animationABS = null;
  };

  Spriteset_Map.prototype._startAnimationABS = function(animationData) {
    try {
      var animation = $dataAnimations[animationData.id];
      if(!animation) return;
      var point = animationData.point;
      var tmp = new Game_Character();
      tmp.setPosition(point.x, point.y);
      tmp.requestAnimation(animationData.id);
      tmp._absMapAnimationIsRequested = true;
      var spr = new Sprite_CharacterABS(tmp);
      this.addChildAtLayer(spr, animation.position);
      this._absParams.animationSprites.push(spr);
      this.__animationCheckDelay = 3;
    } catch (e) {
      KDCore.warning(e);
    }
  };

  Spriteset_Map.prototype._updateAnimationABS = function () {
    if (!this._absParams) return;
    if (this._absParams.animationSprites.length > 0) {
      // * Чтобы сразу не удалял
      if(this.__animationCheckDelay != 0) {
        this.__animationCheckDelay--;
        return;
      }
      var sprites = this._absParams.animationSprites;
      for (var i = 0; i < sprites.length; i++) {
          var spr = sprites[i];
          if(!spr.isAnimationPlaying()) {
            this._absParams.animationSprites.delete(spr);
            spr.parent.removeChild(spr);
          }
      }
    }
  };

  Spriteset_Map.prototype._setupPlayerTargetCircle = function () {
    if (!$gameMap.isABS()) return;
    if (!this._absParams) return;
    if (!this._absParams.spriteTargetCircle) {
      //LOG.p("MAP : Target sprite created!");
      this._absParams.spriteTargetCircle = AASprite.FromImg('targetSelectedCircle');
      this.addChildAtLayer(this._absParams.spriteTargetCircle, -1);
      this._absParams.spriteTargetCircle.anchor.x = 0.5;
      this._absParams.spriteTargetCircle.anchor.y = 0.5;
      this._absParams.spriteTargetCircle.visible = false;
    }
    if ($gameMap.ABSParams().targetCircle != null) {
      if (!this._absParams.targetConfig) {

        var r = $gameMap.ABSParams().targetCircle.radius;

        this._absParams.spriteTargetCircle.scale.x = 0.5 * r;
        if (r > 3)
          this._absParams.spriteTargetCircle.scale.x += (r - 3) * 0.2;
        this._absParams.spriteTargetCircle.scale.y = this._absParams.spriteTargetCircle.scale.x;

        var t3 = TouchInput.getMousePosition();
        this._absParams.spriteTargetCircle.x = t3.x;
        this._absParams.spriteTargetCircle.y = t3.y;
        this._absParams.targetConfig = true;

        if (Input.isGamepad()) {
          AAGamePadManager.InitPlayerTargetCirclePosition();
          var gPoint = AAGamePadManager.GetTargetCirclePositionByGamepad();
          this._absParams.spriteTargetCircle.x = gPoint.x;
          this._absParams.spriteTargetCircle.y = gPoint.y;
          this._absParams._lastLockedGSPoint = null;
        }
      }

      var t = this._absParams.spriteTargetCircle;
      var t2 = TouchInput.getMousePosition();
      if (Input.isGamepad()) {
        t2 = AAGamePadManager.GetTargetCirclePositionByGamepad();
      }
      if ($gameMap.ABSParams().targetCircleNeedLock) {
        if(Input.isGamepad()) {
          if (this._absParams._lastLockedGSPoint == null) {
            this._absParams._lastLockedGSPoint = t2;
          } else {
            t2 = this._absParams._lastLockedGSPoint;
          }
        } else {
          if(!$gameTemp._targetCircleLockedPosition) {
            var { x, y } = TouchInput;
            $gameTemp._targetCircleLockedPosition = new KDCore.Point(x, y);
          }
          t2 = $gameTemp._targetCircleLockedPosition;
        }
      }

      var color = KDCore.Color.GREEN;
      var point2 = t2.convertToMap();
      var dist = AlphaABS.UTILS.distanceTo($gamePlayer, point2);
      if (dist > $gameMap.ABSParams().targetCircle.range) {
        color = KDCore.Color.RED;
      }
      if (!$gamePlayer._absParams.currentAction.isIgnoreObstacles())
        if (!AlphaABS.BattleManagerABS.checkLineOfSight($gamePlayer.toPoint(), point2)) {
          color = KDCore.Color.RED;
        }

      // * ДВИЖЕНИЕ КРУГА ВЫБОРА ЗОНЫ
      t.x = t2.x;
      t.y = t2.y;

      t.setBlendColor(color.ARR);
      t.visible = true;
    } else {
      $gameTemp._targetCircleLockedPosition = null;
      this._absParams.spriteTargetCircle.visible = false;
      this._absParams.targetConfig = false;
    }
  };

  Spriteset_Map.prototype.addChildAtLayer = function (sprite, layerIndex) {
    switch (layerIndex) {
      case 0: //HEAD
        this._tilemap.addChild(sprite);
        break;
      case 1: //CENTER
        if (this._tilemap._upperLayer)
          this._tilemap._upperLayer.addChild(sprite);
        else
          this._tilemap.addChild(sprite);
        //else
        //  this._tilemap.upperLayer.children[0].addChild(sprite);
        break;
      case 2: //FEET
        sprite.z = 1;
        if (this._tilemap._lowerLayer)
          this._tilemap._lowerLayer.addChild(sprite);
        else
          this._tilemap.addChild(sprite);
        break;
      default: //SCREEN
        this.addChild(sprite);
        break;
    }
  };


  //?[NEW]
  Spriteset_Map.prototype.createSpawnEventABS = function (id) {
    var event = $gameMap.event(id);
    var newChar = new AlphaABS.LIBS.Sprite_CharacterABS(event, 0);
    this._characterSprites.push(newChar);
    this._characterSpritesABS.push(newChar);
    this._tilemap.addChild(newChar);
    newChar.initABS();
    newChar.update();
  };

  //?[NEW]
  Spriteset_Map.prototype.removeSpawnEventABS = function (id) {
    var event = $gameMap.event(id);
    var sprite = this.getSpriteForCharacter(event);
    if(sprite) {
      sprite.visible = false;
      //sprite._absParams.spriteSelect.visible = false;
      if(sprite._animationSprites)
        sprite._animationSprites.forEach(element => {
          element.visible = false;
        });
      if(sprite._hpBarSprite)
        sprite._hpBarSprite.visible = false;
      sprite.__bushUpperSprite.visible = false;
      if(sprite._animationCast)
        sprite._animationCast.remove();
      this._characterSprites.delete(sprite);
      this._characterSpritesABS.delete(sprite);
      this._tilemap.removeChild(sprite);
    }
  };


})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpritesetAA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
var SpritesetAA;

SpritesetAA = class SpritesetAA extends Sprite {
  constructor() {
    super();
    this._create();
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = SpritesetAA.prototype;
  //@[PUBLIC]
  //@[=====================================================================]
  _.refresh = function() {}; //????
  _.terminate = function() {};
  _.showTargetUI = function(target) {
    this._destroyTargetUI();
    if (target != null) {
      return this(target);
    }
  };
  //@[PRIVATE]
  //@[=====================================================================]
  _._create = function() {};
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_ExtraUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
var Spriteset_ExtraUI;

Spriteset_ExtraUI = class Spriteset_ExtraUI extends Sprite {
  constructor() {
    super();
    this._initEU();
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_ExtraUI.prototype;
  _._initEU = function() {
    this._inventorySprite = new AA.LIBS.Sprite_MapInvMain();
    this.inventory = new AA.LIBS.MapInvController(this._inventorySprite, this);
    this.addChild(this._inventorySprite);
  };
  //?{TEST}
  //setTimeout (=>
  //    @openMapChest()
  //), 300
  _.isMouseInInventory = function() {
    if (this.isInventoryOpen()) {
      if (this._inventorySprite.isMouseIn()) {
        return true;
      }
    }
    if (this.isChestOpen()) {
      if (this._chestSprite.isMouseIn()) {
        return true;
      }
    } else if (this.isUserChestOpen()) {
      if (this._userChestSprite.isMouseIn()) {
        return true;
      }
    }
    return false;
  };
  _.openInventory = function() {
    this.inventory.open();
    return this.openCategory($gameTemp._lastInvCategory);
  };
  _.closeInventory = function() {
    return this.inventory.close();
  };
  _.isInventoryOpen = function() {
    return this.inventory.isInventoryActive();
  };
  _.openCategory = function(catId) {
    if (this.inventory.isSomeItemFocused()) {
      return;
    }
    if (catId == null) {
      catId = 0;
    }
    catId = this._checkAvailableCategory(catId);
    $gameTemp._lastInvCategory = catId;
    return this.inventory.loadItemsInCategory(catId);
  };
  _._checkAvailableCategory = function(catId) {
    var avail, nextCatId;
    if (this._availCats == null) {
      avail = AA.JSON.getUIMapInventorySettings().availableCategories;
      if (!this._availCats) {
        this._availCats = [];
      }
      if (avail.items === true) {
        this._availCats.push(0);
      }
      if (avail.weapons === true) {
        this._availCats.push(1);
      }
      if (avail.armors === true) {
        this._availCats.push(2);
      }
      if (avail.keyItems === true) {
        this._availCats.push(3);
      }
      return this._checkAvailableCategory(catId);
    } else {
      if (this._availCats.contains(catId)) {
        return catId;
      } else {
        nextCatId = catId + 1;
        if (nextCatId === 4) {
          nextCatId = 0;
        }
        return this._checkAvailableCategory(nextCatId);
      }
    }
  };
  _.refreshInventory = function() {
    var e;
    try {
      $gameParty.requestWeightCapacityRefresh();
      $gameParty._refreshInventoryWAutoState();
      $gamePlayer.refreshInventoryWSpeedDebuff();
      if (this.isInventoryOpen()) {
        return this.openCategory($gameTemp._lastInvCategory);
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _.showNextInvPage = function() {
    if (!this.isInventoryOpen()) {
      return;
    }
    return this.inventory.showNextPage();
  };
  _.showPrevInvPage = function() {
    if (!this.isInventoryOpen()) {
      return;
    }
    return this.inventory.showPrevPage();
  };
  _.showNextChestPage = function() {
    var ref, ref1;
    if ((ref = this.chest) != null) {
      ref.showNextPage();
    }
    return (ref1 = this.userChest) != null ? ref1.showNextPage() : void 0;
  };
  _.showPrevChestPage = function() {
    var ref, ref1;
    if ((ref = this.chest) != null) {
      ref.showPrevPage();
    }
    return (ref1 = this.userChest) != null ? ref1.showPrevPage() : void 0;
  };
  _.clickInvItem = function(index) {
    if (!this.isInventoryOpen()) {
      return;
    }
    return this.inventory.clickAt(index);
  };
  //?UPDAA
  _.activateHotKey = function(index) {
    if (!AA.isABS()) {
      return false;
    }
    if (this.isInventoryOpen()) {
      if (this.inventory.placeItemToPanel(index)) {
        this.refreshSkillWindow();
        return true;
      }
    }
    if (this.isSkillWindowIsOpen()) {
      if (this.skills.placeItemToPanel(index)) {
        this.refreshInventory();
        return true;
      }
    }
    return false;
  };
  _.activateFavKey = function(index) {
    if (!this.isInventoryOpen()) {
      return false;
    }
    if (!AA.isABS()) {
      return false;
    }
    return this.inventory.placeWeaponToFavorite(index);
  };
  _.update = function() {
    var ref, ref1;
    Sprite.prototype.update.call(this);
    this.inventory.update();
    if ((ref = this.chest) != null) {
      ref.update();
    }
    if ((ref1 = this.userChest) != null) {
      ref1.update();
    }
    if ((this.chest != null) || (this.userChest != null)) {
      return this._updateChestClose();
    }
  };
  _.terminate = function() {
    var ref, ref1;
    this.inventory.terminate();
    if ((ref = this.chest) != null) {
      ref.terminate();
    }
    return (ref1 = this.userChest) != null ? ref1.terminate() : void 0;
  };
  // * ============= CHEST ==============================
  _.openMapChest = function() {
    if (this.isUserChestOpen()) {
      this.closeUserChest();
    }
    this._chestSprite = new AA.LIBS.Sprite_MapChestMain();
    this.chest = new AA.LIBS.MapChestController(this._chestSprite, this);
    this.chest.open();
    if ($gameTemp.__aaItemsForChest != null) {
      this.chest.loadItemsInCategory();
    }
    this.chest._moveToLastPos();
    this.addChild(this._chestSprite);
  };
  _.closeMapChest = function() {
    var ref;
    if ((ref = this.chest) != null) {
      ref.close();
    }
    this.saveStoredChest();
    if (this._chestSprite != null) {
      this.removeChild(this._chestSprite);
    }
    this.chest = null;
  };
  _.saveStoredChest = function() {
    var e, itemsToStore, key;
    try {
      if ($gameTemp.__isStoredVisualChestShouldOpened !== true) {
        return;
      }
      itemsToStore = AA.LIBS.CStoredItems.FromChestItems($gameTemp.__aaItemsForChest);
      key = $gameTemp.__storedVisualChestId;
      $gamePlayer.aaRegisterStoredChest(key[0], key[1], itemsToStore);
      $gameTemp.__storedVisualChestId = null;
      $gameTemp.__aaItemsForChest = [];
      $gameTemp.__isStoredVisualChestShouldOpened = false;
    } catch (error) {
      e = error;
      AA.warning('saveStoredChest', e);
    }
  };
  _.takeAllFromChest = function() {
    var ref, ref1;
    // * Два одновременно не могут быть открыты
    if ((ref = this.chest) != null) {
      ref.takeAll();
    }
    return (ref1 = this.userChest) != null ? ref1.takeAll() : void 0;
  };
  _.isChestOpen = function() {
    return this.chest != null;
  };
  _.clickChestItem = function(index) {
    var ref;
    return (ref = this.chest) != null ? ref.clickAt(index) : void 0;
  };
  _._updateChestClose = function() {
    if (Input.isCancel()) {
      this.closeMapChest();
      this.closeUserChest();
    }
  };
  // * ======================== USER CHEST ==============
  _.openUserChest = function() {
    if (this.isChestOpen()) {
      this.closeMapChest();
    }
    this._userChestSprite = new AA.LIBS.Sprite_MapUserChestMain();
    this.userChest = new AA.LIBS.MapUserChestController(this._userChestSprite, this);
    this.userChest.open();
    this.userChest._moveToLastPos();
    this.userChest.loadItemsInCategory();
    this.addChild(this._userChestSprite);
    this.refreshUserChest();
  };
  _.isUserChestOpen = function() {
    return this.userChest != null;
  };
  _.closeUserChest = function() {
    var ref;
    if ((ref = this.userChest) != null) {
      ref.close();
    }
    if (this._userChestSprite != null) {
      this.removeChild(this._userChestSprite);
    }
    this._userChestSprite = null;
    this.userChest = null;
  };
  _.refreshUserChest = function() {
    if (this.isUserChestOpen()) {
      return this.openUserChestCategory($gameTemp._newUserChestCat);
    }
  };
  _.openUserChestCategory = function(catId) {
    if (catId == null) {
      catId = 0;
    }
    this.userChest.loadItemsInCategory(catId);
    catId = this._checkAvailableCategory(catId);
    if (AA.JSON.getUIMapUserChestSettings().isLinkedCategories === true) {
      if (this.isInventoryOpen()) {
        return this.openCategory(catId);
      }
    }
  };
  _.clickUserChestItem = function(index) {
    var ref;
    return (ref = this.userChest) != null ? ref.clickAt(index) : void 0;
  };
  // * ============================ UPDATE 1.1 =========================
  _.clickInvFocusedItem = function(index) {
    if (!this.isInventoryOpen()) {
      return;
    }
    return this.inventory.clickAtFocusItem(index);
  };
  _.clickInvPartyActor = function(actor) {
    if (!this.isInventoryOpen()) {
      return;
    }
    return this.inventory.clickAtPartyActor(actor);
  };
  _.refreshStoredChest = function() {
    var ref;
    return (ref = this.chest) != null ? ref.loadItemsInCategory() : void 0;
  };
})();

// ■ END Spriteset_ExtraUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCast.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteSpellCast;
  SpriteSpellCast = class SpriteSpellCast extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createGauge();
      this._createIcon();
      this._createNameText();
      this._createValue1Text();
      return this._createValue2Text();
    }

    _loadSettings() {
      this.settings = AA.JSON.getActorSpellCastSettings();
      return this.moveByJson(this.settings);
    }

    _createBackground() {
      this._backgroundImg = AASprite.FromImg(this.settings.backgroundImg);
      return this.add(this._backgroundImg);
    }

    _createGauge() {
      this._gaugeSpr = new AA.LIBS.SpriteGauge(this.settings.gaugeName);
      return this.add(this._gaugeSpr);
    }

    _createIcon() {
      this._iconSpr = AASprite.FromBitmap(this.settings.iconSize, this.settings.iconSize);
      this._iconSpr.move(this.settings.iconMarginX, this.settings.iconMarginY);
      this.add(this._iconSpr);
      return this.setIcon(66); //TODO: test
    }

    _createNameText() {
      this._nameSpr = AASprite.FromBitmap(this.settings.textSkillName.textBoxWidth, this.settings.textSkillName.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._nameSpr, this.settings.textSkillName);
      this.add(this._nameSpr);
      return this.drawText('Lighting Strike'); //TODO: test
    }

    _createValue1Text() {
      if (this.settings.textValue1 == null) {
        return;
      }
      this._value1Spr = AASprite.FromBitmap(this.settings.textValue1.textBoxWidth, this.settings.textValue1.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._value1Spr, this.settings.textValue1);
      this.add(this._value1Spr);
      return this.drawValue1('2.2');
    }

    _createValue2Text() {
      if (this.settings.textValue2 == null) {
        return;
      }
      this._value2Spr = AASprite.FromBitmap(this.settings.textValue2.textBoxWidth, this.settings.textValue2.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._value2Spr, this.settings.textValue2);
      this.add(this._value2Spr);
      return this.drawValue2('3');
    }

    setIcon(iconIndex) {
      this._iconSpr.clear();
      return this._iconSpr.drawIcon(0, 0, iconIndex, this.settings.iconSize);
    }

    drawText(text) {
      if (this._nameSpr == null) {
        return;
      }
      this._nameSpr.clear();
      return this._nameSpr.drawTextFull(text, this.settings.textSkillName.position);
    }

    drawValue1(text) {
      if (this._value1Spr == null) {
        return;
      }
      this._value1Spr.clear();
      return this._value1Spr.drawTextFull(text, this.settings.textValue1.position);
    }

    drawValue2(text) {
      if (this._value2Spr == null) {
        return;
      }
      this._value2Spr.clear();
      text = this.settings.valuesSeparateSymbol + text + this.settings.secondsSymbol;
      return this._value2Spr.drawTextFull(text, this.settings.textValue2.position);
    }

    drawGauge(percent) {
      return this._gaugeSpr.drawGauge(percent);
    }

  };
  AA.register(SpriteSpellCast);
})();

// ■ END SpriteSpellCast.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCastEnemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteSpellCastEnemy;
  SpriteSpellCastEnemy = class SpriteSpellCastEnemy extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getEnemySpellCastSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteSpellCastEnemy);
})();

// ■ END SpriteSpellCastEnemy.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCastPet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellCastPet;
  SpriteSpellCastPet = class SpriteSpellCastPet extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getSummonSpellCastSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteSpellCastPet);
})();

// ■ END SpriteSpellCastPet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteShieldTimer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteShieldTimer;
  SpriteShieldTimer = class SpriteShieldTimer extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getShieldTimerSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteShieldTimer);
})();

// ■ END SpriteShieldTimer.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellInfo.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellInfo;
  SpriteSpellInfo = class SpriteSpellInfo extends AASprite {
    constructor(skill, isWeapon) { //TODO: Конструктор должен принимать AASkill
      super();
      this.skill = skill;
      this.isWeapon = isWeapon;
      if (this.skill != null) {
        this._create();
      }
    }

    //TODO: * isWeapon один раз только испльзуется, чтобы имя вывести правильно, может убрать?
    _create() {
      this.settings = AAJsonSettings.getUISpellInfoSettings();
      this._PFL = this.settings.pixelsForLine;
      this.S = this.settings;
      this.SE = this.settings.elements;
      this.width = this.settings.width;
      this.height = 600; // * FLOATING VALUE
      this._loadResources();
      this._createBackground();
      this._drawTopBorder();
      this._initDraw();
      this._drawInfo();
      this._drawBottomBorder();
      this.background.height = this.realHeight();
      return this.height = this.realHeight();
    }

    _loadResources() {
      this._separatorBitmap = ImageManager.loadAA(this.settings.separatorImg);
      return this._borderBitmap = ImageManager.loadAA(this.settings.borderImg);
    }

    _createBackground() {
      this.background = AASprite.FromBitmap(this.width, this.height);
      this.add(this.background);
      this.background.fillAll(KDCore.Color.FromHex(this.settings.backgroundColor));
      return this.background.opacity = this.settings.backgroundOpacity;
    }

    _drawTopBorder() {
      var topBorder;
      topBorder = new Sprite(this._borderBitmap);
      return this.add(topBorder);
    }

    _initDraw() {
      this.curX = 0;
      this.curY = 0;
      return this.commands = this.S.commands;
    }

    _drawInfo() {
      var args, cmd, e, i, j, method, ref, results;
      if (this.commands == null) {
        return;
      }
      results = [];
      for (i = j = 0, ref = this.commands.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this.commands[i] == null) {
          continue;
        }
        cmd = this.commands[i];
        method = "command" + cmd[0];
        try {
          args = cmd[1];
          this[method](args);
          if (method !== 'commandMoveX') {
            results.push(this.curX = 0);
          } else {
            results.push(void 0);
          }
        } catch (error) {
          e = error;
          results.push(AA.warning("Wrong Spell Info command in JSON", e));
        }
      }
      return results;
    }

    _drawBottomBorder() {
      var bottomBorder;
      bottomBorder = new Sprite(this._borderBitmap);
      bottomBorder.move(0, this.curY);
      return this.add(bottomBorder);
    }

    _drawPair(settingsA, text1, settingsB, text2) {
      var pairOne, pairSpr, pairTwo;
      pairSpr = AASprite.FromBitmap(this.width, this._PFL);
      pairOne = AASprite.FromBitmap(this.width / 2, this._PFL);
      pairTwo = AASprite.FromBitmap(this.width / 2, this._PFL);
      pairOne.applyTextSettingsByExtraSettings(pairOne, settingsA);
      pairOne.drawTextFull(text1, settingsA.position);
      pairTwo.applyTextSettingsByExtraSettings(pairTwo, settingsB);
      pairTwo.drawTextFull(text2, settingsB.position);
      pairTwo.move(pairTwo.x + (this.width / 2), pairTwo.y);
      pairSpr.add(pairOne);
      pairSpr.add(pairTwo);
      pairSpr.move(this.curX, this.curY);
      return this.add(pairSpr);
    }

    _drawParamValPair(text1, text2) {
      return this._drawPair(this.SE.PARAM, text1, this.SE.VALUE, text2);
    }

    _drawParamValLongPair(text1, text2) {
      return this._drawPair(this.SE.PARAM, text1, this.SE.VALUE_LONG, text2);
    }

    _drawText(setting, text) {
      var spr;
      spr = AASprite.FromBitmap(this.width, this._PFL);
      spr.applyTextSettingsByExtraSettings(spr, setting);
      spr.drawTextFull(text, setting.position);
      spr.move(spr.x + this.curX, spr.y + this.curY);
      return this.add(spr);
    }

    _drawDescription(text) {
      if (AA.Parameters.get_NewSpellInfoDescriptionStyle() === true) {
        return this._drawDescriptionNew(text);
      } else {
        this.description = new PIXI.Text(text, this.SE.DESCRIPTION);
        this.description.x = this.curX;
        this.description.y = this.curY;
        return this.add(this.description);
      }
    }

    _drawDescriptionNew(text) {
      var fontFace, fontSize;
      this.description = new Window_Base(this.curX - 14, this.curY - 14, this.settings.width + 20, 100);
      this.description.setBackgroundType(2);
      fontSize = Number(this.SE.DESCRIPTION.fontSize.replace("px", ""));
      fontFace = this.SE.DESCRIPTION.fontFamily;
      this.description.standardFontSize = function() {
        return fontSize;
      };
      this.description.standardFontFace = function() {
        return fontFace;
      };
      this.description.drawTextEx(text, 0, 0);
      this.add(this.description);
    }

    _getName() {
      var name, weaps;
      name = this.skill.name();
      if (this.isWeapon) {
        weaps = $gamePlayer.battler().weapons();
        if (weaps.length > 0) {
          name = weaps[0].name;
        }
      }
      return name;
    }

    _getTargetType() {
      var targetText;
      targetText = '';
      if (this.skill == null) {
        return '';
      }
      if (this.skill.isNoTarget()) {
        return '';
      }
      switch (this.skill.type) {
        case 0:
          if (this.skill.isNeedTarget()) {
            if (this.skill.isForAlly()) {
              targetText = AA.SYSTEM.STRING_SKILL_INFO_ONTARGETALLY;
            } else {
              targetText = AA.SYSTEM.STRING_SKILL_INFO_ONTARGET;
            }
          } else {
            targetText = AA.SYSTEM.STRING_SKILL_INFO_ONUSER;
          }
          break;
        case 1:
          if (this.skill.isVectorTypeR()) {
            targetText = AA.SYSTEM.STRING_SKILL_INFO_AREA;
          } else {
            targetText = AA.SYSTEM.STRING_SKILL_INFO_ONTARGET;
          }
          break;
        case 2:
          if (this.skill.isNeedTarget()) {
            targetText = AA.SYSTEM.STRING_SKILL_INFO_AREA;
          } else {
            targetText = AA.SYSTEM.STRING_SKILL_INFO_CIRCLE;
          }
          break;
        case 3:
          targetText = AA.SYSTEM.STRING_SKILL_INFO_ZONE;
      }
      return targetText;
    }

    _getCastTime() {
      return KDCore.SDK.decimalAdjust('round', this.skill.getCastTime($gamePlayer.battler()) / AA.BattleManagerABS.TURN, -1) + AA.SYSTEM.STRING_SKILL_INFO_SEC;
    }

    _getDiscription() {
      var descriptionText, playerWeapon;
      descriptionText = this.skill.skill().description;
      if (this.skill.skillId === $gamePlayer.battler().attackSkillId() && descriptionText === '') {
        if ($gamePlayer.battler().weapons().length > 0) {
          playerWeapon = $gamePlayer.battler().weapons()[0];
          descriptionText = playerWeapon.description;
          if (playerWeapon.meta.noDescription && playerWeapon.meta.noDescription === '1') {
            descriptionText = '';
          }
        }
      }
      return descriptionText;
    }

    _getDamageTypeText() {
      var damage, damageTypeText;
      damage = this.skill.skill().damage;
      damageTypeText = AA.SYSTEM.STRING_SKILL_INFO_DAMAGE;
      switch (damage.type) {
        case 1:
          damageTypeText += TextManager.hpA;
          break;
        case 2:
          damageTypeText += TextManager.mpA;
          break;
        case 3:
          damageTypeText = AA.SYSTEM.STRING_SKILL_INFO_RECOVER + TextManager.hpA;
          break;
        case 4:
          damageTypeText = AA.SYSTEM.STRING_SKILL_INFO_RECOVER + TextManager.mpA;
          break;
        case 5:
          damageTypeText = AA.SYSTEM.STRING_SKILL_INFO_DRAIN + TextManager.hpA;
          break;
        case 6:
          damageTypeText = AA.SYSTEM.STRING_SKILL_INFO_DRAIN + TextManager.mpA;
      }
      return damageTypeText;
    }

    _getDamageValue() {
      var damage, damageValueText, e, isForUser, isNeedTarget, tempTarget;
      damageValueText = "";
      try {
        damage = this.skill.skill().damage;
        isForUser = this.skill.type === 0 && !this.skill.isNeedTarget();
        isNeedTarget = damage.formula.contains('b');
        if (isNeedTarget) {
          if (isForUser) {
            tempTarget = $gamePlayer.battler();
          } else {
            tempTarget = AA.BattleManagerABS.getPlayerTarget();
          }
          if (tempTarget === null) {
            damageValueText = AA.SYSTEM.STRING_SKILL_INFO_TARGET;
          } else {
            damageValueText = this._getPotentialDamage(tempTarget.battler());
          }
        } else {
          damageValueText = this._getPotentialDamage($gamePlayer.battler());
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'When calculate Damage for Info');
        damageValueText = "?";
      }
      return damageValueText;
    }

    _getPotentialDamage(target) {
      var action, damageValue, damageValueText, dm, e, max, min, percent;
      try {
        damageValueText = '';
        action = new Game_Action($gamePlayer.battler());
        if (this.skill.isItem()) {
          action.setItem(this.skill.skill().id);
        } else {
          action.setSkill(this.skill.skill().id);
        }
        damageValue = Math.abs(action.evalDamageFormula(target));
        if (damageValue > 0 && this.skill.skill().damage.variance > 0) {
          dm = this.skill.skill().damage.variance;
          percent = Math.round(damageValue / 100 * dm);
          min = damageValue - percent;
          max = damageValue + percent;
          damageValueText = min + '-' + max;
        } else {
          damageValueText = damageValue;
        }
        return damageValueText;
      } catch (error) {
        e = error;
        AA.warning('when calculate potetial skill damage', e);
        return '?';
      }
    }

    //REGION COMMANDS
    commandMoveX(dx = 0) {
      return this.curX += dx;
    }

    commandNextLine(dy) {
      this.curX = 0;
      if (dy == null) {
        dy = this._PFL;
      }
      return this.curY += dy;
    }

    commandName(dy) {
      var name;
      name = this._getName();
      this._drawText(this.SE.NAME, name);
      return this.commandNextLine(dy);
    }

    commandCost(dy) {
      var mvSkill;
      if (this.skill.isItem()) {
        return;
      }
      mvSkill = this.skill.skill();
      if (mvSkill.mpCost > 0) {
        this._drawPair(this.SE.COST_MP, TextManager.mpA, this.SE.VALUE_COST, mvSkill.mpCost);
        this.commandNextLine(dy);
      }
      if (mvSkill.tpCost > 0) {
        this._drawPair(this.SE.COST_TP, TextManager.tpA, this.SE.VALUE_COST, mvSkill.tpCost);
        return this.commandNextLine(dy);
      }
    }

    commandTargetType() {
      var tagetText;
      tagetText = this._getTargetType();
      this._drawText(this.SE.TARGET, tagetText);
      return this.commandNextLine();
    }

    commandRange(dy) {
      if (this.skill.isRadiusType() && !this.skill.isNeedTarget()) {
        return;
      }
      if (this.skill.range > 0) {
        this._drawParamValPair(AA.SYSTEM.STRING_SKILL_INFO_RANGE, this.skill.range);
        return this.commandNextLine(dy);
      } else {
        if (this.skill.range === 0 && this.skill.isNeedTarget()) {
          this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_RANGE, AA.SYSTEM.STRING_SKILL_INFO_MELEE);
          return this.commandNextLine(dy);
        }
      }
    }

    commandRadius(dy) {
      if (this.skill.isRadiusType() && !this.skill.isNeedTarget()) {
        this._drawParamValPair(AA.SYSTEM.STRING_SKILL_INFO_RADIUS, this.skill.radius);
        return this.commandNextLine(dy);
      } else {
        if (this.skill.radius > 0) {
          this._drawParamValPair(AA.SYSTEM.STRING_SKILL_INFO_RADIUS, this.skill.radius);
          return this.commandNextLine(dy);
        }
      }
    }

    commandRepeats(dy) {
      var repeats;
      repeats = this.skill.skill().repeats;
      if (repeats <= 1) {
        return;
      }
      this._drawParamValPair(AA.SYSTEM.STRING_SKILL_INFO_REPEATS, this.skill.repeats);
      return this.commandNextLine(dy);
    }

    commandCastTime(dy) {
      var val;
      if (!this.skill.isNeedCast()) {
        return;
      }
      val = this._getCastTime();
      this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_CAST, val);
      return this.commandNextLine(dy);
    }

    commandReloadTime(dy) {
      var reloadTime;
      if (this.skill.getReloadTime() > 0 || this.skill.isNeedReloadParam()) {
        reloadTime = this.skill.reloadTime; //@skill.getReloadTime()
        if (this.skill.isNeedReloadParam()) {
          reloadTime += $gamePlayer.battler()._calculateABSSkillReloadParam(this.skill.reloadParam);
        }
        reloadTime = KDCore.SDK.decimalAdjust('round', reloadTime / AA.BattleManagerABS.TURN, -1);
        this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_COOLDOWN, reloadTime + AA.SYSTEM.STRING_SKILL_INFO_SEC);
        return this.commandNextLine(dy);
      }
    }

    commandDescription(dy) {
      var text;
      text = this._getDiscription();
      if (text == null) {
        return;
      }
      if (text === "") {
        return;
      }
      if (this.skill.noDescription === true) {
        return;
      }
      this._drawDescription(text);
      if (dy == null) {
        dy = 0;
      }
      return this.commandNextLine(this.description.height + dy);
    }

    commandAmmoName(dy) {
      var ammoName;
      if (!this.skill.isNeedAmmo()) {
        return;
      }
      ammoName = $dataItems[this.skill.ammo].name;
      this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_USE, ammoName);
      return this.commandNextLine(dy);
    }

    commandAmmoCount(dy) {
      var ammoCount;
      if (!this.skill.isNeedAmmo()) {
        return;
      }
      ammoCount = $gameParty.numItems($dataItems[this.skill.ammo]);
      this._drawParamValPair(AA.SYSTEM.STRING_SKILL_INFO_HAS, ammoCount);
      return this.commandNextLine(dy);
    }

    commandStackCount(dy) {
      var text;
      if (!this.skill.isStackType()) {
        return;
      }
      text = this.skill._currentStack + '/' + this.skill.stack;
      this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_CHARGES, text);
      return this.commandNextLine(dy);
    }

    commandStackReloadTime(dy) {
      var reloadStack;
      if (!this.skill.isStackType()) {
        return;
      }
      reloadStack = KDCore.SDK.decimalAdjust('round', this.skill.stackTime / AA.BattleManagerABS.TURN, -1);
      this._drawParamValLongPair(AA.SYSTEM.STRING_SKILL_INFO_RELOADCHR, reloadStack + AA.SYSTEM.STRING_SKILL_INFO_SEC);
      return this.commandNextLine(dy);
    }

    commandDamage(dy) {
      var text, value;
      if (this.skill.skill().damage.type === 0) {
        return;
      }
      text = this._getDamageTypeText();
      value = this._getDamageValue();
      this._drawPair(this.SE.DAMAGE, text, this.SE.DAMAGE_VALUE, value);
      return this.commandNextLine(dy);
    }

    commandSeparator(offset) {
      var sep;
      sep = new Sprite(this._separatorBitmap);
      sep.move(this.curX + offset[0], this.curY + offset[1]);
      return this.add(sep);
    }

    //END REGION
    realHeight() {
      return this.curY;
    }

    refreshPlacementForSkillWindow(cell) {
      var dx, dy, pos, xsettings;
      xsettings = AA.JSON.getUIMapSkillSettings().helpWindow;
      pos = this.getSourcePos(cell);
      this.move(pos.x + xsettings.marginX, pos.y + xsettings.marginY);
      dx = dy = 0;
      if (this.background.width + this.x + 5 > Graphics._boxWidth) {
        dx = 1;
        this.x -= xsettings.marginX;
      }
      if (this.background.height + this.y + 5 > Graphics._boxHeight) {
        dy = 1;
        this.y -= xsettings.marginY;
      }
      this.setStaticAnchor(dx, dy);
    }

    getSourcePos(cell) {
      var x, y;
      if (cell != null) {
        x = KDCore.SDK.toGlobalCoord(cell, "x");
        y = KDCore.SDK.toGlobalCoord(cell, "y");
        return new KDCore.Point(x, y);
      } else {
        return TouchInput.getMousePosition();
      }
    }

  };
  AA.register(SpriteSpellInfo);
})();

// ■ END SpriteSpellInfo.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteSpellPanel;
  SpriteSpellPanel = class SpriteSpellPanel extends AASprite {
    constructor(maxItemCount) {
      super();
      this.maxItemCount = maxItemCount;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createContainer();
      return this._createItems();
    }

    _loadSettings() {
      this.settings = AA.JSON.getUISpellPanelSettings();
      this.moveByJson(this.settings);
      return this.visible = this.settings.visible;
    }

    _createContainer() {
      this._container = new AA.LIBS.SpriteUIContainer(this.settings.itemSize);
      this._applySettingsToContainer();
      this._container.setItemsCount(8); // * Максимум 8
      return this.add(this._container);
    }

    _createItems() {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = this.maxItemCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        results.push(this._container.addChild(new AA.LIBS.SpriteSpellPanelItem(i)));
      }
      return results;
    }

    _applySettingsToContainer() {
      this._container.setSpacing(this.settings.itemsMargin);
      if (this.settings.isVertical) {
        this._container.setVertical();
      }
      if (this.settings.itemsAlign === 0) {
        this._container.setPivotToCenter();
      }
      if (this.settings.itemsAlign === 1) {
        this._container.setPivotToLeft();
      }
      if (this.settings.itemsAlign === 2) {
        return this._container.setPivotToRight();
      }
    }

    getItemAt(index) {
      if (this._container == null) {
        return null;
      }
      return this._container.items[index];
    }

    getIndexUnderTouch() {
      var i, item, j, ref;
      for (i = j = 0, ref = this.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = this._container.items[i];
        if (item.isUnderCursor()) {
          return i;
        }
      }
      return null;
    }

    getIndexUnderMouse() {
      var i, item, j, ref;
      if (!this.isMouseInSpellPanel()) {
        return null;
      }
      for (i = j = 0, ref = this.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = this._container.items[i];
        if (item.isUnderMouse()) {
          return i;
        }
      }
      return null;
    }

    isMouseInSpellPanel() {
      return this._container.inPosition(TouchInput.getMousePosition());
    }

    getItemsCount() {
      return this._container.items.length;
    }

    applyMenuPosition() {
      var pos;
      pos = AA.Utils.convertPositionPointFromJSON(this.settings.positionInMenu);
      return this.move(pos.x, pos.y);
    }

  };
  AA.register(SpriteSpellPanel);
})();

// ■ END SpriteSpellPanel.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanelGP.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellPanelGP;
  SpriteSpellPanelGP = class SpriteSpellPanelGP extends AASprite {
    constructor(maxItemCount) {
      super();
      this.maxItemCount = maxItemCount;
      this._create();
    }

    _create() {
      this._loadSettings();
      return this._createContainer();
    }

    _loadSettings() {
      this.settings = AA.JSON.getGamepadUISettings().SpellPanel;
      this.moveByJson(this.settings);
      return this.visible = this.settings.visible;
    }

    //convertPositionPointFromJSON
    _createContainer() {
      var s, swichSkillIcon;
      //TODO: Названия картинок вроде тоже должны быть в JSON
      this._baseSpr = AASprite.FromImg(this.settings.backgroundImg);
      this._containerA = new Sprite();
      this._containerB = new Sprite();
      this.add(this._baseSpr);
      this.add(this._containerB);
      this.add(this._containerA);
      swichSkillIcon = AASprite.FromImg(this.settings.switchSkillImg);
      s = this.settings;
      swichSkillIcon.move(s.switchSkillMarginX, s.switchSkillMarginY);
      return this.add(swichSkillIcon);
    }

    getItemAt(index) {
      return this._items[index];
    }

    getIndexUnderTouch() {
      return null;
    }

    getIndexUnderMouse() {
      return null;
    }

    getItemsCount() {
      return this._items.length;
    }

    applyMenuPosition() {} // *EMPTY

    refresh(items) {
      this._containerA.visible = false;
      this._containerB.visible = false;
      this.removeChild(this._containerA);
      this.removeChild(this._containerB);
      this._containerA = new Sprite();
      this._containerB = new Sprite();
      this.add(this._containerB);
      this.add(this._containerA);
      return this.setupItems(items);
    }

    setupItems(items) {
      var i, j, k;
      this._items = items;
      for (i = j = 0; j < 4; i = ++j) {
        this._placeItem(items[i], i, this._containerA);
      }
      for (i = k = 4; k < 8; i = ++k) {
        this._placeItem(items[i], i - 4, this._containerB);
      }
      return this._setMainContainerA();
    }

    _setMainContainerA() {
      this._containerA.parent.removeChild(this._containerA);
      this._containerB.parent.removeChild(this._containerB);
      this.add(this._containerB);
      this.add(this._containerA);
      this._containerA.move(0, 0);
      this._containerB.move(this.settings.backLayerMarginX, this.settings.backLayerMarginY);
      this._containerA.opacity = 255;
      return this._containerB.opacity = this.settings.backLayerOpacity;
    }

    _setMainContainerB() {
      this._containerA.parent.removeChild(this._containerA);
      this._containerB.parent.removeChild(this._containerB);
      this.add(this._containerA);
      this.add(this._containerB);
      this._containerB.move(0, 0);
      this._containerA.move(this.settings.backLayerMarginX, this.settings.backLayerMarginY);
      this._containerB.opacity = 255;
      return this._containerA.opacity = this.settings.backLayerOpacity;
    }

    _placeItem(item, index, layer) {
      if (item == null) {
        return;
      }
      item.drawText("");
      layer.addChild(item);
      switch (index) {
        case 0:
          return item.move(this.settings.item_0);
        case 1:
          return item.move(this.settings.item_1);
        case 2:
          return item.move(this.settings.item_2);
        case 3:
          return item.move(this.settings.item_3);
      }
    }

  };
  AA.register(SpriteSpellPanelGP);
})();

// ■ END SpriteSpellPanelGP.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanelItem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:2
(function() {
  var SpriteSpellPanelItem;
  SpriteSpellPanelItem = class SpriteSpellPanelItem extends AASprite {
    constructor(index, settings) {
      super();
      this.index = index;
      this.settings = settings;
      this._mouseIn = false;
      this._isPulsing = false;
      this._hoverColor = null;
      this._pulseSwing = null;
      this._canBeHovered = true;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createIconSprite();
      this._createRechargeSprite();
      this._createTextSprite();
      return this._createText2Sprite();
    }

    _loadSettings() {
      if (this.settings == null) {
        this.settings = AA.JSON.getUISpellItemSettings();
      }
      this.visible = this.settings.visible;
      this._hoverColor = KDCore.Color.FromHex(this.settings.hover.color).ARR; //.OX
      this._pulseColorA = KDCore.Color.FromHex(this.settings.pulse.colorA).ARR; //.OX
      this._pulseColorB = KDCore.Color.FromHex(this.settings.pulse.colorB).ARR; //.OX
      this._textDisabledColor = KDCore.Color.FromHex(this.settings.disabledTextColor);
      this._text2DisabledTextColor = KDCore.Color.FromHex(this.settings.disabledText2Color);
      return this._text2SpecialTextColor = KDCore.Color.FromHex(this.settings.specialText2Color);
    }

    _createBackground() {
      if (this.settings.backgroundImg != null) {
        this._background = AASprite.FromImg(this.settings.backgroundImg);
        this._background.onReady(() => {
          return this.setFrame(0, 0, 40, 40);
        });
        this.add(this._background);
        this._backgroundHover = AASprite.FromImg("SkillSlot_hover");
        this._background.add(this._backgroundHover);
        return this._backgroundHover.opacity = 0;
      } else {
        return this.setFrame(this.settings.iconMarginX, this.settings.iconMarginY, this.settings.iconSize, this.settings.iconSize);
      }
    }

    _createIconSprite() {
      this._iconSprite = AASprite.FromBitmap(this.settings.iconSize);
      this._iconSprite.move(this.settings.iconMarginX, this.settings.iconMarginY);
      this._iconSprite.onReady(this._drawIconOnReady.bind(this));
      return this.add(this._iconSprite);
    }

    _drawIconOnReady() {
      if (this._drawOnReady != null) {
        this.drawIcon(this._drawOnReady);
        return this._drawOnReady = null;
      }
    }

    _createRechargeSprite() {
      this._recharge = new AA.LIBS.SpriteItemRecharge(this.settings.recharge);
      return this.add(this._recharge);
    }

    _createTextSprite() {
      this._textSpr = AASprite.FromBitmap(this.settings.textZoneWidth, this.settings.textZoneHeight);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      this._textSpr.bitmap.outlineColor = '#000000';
      this._textSpr.bitmap.outlineWidth = 2;
      return this.add(this._textSpr);
    }

    _createText2Sprite() {
      this._textSpr2 = AASprite.FromBitmap(this.settings.text2ZoneWidth, this.settings.text2ZoneHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr2, this.settings.text2);
      this._textSpr2.bitmap.outlineColor = '#000000';
      this._textSpr2.bitmap.outlineWidth = 2;
      return this.add(this._textSpr2);
    }

    clear() {
      return this.drawIcon(null);
    }

    drawIcon(iconIndex) {
      if (this._iconSprite == null) {
        return;
      }
      this._iconSprite.clear();
      if (iconIndex != null) {
        return this._iconSprite.drawIcon(0, 0, iconIndex, this.settings.iconSize);
      }
    }

    drawIconOnReady(iconIndex) {
      this._drawOnReady = iconIndex;
      return this.drawIcon(iconIndex);
    }

    drawTextDisabled(text) {
      return this.drawText(text, this._textDisabledColor);
    }

    drawText(text, color) {
      if (this._textSpr == null) {
        return;
      }
      return this._drawTextOnSprite(this._textSpr, text, this.settings.text.position, color);
    }

    _drawTextOnSprite(sprite, text, position, color) {
      var _defColor;
      if (sprite == null) {
        return;
      }
      sprite.clear();
      if (color != null) {
        _defColor = sprite.b().textColor;
        sprite.b().textColor = color.CSS;
      }
      sprite.drawTextFull(text, position);
      if (_defColor != null) {
        return sprite.b().textColor = _defColor;
      }
    }

    drawText2Disabled(text) {
      return this.drawText2(text, this._text2DisabledTextColor);
    }

    drawText2(text, color) {
      if (this._textSpr2 == null) {
        return;
      }
      return this._drawTextOnSprite(this._textSpr2, text, this.settings.text2.position, color);
    }

    drawText2Special(text) {
      return this.drawText2(text, this._text2SpecialTextColor);
    }

    isUnderTouch() {
      return this.inPosition(TouchInput);
    }

    isUnderMouse() {
      return this.inPosition(TouchInput.getMousePosition());
    }

    isUnderCursor() {
      return this.isUnderMouse() || this.isUnderTouch();
    }

    update() {
      super.update();
      if (AA.Parameters.get_UsePerformanceSkillPanel()) {
        return;
      }
      if (this._canBeHovered === true) {
        this._upateUnderCursor();
      }
      if (this.isPulsing()) {
        return this.updatePulse();
      }
    }

    _upateUnderCursor() {
      if (this.isUnderMouse()) {
        if (this._mouseIn === true) {
          return;
        }
        this._mouseIn = true;
        return this._onMouseEnter();
      } else {
        if (this._mouseIn === false) {
          return;
        }
        this._mouseIn = false;
        return this._onMouseLeave();
      }
    }

    _onMouseEnter() {
      return this.showSelectedFrame();
    }

    _onMouseLeave() {
      if (!this.isPulsing()) {
        return this.clearFilter();
      }
    }

    showSelectedFrame() {
      if (this._backgroundHover == null) {
        return;
      }
      //@_background.setGlowFilter(@_hoverColor, @settings.hover.power)
      this._backgroundHover.setBlendColor(this._hoverColor);
      this._backgroundHover.opacity = 255;
    }

    clearFilter() {
      //return unless @_background?
      if (this._backgroundHover == null) {
        return;
      }
      //@_background.clearFilters()
      this._backgroundHover.opacity = 0;
    }

    //@_backgroundHover.setBlendColor(KDCore.Color.WHITE.ARR)
    updatePulse() {
      if (this._pulseSwing == null) {
        return;
      }
      this._pulseSwing.update();
      if (this._pulseSwing.isReady()) {
        return this.stopPulse();
      }
    }

    startPulse(xcolor, isLoop = false) {
      if (AA.Parameters.get_UsePerformanceSkillPanel()) {
        return;
      }
      if (this._isPulsing === true) {
        this.stopPulse();
      }
      this._isPulsing = true;
      if (this._backgroundHover == null) {
        return;
      }
      //@_background.setGlowFilter(xcolor, @settings.pulse.power)
      this._backgroundHover.setBlendColor(xcolor);
      this._backgroundHover.opacity = 255;
      this._pulseSwing = new AA.LIBS.ValueSwing(this._backgroundHover, "opacity", this.settings.pulse.duration);
      if (isLoop) {
        this._pulseSwing.setRepeat();
      }
      return this._pulseSwing.start();
    }

    stopPulse() {
      this._pulseSwing = null;
      this._isPulsing = false;
      return this.clearFilter();
    }

    isPulsing() {
      return this._isPulsing === true;
    }

    pulseOnceA() {
      return this.startPulse(this._pulseColorA);
    }

    pulseOnceB() {
      return this.startPulse(this._pulseColorB);
    }

    disableHover() {
      this._onMouseLeave();
      return this._canBeHovered = false;
    }

    drawRecharge(percent = 1) {
      return this._recharge.drawRecharge(percent);
    }

  };
  AA.register(SpriteSpellPanelItem);
})();

// ■ END SpriteSpellPanelItem.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteUIContainer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteUIContainer;
  SpriteUIContainer = class SpriteUIContainer extends AASprite {
    constructor(size) {
      super(new Bitmap(size, size));
      this.size = size;
      this.items = [];
      this.orientation = "horizontal";
      this.placePoint = "right";
      this.itemsCount = 1;
      this.spacing = 0;
    }

    //?{PUBLIC}
    setItemsCount(itemsCount) {
      this.itemsCount = itemsCount;
      return this._refreshMain();
    }

    _refreshMain() {
      var s;
      s = this._getSize() * this.itemsCount;
      this.bitmap = new Bitmap(s, s);
      this._rearrange();
      return this._refreshPlace();
    }

    _getSize() {
      return this.size + this.spacing;
    }

    //?{PUBLIC}
    setSpacing(spacing) {
      this.spacing = spacing;
      return this._refreshMain();
    }

    //?{PUBLIC}
    addChild(sprite) {
      this._createItem(sprite);
      this._rearrange();
      return this._refreshPlace();
    }

    _createItem(sprite) {
      this._reCreatePlacer(sprite.visible);
      this.items.push(sprite);
      return this._placer.addChild(sprite);
    }

    _reCreatePlacer(isNew) {
      var pl, s, visLen;
      if (this._placer != null) {
        super.removeChild(this._placer);
      }
      visLen = this._visItemsLength();
      if (isNew === true) {
        visLen += 1;
      }
      s = this._getSize() * visLen;
      s -= this.spacing;
      this._placer = new Sprite(new Bitmap(s, s));
      super.addChild(this._placer);
      pl = this._placer;
      this.items.forEach(function(item) {
        if (item.visible === true) {
          return pl.addChild(item);
        }
      });
    }

    _visItemsLength() {
      var count, i, j, ref;
      count = 0;
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this.items[i].visible === true) {
          count++;
        }
      }
      return count;
    }

    _rearrange() {
      var ref, ref1;
      if (this._placer == null) {
        return;
      }
      if ((ref = this._placer.children[0]) != null) {
        ref.x = 0;
      }
      if ((ref1 = this._placer.children[0]) != null) {
        ref1.y = 0;
      }
      if (this.isVertical()) {
        return this._rearrangeVertical();
      } else {
        return this._rearrangeHorizontal();
      }
    }

    _rearrangeVertical() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].y = items[0].y + (s * i));
      }
      return results;
    }

    _rearrangeHorizontal() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].x = items[0].x + (s * i));
      }
      return results;
    }

    _refreshPlace() {
      if (this._placer == null) {
        return;
      }
      if (this.isVertical()) {
        return this._refreshPlaceVertical();
      } else {
        return this._refreshPlaceHorizontal();
      }
    }

    _refreshPlaceVertical() {
      if (this.placePoint === "center") {
        this._placer.y = this.height / 2;
        this._placer.y = this._placer.y - (this._placer.height / 2);
      }
      if (this.placePoint === "left") {
        this._placer.y = this.height;
        return this._placer.y = this._placer.y - this._placer.height;
      }
    }

    _refreshPlaceHorizontal() {
      if (this.placePoint === "center") {
        this._placer.x = this.width / 2;
        this._placer.x = this._placer.x - (this._placer.width / 2);
      }
      if (this.placePoint === "left") {
        this._placer.x = this.width;
        return this._placer.x = this._placer.x - this._placer.width;
      }
    }

    //?{PUBLIC}
    refresh() {
      this._reCreatePlacer(false);
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    setHorizontal() {
      this.orientation = "horizontal";
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    isHorizontal() {
      return this.orientation === "horizontal";
    }

    //?{PUBLIC}
    setVertical() {
      this.orientation = "vertical";
      this._rearrange();
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    isVertical() {
      return this.isHorizontal() === false;
    }

    
      //?{PUBLIC}
    setPivotToCenter() {
      this.placePoint = "center";
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    setPivotToLeft() {
      this.placePoint = "left";
      return this._refreshPlace();
    }

    
      //?{PUBLIC}
    setPivotToRight() {
      this.placePoint = "right";
      return this._refreshPlace();
    }

  };
  AA.register(SpriteUIContainer);
})();

// ■ END SpriteUIContainer.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteWeaponIcon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//?rev:1
(function() {
  var SpriteWeaponIcon;
  SpriteWeaponIcon = class SpriteWeaponIcon extends AA.LIBS.SpriteSpellPanelItem {
    constructor() {
      super(0, AA.JSON.getWeaponIconSettings());
    }

    _create() {
      super._create();
      this.moveByJson(this.settings);
      return this.disableHover();
    }

    _createRechargeSprite() {
      super._createRechargeSprite();
      return this._createForeground();
    }

    _createForeground() {
      this._background = AASprite.FromImg(this.settings.foregroundImg);
      this._background.onReady(() => {
        return this.drawDefault();
      });
      return this.add(this._background);
    }

    drawDefault() {
      return this.drawIcon(this.settings.defaultIcon);
    }

  };
  AA.register(SpriteWeaponIcon);
})();

// ■ END SpriteWeaponIcon.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var StringsLoader;
  StringsLoader = class StringsLoader {
    constructor(_parameters) {
      this._parameters = _parameters;
    }

    loadAllStrings(object) {
      var strings;
      strings = this._collect(object);
      this._writeNewString(object, strings);
    }

    _collect(object) {
      var properties, strings;
      properties = Object.getOwnPropertyNames(object);
      strings = properties.filter(function(item) {
        return item.includes("STRING_");
      });
      return strings;
    }

    _writeNewString(object, strings) {
      var i, len, string;
      for (i = 0, len = strings.length; i < len; i++) {
        string = strings[i];
        this._setStringFromPluginParametersToObject(object, string);
      }
    }

    _setStringFromPluginParametersToObject(object, stringName) {
      var newValue;
      newValue = this._parameters[stringName];
      if (newValue) {
        object[stringName] = newValue;
      }
    }

  };
  AlphaABS.register(StringsLoader);
})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonAIBotH.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
function Game_SummonAiBot() {
    this.initialize.apply(this, arguments);
}

(function () {

    Game_SummonAiBot.prototype = Object.create(Game_SpawnedAiBot.prototype);
    Game_SummonAiBot.prototype.constructor = Game_SummonAiBot;

    Game_SummonAiBot.prototype.initialize = function (mapId, eventId, enemyId, x, y, spawnEventId) {
        Game_SpawnedAiBot.prototype.initialize.call(this, mapId, eventId, enemyId, x, y, spawnEventId);
    };

    //@[DEFINE]
    var _ = Game_SummonAiBot.prototype;

    _._beforeRemoveFromMap = function () {
        // * Это костыль, но в 12 версии союзник сразу сбрасывается как цель
        if (AA.BattleUI._lastUITaget == this)
            AA.BattleManagerABS.setPlayerTarget(null);
        this.selectOnMap(false);
        this._onBattleEnd();
        this.battler().stopABS();
        this._deactivate();
    };

    //$[OVER AIBOT]
    _.isSummonUnit = function () {
        return (this._summonUnit == true);
    };

    _.canChangeMode = function() {
        return (this.behaviorModel().sChangeModeAllowed > 0);
    };

    _.activateSummonUnit = function () {
        this.changeTeamTo(0); // * Меняем номер команды под игрока
        this._summonUnit = true;
        this._loadSupportAction();
        this._stateMachine = new AlphaABS.LIBS.AIStateMachinePet();
        this._stateMachine.switchStateToFree(this);
        this.changeBehMode(this.behaviorModel().sBattleMode);
        this._absParams.useAStar = true;
        //this.setThrough(true);
        this.refreshGlobal();
        this.checkCollisionWithPlayer();
    };

})();

// ■ END SummonAIBotH.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonExtension.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Spriteset_InterfaceABS;
  Spriteset_InterfaceABS = AlphaABS.LIBS.Spriteset_InterfaceABS;
  Spriteset_InterfaceABS.prototype._isSummonUIExists = function() {
    return this._faceSpriteP != null;
  };
  Spriteset_InterfaceABS.prototype._createSummonUI = function() {
    var ref, summon;
    summon = $gamePlayer.getSummonUnit();
    if (summon == null) {
      return;
    }
    if (this._summonUnitCtr != null) {
      this._destroySummonUI();
    }
    this._summonUnitCtr = new AA.LIBS.SummonUIController(this, summon);
    if ((ref = this.partyUIGroup) != null) {
      ref.onActorSummonAny();
    }
    if (this._sumCircle == null) {
      return this._createSummonCircle(); // * Для предзагрузки ресурсов
    }
  };
  Spriteset_InterfaceABS.prototype._destroySummonUI = function() {
    var ref;
    if (this._summonUnitCtr == null) {
      return;
    }
    this._summonUnitCtr.terminate();
    this._summonUnitCtr = null;
    if ((ref = this.partyUIGroup) != null) {
      ref.onSummonCancel();
    }
    return AA.BattleUI.closeSummonCircle();
  };
  Spriteset_InterfaceABS.prototype._createSummonCircle = function() {
    this._sumCircle = new AA.LIBS.UI_SummonCircle(function(index) {
      if (this.isOpen()) {
        return $gamePlayer._touchSummonCommandAt(index);
      }
    });
    this.addChild(this._sumCircle);
    return this._refreshSummonCircle();
  };
  Spriteset_InterfaceABS.prototype._refreshSummonCircle = function() {
    var ref;
    return (ref = this.commonBehCircle()) != null ? ref.refresh() : void 0;
  };
  //==========================================================================
  AA.BattleUI.showSummonUnitUI = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref._createSummonUI();
    }
    return $gamePlayer._refreshGamePadCommands();
  };
  AA.BattleUI.hideSummonUnitUI = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref._destroySummonUI();
    }
    return $gamePlayer._refreshGamePadCommands();
  };
  AA.BattleUI.setSummonMoveMode = function(modeIndex) {
    var ref, ref1;
    return (ref = this._ui) != null ? (ref1 = ref._summonUnitCtr) != null ? ref1.setMove(modeIndex) : void 0 : void 0;
  };
  AA.BattleUI.setSummonBehMode = function(modeIndex) {
    var ref, ref1;
    return (ref = this._ui) != null ? (ref1 = ref._summonUnitCtr) != null ? ref1.setMode(modeIndex) : void 0 : void 0;
  };
  AA.BattleUI._getCommonBehCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.commonBehCircle() : void 0;
  };
  AA.BattleUI._getSummonCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref._sumCircle : void 0;
  };
  AA.BattleUI._getAllyBehCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.allyBehCircle() : void 0;
  };
  AA.BattleUI.refreshSummonCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref._refreshSummonCircle() : void 0;
  };
  AA.BattleUI.touchOnSummonCircle = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getCommonBehCircle()) != null ? ref.click(index) : void 0;
    }
  };
  AA.BattleUI.isSummonCircleOpen = function() {
    var ref;
    return (ref = this._getSummonCircle()) != null ? ref.isOpen() : void 0;
  };
  AA.BattleUI.isBehCircleOpen = function() {
    var ref;
    return (ref = this._getCommonBehCircle()) != null ? ref.isOpen() : void 0;
  };
  AA.BattleUI.isAllyBehCircleOpen = function() {
    var ref;
    return (ref = this._getAllyBehCircle()) != null ? ref.isOpen() : void 0;
  };
  AA.BattleUI.openSummonCircle = function() {
    var circle;
    circle = this._getCommonBehCircle();
    if (circle != null) {
      if (!circle.isOpen()) {
        circle.open();
      }
    }
  };
  AA.BattleUI.closeSummonCircle = function() {
    var circle;
    circle = this._getSummonCircle();
    if (circle != null) {
      if (circle.isOpen()) {
        circle.close();
      }
    }
  };
  AA.BattleUI.closeBehCircle = function() {
    this.closeSummonCircle();
    return this.closeAllyBehCircle();
  };
  AA.BattleUI.closeAllyBehCircle = function() {
    var circle;
    circle = this._getAllyBehCircle();
    if (circle != null) {
      if (circle.isOpen()) {
        circle.close();
        return $gamePlayer._resetCircleInputMode();
      }
    }
  };
  AA.BattleUI.isSummonCircleTouchedAny = function() {
    var cl;
    cl = this._getCommonBehCircle();
    if (cl == null) {
      return false;
    }
    return cl.isOpen() && cl.isTouchedAny();
  };
  AA.BattleUI.moveSummonCircle = function(x, y) {
    var ref;
    if ((x != null) && (y != null)) {
      return (ref = this._getSummonCircle()) != null ? ref.move(x, y) : void 0;
    }
  };
})();

// ■ END SummonExtension.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonUIController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SummonUIController;
  SummonUIController = class SummonUIController {
    constructor(parent, summonUnit) {
      this.parent = parent;
      this.summonUnit = summonUnit;
      if (this.summonUnit == null) {
        return;
      }
      this._elements = [];
      this._modes = [];
      this._moves = [];
      this.createFace();
      this.createHP();
      this.createMP();
      this.createCast();
      this.createTitle();
      this.createBehMode();
      this.createMoveMode();
      this.setMode(this.summonUnit._bahMode);
      this.setMove(0);
    }

    createFace() {
      var faceSpriteP;
      faceSpriteP = new AA.LIBS.SpriteActorPortrait(2, this.summonUnit.behaviorModel());
      this.parent.addChild(faceSpriteP);
      return this._elements.push(faceSpriteP);
    }

    createHP() {
      var gaugeSprite;
      gaugeSprite = new AA.LIBS.SpriteGauge('hpP');
      this.parent.addChild(gaugeSprite);
      this._hpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
      this._hpGaugeCntr.setup(this.summonUnit.battler(), 'hp', 'mhp');
      return this._elements.push(gaugeSprite);
    }

    createMP() {
      var gaugeSprite;
      gaugeSprite = new AA.LIBS.SpriteGauge('mpP');
      this.parent.addChild(gaugeSprite);
      this._mpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
      this._mpGaugeCntr.setup(this.summonUnit.battler(), 'mp', 'mmp');
      return this._elements.push(gaugeSprite);
    }

    createCast() {
      var castSprite;
      castSprite = new AlphaABS.LIBS.SpriteSpellCastPet();
      this._castController = new AlphaABS.LIBS.NewCastBarControllerEnemy(castSprite);
      this._castController.setTarget(this.summonUnit);
      this.parent.addChild(castSprite);
      return this._elements.push(castSprite);
    }

    createTitle() {
      var loader, summonIcon, summonTitle;
      loader = AAJsonSettings.getUISummonUnitSettings;
      summonTitle = new AA.LIBS.SpriteUIElement('SummonTitle', loader);
      summonTitle.drawTextOnReady('Summoned');
      this.parent.addChild(summonTitle);
      summonIcon = new AA.LIBS.SpriteUIElement('SummonIcon', loader);
      this.parent.addChild(summonIcon);
      this._elements.push(summonTitle);
      return this._elements.push(summonIcon);
    }

    createBehMode() {
      var behMode1, behMode2, behMode3, loader;
      loader = AAJsonSettings.getUISummonUnitSettings;
      behMode1 = new AA.LIBS.SpriteUIElement('UnitBeh_AttackAll', loader);
      this.parent.addChild(behMode1);
      this._modes.push(behMode1);
      behMode2 = new AA.LIBS.SpriteUIElement('UnitBeh_AttackTarget', loader);
      this.parent.addChild(behMode2);
      this._modes.push(behMode2);
      behMode3 = new AA.LIBS.SpriteUIElement('UnitBeh_Protect', loader);
      this.parent.addChild(behMode3);
      return this._modes.push(behMode3);
    }

    createMoveMode() {
      var behMode1, behMode2, behMode3, behMode4, loader;
      loader = AAJsonSettings.getUISummonUnitSettings;
      behMode1 = new AA.LIBS.SpriteUIElement('UnitMode_Follow', loader);
      this.parent.addChild(behMode1);
      this._moves.push(behMode1);
      behMode2 = new AA.LIBS.SpriteUIElement('UnitMode_Looting', loader);
      this.parent.addChild(behMode2);
      this._moves.push(behMode2);
      behMode3 = new AA.LIBS.SpriteUIElement('UnitMode_Support', loader);
      this.parent.addChild(behMode3);
      this._moves.push(behMode3);
      behMode4 = new AA.LIBS.SpriteUIElement('UnitMode_Battle', loader);
      this.parent.addChild(behMode4);
      return this._moves.push(behMode4);
    }

    setMode(index) {
      var i, item, len, ref;
      ref = this._modes;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        item.visible = false;
      }
      return this._modes[index].visible = true;
    }

    setMove(index) {
      var i, item, len, ref;
      ref = this._moves;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        item.visible = false;
      }
      return this._moves[index].visible = true;
    }

    terminate() {
      var i, item, j, k, len, len1, len2, ref, ref1, ref2;
      ref = this._elements;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.parent.removeChild(item);
        item.visible = false;
      }
      ref1 = this._modes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        this.parent.removeChild(item);
        item.visible = false;
      }
      ref2 = this._moves;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        item = ref2[k];
        this.parent.removeChild(item);
        item.visible = false;
      }
      this._castController.stop();
      return this._castController.terminate();
    }

    update() {
      this._hpGaugeCntr.update();
      return this._mpGaugeCntr.update();
    }

  };
  AA.register(SummonUIController);
})();

// ■ END SummonUIController.coffee
//---------------------------------------------------------------------------


//$[ENCODE]
Window_Message.prototype.wordWrap = function (text, options) {
    var lines = text.split('\n');
    var maxWidth = options.maxWidth;
    var spaceWidth = this.contents.measureTextWidth(' ');
    var result = '';
    var newLines = 1;

    for (var i = 0; i < lines.length; i++) {
        var spaceLeft = maxWidth;
        var line = lines[i];
        var words = line.split(' ');

        for (var j = 0; j < words.length; j++) {
            var wordWidth = this.contents.measureTextWidth(words[j]);

            var wordWidthWithSpace = wordWidth + spaceWidth;

            if (j === 0 || wordWidthWithSpace > spaceLeft) {
                if (j > 0) {
                    if (options.maxLines === newLines) {
                        return result;
                    }
                    result += '\n';
                    newLines++;
                }
                result += words[j];
                spaceLeft = maxWidth - wordWidth;
                if (j === 0 && line.match(/\\n\w*\s*<\s*\\n\[\w*\s*\]\s*>*/gi)) {
                    spaceLeft += 200;
                }
            } else {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length - 1) {
            result += '\n';
        }
    }

    return result;
};

Window_Base.prototype.drawTextExWithPrepare = function (text, x, y, width) {
    var allText = text;
    var maxWidth = this.contentsWidth();
    allText = Window_Message.prototype.wordWrap.call(this, allText, {
        maxWidth: width || maxWidth,
        px: 0
    });
    this.drawTextEx(allText, x, y);
};
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ User API.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var uAPI;

uAPI = function() {
  throw new Error("This is a static class");
};

uAPI.putLine = function(text) {
  var ref;
  return (ref = AlphaABS.BattleUI) != null ? ref._pushOnPanel(null, text) : void 0;
};

uAPI.putText = function(text) {
  var ui;
  if (AlphaABS.BattleUI != null) {
    ui = AlphaABS.BattleUI.getUI();
    if (ui != null) {
      return ui.addPopUp(AlphaABS.PopInfoManagerABS.ALERT(text));
    }
  }
};

uAPI.putLineWithIcon = function(text, iconIndex) {
  var ref;
  return (ref = AlphaABS.BattleUI) != null ? ref.pushIconTextOnPanel({text, iconIndex}) : void 0;
};

uAPI.findEnemy = function(id) {
  var ref;
  if (id == null) {
    return null;
  }
  return (ref = $gameTroop.membersABS()) != null ? ref.find(function(item) {
    return item.eventId() === id;
  }) : void 0;
};

uAPI.activateE = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.activate() : void 0;
};

uAPI.deactivateE = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.deactivate() : void 0;
};

uAPI.reviveE = function(id, time) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.setRevive(time) : void 0;
};

uAPI.loot = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.loot() : void 0;
};

uAPI.spawn = function(id, regionOrX, region) {
  return Game_Interpreter.prototype._onABSSpawn(id, regionOrX, region);
};

uAPI.setParamE = function(id, paramName, newValue) {
  var e;
  try {
    if (paramName == null) {
      return;
    }
    if (newValue == null) {
      newValue = 0;
    }
    e = uAPI.findEnemy(id);
    if (e == null) {
      return;
    }
    if (AlphaABS.LIBS.Game_AIBehavior.PARAMS.indexOf(paramName) > 0) {
      e.behaviorModel()[paramName] = newValue;
      e.LOG.p("New value " + newValue + " of " + paramName);
      if (!e.inBattle()) {
        e.refreshBehavior();
      }
    }
    return;
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while you call setParamE with uAPI');
  }
};

// * См. Extension_RyanScriptCall.js
// * selfEventId - for set Self.Switch, only if iavra_self_variables plugin imported
uAPI.findNearestEnemy = function(notetag, range, varId, selfEventId) {
  var e;
  try {
    if (window.find_nearest_event != null) {
      if (selfEventId >= 1) {
        window.find_nearest_event(notetag, range, varId, selfEventId, true);
      } else {
        window.find_nearest_event(notetag, range, varId);
      }
    }
  } catch (error) {
    e = error;
    AA.warning(e);
  }
};

uAPI.UISetSkill = function(id, index) {
  var ref;
  if (id == null) {
    return;
  }
  if (index != null) {
    if (index > 0) {
      index = index - 1;
    }
  }
  return (ref = uAPI.actor) != null ? ref._setSkillOnPanelByID(id, index) : void 0;
};

uAPI.UIRemoveSkill = function(id) {
  var ref;
  if (id != null) {
    return (ref = uAPI.actor) != null ? ref._removeSkillFromPanelByID(id) : void 0;
  }
};

uAPI.UISetItem = function(id, index) {
  var ref;
  if (id == null) {
    return;
  }
  if (index != null) {
    if (index > 0) {
      index = index - 1;
    }
  }
  return (ref = uAPI.actor) != null ? ref._setItemOnPanelByID(id, index) : void 0;
};

uAPI.UIRemoveItem = function(id) {
  var ref;
  if (id != null) {
    return (ref = uAPI.actor) != null ? ref._removeItemFromPanelByID(id) : void 0;
  }
};

uAPI.UIRemoveByIndex = function(index) {
  var ref;
  if (index == null) {
    return;
  }
  if (index > 0) {
    index = index - 1;
  }
  return (ref = uAPI.actor) != null ? ref.setSkillOnPanel(null, index) : void 0;
};

// * NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI.playAMotionForPlayer = function(...params) {
  return uAPI._playAMotionForCharacter($gamePlayer, ...params);
};

// * EVENT_ID, NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI.playAMotionForEnemy = function(...params) {
  var enemy;
  if (params[0] == null) {
    return;
  }
  enemy = uAPI.findEnemy(params[0]);
  params.shift();
  if (enemy != null) {
    uAPI._playAMotionForCharacter(enemy, ...params);
  }
};

uAPI.showMiniText = function(eventId, text, colorIndex) {
  var e;
  try {
    return uAPI._showMiniText(eventId, text, colorIndex, false);
  } catch (error) {
    e = error;
    return AA.warning(e, 'uAPI.showMiniText');
  }
};

uAPI._showMiniText = function(id, text, colorIndex, isParty) {
  var s;
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if (!AA.isPro()) {
    return;
  }
  if (id < 0) {
    return;
  }
  s = SceneManager._scene;
  return s._showAAMiniMsg({
    "evId": id,
    "text": text,
    "color": colorIndex != null ? colorIndex : 0,
    "party": isParty
  });
};

uAPI.showMiniTextParty = function(actorId, text, colorIndex) {
  var e;
  if (!AA.isABS()) {
    return;
  }
  try {
    return uAPI._showMiniText(actorId, text, colorIndex, true);
  } catch (error) {
    e = error;
    return AA.warning(e, 'uAPI.showMiniTextParty');
  }
};

uAPI.resetCamera = function() {
  var e;
  try {
    $gamePlayer.center($gamePlayer.x, $gamePlayer.y);
    return $gameTemp.aaIsScrollBeenApplied = false;
  } catch (error) {
    e = error;
    return AA.warning(e, 'uAPI.resetCamera');
  }
};

// * LANDMINES
uAPI.setLandmine = function(index, eventId, skillId, x, y) {
  var data, e;
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  try {
    data = {
      "objectId": skillId,
      "placerId": 0,
      "timer": 0,
      "onlyTimer": 0
    };
    $gameMap.spawnLandMine(eventId, x, y, data);
    $gameMap._AALandmines.storeLastMineAs(index);
  } catch (error) {
    e = error;
    AA.warning(e, 'uAPI.setLandmine');
  }
};

uAPI.setTimerForLandmine = function(index, time, onlyTimerExplosion) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    if (time > 0) {
      if (onlyTimerExplosion === true) {
        onlyTimerExplosion = 1;
      } else {
        onlyTimerExplosion = 0;
      }
      $gameMap._AALandmines.setTimerTo(index, time, onlyTimerExplosion);
    }
  }
};

uAPI.deleteLandmine = function(index) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    return $gameMap._AALandmines.removeByIndex(index);
  }
};

uAPI.explodeLandmine = function(index) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    return $gameMap._AALandmines.explodeByIndex(index);
  }
};

uAPI.resetFogOnMap = function(mapId) {
  return $gamePlayer._resetFogOnMap(mapId);
};

uAPI.clearAllStoredChests = function() {
  $gamePlayer._aaChestStorages = {};
};

uAPI.clearStoredChestsOnMap = function(mapId) {
  if (mapId == null) {
    mapId = $gameMap.mapId();
  }
  $gamePlayer.aaClearStoredChestOnMap(mapId);
};

uAPI.addWeaponInPlayerStorage = function(id, count = 1) {
  var e;
  try {
    return uAPI._addRawItemInPlayerStorage(id, $dataWeapons, count);
  } catch (error) {
    e = error;
    return AA.warning('uAPI.addWeaponInPlayerStorage', e);
  }
};

uAPI.addItemInPlayerStorage = function(id, count = 1) {
  var e, item;
  try {
    item = $dataItems[id];
    if (item == null) {
      return;
    }
    if (item.itypeId === 1) { // * Только не ключи
      return uAPI._addRawItemInPlayerStorage(id, $dataItems, count);
    }
  } catch (error) {
    e = error;
    return AA.warning('uAPI.addItemInPlayerStorage', e);
  }
};

uAPI._addRawItemInPlayerStorage = function(id, data, count = 1) {
  var item;
  item = data[id];
  if ((item != null) && count > 0) {
    $gamePlayer.addPutItemToPlayerChest(item, count);
    if (AA.UI.isUserChestIsOpen()) {
      AA.UI.refreshUserChest();
    }
  }
};

uAPI.addArmorInPlayerStorage = function(id, count = 1) {
  var e;
  try {
    return uAPI._addRawItemInPlayerStorage(id, $dataArmors, count);
  } catch (error) {
    e = error;
    return AA.warning('uAPI.addArmorInPlayerStorage', e);
  }
};

uAPI.moveAllItemsToStorage = function() {
  var e;
  try {
    return $gameParty.moveAllItemsToAAStorage();
  } catch (error) {
    e = error;
    return AA.warning('uAPI.moveAllItemsToStorage', e);
  }
};

uAPI.moveEquipedItemsToStorage = function() {
  var e;
  try {
    return $gameParty.moveEquipedItemsToStorage();
  } catch (error) {
    e = error;
    return AA.warning('uAPI.moveEquipedItemsToStorage', e);
  }
};

uAPI.clearPlayerStorage = function() {
  var e;
  try {
    $gamePlayer.initAAPlayerChestStorage();
    if (AA.UI.isUserChestIsOpen()) {
      return AA.UI.refreshUserChest();
    }
  } catch (error) {
    e = error;
    return AA.warning('uAPI.clearPlayerStorage', e);
  }
};

uAPI.refreshWeightSystem = function() {
  var e;
  try {
    if (!AA.isPro()) {
      return;
    }
    $gameParty._refreshInventoryWAutoState();
    $gamePlayer.refreshInventoryWSpeedDebuff();
    return $gameParty.requestWeightCapacityRefresh();
  } catch (error) {
    e = error;
    return AA.warning('uAPI.refreshWeightSystem', e);
  }
};

uAPI.modifyInventoryMaxWeight = function(weight) {
  var e;
  try {
    if (value > 0) {
      $gamePlayer.modifyPlayerStaticWeight(value);
      return AA.UI.refreshInventory();
    }
  } catch (error) {
    e = error;
    return AA.warning('uAPI.modifyInventoryMaxWeight', e);
  }
};

// ? [PRIVATE]
// * CHARACTER, NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI._playAMotionForCharacter = function(...params) {
  var data, e, offset;
  if (params[0] == null) {
    return;
  }
  if (params[1] == null) {
    return;
  }
  try {
    data = new AA.LIBS.ABSMotion2();
    data.setType(AA.MotionType.Action);
    if (params[2] != null) {
      data.setFrames(params[2]);
    }
    if (params[3] != null) {
      data.setActionDelay(params[3]);
    }
    if (params[4] === true) {
      data.setWait();
    }
    offset = 0;
    if (params[5] != null) {
      offset = params[5];
    }
    data.setMotion(params[1], offset, params[0]);
    params[0].battler().performAAnimAction(data);
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while you call playAMotion with uAPI');
  }
};

Object.defineProperties(uAPI, {
  isABS: {
    get: function() {
      return AlphaABS.isABS(); // * Активирована ли ABS (мы на ABS карте?)
    }
  },
  player: {
    get: function() {
      return $gamePlayer;
    }
  },
  actor: {
    get: function() {
      return $gamePlayer.battler();
    }
  },
  party: {
    get: function() {
      return $gameParty.membersABS();
    }
  },
  pActor: {
    get: function() {
      return $gameParty.membersABS().map(function(item) {
        return item.battler();
      });
    }
  },
  actorId: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref.actorId() : void 0;
    }
  },
  pActorId: {
    get: function() {
      return uAPI.pActor.map(function(item) {
        return item.actorId();
      });
    }
  },
  isUI: {
    get: function() {
      return uAPI.isABS && AlphaABS.BattleUI.isUI() && AlphaABS.BattleUI.getUI().isVisible();
    }
  },
  hide: {
    get: function() {
      if (AlphaABS.BattleUI.isUI()) {
        return AlphaABS.BattleUI.hideUI();
      }
    }
  },
  show: {
    get: function() {
      if (AlphaABS.BattleUI.isUI()) {
        return AlphaABS.BattleUI.showUI();
      }
    }
  },
  isBattle: {
    get: function() {
      var ref;
      return (ref = uAPI.player) != null ? ref.inBattle() : void 0;
    }
  },
  hideSkills: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.hideSkillPanel() : void 0;
    }
  },
  hideControls: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.setControlPanelVisible(false) : void 0;
    }
  },
  showSkills: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.showSkillPanel() : void 0;
    }
  },
  showControls: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.setControlPanelVisible(true) : void 0;
    }
  },
  target: {
    get: function() {
      return uAPI.player.target();
    }
  },
  tActor: {
    get: function() {
      var ref;
      return (ref = uAPI.target) != null ? ref.battler() : void 0;
    }
  },
  tId: {
    get: function() {
      var ref;
      return (ref = uAPI.target) != null ? ref.eventId() : void 0;
    }
  },
  jumpOff: {
    get: function() {
      return $gamePlayer._absJumpOffByUAPI = true;
    }
  },
  jumpOn: {
    get: function() {
      return $gamePlayer._absJumpOffByUAPI = false;
    }
  },
  rotateOff: {
    get: function() {
      return $gamePlayer._absRotateOffByUAPI = true;
    }
  },
  rotateOn: {
    get: function() {
      return $gamePlayer._absRotateOffByUAPI = false;
    }
  },
  weaponsOff: {
    get: function() {
      return $gamePlayer._absWeapOffByUAPI = true;
    }
  },
  weaponsOn: {
    get: function() {
      return $gamePlayer._absWeapOffByUAPI = false;
    }
  },
  inventoryOff: {
    get: function() {
      return $gamePlayer._absInvOffByUAPI = true;
    }
  },
  inventoryOn: {
    get: function() {
      return $gamePlayer._absInvOffByUAPI = null;
    }
  },
  skillWindowOff: {
    get: function() {
      return $gamePlayer._absSWinOffByUAPI = true;
    }
  },
  skillWindowOn: {
    get: function() {
      return $gamePlayer._absSWinOffByUAPI = null;
    }
  },
  doJump: {
    get: function() {
      return $gamePlayer.touchControlAt(2);
    }
  },
  doFollow: {
    get: function() {
      return $gamePlayer.touchControlAt(1);
    }
  },
  doRotate: {
    get: function() {
      return $gamePlayer.touchControlAt(3);
    }
  },
  doChangeWeapons: {
    get: function() {
      return $gamePlayer.touchControlAt(4);
    }
  },
  doUseShield: {
    get: function() {
      return $gamePlayer.touchControlAt(5);
    }
  },
  doAttack: {
    get: function() {
      return $gamePlayer.touchControlAt(0);
    }
  },
  showSummonMenu: {
    get: function() {
      return $gamePlayer.showBehCircle();
    }
  },
  unSummonUnit: {
    get: function() {
      if (uAPI.isSummonUnitExist === true) {
        return $gamePlayer.deleteSummonUnit();
      }
    }
  },
  isJumpAllowed: {
    get: function() {
      return $gamePlayer.isJumpAllowed();
    }
  },
  isFollowAllowed: {
    get: function() {
      return $gamePlayer.isFollowAllowed();
    }
  },
  isRotateAllowed: {
    get: function() {
      return $gamePlayer.isRotateAllowed();
    }
  },
  isWeaponsAllowed: {
    get: function() {
      return $gamePlayer.isWeaponsAllowed();
    }
  },
  isCanAttack: {
    get: function() {
      return true;
    }
  },
  isCanUseShield: {
    get: function() {
      return $gamePlayer.isCanApplyShieldState() && AlphaABS.BattleUI.getUI().isVisible();
    }
  },
  isCanUseShieldNow: {
    get: function() {
      return $gamePlayer.isCanApplyShieldNow();
    }
  },
  isSummonUnitExist: {
    get: function() {
      return $gamePlayer.getSummonUnit() != null;
    }
  },
  isCanChangeSummonUnitMode: {
    get: function() {
      return $gamePlayer.isCanBehModeButtonBeVisible();
    }
  },
  isSummonWithoutMode: {
    get: function() {
      return $gamePlayer.isCanUnsummonButtonBeVisible();
    }
  },
  findNextTarget: {
    get: function() {
      return $gamePlayer.setNextTarget();
    }
  },
  findNearestTarget: {
    get: function() {
      return $gamePlayer.setNearestTarget();
    }
  },
  doReload: {
    get: function() {
      return $gamePlayer.reloadFirearm();
    }
  },
  UIClearSkills: {
    get: function() {
      var ref;
      return (ref = $gamePlayer.battler()) != null ? ref.uiPanelReset() : void 0;
    }
  },
  UISavePanelState: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref._saveUISkillPanelState() : void 0;
    }
  },
  UIRestorePanelState: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref._restoreUISkillPanelState() : void 0;
    }
  },
  refreshFog: {
    get: function() {
      return $gamePlayer._AAFOG_checkFog();
    }
  },
  encountersCount: {
    get: function() {
      return $gameMap._getAAEncounterCount();
    }
  },
  openInventory: {
    get: function() {
      return AA.UI.openInventory();
    }
  },
  closeInventory: {
    get: function() {
      return AA.UI.closeInventory();
    }
  },
  openSkillWindow: {
    get: function() {
      return AA.UI.openSkillWindow();
    }
  },
  closeSkillWindow: {
    get: function() {
      return AA.UI.closeSkillWindow();
    }
  },
  openCloseSkillWindow: {
    get: function() {
      return AA.UI.openOrCloseSkillWindow();
    }
  },
  openCloseInventory: {
    get: function() {
      return AA.UI.openOrCloseInventory();
    }
  },
  openStatusWindow: {
    get: function() {
      return AA.UI.openStatusWindow();
    }
  },
  closeStatusWindow: {
    get: function() {
      return AA.UI.closeStatusWindow();
    }
  },
  openCloseStatusWindow: {
    get: function() {
      return AA.UI.openOrCloseStatusWindow();
    }
  },
  refreshStatusWindow: {
    get: function() {
      return AA.UI.refreshStatusWindow();
    }
  },
  isInventoryAllowed: {
    get: function() {
      return $gamePlayer._absInvOffByUAPI !== true;
    }
  },
  isSkillWindowAllowed: {
    get: function() {
      return $gamePlayer._absSWinOffByUAPI !== true;
    }
  },
  showEnemyVision: {
    get: function() {
      return $gameSystem._absEVision = true;
    }
  },
  hideEnemyVision: {
    get: function() {
      return $gameSystem._absEVision = null;
    }
  },
  aliveEnemiesCount: {
    get: function() {
      return $gameTroop.onlyHostileMembersABS().length;
    }
  },
  deadEnemiesCount: {
    get: function() {
      return $gameTroop.deadMembersABS().length;
    }
  },
  inBattleEnemiesCount: {
    get: function() {
      return $gameTroop.onlyHostileMembersABSInBattle().length;
    }
  },
  stopParty: {
    get: function() {
      return $gameParty.stopABS();
    }
  },
  resumeParty: {
    get: function() {
      return $gameParty.resumeABS();
    }
  },
  maxWeight: {
    get: function() {
      return $gameParty.getMaxWeightCapacity();
    }
  },
  currentWeight: {
    get: function() {
      return $gameParty.getCurrentWeight();
    }
  },
  isOverWeight: {
    get: function() {
      return $gameParty.getCurrentWeight() > $gameParty.getMaxWeightCapacity();
    }
  }
});

(Object.freeze || Object)(uAPI);

// ■ END User API.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_Circle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_Circle;
  UI_Circle = class UI_Circle extends Sprite {
    constructor(segmentBitmap, iconSize = 36) {
      super(new Bitmap(200, 200));
      this.segmentBitmap = segmentBitmap;
      this.iconSize = iconSize;
      this._initParameters();
      this._createSegments();
      this._moveSegments(this._maxRadius());
      this._postConfigurate();
    }

    _initParameters() {
      this.anchor.x = 0.5;
      return this.anchor.y = 0.5;
    }

    _createSegments() {
      this._segments = [];
      this._icons = [];
      this._helpers = [];
      this._inputs = [];
      this._createSegment(0, 0);
      this._createSegment(1, Math.PI / 2);
      this._createSegment(2, Math.PI);
      this._createSegment(3, -Math.PI / 2);
      this._segments.forEach((function(segment) {
        return this.addChild(segment);
      }).bind(this));
      this._configurateSegmentsElements();
      this._createInputZones();
    }

    _createSegment(index, rotation = 0) {
      var helper, icon, segment;
      segment = this._createSegmentElement(rotation);
      icon = this._createIconForSegment(rotation);
      helper = this._createHelperForSegment();
      if (index === 2) { //down text upwards
        helper.rotation = -rotation;
      }
      segment.addChild(icon);
      segment.addChild(helper);
      this._segments[index] = segment;
      this._icons[index] = icon;
      this._helpers[index] = helper;
    }

    _createSegmentElement(rotation = 0) {
      var segment;
      segment = new Sprite();
      segment.bitmap = this.segmentBitmap;
      segment.anchor.x = 0.5;
      segment.anchor.y = 0.5;
      segment.rotation = rotation;
      return segment;
    }

    _createIconForSegment(rotation = 0) {
      var icon;
      icon = new Sprite(new Bitmap(this.iconSize, this.iconSize));
      icon.anchor.x = 0.5;
      icon.anchor.y = 0.5;
      icon.rotation = -rotation;
      return icon;
    }

    _createHelperForSegment() {
      var help;
      help = new Sprite(new Bitmap(this.segmentBitmap.width, this.segmentBitmap.height));
      help.anchor.x = 0.5;
      help.anchor.y = 0.5;
      return help;
    }

    _configurateSegmentsElements() {
      var dy;
      dy = -this.segmentBitmap.height;
      this._helpers.forEach(function(item) {
        return item.move(0, dy);
      });
      return this._icons.forEach(function(item) {
        return item.move(0, -5);
      });
    }

    _createInputZones() {
      var down, left, raduis, right, top;
      raduis = this._maxRadius();
      top = new Sprite_Button();
      top.bitmap = new Bitmap(this.segmentBitmap.width, this.segmentBitmap.height);
      top.moveToCenter(0, -raduis);
      this._inputs.push(top);
      right = new Sprite_Button();
      right.bitmap = new Bitmap(this.segmentBitmap.height, this.segmentBitmap.width);
      right.moveToCenter(raduis, 0);
      this._inputs.push(right);
      down = new Sprite_Button();
      down.bitmap = top.bitmap;
      down.moveToCenter(0, raduis);
      this._inputs.push(down);
      left = new Sprite_Button();
      left.bitmap = right.bitmap;
      left.moveToCenter(-raduis, 0);
      this._inputs.push(left);
      return this._inputs.forEach((function(item) {
        return this.addChild(item);
      }).bind(this));
    }

    _moveSegments(radius) {
      if (radius == null) {
        radius = this._maxRadius();
      }
      this._segments[0].move(0, -radius); //TOP
      this._segments[2].move(0, radius); //DOWN
      this._segments[3].move(-radius, 0); //LEFT
      return this._segments[1].move(radius, 0); //RIGHT
    }

    _maxRadius() {
      return Math.floor(this.segmentBitmap.height / 4 + this.segmentBitmap.width / 2);
    }

    _minRadius() {
      return Math.floor(this.segmentBitmap.width / 2);
    }

    _postConfigurate() {} //EMPTY

  };
  if (window.KDCore !== void 0) {
    KDCore.register(UI_Circle);
  }
})();

// ■ END UI_Circle.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_Gauge.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
(function () {

  function UI_Gauge() {
    this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_Gauge);

  UI_Gauge.prototype = Object.create(Sprite.prototype);
  UI_Gauge.prototype.constructor = UI_Gauge;

  UI_Gauge.prototype.initialize = function (width, height) {
    Sprite.prototype.initialize.call(this, new Bitmap(width || 1, height || 1));
    this.reset();
  };

  UI_Gauge.prototype.reset = function () {
    this._backgroundColor = '#000000';
    this._startColor = '#FFFFFF';
    this._endColor = '#FFFFFF';
    this._currentValue = 0;
    this._maxValue = 0;
    this._centerText = null;
    this._leftText = null;
    this._rightText = null;
    this._gaugeWidth = 0;
    this._lastValue = -1;
  };

  UI_Gauge.prototype.applyGeneratedGradient = function () {
    if (window.KDCore === undefined) return;
    var color = KDCore.Color.FromHex(this._startColor);
    this._endColor = color.getLightestColor(230).CSS;
  };

  UI_Gauge.prototype.setFont = function (fontName) {
    this.bitmap.fontFace = fontName;
  };

  UI_Gauge.prototype.setMaxValue = function (value) {
    this._maxValue = value;
    this._updateGaugeWidth();
  };

  UI_Gauge.prototype._updateGaugeWidth = function () {
    if (this._maxValue > 0 && this._currentValue < this._maxValue)
      this._gaugeWidth = Math.floor(
        (100 * this._currentValue / this._maxValue) * ((this.bitmap.width - 2) / 100));
    else
      this._gaugeWidth = this.bitmap.width - 2;
  };

  UI_Gauge.prototype.setValue = function (value) {
    this._currentValue = value;
    this._updateGaugeWidth();
  };

  UI_Gauge.prototype.setGaugeColors = function (startHexColor, endHexColor) {
    this._startColor = startHexColor;
    this._endColor = endHexColor || this._startColor;
  };

  UI_Gauge.prototype.setBackgroundColor = function (hexColor) {
    this._backgroundColor = hexColor;
  };

  UI_Gauge.prototype.setCenterText = function (text, color) {
    this._centerText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype._makeTextData = function (textValue, colorValue) {
    return {
      text: textValue || '',
      color: colorValue || '#FFFFFF'
    };
  };

  UI_Gauge.prototype.setRightText = function (text, color) {
    this._rightText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype.setLeftText = function (text, color) {
    this._leftText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype.update = function () {
    Sprite.prototype.update.call(this);
    this._updateValues();
    if (this._isValueChanged()) {
      this.refresh();
    }
  };

  UI_Gauge.prototype._updateValues = function () {
    //EMPTY
  };

  UI_Gauge.prototype._isValueChanged = function () {
    return (this._currentValue != this._lastValue);
  };

  UI_Gauge.prototype.refresh = function () {
    this._lastValue = this._currentValue;
    this._drawAll();
  };

  UI_Gauge.prototype._drawAll = function () {
    this._drawBackground();
    this._drawGaugeLine();
    this._drawTexts();
  };

  UI_Gauge.prototype._drawBackground = function () {
    this.bitmap.fillRect(0, 0, this.bitmap.width, this.bitmap.height, this._backgroundColor);
  };

  UI_Gauge.prototype._drawGaugeLine = function () {
    this.bitmap.gradientFillRect(1, 1, this._gaugeWidth, this.bitmap.height - 2,
      this._startColor,
      this._endColor,
      false);

  };

  UI_Gauge.prototype._drawTexts = function () {
    this._setTextFontSize();
    this._drawText(this._leftText, 'left');
    this._drawText(this._centerText, 'center');
    this._drawText(this._rightText, 'right');
  };

  UI_Gauge.prototype._setTextFontSize = function () {
    this.bitmap.fontSize = this.bitmap.height - 4;
  };

  UI_Gauge.prototype._drawText = function (textData, position) {
    if (textData && textData.text != '') {
      var prevtextColor = this.bitmap.textColor;
      this.bitmap.textColor = textData.color;
      this.bitmap.drawText(textData.text, 4, 0, this.bitmap.width - 8, this.bitmap.height, position);
      this.bitmap.textColor = prevtextColor;
    }
  };

})();

//■ END UI_Gauge
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SelectCircle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Color, SDK, UI_Circle, UI_SelectCircle;
  UI_Circle = KDCore.LIBS.UI_Circle;
  Color = KDCore.Color;
  SDK = KDCore.SDK;
  UI_SelectCircle = (function() {
    class UI_SelectCircle extends UI_Circle {
      constructor(segmentBitmap, isOpen = true, iconSize = 36) {
        super(segmentBitmap, iconSize);
        this._isOpen = isOpen;
        if (!this._isOpen) {
          this.opacity = 0;
        }
      }

      _initParameters() {
        UI_Circle.prototype._initParameters.call(this);
        this._clickedSegmentIndex = null;
        this._selectedSegmentIndex = null;
        this._isHelperVisible = false;
        this._isAnimated = false;
        this._clickTimer = new Game_TimerABS();
        this._newRadius = this._maxRadius();
        return this._disabledIndexes = [];
      }

      isOpen() {
        return this._isOpen === true;
      }

      isClicked() {
        return this._clickedSegmentIndex !== null;
      }

      isSelected() {
        return this._selectedSegmentIndex !== null;
      }

      isAnimated() {
        return this._isAnimated === true;
      }

      isHelpersVisible() {
        return this._isHelperVisible === true;
      }

      isOpenning() {
        return (this.isAnimated() && !this.isOpen()) || this.isOpen();
      }

      showHelpers() {
        return this._isHelperVisible = true;
      }

      hideHelpers() {
        return this._isHelperVisible = false;
      }

      select(index) {
        this.deselectAll();
        this._segments[index].setBlendColor(UI_SelectCircle.COLOR_SELECT.ARR);
        return this._selectedSegmentIndex = index;
      }

      deselectAll() {
        this._selectedSegmentIndex = null;
        return this._resetSegmentsColors();
      }

      _resetSegmentsColors() {
        var index, j, len, ref, results, segment;
        ref = this._segments;
        results = [];
        for (index = j = 0, len = ref.length; j < len; index = ++j) {
          segment = ref[index];
          if (!this._disabledIndexes.includes(index)) {
            results.push(this._resetSegmentColor(segment));
          }
        }
        return results;
      }

      _resetSegmentColor(segment) {
        return segment.setBlendColor(Color.NONE.ARR);
      }

      click(index) {
        this.deselectAll();
        this._clickTimer.start(UI_SelectCircle.CLICK_TIME);
        this._clickedSegmentIndex = index;
        return this._segments[index].setBlendColor(UI_SelectCircle.COLOR_CLICK.ARR);
      }

      update() {
        UI_Circle.prototype.update.call(this);
        if (this.isClicked()) {
          this._updateClick();
        }
        this._updateHelpers();
        return this._updateAnimation();
      }

      _updateClick() {
        this._clickTimer.update();
        if (this._clickTimer.isReady()) {
          this._resetSegmentsColors();
          return this._clickedSegmentIndex = null;
        }
      }

      _updateHelpers() {
        if (!this.isAnimated() && this.isOpen() && this.isHelpersVisible()) {
          return this._showHelpers();
        } else {
          return this._hideHelpers();
        }
      }

      _hideHelpers() {
        return this._helpers.forEach(function(item) {
          return item.visible = false;
        });
      }

      _showHelpers() {
        return this._helpers.forEach(function(item) {
          return item.visible = true;
        });
      }

      _updateAnimation() {
        if (!this.isAnimated()) {
          return;
        }
        this._moveSegments(this._newRadius);
        if (this.isOpen()) {
          return this._closeCircle();
        } else {
          return this._openCircle();
        }
      }

      _closeCircle() {
        var minRadius;
        minRadius = this._minRadius();
        if (this.opacity > 30) {
          this.opacity -= 30;
        }
        if (this._newRadius > minRadius) {
          this._newRadius -= 2;
        }
        if (this._newRadius <= minRadius) {
          this._isOpen = false;
          this._isAnimated = false;
          return this.opacity = 0;
        }
      }

      _openCircle() {
        var maxRadius;
        maxRadius = this._maxRadius();
        if (this.opacity <= 225) {
          this.opacity += 30;
        }
        if (this._newRadius < maxRadius) {
          this._newRadius += 2;
        }
        if (this._newRadius >= maxRadius) {
          this._isOpen = true;
          this._isAnimated = false;
          return this.opacity = 255;
        }
      }

      hideAllSegments() {
        return SDK.times(4, (function(i) {
          this.hideSegment(i);
        }).bind(this));
      }

      hideSegment(index) {
        return this._segments[index].visible = false;
      }

      showAllSegments() {
        return SDK.times(4, (function(i) {
          this.showSegment(i);
        }).bind(this));
      }

      showSegment(index) {
        return this._segments[index].visible = true;
      }

      disableAllSegments() {
        return SDK.times(4, (function(i) {
          this.disableSegment(i);
        }).bind(this));
      }

      disableSegment(index) {
        this._segments[index].setBlendColor(UI_SelectCircle.COLOR_DISABLED.ARR);
        this._icons[index].setBlendColor(UI_SelectCircle.COLOR_DISABLED.ARR);
        return this._disabledIndexes.push(index);
      }

      enableAllSegments() {
        return SDK.times(4, (function(i) {
          this.enableSegment(i);
        }).bind(this));
      }

      enableSegment(index) {
        this._disabledIndexes.delete(index);
        this._resetSegmentColor(this._segments[index]);
        return this._resetIconColor(this._icons[index]);
      }

      _resetIconColor(icon) {
        return icon.setBlendColor(Color.NONE.ARR);
      }

      resetAllSegments() {
        this.showAllSegments();
        this.deselectAll();
        return this.enableAllSegments();
      }

      addClickListener(index, method) {
        return this._inputs[index].setClickHandler(method);
      }

      setIcons(iconsArray) {
        return iconsArray.forEach(this.setIcon.bind(this));
      }

      setIcon(icon, index) {
        return this._drawIcon(icon, index);
      }

      _drawIcon(icon, index) {
        this._icons[index].bitmap.clear();
        if (icon instanceof Bitmap) {
          return this._icons[index].bitmap.drawOnMe(icon, 0, 0, this.iconSize, this.iconSize);
        } else {
          return this._icons[index].bitmap.drawIcon(0, 0, icon, this.iconSize);
        }
      }

      setHelpers(textArray) {
        return textArray.forEach(this.setHelper.bind(this));
      }

      setHelper(text, index) {
        return this._drawHelperText(text, index);
      }

      _drawHelperText(text, index) {
        var helper;
        helper = this._helpers[index].bitmap;
        helper.clear();
        return helper.drawText(text, 0, 0, helper.width, helper.height, 'center');
      }

      open() {
        if (this.isOpen()) {
          return;
        }
        return this._changeOpenClose(0, this._minRadius());
      }

      _changeOpenClose(beginOpacity, newRadius) {
        if (this.isAnimated()) {
          return;
        }
        this._newRadius = newRadius;
        return this._isAnimated = true;
      }

      close() {
        if (!this.isOpen()) {
          return;
        }
        return this._changeOpenClose(255, this._maxRadius());
      }

      _setOpacity(opacity) {
        var icon, j, len, ref, results;
        this.opacity = opacity;
        ref = this._icons;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          icon = ref[j];
          results.push(icon.opacity = opacity);
        }
        return results;
      }

    };

    UI_SelectCircle.COLOR_CLICK = new Color(98, 225, 236, 220);

    UI_SelectCircle.COLOR_SELECT = new Color(164, 255, 164, 220);

    UI_SelectCircle.COLOR_DISABLED = new Color(89, 89, 89, 120);

    UI_SelectCircle.CLICK_TIME = 5;

    return UI_SelectCircle;

  }).call(this);
  AlphaABS.register(UI_SelectCircle);
})();

// ■ END UI_SelectCircle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SelectCircleFW.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_SelectCircleFW;
  UI_SelectCircleFW = class UI_SelectCircleFW extends AlphaABS.LIBS.UI_SelectCircle {
    constructor(battler, callHandler) {
      super(ImageManager.loadAA("Circle_segment"), false, 24);
      this.battler = battler;
      this.callHandler = callHandler;
      this.refresh();
      this._setHelpers();
      this.addClickListener(0, (function() {
        return this.callHandler(0);
      }).bind(this));
      this.addClickListener(1, (function() {
        return this.callHandler(1);
      }).bind(this));
      this.addClickListener(2, (function() {
        return this.callHandler(2);
      }).bind(this));
      this.addClickListener(3, (function() {
        return this.callHandler(3);
      }).bind(this));
    }

    refresh() {
      var index;
      this.setIcons(this.battler.getFavWeapIcons());
      index = 0;
      this.enableAllSegments();
      if (!this.battler._firstBattleABSSkill().isReady()) {
        this.disableAllSegments();
        return;
      }
      this.battler.ABSParams().favoriteWeapons.forEach((function(i) {
        var weap;
        if (i != null) {
          weap = $dataWeapons[i];
          if (!$gameParty.hasItem(weap, true)) {
            this.disableSegment(index);
          }
          if (this.battler.hasWeapon(weap)) {
            this.disableSegment(index);
          }
        }
        return index++;
      }).bind(this));
    }

    _setHelpers() {
      var x;
      x = AlphaABS.LIBS.IKey;
      this.setHelper(x.convertIKeyToLetter(x.SC_W()).toUpperCase(), 0);
      this.setHelper(x.convertIKeyToLetter(x.SC_D()).toUpperCase(), 1);
      this.setHelper(x.convertIKeyToLetter(x.SC_S()).toUpperCase(), 2);
      return this.setHelper(x.convertIKeyToLetter(x.SC_A()).toUpperCase(), 3);
    }

    isTouchedAny() {
      if (this.visible === true) {
        return this._inputs.some(function(i) {
          return i.isButtonTouched();
        });
      } else {
        return false;
      }
    }

  };
  AlphaABS.register(UI_SelectCircleFW);
})();

// ■ END UI_SelectCircleFW.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SummonCircle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_SummonCircle;
  UI_SummonCircle = class UI_SummonCircle extends AlphaABS.LIBS.UI_SelectCircle {
    constructor(callHandler) {
      var icons;
      super(ImageManager.loadAA("Circle_segment"), false, 24);
      this.callHandler = callHandler;
      this.refresh();
      this._setHelpers();
      this.addClickListener(0, (function() {
        return this.callHandler(0);
      }).bind(this));
      this.addClickListener(1, (function() {
        return this.callHandler(1);
      }).bind(this));
      this.addClickListener(2, (function() {
        return this.callHandler(2);
      }).bind(this));
      this.addClickListener(3, (function() {
        return this.callHandler(3);
      }).bind(this));
      icons = [ImageManager.loadAA("SummonDelete"), ImageManager.loadAA("SummonBeh_AttackAll"), ImageManager.loadAA("SummonBeh_AttackTarget"), ImageManager.loadAA("SummonBeh_Protect")];
      AA.setTimeout((() => {
        return this.setIcons(icons);
      }), 500);
    }

    refresh() {
      var behIndex, index, summon;
      index = 0;
      this.deselectAll();
      summon = $gamePlayer.getSummonUnit();
      if (summon != null) {
        behIndex = summon._bahMode;
        this.select(behIndex + 1);
      }
    }

    _setHelpers() {
      var x;
      x = AlphaABS.LIBS.IKey;
      this.setHelper(x.convertIKeyToLetter(x.SC_W()).toUpperCase(), 0);
      this.setHelper(x.convertIKeyToLetter(x.SC_D()).toUpperCase(), 1);
      this.setHelper(x.convertIKeyToLetter(x.SC_S()).toUpperCase(), 2);
      return this.setHelper(x.convertIKeyToLetter(x.SC_A()).toUpperCase(), 3);
    }

    isTouchedAny() {
      if (this.visible === true) {
        return this._inputs.some(function(i) {
          return i.isButtonTouched();
        });
      } else {
        return false;
      }
    }

  };
  AlphaABS.register(UI_SummonCircle);
})();

// ■ END UI_SummonCircle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ValueSwing.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ValueSwing;
  ValueSwing = class ValueSwing {
    constructor(swingObject, fieldName, time) {
      this.swingObject = swingObject;
      this.fieldName = fieldName;
      this.mode = 1;
      this._repeat = false;
      this._ready = false;
      this._started = false;
      this._config = {
        start: this.getValue(),
        step: this.getValue() / time
      };
      this._refreshConfig();
    }

    getValue() {
      return this.swingObject[this.fieldName];
    }

    _refreshConfig() {
      if (this.isIncrement()) {
        this._config.toValue = this._config.start;
        this._config.fromValue = 0;
      } else {
        this._config.toValue = 0;
        this._config.fromValue = this._config.start;
      }
      return this.setValue(this._config.fromValue);
    }

    isIncrement() {
      return this.mode === 0;
    }

    setValue(value) {
      return this.swingObject[this.fieldName] = value;
    }

    start() {
      this._ready = false;
      return this._started = true;
    }

    reset() {
      this._ready = true;
      return this.setValue(this._config.start);
    }

    stop() {
      return this._started = false;
    }

    isStarted() {
      return this._started === true;
    }

    isReady() {
      return this._ready === true;
    }

    setIncrementMode() {
      this.mode = 0;
      this.stop();
      return this._refreshConfig();
    }

    setDecrementMode() {
      this.mode = 1;
      this.stop();
      return this._refreshConfig();
    }

    setRepeat() {
      return this._repeat = true;
    }

    update() {
      if (!this.isStarted()) {
        return;
      }
      if (this.isIncrement()) {
        this._updateIncr();
      } else {
        this._updateDecr();
      }
      if (this.isReady() && this._repeat === true) {
        return this._changeMode();
      }
    }

    _updateIncr() {
      var v;
      if (this.isReady()) {
        return;
      }
      v = this.getValue();
      if (v < this._config.toValue - this._config.step) {
        return this.setValue(v + this._config.step);
      } else {
        return this._swingDone();
      }
    }

    _swingDone() {
      this.setValue(this._config.toValue);
      return this._ready = true;
    }

    _updateDecr() {
      var v;
      if (this.isReady()) {
        return;
      }
      v = this.getValue();
      if (v > this._config.toValue + this._config.step) {
        return this.setValue(v - this._config.step);
      } else {
        return this._swingDone();
      }
    }

    _changeMode() {
      if (this.isIncrement()) {
        this.setDecrementMode();
      } else {
        this.setIncrementMode();
      }
      return this.start();
    }

  };
  AA.register(ValueSwing);
})();

// ■ END ValueSwing.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
AlphaABS.getVersionInfo = function() {
  if (KDCore.isMV()) {
    return "Build " + AlphaABS.Build + " [PRO] on MV " + Utils.RPGMAKER_VERSION;
  } else {
    return "Build " + AlphaABS.Build + " [PRO] on MZ " + Utils.RPGMAKER_VERSION;
  }
};

AlphaABS.isPro = function() {
  return true;
};

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_AADBEnemiesSelectWindow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var Window_AADBEnemiesSelectWindow;

Window_AADBEnemiesSelectWindow = class Window_AADBEnemiesSelectWindow extends Window_Selectable {
  constructor() {
    super(20, 60, 400, 520);
    this._createExtraEnemyInfo();
    this._euiPortraits = [];
    this.prepareData();
    this.refresh();
  }

  maxItems() {
    if (this.enemies != null) {
      return this.enemies.length;
    }
    return 0;
  }

  itemHeight() {
    return 80;
  }

  isEnable(index) {
    var e;
    e = this.getItemData(index);
    if (e.meta.outer === true) {
      return false;
    }
    return true;
  }

  isCurrentItemEnabled() {
    return this.isEnable(this.index());
  }

  drawItem(index) {
    var e, rect;
    rect = this.itemRect(index);
    e = this.getItemData(index);
    this.changePaintOpacity(this.isEnable(index));
    this._drawEnemyName(e, rect.x, rect.y);
    this._drawEnemyEUI(e, rect, index);
    if (!this.isEnable(index)) {
      this._drawEnemyOuterWarning(rect);
    }
    this._drawEnemyHaveBeenModified(rect, e.id);
    if (index !== 0) {
      return this._drawLineRect(rect.x, rect.y, rect.width, rect.hight);
    }
  }

  select(index) {
    super.select(index);
    return this._drawExtraEnemyInfo(index);
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Window_AADBEnemiesSelectWindow.prototype;
  _.selectedEnemy = function() {
    return this.getItemData(this.index());
  };
  _.prepareData = function() {
    return this.enemies = $dataEnemies.filter(function(i) {
      return (i != null) && i.name !== "";
    });
  };
  _.getItemData = function(index) {
    return this.enemies[index];
  };
  _._drawEnemyName = function(enemyData, x, y) {
    this.drawText(enemyData.name, x + 80, y + 20);
    this.changeTextColor(this.crisisColor());
    this.makeFontSmaller();
    this.makeFontSmaller();
    this.drawText("ID: " + enemyData.id, x, y, this.width - this.textWidth('000000'), 'right');
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _._drawLineRect = function(x, y, w, h) {
    var c;
    c = KDCore.Color.BLACK.reAlpha(60).CSS;
    return this.contents.fillRect(x, y, w, 1, c);
  };
  _._drawEnemyEUI = function(e, rect, index) {
    var faceIndex, faceName, values;
    if (this._euiPortraits[index] != null) {
      this._euiPortraits[index].visible = false;
      this._euiPortraits[index].removeFromParent();
      this._euiPortraits[index] = null;
    }
    values = this._getEnemyFaceNameAndIndex(e);
    faceName = values[0];
    faceIndex = values[1];
    this._euiPortraits[index] = new AA.LIBS.SpriteActorPortrait(1, {faceName, faceIndex});
    //@_euiPortraits[index].anchor.y = 0.5
    this._euiPortraits[index].move(rect.x + 30, rect.y + 30);
    return this.addChild(this._euiPortraits[index]);
  };
  _._drawEnemyOuterWarning = function(rect) {
    this.changeTextColor(this.deathColor());
    this.makeFontSmaller();
    this.drawText("<outer>", rect.x, rect.y + 24, rect.width - this.textWidth('0000'), 'right');
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _._drawEnemyHaveBeenModified = function(rect, enemyId) {
    if ($gameTemp._aaDBmodifiedEnemies == null) {
      return;
    }
    if (!$gameTemp._aaDBmodifiedEnemies.contains(enemyId)) {
      return;
    }
    this.changeTextColor(this.mpGaugeColor1());
    this.makeFontSmaller();
    this.drawText("<modified>", rect.x, rect.y + 24, rect.width - this.textWidth('0000'), 'right');
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _._createExtraEnemyInfo = function() {
    this._infoBase = new Sprite();
    this._infoBase.move(this.width + 50, 0);
    this._infoInfoBattler = AASprite.FromBitmap(280, 360);
    this._infoBase.addChild(this._infoInfoBattler);
    this._infoEnemyPortrait = AASprite.FromBitmap(120, 120);
    this._infoEnemyPortrait.anchor.x = 0.5;
    this._infoEnemyPortrait.move(140, 364);
    this._infoBase.addChild(this._infoEnemyPortrait);
    this._infoOuterWarning = AASprite.FromBitmap(340, 50);
    //@_infoOuterWarning.fillAll KDCore.Color.RED.reAlpha(200).CSS
    this._infoOuterWarning.move(this.width + 20, this.height - 40);
    this._infoOuterWarning.bitmap.textColor = KDCore.Color.RED.CSS;
    this._infoOuterWarning.bitmap.drawTextFull('This Enemy uses <outer> settings', 'center');
    this._infoOuterWarning.visible = false;
    this.addChild(this._infoOuterWarning);
    return this.addChild(this._infoBase);
  };
  _._drawExtraEnemyInfo = function(index) {
    var e;
    if (index < 0) {
      return;
    }
    e = this.getItemData(index);
    if (e != null) {
      this._infoOuterWarning.visible = !this.isEnable(index);
      return this._drawEnemyBattler(e);
    } else {
      //@_drawEnemyPortrait(e)
      return this._clearExtraEnemyInfo();
    }
  };
  _._clearExtraEnemyInfo = function() {};
  _._drawEnemyBattler = function(e) {
    var pic;
    this._infoInfoBattler.bitmap.clear();
    this._infoInfoBattler.fillAll(KDCore.Color.BLACK.reAlpha(200).CSS);
    if ((e.battlerName != null) && e.battlerName !== "") {
      pic = ImageManager.loadEnemy(e.battlerName, e.battlerHue);
      if (pic.isReady()) {
        this._drawEnemyBattlerProperly(pic);
      } else {
        pic.addLoadListener((m) => {
          return this._drawEnemyBattlerProperly(pic);
        });
      }
    }
  };
  _._drawEnemyBattlerProperly = function(source) {
    var b, cx, cy;
    b = this._infoInfoBattler.bitmap;
    if (source.width < b.width && source.height < b.height) {
      cx = (b.width / 2) - source.width / 2;
      cy = (b.height / 2) - source.height / 2;
      return b.drawOnMe(source, cx, cy, source.width, source.height);
    } else {
      cx = (b.width / 2) - b.width / 2;
      cy = (b.height / 2) - b.height / 2;
      return b.drawOnMe(source, cx, cy, b.width, b.height);
    }
  };
  _._drawEnemyPortrait = function(e) {
    var faceIndex, faceName, values;
    this._infoEnemyPortrait.bitmap.clear();
    this._infoEnemyPortrait.fillAll(KDCore.Color.BLACK.reAlpha(200).CSS);
    values = this._getEnemyFaceNameAndIndex(e);
    faceName = values[0];
    faceIndex = values[1];
    if ((faceName != null) && faceName !== "") {
      return this._drawEnemyFace(faceName, faceIndex);
    }
  };
  _._getEnemyFaceNameAndIndex = function(e) {
    var faceIndex, faceName, id, params;
    faceName = "";
    faceIndex = 0;
    if (e.meta.faceName != null) {
      faceName = e.meta.faceName;
      if (e.meta.faceIndex != null) {
        faceIndex = e.meta.faceIndex;
      }
    } else if (e.meta.outer != null) {
      id = AA.Utils.getNumberFromMeta('outer', e);
      if (id === 0) {
        id = e.id;
      }
      params = AAJsonSettings.getEnemyParameters(id);
      if ((params != null) && (params.faceName != null)) {
        faceName = params.faceName;
        if (params.faceIndex != null) {
          faceIndex = params.faceIndex;
        }
      }
    }
    return [faceName, faceIndex];
  };
  _._drawEnemyFace = function(faceName, faceIndex) {
    var tBitmap;
    tBitmap = ImageManager.loadFace(faceName);
    return tBitmap.addLoadListener(() => {
      var ph, pw, sx, sy;
      pw = Window_Base._faceWidth;
      ph = Window_Base._faceHeight;
      sx = faceIndex % 4 * pw;
      sy = Math.floor(faceIndex / 4) * ph;
      return this._infoEnemyPortrait.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this._infoEnemyPortrait.width, this._infoEnemyPortrait.height);
    });
  };
})();

// ■ END Window_AADBEnemiesSelectWindow.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_AADBEnemyEditABSWindow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var Window_AADBEnemyEditABSWindow;

Window_AADBEnemyEditABSWindow = class Window_AADBEnemyEditABSWindow extends Window_Selectable {
  constructor() {
    super(20, 90, 760, 500);
    this._wikiButtons = [];
    this._resetButtons = [];
    this._mainContentSwitches = [];
    this._createExtraEnemyInfo();
  }

  itemHeight() {
    return 110;
  }

  maxItems() {
    return AIBehavModel.PARAMS.length;
  }

  isCurrentItemEnabled() {
    return this.isEnable(this.index());
  }

  isEnable(index) {
    var item;
    item = this.getItemData(index);
    return this.getParamTypeIndex(item) >= 0;
  }

  drawItem(index) {
    var isEnabled, item, rect;
    rect = this.itemRect(index);
    item = this.getItemData(index);
    isEnabled = this.isEnable(index);
    this.changePaintOpacity(isEnabled);
    this._drawParamName(item, rect);
    this._drawParamContent(item, rect, index);
    if (index !== 0) {
      return Window_AADBEnemiesSelectWindow.prototype._drawLineRect.call(this, rect.x, rect.y, rect.width, rect.hight);
    }
  }

  clearItem(index) {
    super.clearItem();
    return this._clearItemButtons(index);
  }

  select(index) {
    super.select(index);
    return this._onParamSelected(index);
  }

  refresh() {
    super.refresh();
    return this.drawEnemyFace();
  }

  drawAllItems() {
    var i, j, ref;
    for (i = j = 0, ref = this.maxItems(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this._clearItemButtons(i);
    }
    super.drawAllItems();
    return this._activateCurrentParamButtons(this.index());
  }

  update() {
    super.update();
    return this._updateKeyboardInput();
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Window_AADBEnemyEditABSWindow.prototype;
  _._onParamSelected = function(index) {
    this._deactivateAllButtons();
    return this._activateCurrentParamButtons(index);
  };
  _.getItemData = function(index) {
    var item;
    item = AIBehavModel.PARAMS[index];
    return item;
  };
  _.setEnemyToEdit = function(enemy) {
    this.enemy = enemy;
    console.info(this.enemy);
    this.drawEditedEnemyName();
    this.drawEnemyFace();
    return this.refresh();
  };
  _._createExtraEnemyInfo = function() {
    this._enemyName = AASprite.FromBitmap(300, 40);
    //@_enemyName.fillAll KDCore.Color.RED.reAlpha(200).CSS
    this._enemyName.x = 230;
    this._enemyName.y = -40;
    return this.addChild(this._enemyName);
  };
  _.drawEditedEnemyName = function() {
    this._enemyName.bitmap.clear();
    this._enemyName.bitmap.textColor = KDCore.Color.GREEN.CSS;
    return this._enemyName.bitmap.drawTextFull(this.enemy.name, 'center');
  };
  _.drawEnemyFace = function() {
    var faceIndex, faceName, values;
    if (this._enemyFace != null) {
      this._enemyFace.removeFromParent();
      this._enemyFace = null;
    }
    values = Window_AADBEnemiesSelectWindow.prototype._getEnemyFaceNameAndIndex.call(this, this.enemy);
    faceName = values[0];
    faceIndex = values[1];
    this._enemyFace = new AA.LIBS.SpriteActorPortrait(1, {faceName, faceIndex});
    this._enemyFace.move(this.width - 70, -70);
    return this.addChild(this._enemyFace);
  };
  _._drawParamName = function(param, rect) {
    var paramTitle;
    paramTitle = this._convertParam(param, this.getParamTypeIndex(param));
    return this.drawText(paramTitle, rect.x + 4, rect.y + 4);
  };
  _._convertParam = function(param, typeIndex) {
    return AADBEditorManager.convertParam(param, typeIndex);
  };
  _.getParamTypeIndex = function(param) {
    return AADBEditorManager.getParamTypeIndex(param);
  };
  _._drawParamContent = function(param, rect, index) {
    this.drawParamDescription(param, rect);
    this.createWikiButtonForParam(param, rect, index);
    if (this.isEnable(index)) {
      this.createResetButtonForParam(param, rect, index);
      return this.createMainSwitchForParam(param, rect, index);
    } else {
      return this.drawNotSupportedOrImplemented(param, rect);
    }
  };
  _.drawParamDescription = function(param, rect) {
    var descriptions;
    descriptions = this.getParameterDescription(param);
    this.makeFontSmaller();
    this.makeFontSmaller();
    this.changeTextColor(this.crisisColor());
    this.drawText(descriptions[0], rect.x + 8, rect.y + 38);
    if (descriptions[1] != null) {
      this.drawText(descriptions[1], rect.x + 8, rect.y + 64);
    }
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _.drawNotSupportedOrImplemented = function(param, rect) {
    var text;
    text = AADBEditorManager.getNotSupportedOrImplementedMessage(param);
    this.makeFontSmaller();
    this.makeFontSmaller();
    this.changeTextColor(this.deathColor());
    this.drawText(text, rect.x + 8, rect.y + 64);
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _.getParameterDescription = function(param) {
    return AADBEditorManager.getParameterDescription(param);
  };
  _.createWikiButtonForParam = function(param, rect, index) {
    var b, img0, img1, img3, wikiLink;
    this._clearWikiButtonForIndex(index);
    wikiLink = this.getParameterWiki(param);
    if (wikiLink == null) {
      return;
    }
    b = new KDCore.Button();
    img0 = ImageManager.loadAA('DBEditor/Wiki_00');
    img1 = ImageManager.loadAA('DBEditor/Wiki_01');
    img3 = ImageManager.loadAA('DBEditor/Wiki_03');
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 92, rect.y + 20);
    //b.setHelpText 'Wiki', 20
    //b.setTextPosition 1
    b.addClickHandler(function() {
      var e;
      try {
        if (Utils.isNwjs()) {
          return require('nw.gui').Shell.openExternal(wikiLink);
        }
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    });
    b.disable();
    this._wikiButtons[index] = b;
    return this.addChild(b);
  };
  _._clearWikiButtonForIndex = function(index) {
    if (this._wikiButtons == null) {
      return;
    }
    if (this._wikiButtons[index] != null) {
      this._wikiButtons[index].removeFromParent();
      this._wikiButtons[index].visible = false;
      this._wikiButtons[index] = null;
    }
  };
  _.getParameterWiki = function(param) {
    return AADBEditorManager.getParameterWiki(param);
  };
  _._deactivateAllButtons = function() {
    var b, innerItem, item, j, k, l, len, len1, len2, len3, m, ref, ref1, ref2;
    if (this._wikiButtons != null) {
      ref = this._wikiButtons;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b != null) {
          b.disable();
        }
      }
    }
    if (this._resetButtons != null) {
      ref1 = this._resetButtons;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        b = ref1[k];
        if (b != null) {
          b.disable();
        }
      }
    }
    if (this._mainContentSwitches != null) {
      ref2 = this._mainContentSwitches;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        item = ref2[l];
        if (item != null) {
          for (m = 0, len3 = item.length; m < len3; m++) {
            innerItem = item[m];
            if (innerItem != null) {
              innerItem.disable();
            }
          }
        }
      }
    }
  };
  _._activateCurrentParamButtons = function(index) {
    var innerItem, j, len, ref, ref1, ref2;
    if (this._wikiButtons != null) {
      if ((ref = this._wikiButtons[index]) != null) {
        ref.enable();
      }
    }
    if (this._resetButtons != null) {
      if ((ref1 = this._resetButtons[index]) != null) {
        ref1.enable();
      }
    }
    if ((this._mainContentSwitches != null) && (this._mainContentSwitches[index] != null)) {
      ref2 = this._mainContentSwitches[index];
      for (j = 0, len = ref2.length; j < len; j++) {
        innerItem = ref2[j];
        if (innerItem != null) {
          innerItem.enable();
        }
      }
    }
  };
  _._clearItemButtons = function(index) {
    this._clearWikiButtonForIndex(index);
    this._clearResetButtonForIndex(index);
    return this._clearMainContentForIndex(index);
  };
  _.createResetButtonForParam = function(param, rect, index) {
    var b, img0, img1, img3;
    this._clearResetButtonForIndex(index);
    b = new KDCore.Button();
    img0 = ImageManager.loadAA('DBEditor/Default_00');
    img1 = ImageManager.loadAA('DBEditor/Default_01');
    img3 = ImageManager.loadAA('DBEditor/Default_03');
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 22, rect.y + 22);
    b.setHelpText('Reset', 16);
    b.setTextPosition(1);
    b.addClickHandler(function() {
      return AADBEditorManager.onResetParamValue(param);
    });
    b.disable();
    this._resetButtons[index] = b;
    return this.addChild(b);
  };
  _._clearResetButtonForIndex = function(index) {
    if (this._resetButtons == null) {
      return;
    }
    if (this._resetButtons[index] != null) {
      this._resetButtons[index].removeFromParent();
      this._resetButtons[index].visible = false;
      this._resetButtons[index] = null;
    }
  };
  _.createMainSwitchForParam = function(param, rect, index) {
    var type;
    type = this.getParamTypeIndex(param);
    switch (type) {
      case 0:
        return this._createNumberInputForParam(param, rect, index);
      case 1:
        return this._createBooleanInputForParam(param, rect, index);
      case 2:
        return this._createChoiceInputForParam(param, rect, index);
    }
  };
  // * NOTHING
  _._createNumberInputForParam = function(param, rect, index) {
    var value;
    value = this.getCurrentValueForParam(param);
    this._clearMainContentForIndex(index);
    this._createLeftArrow(param, rect, index);
    this._createRightArrow(param, rect, index);
    this._createValueText(param, rect, index);
    return this._createValueTypeText(param, rect, index);
  };
  _._createLeftArrow = function(param, rect, index) {
    var b, img0, img1, img3;
    b = new KDCore.Button();
    img0 = ImageManager.loadAA('DBEditor/ArrowL_00');
    img1 = ImageManager.loadAA('DBEditor/ArrowL_01');
    img3 = ImageManager.loadAA('DBEditor/ArrowL_03');
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 180, rect.y + 56);
    b.disable();
    b.addClickHandler(function() {
      return AADBEditorManager.onMinusParamValue(param);
    });
    if (this._mainContentSwitches[index] == null) {
      this._mainContentSwitches[index] = [];
    }
    this._mainContentSwitches[index].push(b);
    return this.addChild(b);
  };
  _._createRightArrow = function(param, rect, index) {
    var b, img0, img1, img3;
    b = new KDCore.Button();
    img0 = ImageManager.loadAA('DBEditor/ArrowR_00');
    img1 = ImageManager.loadAA('DBEditor/ArrowR_01');
    img3 = ImageManager.loadAA('DBEditor/ArrowR_03');
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 80, rect.y + 56);
    b.disable();
    b.addClickHandler(function() {
      return AADBEditorManager.onPlusParamValue(param);
    });
    if (this._mainContentSwitches[index] == null) {
      this._mainContentSwitches[index] = [];
    }
    this._mainContentSwitches[index].push(b);
    return this.addChild(b);
  };
  _._createValueText = function(param, rect, index) {
    var value, valueText;
    value = this.getCurrentValueForParam(param);
    valueText = AASprite.FromBitmap(50, 40);
    //valueText.fillAll KDCore.Color.RED.reAlpha(200).CSS
    // * for compatibility with other methods
    valueText.disable = function() {};
    valueText.enable = function() {};
    valueText.move(rect.x + rect.width - 134, rect.y + 76);
    valueText.anchor.y = 0.5;
    if (value !== this.getDefaultValueForParam(param)) {
      valueText.bitmap.textColor = KDCore.Color.AQUA.CSS;
    }
    valueText.bitmap.drawTextFull(value, 'center');
    this._mainContentSwitches[index].push(valueText);
    return this.addChild(valueText);
  };
  _._createValueTypeText = function(param, rect, index) {
    var typeText, valueText;
    typeText = this.getTypeTextForParam(param);
    valueText = AASprite.FromBitmap(180, 26);
    //valueText.fillAll KDCore.Color.RED.reAlpha(200).CSS
    // * for compatibility with other methods
    valueText.disable = function() {};
    valueText.enable = function() {};
    valueText.move(rect.x + rect.width - 200, rect.y + 100);
    valueText.bitmap.fontSize = 17;
    valueText.bitmap.textColor = KDCore.Color.ORANGE.CSS;
    valueText.bitmap.drawTextFull(typeText, 'center');
    this._mainContentSwitches[index].push(valueText);
    return this.addChild(valueText);
  };
  _._createBooleanInputForParam = function(param, rect, index) {
    var b, img0, img1, img3, value;
    value = parseInt(this.getCurrentValueForParam(param));
    this._clearMainContentForIndex(index);
    b = new KDCore.Button();
    if (value === 1) {
      img0 = ImageManager.loadAA('DBEditor/SwitchOn_00');
      img1 = ImageManager.loadAA('DBEditor/SwitchOn_01');
      img3 = ImageManager.loadAA('DBEditor/SwitchOn_00');
    } else {
      img0 = ImageManager.loadAA('DBEditor/SwitchOff_00');
      img1 = ImageManager.loadAA('DBEditor/SwitchOff_01');
      img3 = ImageManager.loadAA('DBEditor/SwitchOff_00');
    }
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 120, rect.y + 54);
    b.disable();
    b.addClickHandler(function() {
      return AADBEditorManager.onToggleParamValue(param);
    });
    if (this._mainContentSwitches[index] == null) {
      this._mainContentSwitches[index] = [];
    }
    this._mainContentSwitches[index].push(b);
    return this.addChild(b);
  };
  _._createChoiceInputForParam = function(param, rect, index) {
    var b, baseValue, img0, img1, img3, t, value, valueOption;
    this._clearMainContentForIndex(index);
    value = this.getCurrentValueForParam(param);
    baseValue = this.getDefaultValueForParam(param);
    valueOption = this.convertOptionValueForParam(param, value);
    b = new KDCore.Button();
    img0 = ImageManager.loadAA('DBEditor/Option_00');
    img1 = ImageManager.loadAA('DBEditor/Option_01');
    img3 = ImageManager.loadAA('DBEditor/Option_03');
    b.setButtonImages(img0, img1, img0, img3);
    b.move(rect.x + rect.width - 166, rect.y + 54);
    t = AASprite.FromBitmap(100, 40);
    t.bitmap.fontSize = 19;
    t.y = 2;
    t.x = 5;
    if (value !== baseValue) {
      t.bitmap.textColor = KDCore.Color.AQUA.CSS;
    }
    t.bitmap.drawTextFull(valueOption, 'center');
    b.addChild(t);
    b.disable();
    b.addClickHandler(function() {
      return AADBEditorManager.onOptionParamValue(param);
    });
    if (this._mainContentSwitches[index] == null) {
      this._mainContentSwitches[index] = [];
    }
    this._mainContentSwitches[index].push(b);
    this.addChild(b);
    return this._createValueTypeText(param, rect, index);
  };
  _.getCurrentValueForParam = function(param) {
    return AADBEditorManager.getCurrentValueForParam(this.enemy, param);
  };
  _.getDefaultValueForParam = function(param) {
    return AADBEditorManager.getDefaultValueForParam(param);
  };
  _.convertOptionValueForParam = function(param, value) {
    return AADBEditorManager.convertOptionValueForParam(param, value);
  };
  _.getTypeTextForParam = function(param) {
    return AADBEditorManager.getTypeTextForParam(param);
  };
  _._clearMainContentForIndex = function(index) {
    var item, j, len, ref;
    if (this._mainContentSwitches == null) {
      return;
    }
    if (this._mainContentSwitches[index] != null) {
      ref = this._mainContentSwitches[index];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        item.removeFromParent();
        item.visible = false;
      }
      this._mainContentSwitches[index] = null;
    }
  };
  _._updateKeyboardInput = function() {
    if (this.active === false) {
      return;
    }
    if (Input.isTriggered('ok')) {
      Input.clear();
      this.onOkClick();
    }
    if (Input.isTriggered('left')) {
      Input.clear();
      this.onArrowClick(0);
    }
    if (Input.isTriggered('right')) {
      Input.clear();
      this.onArrowClick(1);
    }
    if (Input.isTriggered('r')) {
      Input.clear();
      this.onResetClick();
    }
    if (Input.isTriggered('f')) {
      Input.clear();
      this.onWikiClick();
    }
  };
  _.onOkClick = function() {
    var param, t;
    param = this.getItemData(this.index());
    if (param == null) {
      return;
    }
    t = this.getParamTypeIndex(param);
    if (t === 1) {
      AADBEditorManager.onToggleParamValue(param);
    } else if (t === 2) {
      AADBEditorManager.onOptionParamValue(param);
    } else {
      SoundManager.playBuzzer();
    }
  };
  _.onArrowClick = function(index) {
    var param, t;
    param = this.getItemData(this.index());
    if (param == null) {
      return;
    }
    t = this.getParamTypeIndex(param);
    if (t !== 0) {
      return;
    }
    SoundManager.playCursor();
    if (index === 0) {
      AADBEditorManager.onMinusParamValue(param);
    } else {
      AADBEditorManager.onPlusParamValue(param);
    }
  };
  _.onResetClick = function() {
    var param;
    param = this.getItemData(this.index());
    SoundManager.playCursor();
    if (param != null) {
      return AADBEditorManager.onResetParamValue(param);
    }
  };
  _.onWikiClick = function() {
    var param, wikiLink;
    param = this.getItemData(this.index());
    if (param == null) {
      return;
    }
    wikiLink = this.getParameterWiki(param);
    if (Utils.isNwjs() && (wikiLink != null)) {
      SoundManager.playCursor();
      return require('nw.gui').Shell.openExternal(wikiLink);
    } else {
      return SoundManager.playBuzzer();
    }
  };
})();

// ■ END Window_AADBEnemyEditABSWindow.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
var Window_AADBOptionSelector;

Window_AADBOptionSelector = class Window_AADBOptionSelector extends Window_Selectable {
  constructor() {
    super(0, 130, 800, 400);
    this.param = "";
    this._options = [];
    this._type = null;
    this._createExtraOptionsInfo();
  }

  maxCols() {
    return 3;
  }

  drawItem(index) {
    var option, rect;
    rect = this.itemRect(index);
    option = this.getItemData(index);
    switch (this._type) {
      case 'commonEvent':
      case 'skill':
      case 'returnType':
      case 'summonBattleMode':
      case 'element':
        return this._drawOptionWithID(option, rect, index);
      case 'hpBar':
      case 'faces':
        return this._drawOptionSimple(option, rect, index);
      default:
        // * NOTHING
        return this.drawText(option.name, rect.x, rect.y);
    }
  }

  maxItems() {
    if (this._options != null) {
      return this._options.length;
    } else {
      return 0;
    }
  }

  select(index) {
    super.select(index);
    return this._drawOptionHelp(index);
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Window_AADBOptionSelector_PRO.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Window_AADBOptionSelector.prototype;
  _.getItemData = function(index) {
    return this._options[index];
  };
  _.selectedOption = function() {
    return this.getItemData(this.index());
  };
  _.setOptions = function(param, _type, _options) {
    this.param = param;
    this._type = _type;
    this._options = _options;
    console.info(this._options);
    this.refresh();
    return this._drawExtraOptionInfo();
  };
  _._drawOptionWithID = function(option, rect, index) {
    this.makeFontSmaller();
    this.drawText(option.name, rect.x + 4, rect.y);
    this.changeTextColor(this.crisisColor());
    this.makeFontSmaller();
    this.drawText("ID: " + option.value, rect.x, rect.y, rect.width - this.textWidth('00'), 'right');
    this.resetFontSettings();
    return this.resetTextColor();
  };
  _._createExtraOptionsInfo = function() {
    this.textON = AASprite.FromBitmap(800, 40);
    //@textON.fillAll KDCore.Color.BLUE.reAlpha(200).CSS
    this.textON.move(0, -70);
    this.textON.bitmap.textColor = KDCore.Color.GREEN.CSS;
    this.addChild(this.textON);
    this.textOP = AASprite.FromBitmap(800, 30);
    //@textOP.fillAll KDCore.Color.RED.reAlpha(200).CSS
    this.textOP.move(0, -30);
    this.textOP.bitmap.textColor = KDCore.Color.ORANGE.CSS;
    this.addChild(this.textOP);
    this.textOD = AASprite.FromBitmap(800, 60);
    this.textOD.fillAll(KDCore.Color.BLACK.reAlpha(80).CSS);
    this.textOD.move(0, this.height + 10);
    this.textOD.bitmap.fontSize = 18;
    //@textOD.bitmap.textColor = KDCore.Color.ORANGE.CSS
    this.addChild(this.textOD);
  };
  _._drawExtraOptionInfo = function() {
    var name, t;
    this.textON.bitmap.clear();
    this.textOP.bitmap.clear();
    t = Window_AADBEnemyEditABSWindow.prototype.getParamTypeIndex.call(this, this.param);
    name = Window_AADBEnemyEditABSWindow.prototype._convertParam.call(this, this.param, t);
    this.textON.bitmap.drawTextFull(name, 'center');
    this.textOP.bitmap.fontSize = 17;
    return this.textOP.bitmap.drawTextFull(this._getTypeText(), 'center');
  };
  _._getTypeText = function() {
    switch (this._type) {
      case 'commonEvent':
        return 'Common Event ID';
      case 'skill':
        return 'ABS Skill ID';
      case 'hpBar':
        return "Mini HB Bar ID";
      case 'faces':
        return "Face Image Name";
      case 'returnType':
        return "Return Type ID";
      case 'summonBattleMode':
        return "Battle Mode ID";
      case 'element':
        return "Element ID";
      default:
        return "???";
    }
  };
  _._drawOptionHelp = function(index) {
    var option;
    if (index < 0) {
      return;
    }
    option = this.getItemData(index);
    this.textOD.visible = false;
    if (option == null) {
      return;
    }
    this.textOD.visible = option.desc !== "";
    this.textOD.bitmap.clear();
    return this.textOD.bitmap.drawTextFull(option.desc, 'center');
  };
  _._drawOptionSimple = function(option, rect, index) {
    if (option.name.length >= 20) {
      this.makeFontSmaller();
    }
    this.drawText(option.name, rect.x + 4, rect.y);
    this.resetFontSettings();
    return this.resetTextColor();
  };
})();

// ■ END Window_AADBOptionSelector_PRO.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Base.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Window_Base_drawActorFace = Window_Base.prototype.drawActorFace;
    Window_Base.prototype.drawActorFace = function (actor, x, y, width, height) {
        _alias_Window_Base_drawActorFace.call(this, actor, x, y, width, height);
        if(!AA.isPro()) {
            return;
        }
        if (actor.isHasVisualEq()) {
            var equips = actor._getVisualEqData();
            for(var i = 0; i< equips.length; i++) {
                this._drawAAVisualEq(equips[i], x, y, width, height);
            }
        }
    };

    //?[NEW]
    Window_Base.prototype._drawAAVisualEq = function (filename, x, y, width, height) {
        if(filename == null)
            return;
        width = width || Window_Base._faceWidth;
        height = height || Window_Base._faceHeight;
        var bitmap = ImageManager.loadAAEquip(filename + "_Face");
        var pw = Window_Base._faceWidth;
        var ph = Window_Base._faceHeight;
        var sw = Math.min(width, pw);
        var sh = Math.min(height, ph);
        var dx = Math.floor(x + Math.max(width - pw, 0) / 2);
        var dy = Math.floor(y + Math.max(height - ph, 0) / 2);
        this.contents.blt(bitmap, 0, 0, sw, sh, dx, dy);
    };

})();
// ■ END Window_Base.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
    //Window_EquipItem
    //------------------------------------------------------------------------------
    Window_EquipItem.prototype.onTouch = function (triggered) {
        if (this._sCircle) {
            if (this._sCircle.isOpen() && this._sCircle.isTouchedAny()) {
                return;
            }
        }
        Window_ItemList.prototype.onTouch.call(this, triggered);
    };

    var _Window_EquipItem_setActor = Window_EquipItem.prototype.setActor;
    Window_EquipItem.prototype.setActor = function (actor) {
        _Window_EquipItem_setActor.call(this, actor);
        if (this._actor != null && AlphaABS.Parameters.isWeaponsAllowed() == true) {
            this._createFavWeapCircle();
            this._createFavWeapButton();
        }
    };

    Window_EquipItem.prototype.update = function () {
        Window_ItemList.prototype.update.call(this);
        if (this._sCircle && this._sCircle.isOpen()) {
            var index = AlphaABS.LIBS.IKey.isTriggeredWeapCircleIndex();
            if(Input.isGamepad()) {
                index = AAGamePadManager.GetSelectIndex() - 1;
                if(index < 0)
                    index = null;
            }
            if (index != null) {
                this.touchWeaponAt(index);
                this.refresh();
                return;
            }
        }

        if(this._sCircle && this._sCircleButton) {
            if(Input.isTriggered(AlphaABS.LIBS.IKey.WC())) {
                this._sCircleButton.simulateClick();
                this._sCircleButton.click();
            }
            if(Input.isGamepad() && Input.isTriggered(AAGamePadManager.CommandKey())) {
                this._sCircleButton.simulateClick();
                this._sCircleButton.click();
            }
        }
    };

    Window_EquipItem.prototype.drawItemNumber = function (item, x, y, width) {
        Window_ItemList.prototype.drawItemNumber.call(this, item, x, y, width);
        try {
            if (!this._actor) {
                return;
            }
            if (!DataManager.isWeapon(item))
                return;

            var symbol = this._actor.getFavWeapSymbol(item);
            if (symbol != null) {
                this.changeTextColor(KDCore.Color.ORANGE.CSS);
                var spacer = '0000';
                if (Imported.YEP_ItemCore == true) {
                    spacer += '00';
                }
                if (!Utils.isMobileDevice() && !Input.isGamepad())
                    this.drawText('[' + symbol.toUpperCase() + ']', x, y, width - this.textWidth(spacer), 'right');
                else
                    this.drawText('■', x, y, width - this.textWidth(spacer), 'right');
            }
        } catch (e) {
            console.error(e);
        }
    };

    //NEW
    Window_EquipItem.prototype.touchWeaponAt = function (index) {
        try {
            if (this._sCircle) {
                if (DataManager.isWeapon(this.item())) {
                    this._sCircle.click(index);
                    this._actor.setFavWeap(this.item(), index);
                    SoundManager.playEquip();
                    this._sCircle.refresh();
                    this.refresh();
                } else
                    SoundManager.playBuzzer();
            }
        } catch (e) {
            console.error(e);
        }
    };


    Window_EquipItem.prototype.refresh = function () {
        Window_ItemList.prototype.refresh.call(this);

    };

    Window_EquipItem.prototype.activate = function () {
        Window_ItemList.prototype.activate.call(this);
        if (this._sCircleButton) {
            this._sCircleButton.visible = true;
        }
    };

    Window_EquipItem.prototype.deactivate = function () {
        Window_ItemList.prototype.deactivate.call(this);
        try {
            if (this._sCircleButton) {
                this._sCircleButton.visible = false;
                if (this._sCircle && this._sCircle.isOpen())
                    this._sCircleButton.click();
            }
        } catch (e) {
            console.error(e);
        }
    };

    Window_EquipItem.prototype._createFavWeapCircle = function () {
        try {
            this._sCircleBackSprite = new Sprite(new Bitmap((this.width / 2) - 4, this.height - 8));
            this._sCircleBackSprite.bitmap.addLoadListener(function () {
                this._sCircleBackSprite.bitmap.fillAll(KDCore.Color.BLACK.reAlpha(200).CSS);
            }.bind(this));
            this._sCircleBackSprite.visible = false;
            this.addChild(this._sCircleBackSprite);
            this._sCircle = new AlphaABS.LIBS.UI_SelectCircleFW(this._actor, function (index) {
                this.touchWeaponAt(index);
            }.bind(this));
            this._sCircle.move(this._sCircleBackSprite.width / 2, this._sCircleBackSprite.height / 2);
            if (!Utils.isMobileDevice())
                this._sCircle.showHelpers();
            this._sCircleBackSprite.addChild(this._sCircle);
        } catch (e) {
            console.error(e);
            this._sCircle = null;
        }
    };

    Window_EquipItem.prototype._createFavWeapButton = function () {
        this._sCircleButton = new KDCore.ButtonM("Button_FavWeapon", false, "AABS");
        this._sCircleButton.move(this.width - 36, this.height - 36);
        this._sCircleButton.visible = false;
        $gameTemp.__isSCircleButtonIsCliceked = false;
        this._sCircleButton.addClickHandler(function () {
            if ($gameTemp.__isSCircleButtonIsCliceked == false) {
                $gameTemp.__isSCircleButtonIsCliceked = true;
                this._onEquipMode();
            } else {
                $gameTemp.__isSCircleButtonIsCliceked = false;
                this._offEquipMode();
            }
        }.bind(this));
        this.addChild(this._sCircleButton);
    };

    Window_EquipItem.prototype.select = function (index) {
        Window_ItemList.prototype.select.call(this, index);
        try {
            if (!this._sCircle) return;
            if (this.maxCols() > 1) {
                this._placeFavWeapCircle(index % this.maxCols());
            } else {
                this._placeFavWeapCircle(0);
            }

            if (this._sCircleButton) {
                this._sCircleButton.visible = DataManager.isWeapon(this.item());

            }
        } catch (e) {
            console.error(e);
        }
    };

    Window_EquipItem.prototype._onEquipMode = function () {
        if (!this._sCircle) return;
        this._sCircle.open();
        this._sCircleBackSprite.visible = true;
    };

    Window_EquipItem.prototype._offEquipMode = function () {
        if (!this._sCircle) return;
        this._sCircle.close();
        this._sCircleBackSprite.visible = false;
    };

    Window_EquipItem.prototype._placeFavWeapCircle = function (place) {
        try {
            if (place <= 0) { //RIGHT
                this._sCircleBackSprite.move(this.width - 6, this.height - 4);
                this._sCircleBackSprite.setStaticAnchor(1, 1);
            } else { //LEFT
                this._sCircleBackSprite.move(6, this.height - 4);
                this._sCircleBackSprite.setStaticAnchor(0, 1);
            }
        } catch (e) {
            console.error(e);
        }
    };
    //END Window_EquipItem
    //------------------------------------------------------------------------------

})();
(function () {
  var _Window_EquipSlot_drawItem = Window_EquipSlot.prototype.drawItem;
  Window_EquipSlot.prototype.drawItem = function (index) {
    _Window_EquipSlot_drawItem.call(this, index);
    try {
      if (index !== null || index !== undefined)
        this._drawFavWeapSymbol(index);
    } catch (e) {
      console.error(e);
    }
  };

  //NEW
  Window_EquipSlot.prototype._drawFavWeapSymbol = function (index) {
    if (this._actor) {
      var item = this._actor.equips()[index];
      if (item) {
        var symbol = this._actor.getFavWeapSymbol(item);
        if (symbol != null) {
          this.changeTextColor(KDCore.Color.ORANGE.CSS);
          var rect = this.itemRectForText(index);
          var drawSymbol = '[' + symbol.toUpperCase() + ']';
          if (Utils.isMobileDevice()) {
            drawSymbol = '■';
          }
          if (Imported.YEP_EquipCore == true) {
            this.contents.drawText(drawSymbol, rect.x + this._nameWidth, rect.y, rect.width - this._nameWidth, this.lineHeight(), 'right');
          } else {
            var iconBowWidth = Window_Base._iconWidth + 8;
            this.contents.drawText(drawSymbol, rect.x + 138 + iconBowWidth, rect.y, 312 - iconBowWidth, this.lineHeight(), 'right');
          }
        }
      }
    }
  };
})();

(function () {

  var Consts = AlphaABS.SYSTEM;

  //Window_ItemList
  //------------------------------------------------------------------------------
  var _Window_ItemList_isEnabled = Window_ItemList.prototype.isEnabled;
  Window_ItemList.prototype.isEnabled = function (item) {
    if (this._isAllowedAAPanel()) {
          try {
            if (item && item.occasion == 1 && item.meta.ABS) {
              return false;
            } else
              return _Window_ItemList_isEnabled.call(this, item);
          } catch (e) {
            console.error(e);
            return false;
          }
    } else {
      return _Window_ItemList_isEnabled.call(this, item);
    }
  };

  var _Window_ItemList_update = Window_ItemList.prototype.update;
  Window_ItemList.prototype.update = function () {
    _Window_ItemList_update.call(this);
    if (this.active && this._isAllowedAAPanel()) {
      this._absItemToPanel();
      this._gpAbsItemToPanel();
      this._updateAASkillToPanelByTouch();
    }
  };


    //?[NEW]
    Window_ItemList.prototype._gpAbsItemToPanel = function () {
      try {
        if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
          if (this.__gamePadMod == 0) {
            this.__gamePadMod = 1;
          } else {
            this.__gamePadMod = 0;
          }
        }
        var inputIndex = AAGamePadManager.GetSelectIndex();
        if (inputIndex > 0) {
          if (this.__gamePadMod == 1)
            inputIndex += 4;
          this._placeAbsItemToPanel(inputIndex);
        }
      } catch (e) {
        AA.warning(e, 'GamePad ABS Item To Panel');
      }
    };
  Window_ItemList.prototype._absItemToPanel = function () {
    try {
      for (var i = 1; i < 9; i++) {
        if (Input.isTriggered("" + i)) {
          this._placeAbsItemToPanel(i);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Window_ItemList.prototype._placeAbsItemToPanel = function (index) {
      if (this.item() && this.item().occasion == 1 && this.item().meta.ABS) {
        //LOG.p("Item " + this.item().name + " set to slot " + i);
        $gameParty.leader().setItemOnPanel(this.item().id, index - 1);
        SoundManager.playEquip();
        this.refresh();
      } else {
        LOGW.p(Consts.STRING_WARNING_SKILLOC);
        SoundManager.playBuzzer();
      }
  };



  var _Window_ItemList_drawItemNumber = Window_ItemList.prototype.drawItemNumber;
  Window_ItemList.prototype.drawItemNumber = function (item, x, y, width) {
    _Window_ItemList_drawItemNumber.call(this, item, x, y, width);
    if (!this._isAllowedAAPanel()) {
      return;
    }
    try {
      if (this._category != 'item') return;
      var index = $gameParty.leader().skillIndexOnUI(item.id, true);
      if (index >= 0) {
        this.changeTextColor(KDCore.Color.ORANGE.CSS);
        this.drawText("[" + (index + 1) + "]", x + width - 60 - this.numberWidth(), y, 40, 'left');
      }
    } catch (e) {
      console.error(e);
    }
  };

  var _Window_ItemList_initialize = Window_ItemList.prototype.initialize;
  Window_ItemList.prototype.initialize = function (x, y, width, height) {
    _Window_ItemList_initialize.call(this, x, y, width, height);

    this.__gamePadMod = 0;

    this._absPanel = new AA.LIBS.AASpellPanelManagerMenu();
    var dx = 0;
    if (Imported.YEP_ItemCore == true) {
      dx = -200;
    }
    this._absPanel.getSprite().move(dx, -y);
    if ($gameParty.leader()) {
      this._absPanel.battler = $gameParty.leader();
      this._absPanel.refresh();
    }
    this._absPanel.hide();
    if (this._isAllowedAAPanel()) {
      this.addChild(this._absPanel.getSprite());
    }
  };

  var _Window_ItemList_setCategory = Window_ItemList.prototype.setCategory;
  Window_ItemList.prototype.setCategory = function (category) {
    _Window_ItemList_setCategory.call(this, category);
    if (this._isAllowedAAPanel()) {
      if (this._category == 'item') {
        this._absPanel.show();
      } else {
        this._absPanel.hide();
      }
    }
  };


  //?[NEW]
  Window_ItemList.prototype._updateAASkillToPanelByTouch = function () {
      try {
        if (this.active && this._absPanel.isVisible()) {
          if (TouchInput.isTriggered()) {
            var tI = this._absPanel.getIndexUnderTouch();
            if (tI != null) {
              if (this.item() && this.item().occasion == 1 && this.item().meta.ABS) {
                this._absPanel.clickAt(tI);
                //LOG.p("Item " + this.item().name + " set to slot " + tI);
                $gameParty.leader().setItemOnPanel(this.item().id, tI);
                SoundManager.playEquip();
                this.refresh();
              } else {
                LOGW.p(Consts.STRING_WARNING_SKILLOC);
                SoundManager.playBuzzer();
              }
            }
          }
        }
      } catch (e) {
        console.error(e);
      }
  };

  //@[ALIAS]
  var _alias_Window_ItemList_refresh = Window_ItemList.prototype.refresh;
  Window_ItemList.prototype.refresh = function () {
      _alias_Window_ItemList_refresh.call(this);
      this._absPanel.refresh();
      this._absPanel.hide();
  };

  //?[NEW]
  Window_ItemList.prototype._isAllowedAAPanel = function () {
    return Window_SkillList.prototype._isAllowedAAPanel.call();
  };

  //END Window_ItemList
  //------------------------------------------------------------------------------

})();
(function () {
    //@[ALIAS]
    var _alias_Window_Message_isTriggered = Window_Message.prototype.isTriggered;
    Window_Message.prototype.isTriggered = function () {
        if (ButtonsProManager.isAnyButtonOverrideInput()) {
            return (Input.isRepeated('ok') || Input.isRepeated('cancel'));
        } else {
            return _alias_Window_Message_isTriggered.call(this);
        }
    };
})();
(function () {

  var Consts = AlphaABS.SYSTEM;
  var LOG = new KDCore.DevLog("Window_SkillList");

  var _Window_SkillList_update = Window_SkillList.prototype.update;
  Window_SkillList.prototype.update = function () {
    _Window_SkillList_update.call(this);
    if (this.active && this._isAllowedAAPanel()) {
      this._absSkillToPanel();
      this._gpAbsSkillToPanel();
      this._updateAASkillToPanelByTouch();
    }
  };

  Window_SkillList.prototype._absSkillToPanel = function () {
    try {
      for (var i = 1; i < 9; i++) {
        if (Input.isTriggered("" + i)) {
          this._placeAbsSkillToPanel(i);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Window_SkillList.prototype._placeAbsSkillToPanel = function (index) {
      if (this.checkABSItem(this.item())) {
        LOG.p("Skill " + this.item().name + " set to slot " + index);
        this._actor.setSkillOnPanel(this.item().id, index - 1);
        SoundManager.playEquip();
        this.refresh();
      } else {
        LOGW.p(Consts.STRING_WARNING_SKILLOC);
        SoundManager.playBuzzer();
      }
  };

  //?[NEW]
  Window_SkillList.prototype._gpAbsSkillToPanel = function () {
      if(Input.isGamepad()) {
        try {

          if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
            if (this.__gamePadMod == 0) {
              this.__gamePadMod = 1;
            } else {
              this.__gamePadMod = 0;
            }
          }
          var inputIndex = AAGamePadManager.GetSelectIndex();
          if(inputIndex > 0) {
            if(this.__gamePadMod == 1)
              inputIndex += 4;
            this._placeAbsSkillToPanel(inputIndex);
          }
        } catch (e) {
          AA.warning(e, 'GamePad ABS Skill To Panel');
        }
      }
  };

  var _Window_SkillList_isEnabled = Window_SkillList.prototype.isEnabled;
  Window_SkillList.prototype.isEnabled = function (item) {
    if(this._isAllowedAAPanel()) {
      if (this.checkABSItem(item)) {
        return false;
      }
    }
    return _Window_SkillList_isEnabled.call(this, item);
  };

  //NEW
  Window_SkillList.prototype.checkABSItem = function (item) {
    try {
      return (item && item.occasion == 1 && item.meta.ABS);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  var _Window_SkillList_drawSkillCost = Window_SkillList.prototype.drawSkillCost;
  Window_SkillList.prototype.drawSkillCost = function (skill, x, y, width) {
    _Window_SkillList_drawSkillCost.call(this, skill, x, y, width);
    //Draw panel number of skill
    try {
      if (!this._isAllowedAAPanel()) {
        return;
      }
      var index = this._actor.skillIndexOnUI(skill.id);
      if (index >= 0) {
        this.changeTextColor(KDCore.Color.ORANGE.CSS);
        //if(Input.isGamepad()) {
        //  var text = AAGamePadManager.ConvertSelectIndexToSymbol(index);
        //  this.drawText("[" + text + "]", x + width - 60 - this.costWidth(), y, 40, 'left');
        //} else
          this.drawText("[" + (index + 1) + "]", x + width - 60 - this.costWidth(), y, 40, 'left');
      }
    } catch (e) {
      console.error(e);
    }
  };

  var _Window_SkillList_initialize = Window_SkillList.prototype.initialize;
  Window_SkillList.prototype.initialize = function (x, y, width, height) {
    _Window_SkillList_initialize.call(this, x, y, width, height);
    this.__gamePadMod = 0;
    this._absPanel = new AA.LIBS.AASpellPanelManagerMenu();
    this._absPanel.getSprite().move(0, -y);
    if (this._isAllowedAAPanel()) {
      this.addChild(this._absPanel.getSprite());
    }
  };

  var _Window_SkillList_setActor = Window_SkillList.prototype.setActor;
  Window_SkillList.prototype.setActor = function (actor) {
    try {
      if (this._actor !== actor) {
        this._absPanel.battler = actor;
        this._absPanel.refresh();
      }
    } catch (e) {
      console.error(e);
    }
    _Window_SkillList_setActor.call(this, actor);
  };

  //?[NEW]
  Window_SkillList.prototype._updateAASkillToPanelByTouch = function () {
      if (TouchInput.isTriggered()) {
        try {
          var tI = this._absPanel.getIndexUnderTouch();
          if (tI != null) {
            if (this.checkABSItem(this.item())) {
              this._absPanel.clickAt(tI);
              LOG.p("Skill " + this.item().name + " set to slot " + tI);
              this._actor.setSkillOnPanel(this.item().id, tI);
              SoundManager.playEquip();
              this.refresh();
            } else {
              SoundManager.playBuzzer();
              LOGW.p(Consts.STRING_WARNING_SKILLOC);
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
  };

  //@[ALIAS]
  /*var _alias_Window_SkillList_includes = Window_SkillList.prototype.includes;
  Window_SkillList.prototype.includes = function (item) {
    if(this._isAllowedAAPanel())
      return _alias_Window_SkillList_includes.call(this, item);
    else {
      if (AA.Parameters.get_IsABSSkillsAllowedInNONABSBattle()) {
        return _alias_Window_SkillList_includes.call(this, item);
      } else {
        if (item.meta && item.meta.ABS)
          return false;
        return _alias_Window_SkillList_includes.call(this, item);
      }
    }
  };*/

  
  //?[NEW]
  Window_SkillList.prototype._isAllowedAAPanel = function () {
      return !AA.Utils.isSceneBattle();
  };

  //@[ALIAS]
  var _alias_Window_SkillList_refresh = Window_SkillList.prototype.refresh;
  Window_SkillList.prototype.refresh = function () {
      _alias_Window_SkillList_refresh.call(this);
      if(this._absPanel)
        this._absPanel.refresh();
  };
})(); 
// Generated by CoffeeScript 2.5.1
// * Анимация (одна единица анимации, последовательность кадров)

//* STORABLE - значит класс сохраняется в сохранение (т.е. создаётся на игровом объекте)
//@[STORABLE]
var XAnima;

XAnima = class XAnima {
  constructor(framesCount, fileName) {
    this.framesCount = framesCount;
    this.fileName = fileName;
    this.frames = [];
    this._parseFrames();
  }

  // * Хранит только названия картинок кадров
  _parseFrames() {
    var i, j, ref, results;
    results = [];
    for (i = j = 0, ref = this.framesCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      results.push(this.frames.push(this.fileName + "_" + i));
    }
    return results;
  }

  // * Умножить первый кадр times раз
  expandFirstFrame(times) {
    var i, j, ref, results;
    this.framesCount += times;
    results = [];
    for (i = j = 0, ref = times; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      results.push(this.frames.splice(1, 0, this.frames[0]));
    }
    return results;
  }

  preLoad() {
    var f, j, len, ref, results;
    ref = this.frames;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      f = ref[j];
      results.push(ImageManager.loadAnimaX(f));
    }
    return results;
  }

  getFrame(index) {
    return ImageManager.loadAnimaX(this.frames[index]);
  }

};

//TODO: Загрузка всех анимаций при запуске игры?

// Generated by CoffeeScript 2.5.1
// * Дополнительный слой анимации

//@[STORABLE]
var XAnimaPart;

XAnimaPart = class XAnimaPart {
  constructor(filename, isLowerBodyPart, level) {
    this.filename = filename;
    this.isLowerBodyPart = isLowerBodyPart;
    this.level = level;
    this.animations = [];
    this.rules = {};
    this.disabledActions = [];
    if (this.isLowerBodyPart == null) {
      this.isLowerBodyPart = false;
    }
    if (this.level == null) {
      this.level = 0;
    }
    // D, L, R, U, DL, DR, UL, UR, noDir
    this.directionsLevels = [false, false, false, false, false, false, false, false, false];
    this._isDisabled = false;
    // * Дополнительное смещение части
    this.dx = 0;
    this.dy = 0;
    this.setDefaultRule(true, true);
  }

  isDisabled() {
    return this._isDisabled === true;
  }

  is8WayAnimation() {
    return this.is8Way === true;
  }

  // * Тут задаётся стандартное правило
  setDefaultRule(haveDirs, haveFrames) {
    return this.rules['Basic'] = [haveDirs, haveFrames];
  }

  setRuleForMovement(haveDirs, haveFrames) {
    return this.rules['Move'] = [haveDirs, haveFrames];
  }

  setRuleForIdle(haveDirs, haveFrames) {
    return this.rules['Idle'] = [haveDirs, haveFrames];
  }

  setRuleForDashing(haveDirs, haveFrames) {
    return this.rules['Dashing'] = [haveDirs, haveFrames];
  }

  setRuleForAction(actionName, haveDirs, haveFrames, fileName) {
    return this.rules[actionName] = [haveDirs, haveFrames, fileName];
  }

  disableForAction(actionName) {
    return this.disabledActions.push(actionName);
  }

  applyRootAnimation(xAnimaSet) {
    var cFileName, frames, isNoDir, rule, setName;
    setName = xAnimaSet.getActionName();
    if (this.disabledActions.contains(setName)) {
      this._isDisabled = true;
      return;
    } else {
      this._isDisabled = false;
    }
    rule = this.rules[setName];
    if (rule == null) {
      rule = this.rules['Basic'];
      cFileName = this.filename + setName;
    } else {
      if (String.any(rule[2])) {
        cFileName = this.filename + rule[2];
      } else {
        cFileName = this.filename + setName;
      }
    }
    frames = xAnimaSet.frames;
    if (!rule[1]) {
      frames = 1;
    }
    isNoDir = !rule[0];
    return this._setupAnimations(frames, cFileName, isNoDir, xAnimaSet.is8Way, frames === 1);
  }

  _setupAnimations(frames, cFileName, isNoDir, is8way, isNoFrames) {
    this.isOneFrame = isNoFrames;
    this.isNoDirections = isNoDir;
    this.is8Way = is8way;
    if (this.isNoDirections === true) {
      this.animations[0] = new XAnima(frames, cFileName);
    } else {
      this.animations[0] = new XAnima(frames, cFileName + "_D");
      this.animations[1] = new XAnima(frames, cFileName + "_L");
      this.animations[2] = new XAnima(frames, cFileName + "_R");
      this.animations[3] = new XAnima(frames, cFileName + "_U");
      if (is8way === true) {
        this.animations[4] = new XAnima(frames, this.filename + "_DL");
        this.animations[5] = new XAnima(frames, this.filename + "_DR");
        this.animations[6] = new XAnima(frames, this.filename + "_UL");
        this.animations[7] = new XAnima(frames, this.filename + "_UR");
      }
      return;
    }
    this.preLoad();
  }

  preLoad() {
    var anim, i, len, ref, results;
    ref = this.animations;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      anim = ref[i];
      results.push(anim.preLoad());
    }
    return results;
  }

  getPartBitmap(dir, frame) {
    if (this.isOneFrame === true) {
      frame = 0;
    }
    return this.getAnimationByDirection(dir).getFrame(frame);
  }

  // * Часть (слой) должна быть под персонажем?
  isBelowCharacter(dir) {
    if (this.isNoDirections === true) {
      // * Отдельная настройка 8 позиция
      return this.directionsLevels[8];
    } else {
      switch (dir) {
        case 8:
          return this.directionsLevels[3];
        case 2:
          return this.directionsLevels[0];
        case 4:
          return this.directionsLevels[1];
        case 6:
          return this.directionsLevels[2];
        case 1: // * DL
          if (this.is8WayAnimation()) {
            return this.animations[4];
          } else {
            return this.animations[1];
          }
          break;
        case 3: // * DR
          if (this.is8WayAnimation()) {
            return this.animations[5];
          } else {
            return this.animations[2];
          }
          break;
        case 7: // * UL
          if (this.is8WayAnimation()) {
            return this.animations[6];
          } else {
            return this.animations[1];
          }
          break;
        case 9: // * UR
          if (this.is8WayAnimation()) {
            return this.animations[7];
          } else {
            return this.animations[2];
          }
      }
      return this.directionsLevels[8];
    }
  }

  getAnimationByDirection(dir) {
    if (this.isNoDirections === true) {
      return this.animations[0];
    }
    switch (dir) {
      case 8:
        return this.animations[3];
      case 2:
        return this.animations[0];
      case 4:
        return this.animations[1];
      case 6:
        return this.animations[2];
      case 1: // * DL
        if (this.is8WayAnimation()) {
          return this.animations[4];
        } else {
          return this.animations[1];
        }
        break;
      case 3: // * DR
        if (this.is8WayAnimation()) {
          return this.animations[5];
        } else {
          return this.animations[2];
        }
        break;
      case 7: // * UL
        if (this.is8WayAnimation()) {
          return this.animations[6];
        } else {
          return this.animations[1];
        }
        break;
      case 9: // * UR
        if (this.is8WayAnimation()) {
          return this.animations[7];
        } else {
          return this.animations[2];
        }
    }
    return this.animations[0];
  }

};

// Generated by CoffeeScript 2.5.1
// * Набор анимаций для всех направлений

//DIRECTIONS:
// 2 - DOWN
// 8 - UP
// 4 - LEFT
// 6 - RIGHT

//TYPE:
// 0 - movement
// 1 - idle
// 2 - action

//@[STORABLE]
var XAnimaSet;

XAnimaSet = class XAnimaSet {
  constructor(type, filename, frames, speed, isNoDirections, is8Way = false) {
    this.type = type;
    this.filename = filename;
    this.frames = frames;
    this.speed = speed;
    this.isNoDirections = isNoDirections;
    this.is8Way = is8Way;
    this._setupAnimations();
    this.isLoop = false;
    this.actionName = "Action";
    this.moveToIdleDelay = 30;
    this.waitActionEnd = true;
  }

  _setupAnimations() {
    this.animations = [];
    if (this.isNoDirections === true) {
      this.animations[0] = new XAnima(this.frames, this.filename);
    } else {
      this.animations[0] = new XAnima(this.frames, this.filename + "_D");
      this.animations[1] = new XAnima(this.frames, this.filename + "_L");
      this.animations[2] = new XAnima(this.frames, this.filename + "_R");
      this.animations[3] = new XAnima(this.frames, this.filename + "_U");
      if (this.is8WayAnimation()) {
        this.animations[4] = new XAnima(this.frames, this.filename + "_DL");
        this.animations[5] = new XAnima(this.frames, this.filename + "_DR");
        this.animations[6] = new XAnima(this.frames, this.filename + "_UL");
        this.animations[7] = new XAnima(this.frames, this.filename + "_UR");
      }
      return;
    }
    this.preLoad();
  }

  setActionName(actionName) {
    this.actionName = actionName;
  }

  // * Имя действия используется частями, чтобы определять правила и анимации нужные
  getActionName() {
    switch (this.type) {
      case 0:
        return "Move";
      case 1:
        return "Idle";
      case 3:
        return "Dashing";
      default:
        return this.actionName;
    }
  }

  preLoad() {
    var anim, i, len, ref;
    ref = this.animations;
    for (i = 0, len = ref.length; i < len; i++) {
      anim = ref[i];
      anim.preLoad();
    }
  }

  isNoFrames() {
    return this.frames === 1;
  }

  isWait() {
    return this.waitActionEnd === true;
  }

  expandFirstFrameTimes(times) {
    var anim, i, len, ref;
    ref = this.animations;
    for (i = 0, len = ref.length; i < len; i++) {
      anim = ref[i];
      anim.expandFirstFrame(times);
    }
    return this.frames += times;
  }

  //? Оптимизация заменой метода?
  getAnimationByDirection(dir) {
    if (this.isNoDirections === true) {
      return this.animations[0];
    }
    switch (dir) {
      case 8:
        return this.animations[3];
      case 2:
        return this.animations[0];
      case 4:
        return this.animations[1];
      case 6:
        return this.animations[2];
      case 1: // * DL
        if (this.is8WayAnimation()) {
          return this.animations[4];
        } else {
          return this.animations[1];
        }
        break;
      case 3: // * DR
        if (this.is8WayAnimation()) {
          return this.animations[5];
        } else {
          return this.animations[2];
        }
        break;
      case 7: // * UL
        if (this.is8WayAnimation()) {
          return this.animations[6];
        } else {
          return this.animations[1];
        }
        break;
      case 9: // * UR
        if (this.is8WayAnimation()) {
          return this.animations[7];
        } else {
          return this.animations[2];
        }
    }
    return this.animations[0];
  }

  is8WayAnimation() {
    return this.is8Way === true;
  }

  isMovement() {
    return this.type === 0;
  }

  isDashing() {
    return this.type === 3;
  }

  isAction() {
    return this.type === 2;
  }

  isIdle() {
    return this.type === 1;
  }

};

// Generated by CoffeeScript 2.5.1
// * Контроллер анимации (смена кадров, направлений)
// * rootAnimation - это XAnimaSet
// * Контроллер хранится в Sprite_Character
var XAnimaSetController;

XAnimaSetController = class XAnimaSetController {
  constructor(startDirection, rootAnimation) {
    this.rootAnimation = rootAnimation;
    this.cFrame = 0;
    this.cDir = startDirection;
    this._timer = 0;
    this._sKoef = 0;
    this._requireRefresh = true;
    this._animPlaying = false;
    this._initialFrame = false;
  }

  isPlaying() {
    return this._animPlaying === true;
  }

  //?X
  // * Класс каждый раз получает character, не хранит
  update(character) {
    if (AA.UI.isGameShouldPause()) {
      return;
    }
    this._requireRefresh = false;
    this._updateDirection(character);
    return this._updateFrames(character);
  }

  _updateDirection(character) {
    var cDir;
    if (this.rootAnimation.is8WayAnimation()) {
      cDir = character._diagonalDir;
      if (cDir == null) {
        //console.warn('You try start 8 way diagonal animation, but game not support 8 way movement')
        cDir = character.direction();
      }
      if (cDir === false) {
        cDir = character.direction();
      }
    } else {
      //console.log(cDir)
      cDir = character.direction();
    }
    if (cDir !== this.cDir) {
      this.requestRefresh();
    }
    this.cDir = cDir;
  }

  _updateFrames(character) {
    // * Используется один и тотже алгоритм смены кадров для Dashing и Movement
    if (this.rootAnimation.isMovement() || this.rootAnimation.isDashing()) {
      if (!this.rootAnimation.isNoFrames()) { // * IDLE AND ACTION SAME WAY
        return this._updateMovement(character);
      }
    } else {
      return this._updateAction(character);
    }
  }

  _updateMovement(c) {
    if (c.isMoving()) {
      this._sKoef = c.realMoveSpeed();
      this._setInitialFrame(1);
      this._animPlaying = true;
      // * Если Dashing, то таймер обычный
      if (c.isInDashingAnimaX()) {
        this._updateTimer(false); // * Если нет Dashing анимации, то немного ускоряем таймер
      } else {
        this._updateTimer(c.isDashing());
      }
      if (this._timer === 0) {
        return this._nextMovementFrame();
      }
    } else {
      this._sKoef = 0;
      this._updateTimer(false);
      if (this._timer === 0) {
        if (this.cFrame !== 0) {
          this.requestRefresh();
        }
        return this.resetAnimation();
      }
    }
  }

  _setInitialFrame(frameIndex) {
    if (this._initialFrame === true) { // * Установка начального кадра
      return;
    }
    this.cFrame = frameIndex;
    this._initialFrame = true;
    this._timer = 0;
    return this.requestRefresh();
  }

  _updateTimer(isFast) {
    this._timer += 1;
    if (isFast) {
      this._timer += 0.5;
    }
    if (this._timer >= this._speed()) {
      return this._timer = 0;
    }
  }

  _speed() {
    return this.rootAnimation.speed - this._sKoef;
  }

  _nextMovementFrame() {
    this.cFrame++;
    if (this.cFrame >= this.rootAnimation.frames) {
      this.cFrame = 1; // * Не 0, 0 - когда стоит
    }
    if (!this._isNextFrameBitmapIsReady()) {
      if (this.cFrame > 0) {
        // * Если не готов кадр, то назад на 1 кадр (остаёмся на месте)
        this.cFrame--;
      }
      return;
    }
    this.requestRefresh();
  }

  _isNextFrameBitmapIsReady() {
    var b;
    b = this.bitmap();
    if (!b.isReady() || b.width <= 0) {
      return false;
    } else {
      return true;
    }
  }

  _updateAction(c) {
    if (this._initialFrame === false) {
      this._setInitialFrame(0);
      c.onAnimaXActionStart();
    }
    this._updateTimer(false);
    if (this._timer === 0) {
      return this._nextActionFrame(c);
    }
  }

  _nextActionFrame(c) {
    this._animPlaying = true;
    this.cFrame++;
    if (this.cFrame >= this.rootAnimation.frames) {
      this.cFrame = 0;
      if (!this.rootAnimation.isLoop) {
        this.resetAnimation();
        c.onAnimaXActionEnd();
      }
    }
    if (!this._isNextFrameBitmapIsReady()) {
      if (this.cFrame > 0) {
        this.cFrame--;
      }
    }
    return this.requestRefresh();
  }

  resetAnimation() {
    this._timer = 0;
    this.cFrame = 0;
    this._animPlaying = false;
    return this._initialFrame = false;
  }

  // * Если спрайт должен отрисовать новый кадр, то запрашиваем refresh
  requestRefresh() {
    return this._requireRefresh = true;
  }

  bitmap() {
    return this.rootAnimation.getAnimationByDirection(this.cDir).getFrame(this.cFrame);
  }

  isChanged() {
    return this._requireRefresh;
  }

};

// Generated by CoffeeScript 2.5.1
// * Менеджер для работы с БД анимаций
var XAnimaTools;

XAnimaTools = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ XAnimaTools.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = XAnimaTools;
  //?X
  _.getXAnimaActionList = function(id) {
    var data;
    data = this.getXAnimaSetById(id);
    if (data == null) {
      return [];
    }
    return data.actions;
  };
  //?X
  _.getXAnimaSetById = function(id) {
    var data;
    data = AA.Parameters.xAnimations();
    return data != null ? data.find(function(d) {
      return d.id === id;
    }) : void 0;
  };
  //?X
  _.getXAnimaParamsForState = function(state, id) {
    var data;
    data = this.getXAnimaSetById(id);
    if (data == null) {
      return null;
    }
    return data[state];
  };
  //?X
  _.getXAnimaParamsForAction = function(actionName, setId) {
    var data;
    data = this.getXAnimaActionList(setId);
    return data != null ? data.find(function(a) {
      return a.name === actionName;
    }) : void 0;
  };
  //?UPD 1236
  _.getXAnimaPartById = function(id) {
    var data;
    data = AA.Parameters.xAnimationsParts();
    return data != null ? data.find(function(a) {
      return a.id === id;
    }) : void 0;
  };
  
  // * Конвертировать массив Actions из параметров плагина в более компактный вид
  _.convertActionsFromParameters = function(actions) {
    var action, i, item, len, shrinked;
    shrinked = [];
    for (i = 0, len = actions.length; i < len; i++) {
      action = actions[i];
      item = action.animation;
      item.name = action.name;
      shrinked.push(item);
    }
    return shrinked;
  };
  _.createXAnimaSetForAction = function(id, params) {
    var animaSet, e;
    try {
      animaSet = this._createXAnimaSetFromParams(id, 2, null, params);
      return animaSet;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.createXAnimaSetForMove = function(id, state, params) {
    var animaSet, e;
    try {
      animaSet = this._createXAnimaSetFromParams(id, 0, state, params);
      return animaSet;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.createXAnimaSetForIdle = function(id, state, params) {
    var animaSet, e;
    try {
      animaSet = this._createXAnimaSetFromParams(id, 1, state, params);
      return animaSet;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.createXAnimaSetForDashing = function(id, state, params) {
    var animaSet, e;
    try {
      animaSet = this._createXAnimaSetFromParams(id, 3, state, params);
      return animaSet;
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  _._createXAnimaSetFromParams = function(id, type, state, params) {
    var animaSet, e, filename, frames, is8Way, isOneDirection, speed;
    try {
      ({frames, speed, isOneDirection, is8Way} = params);
      if (type === 2) { // * Action
        filename = this.createFilenameForAnimaAction(id, params.name);
      } else {
        filename = this.createFilenameForAnimaState(id, state, type);
      }
      animaSet = new XAnimaSet(type, filename, frames, speed, isOneDirection, is8Way);
      animaSet.dx = params.dx || 0;
      animaSet.dy = params.dy || 0;
      if (params.expandFirstFrame > 0) {
        animaSet.expandFirstFrameTimes(params.expandFirstFrame);
      }
      if (type === 2) {
        // * Задать имя действия
        animaSet.setActionName(params.name);
      }
      return animaSet;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.createFilenameForAnimaState = function(id, state, type) {
    var path;
    path = id + "/";
    if (state !== 'base') {
      path += state + "/";
    }
    if (type === 0) {
      path += "Move";
    } else if (type === 1) {
      path += "Idle";
    } else if (type === 3) {
      path += "Dashing";
    }
    return path;
  };
  _.createFilenameForAnimaAction = function(id, name) {
    var path;
    path = id + "/Actions/" + name;
    return path;
  };
  _.createFilenameForAnimaPart = function(id, name, isRelative) {
    var path;
    if (isRelative) {
      path = id + "/Layers/" + name + "/";
    } else {
      path = "CommonLayers/" + name + "/";
    }
    return path;
  };
  _.createXAnimaPart = function(id, partName, isRelative = false) {
    var animaPartSet, e, params;
    try {
      params = this.getXAnimaPartById(partName);
      if (params == null) {
        return null;
      }
      animaPartSet = this._createXAnimaPartFromParams(id, partName, params, isRelative);
      return animaPartSet;
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  // * isRelative - относительно ID анимации, например Harold\Parts\hat
  // * Если isRealtive = false, то будет Parts\hat
  _._createXAnimaPartFromParams = function(axId, partName, params, isRelative = false) {
    var actionRules, animaPart, baseRule, dashRule, e, filename, i, idleRule, isLowerBodyPart, layerRule, len, moveRule, rule, sortingLevel;
    try {
      ({isLowerBodyPart, sortingLevel, baseRule, moveRule, idleRule, dashRule, actionRules, layerRule} = params);
      filename = this.createFilenameForAnimaPart(axId, partName, isRelative);
      animaPart = new XAnimaPart(filename, isLowerBodyPart, sortingLevel);
      animaPart.directionsLevels = this._convertLayerRuleToDirectionLevels(layerRule);
      if (baseRule != null) {
        animaPart.setDefaultRule(baseRule.isHaveDirections, baseRule.isHaveFrames);
      }
      if (moveRule != null) {
        animaPart.setRuleForMovement(moveRule.isHaveDirections, moveRule.isHaveFrames);
      }
      if (idleRule != null) {
        animaPart.setRuleForIdle(idleRule.isHaveDirections, idleRule.isHaveFrames);
      }
      if (dashRule != null) {
        animaPart.setRuleForDashing(dashRule.isHaveDirections, dashRule.isHaveFrames);
      }
      animaPart.dx = params.dx || 0;
      animaPart.dy = params.dy || 0;
      try {
        for (i = 0, len = actionRules.length; i < len; i++) {
          rule = actionRules[i];
          if (rule == null) {
            continue;
          }
          if (rule.enabled === false) {
            animaPart.disableForAction(rule.actionName);
          } else {
            animaPart.setRuleForAction(rule.actionName, rule.actionRule.isHaveDirections, rule.actionRule.isHaveFrames, rule.fileName);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return animaPart;
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  // * Преобразовать структуру LAnimaXPartDirLevel в массив directionsLevels для слоя
  _._convertLayerRuleToDirectionLevels = function(layerRule) {
    return [layerRule.dirD, layerRule.dirL, layerRule.dirR, layerRule.dirU, layerRule.dirDL, layerRule.dirDR, layerRule.dirUL, layerRule.dirUR, layerRule.noDir];
  };
})();

// ■ END XAnimaTools.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onMapLoaded, ALIAS__updateScene, _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //@[ALIAS]
  ALIAS__onMapLoaded = _.onMapLoaded;
  _.onMapLoaded = function() {
    ALIAS__onMapLoaded.call(this);
    if (AA.isABS()) {
      if (AA.Parameters.get_IsExtraPreviewAllowed()) {
        this._extraPreviewThread = new AATimedUpdate(24, this._updateAAHoverExtraPreview.bind(this));
      } else {
        this._extraPreviewThread = null;
      }
      if (AA.Parameters.get_IsPreviewTargetByMouse() === true) {
        return this._aaTargetPreviewThread = new AATimedUpdate(20, this._updateAAHoverTargetSelection.bind(this));
      } else {
        return this._aaTargetPreviewThread = null;
      }
    }
  };
  //else
  //    @_updateAAHoverTargetSelectionPH = () -> # * NOTHING

  //@[ALIAS]
  ALIAS__updateScene = _.updateScene;
  _.updateScene = function() {
    var ref, ref1;
    ALIAS__updateScene.call(this);
    if (SceneManager.isSceneChanging()) {
      return;
    }
    if ((ref = this._aaTargetPreviewThread) != null) {
      ref.update();
    }
    return (ref1 = this._extraPreviewThread) != null ? ref1.update() : void 0;
  };
  //?[] Place Holder
  _._updateAAHoverTargetSelectionPH = function() {}; // * NOTHING
  
  // * Показ врагов под мышкой
  _._updateAAHoverTargetSelection = function() {
    var enemy;
    enemy = $gameMap.getABSEventUnderMouse();
    AA.BattleUI.previewTarget(enemy);
  };
  
  // * Показ событий под мышкой
  _._updateAAHoverExtraPreview = function() {
    var eventId;
    if (!$gameMap.isHasExtraPrivewEvent()) {
      return;
    }
    eventId = $gameMap.getEventWithEPUnderMouse();
    if (eventId != null) {
      return AA.UI.showExtraTargetUI(eventId);
    } else {
      return AA.UI.hideExtraTargetUI();
    }
  };
})();

(function() {  // ■ END Scene_Map.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Spriteset_InterfaceABS.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Spriteset_InterfaceABS.prototype;
  _.showExtraTargetUI = function(targetInfoData) {
    this._destroyETUI();
    if (targetInfoData != null) {
      return this._createEUI(targetInfoData);
    }
  };
  _.terminateETUI = function() {
    return this._destroyETUI();
  };
  _._destroyETUI = function() {
    var ref, ref1, ref2;
    if (this._teui == null) {
      return;
    }
    if ((ref = this.msgText) != null) {
      ref.openness = 0;
    }
    if ((ref1 = this.msgTextBack) != null) {
      ref1.visible = false;
    }
    if (this._teui == null) {
      return;
    }
    if ((ref2 = this._teui.parent) != null) {
      ref2.removeChild(this._teui);
    }
    this._teui.visible = false;
    this._teui.destroy();
    this._teui = null;
  };
  _._createEUI = function(targetInfoData) {
    var nameSpriteE, portrait;
    this._teui = new Sprite();
    if (targetInfoData.portrait != null) {
      portrait = new AA.LIBS.SpriteActorPortrait(4, targetInfoData.portrait);
      this._teui.addChild(portrait);
    }
    if (targetInfoData.name != null) {
      nameSpriteE = new AA.LIBS.SpriteUIElement('ExtraTargetName');
      nameSpriteE.drawTextOnReady(targetInfoData.name);
      this._teui.addChild(nameSpriteE);
    }
    if (targetInfoData.iconIndex != null) {
      nameSpriteE = new AA.LIBS.SpriteUIElement('ExtraTargetIcon');
      nameSpriteE.drawExtraIcon(targetInfoData.iconIndex);
      this._teui.addChild(nameSpriteE);
    }
    if (targetInfoData.message != null) {
      this._createEUITMsg();
      this.msgText.infoData = {
        text: targetInfoData.message
      };
      this.msgText._setText();
      this.msgText.contents.clear();
      this.msgText.openness = 255;
      this.msgText.update();
      this.msgText.contents.outlineWidth = 2;
      this.msgText._setText();
      this.msgTextBack.visible = true;
    }
    return this.addChild(this._teui);
  };
  _._createEUITMsg = function() {
    var msgSpriteE;
    if (this.msgText != null) {
      return;
    }
    msgSpriteE = new AA.LIBS.SpriteUIElement('ExtraTargetMessage');
    if (msgSpriteE.visible === false) {
      return;
    }
    this.addChild(msgSpriteE);
    this.msgText = new AA.LIBS.Window_EventInfo({
      background: 2,
      text: ""
    }, msgSpriteE.settings.textZoneWidth, msgSpriteE.settings.textZoneHeight);
    this.msgText.lineHeight = function() {
      return msgSpriteE.settings.fontSize + 2;
    };
    if (msgSpriteE.settings.fontFace != null) {
      this.msgText.standardFontFace = function() {
        return msgSpriteE.settings.fontFace;
      };
    }
    this.msgText.standardFontSize = function() {
      return msgSpriteE.settings.fontSize;
    };
    this.msgText.standardPadding = function() {
      return 2;
    };
    this.msgText.textPadding = function() {
      return 2;
    };
    this.addChild(this.msgText);
    this.msgText.x = msgSpriteE.x - 12;
    this.msgText.y = msgSpriteE.y - 12;
    this.msgTextBack = msgSpriteE;
  };
})();

(function() {  // ■ END Spriteset_InterfaceABS.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ BattleUI.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.BattleUI;
  _.lastETUIItem = null;
  _.showExtraTargetUI = function(eventId) {
    var e, event, infoData, ref;
    try {
      if (this._ui == null) {
        return;
      }
      event = $gameMap.event(eventId);
      if (event != null) {
        infoData = event.extraTargetData();
        if (infoData === _.lastETUIItem) {
          return;
        }
        this._ui.showExtraTargetUI(infoData);
        if (this._lastUITaget != null) {
          this._ui.showTarget(null);
        }
        return this.lastETUIItem = infoData;
      } else {
        _.hideExtraTargetUI();
        if (this._lastUITaget !== null) {
          return (ref = this._ui) != null ? ref.showTarget(this._lastUITaget) : void 0;
        }
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _.hideExtraTargetUI = function() {
    if (this._ui == null) {
      return;
    }
    this._ui.showExtraTargetUI(null); // * Hide
    return this.lastETUIItem = null;
  };
  _.previewTarget = function(target) {
    var ref, ref1;
    if (this.lastETUIItem != null) {
      return;
    }
    if (target != null) {
      if ((this._lastUITaget != null) && !AA.Parameters.get_IsPreviewTargetByMouseWhenTargetSelected()) {
        return;
      }
      return (ref = this._ui) != null ? ref.showTarget(target) : void 0; //Nullable
    } else {
      if (this._lastUITaget != null) {
        return this.showTarget(this._lastUITaget);
      } else {
        return (ref1 = this._ui) != null ? ref1.showTarget(null) : void 0;
      }
    }
  };
})();

// ■ END BatleUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PartyUIActorController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.PartyUIActorController.prototype;
  _._createAB = function() {
    if (this._barrierAbHpCntr != null) {
      return;
    }
    this._createABGauge();
    return this._createABIcon();
  };
  _._createABGauge = function() {
    var e, elementId;
    try {
      elementId = this.actor._absParams.barrierElementId;
      this._barrierAbGSprite = new AA.LIBS.Sprite_BarrierGaugeAlly(elementId);
      this._barrierBase.addChild(this._barrierAbGSprite);
      this._barrierAbHpCntr = new AA.LIBS.BarrierGaugeController(this._barrierAbGSprite);
      this._barrierAbHpCntr.setup(this.actor);
      this._barrierAbHpCntr.update();
      return this._updateAB = this._updateABCntrl.bind(this);
    } catch (error) {
      e = error;
      AA.warning(e);
      this._barrierAbHpCntr = null;
      return this._updateAB = function() {}; // * EMPTY
    }
  };
  _._createABIcon = function() {
    var e, elementId, pos, ref;
    try {
      elementId = this.actor._absParams.barrierElementId;
      this.ab_pl_icon = new AA.LIBS.Sprite_BarrierIcon(elementId);
      pos = AA.JSON.getAbsorbBarriersSettings().iconPositionOnAlly;
      if ((ref = this.ab_pl_icon.back) != null) {
        ref.visible = false;
      }
      if (pos != null) {
        this.ab_pl_icon.move(pos);
      }
      return this.addChild(this.ab_pl_icon);
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _._destroyAB = function() {
    var e;
    try {
      this._updateAB = function() {}; // * EMPTY
      if (this.ab_pl_icon != null) {
        this.removeChild(this.ab_pl_icon);
        this.ab_pl_icon.visible = false;
        this.ab_pl_icon = null;
      }
      if (this._barrierAbHpCntr != null) {
        this._barrierAbHpCntr = null;
      }
      if (this._barrierAbGSprite != null) {
        this._barrierBase.removeChild(this._barrierAbGSprite);
        this._barrierAbGSprite.visible = false;
        this._barrierAbGSprite = null;
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  _._updateAB = function() {}; // * EMPTY, REPLACEABLE
  _._updateABCntrl = function() {
    return this._barrierAbHpCntr.update();
  };
})();

// ■ END PartyUIActorController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AA.LIBS.PartyUIActorController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.PartyUIActorController.prototype;
  _._readSwitchKeys = function() {
    this.aIndex = $gameParty.allMembers().indexOf(this.actor);
    this.key = [AA.LIBS.IKey.SWL1(), AA.LIBS.IKey.SWL2(), AA.LIBS.IKey.SWL3()][this.aIndex - 1];
  };
  _._createSwitchLeaderButton = function() {
    var hotKeyBtnBack, hotKeyText, iconIndex, margins, settings;
    hotKeyBtnBack = new Sprite(new Bitmap(26, 26));
    settings = AA.JSON.getCommonUISettings().PartyUIGroup;
    iconIndex = settings.SwitchLeaderKeyBackIcon;
    if (iconIndex == null) {
      iconIndex = 16;
    }
    hotKeyBtnBack.bitmap.drawIcon(0, 0, iconIndex, 26);
    this.addChild(hotKeyBtnBack);
    hotKeyText = new Sprite(new Bitmap(26, 26));
    hotKeyText.bitmap.fontSize = 16;
    hotKeyText.bitmap.outlineWidth = 2;
    hotKeyText.bitmap.drawTextFull(this.key.toUpperCase(), 'center');
    this.hotKeyText = hotKeyText;
    hotKeyBtnBack.addChild(hotKeyText);
    margins = settings.SwitchLeaderKeysMargins;
    if (margins == null) {
      margins = [180, 24];
    }
    hotKeyBtnBack.x = margins[0];
    hotKeyBtnBack.y = margins[1];
  };
  _._updateLeaderSwitch = function() {
    // * Не работает, если отключён плагин (не создан UI)
    if (this.hotKeyText == null) {
      return;
    }
    if (TouchInput.isTriggered()) {
      if (this.isUnderMouse()) {
        this._onFaceClick();
        TouchInput.clear();
      }
    }
    if (Input.isTriggered(this.key)) {
      this._onFaceClick();
    }
  };
  _._onFaceClick = function() {
    var nextActor;
    nextActor = $gameParty.allMembers()[this.aIndex];
    if (!AA.Parameters.isLeaderSwapAllowedInBattle()) {
      if ($gamePlayer.inBattle()) {
        AA.UI.alertNotInDuringBattle();
        return;
      }
    }
    if (nextActor.isAlive()) {
      this._changePartyLeader();
    } else {
      SoundManager.playBuzzer();
    }
  };
  _._changePartyLeader = function() {
    var actorId, ce, i, len, m, ref;
    actorId = $gameParty.allMembers()[this.aIndex].actorId();
    $gameParty.swapLeader(actorId);
    $gamePlayer.refresh();
    setTimeout((function() {
      return $gamePlayer.refresh();
    }), 20);
    ref = $gameParty.allMembers();
    for (i = 0, len = ref.length; i < len; i++) {
      m = ref[i];
      m.refresh();
    }
    ce = AA.Parameters.getCommonEventOnLeaderSwap();
    if (ce > 0) {
      $gameTemp.reserveCommonEvent(ce);
    }
  };
  _.isUnderMouse = function() {
    var r;
    r = this.faceSprite._face.inPosition(TouchInput);
    return r;
  };
})();

// ■ END AA.LIBS.PartyUIActorController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCastAlly.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellCastAlly;
  SpriteSpellCastAlly = class SpriteSpellCastAlly extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getAllySpellCastSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteSpellCastAlly);
})();

// ■ END SpriteSpellCastAlly.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SummonCircle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_UIAllyBehCircle;
  Sprite_UIAllyBehCircle = class Sprite_UIAllyBehCircle extends AlphaABS.LIBS.UI_SelectCircle {
    constructor(callHandler) {
      var icons;
      super(ImageManager.loadAA("Circle_segment"), false, 24);
      this.callHandler = callHandler;
      this.refresh();
      this._setHelpers();
      this.addClickListener(0, (function() {
        return this.callHandler(0);
      }).bind(this));
      this.addClickListener(1, (function() {
        return this.callHandler(1);
      }).bind(this));
      this.addClickListener(2, (function() {
        return this.callHandler(2);
      }).bind(this));
      this.addClickListener(3, (function() {
        return this.callHandler(3);
      }).bind(this));
      icons = [ImageManager.loadAA("PartyBeh_Support"), ImageManager.loadAA("SummonBeh_AttackAll"), ImageManager.loadAA("SummonBeh_AttackTarget"), ImageManager.loadAA("SummonBeh_Protect")];
      AA.setTimeout((() => {
        return this.setIcons(icons);
      }), 500);
    }

    refresh() {
      var behIndex, unit;
      this.deselectAll();
      unit = $gameParty.selectedAllyByPlayer();
      if (unit != null) {
        behIndex = unit.AAEntity().behaviorMode();
        if (behIndex === 3) {
          this.select(0);
        } else {
          this.select(behIndex + 1);
        }
      }
    }

    _setHelpers() {
      var x;
      x = AlphaABS.LIBS.IKey;
      this.setHelper(x.convertIKeyToLetter(x.SC_W()).toUpperCase(), 0);
      this.setHelper(x.convertIKeyToLetter(x.SC_D()).toUpperCase(), 1);
      this.setHelper(x.convertIKeyToLetter(x.SC_S()).toUpperCase(), 2);
      return this.setHelper(x.convertIKeyToLetter(x.SC_A()).toUpperCase(), 3);
    }

    isTouchedAny() {
      if (this.visible === true) {
        return this._inputs.some(function(i) {
          return i.isButtonTouched();
        });
      } else {
        return false;
      }
    }

  };
  AlphaABS.register(Sprite_UIAllyBehCircle);
})();

// ■ END UI_SummonCircle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpritesetAA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = SpritesetAA.prototype;
})();

// ■ END SpritesetAA.coffee
//---------------------------------------------------------------------------
//_.hideFirearmPanel = ->

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpritesetAA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = SpritesetAA.prototype;
  _._createGaugeController = function(gauge, actor, value, maxValue, inPercent) {
    var cntrl;
    cntrl = new AA.LIBS.GaugeController(gauge);
    if (inPercent != null) {
      if (inPercent) {
        cntrl.setPercentText();
      } else {
        cntrl.setFullValueText();
      }
    }
    cntrl.setup(actor, value, maxValue);
    return cntrl;
  };
})();

// ■ END SpritesetAA.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpritesetAA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = SpritesetAA.prototype;
  
  //! THIS METHOD NOT USED!
  _._createTargetUI = function(target) {
    var e;
    try {
      if (!target.isABS()) {
        return;
      }
      this._targetUIBase = new Sprite();
      this.addChild(this._targetUIBase);
      this.__lastTarget = target;
      this.__tBattler = target.AABattler();
      if (this.__tBattler == null) {
        return;
      }
      this._createTargetPortrait(target);
      this._createTargetGauges();
      //@_createTargetName()
      //@_createTargetSpellCastBar()
      return this.__tBattler = null;
    } catch (error) {
      e = error;
      return AA.warning(e, '_createTargetUI');
    }
  };
  //! THIS METHOD NOT USED!
  _._createTargetPortrait = function(target) {
    var aaEntityModel, e, faceIndex, faceName, tFaceSprite;
    try {
      if (target.isEnemy()) {
        aaEntityModel = target.AAEntity().behaviorModel();
        if (aaEntityModel.faceName !== "") {
          faceName = aaEntityModel.faceName;
          faceIndex = aaEntityModel.faceIndex;
        } else {
          return;
        }
      } else {
        faceName = this.__tBattler.faceName();
        faceIndex = this.__tBattler.faceIndex();
      }
      if (AA.isCCEXImproted === true && !target.isEnemy() && this.__tBattler.hasSetImage()) {
        tFaceSprite = new AA.LIBS.SpriteActorPortrait(1, this.__tBattler);
      } else {
        tFaceSprite = new AA.LIBS.SpriteActorPortrait(1, {faceName, faceIndex});
      }
      return this._targetUIBase.addChild(tFaceSprite);
    } catch (error) {
      e = error;
      return AA.warning('_createTargetPortrait', e);
    }
  };
  _._createTargetGauges = function() {
    var e, targetHpGauge;
    try {
      targetHpGauge = new AA.LIBS.SpriteGauge('hpE');
      this._targetHpGaugeCntr = this._createGaugeController(targetHpGauge, this.__tBattler, 'hp', 'mhp', AA.Parameters.isEnemyHPInPercentage());
      return this._targetUIBase.addChild(targetHpGauge);
    } catch (error) {
      e = error;
      return AA.warning('_createTargetGauges', e);
    }
  };
  _._updateTargetUI = function() {
    var ref;
    return (ref = this._targetHpGaugeCntr) != null ? ref.update() : void 0;
  };
  _._destroyTargetUI = function() {
    var ref;
    if (this._targetUIBase == null) {
      return;
    }
    this._targetUIBase.visible = false;
    this.removeChild(this._targetUIBase);
    this._targetUIBase = null;
    this.__lastTarget = null;
    return (ref = this._targetCastBarCnt) != null ? ref.terminate() : void 0;
  };
})();

// ■ END SpritesetAA.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___createHpBar, ALIAS___updateHpBar, _;
  //@[DEFINES]
  _ = AA.LIBS.Sprite_CharacterABS.prototype;
  //@[ALIAS]
  ALIAS___createHpBar = _._createHpBar;
  _._createHpBar = function() {
    var beId;
    ALIAS___createHpBar.call(this);
    beId = this._character.behaviorModel().barrierElemId;
    if (beId > 0) {
      this._createHpBarrierGauge(beId);
    }
  };
  //@[ALIAS]
  ALIAS___updateHpBar = _._updateHpBar;
  _._updateHpBar = function() {
    var ref;
    ALIAS___updateHpBar.call(this);
    if (this._barrierHpSprite == null) {
      return;
    }
    this._barrierHpSprite.visible = (ref = this._character.battler()) != null ? ref.isHaveAbBarrier() : void 0;
    if (this._barrierHpSprite.visible === true) {
      this._barrierHpCntr.setup(this._character.battler());
      return this._barrierHpCntr.update();
    }
  };
  _._createHpBarrierGauge = function(elementId) {
    //settings = AA.JSON.getAbsorbBarriersSettings().barrierHpGauge
    this._barrierHpSprite = new AA.LIBS.Sprite_BarrierGauge(elementId);
    this._hpBarSprite.addChild(this._barrierHpSprite);
    return this._barrierHpCntr = new AA.LIBS.BarrierGaugeController(this._barrierHpSprite);
  };
})();

// ■ END Sprite_CharacterABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_InterfaceABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___createUI13EnemyUI, ALIAS___destroyUI13EnemyUI, _;
  //@[DEFINES]
  _ = AlphaABS.LIBS.Spriteset_InterfaceABS.prototype;
  //@[ALIAS]
  ALIAS___createUI13EnemyUI = _._createUI13EnemyUI;
  _._createUI13EnemyUI = function(target) {
    ALIAS___createUI13EnemyUI.call(this, target);
    if (target.battler().isHaveAbBarrier()) {
      return this._createBarrierUI(target);
    }
  };
  _._createBarrierUI = function(target) {
    var b;
    b = target.battler();
    this._lastBarrierBattler = b;
    this._barrierIconSpr = new AA.LIBS.Sprite_BarrierIcon(b._absParams.barrierElementId);
    return this.addChild(this._barrierIconSpr);
  };
  //@[ALIAS]
  ALIAS___destroyUI13EnemyUI = _._destroyUI13EnemyUI;
  _._destroyUI13EnemyUI = function() {
    ALIAS___destroyUI13EnemyUI.call(this);
    return this._removeBarrierInfo();
  };
  _._removeBarrierInfo = function() {
    if (this._barrierIconSpr != null) {
      this.removeChild(this._barrierIconSpr);
    }
    return this._lastBarrierBattler = null;
  };
  _.refreshBarrierInfo = function(battler) {
    if (battler === this._lastBarrierBattler) {
      if (!battler.isHaveAbBarrier()) {
        this._removeBarrierInfo();
      }
    }
  };
})();

// ■ END Spriteset_InterfaceABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AlphaABS.LIBS.Spriteset_InterfaceABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AlphaABS.LIBS.Spriteset_InterfaceABS.prototype;
  _.refreshPlayerABGaugeAndIcon = function() {
    var b, ref;
    if ((ref = this.partyUIGroup) != null) {
      ref.refreshBarriers();
    }
    b = $gamePlayer.battler();
    if ((b != null) && b.isHaveAbBarrier()) {
      this._createABUI(b);
    } else {
      this._destoryABUI();
    }
  };
  _._createABUI = function(battler) {
    this._createABGauge(battler);
    return this._createABIcon(battler);
  };
  _._createABGauge = function(battler) {
    var e, elementId;
    try {
      elementId = battler._absParams.barrierElementId;
      this._barrierAbGSprite = new AA.LIBS.Sprite_BarrierGaugePlayer(elementId);
      this.addChild(this._barrierAbGSprite);
      this._barrierAbHpCntr = new AA.LIBS.BarrierGaugeController(this._barrierAbGSprite);
      this._barrierAbHpCntr.setup(battler);
      return this._barrierAbHpCntr.update();
    } catch (error) {
      e = error;
      AA.warning(e);
      return this._barrierAbHpCntr = null;
    }
  };
  _._createABIcon = function(battler) {
    var e, pos, ref;
    try {
      this.ab_pl_icon = new AA.LIBS.Sprite_BarrierIcon(battler._absParams.barrierElementId);
      pos = AA.JSON.getAbsorbBarriersSettings().iconPositionOnPlayer;
      if ((ref = this.ab_pl_icon.back) != null) {
        ref.visible = false;
      }
      if (pos != null) {
        this.ab_pl_icon.move(pos);
      }
      return this.addChild(this.ab_pl_icon);
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _._destoryABUI = function() {
    var e;
    try {
      if (this.ab_pl_icon != null) {
        this.removeChild(this.ab_pl_icon);
        this.ab_pl_icon.visible = false;
        this.ab_pl_icon = null;
      }
      if (this._barrierAbHpCntr != null) {
        this._barrierAbHpCntr = null;
      }
      if (this._barrierAbGSprite != null) {
        this.removeChild(this._barrierAbGSprite);
        this._barrierAbGSprite.visible = false;
        this._barrierAbGSprite = null;
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
})();

// ■ END AlphaABS.LIBS.Spriteset_InterfaceABS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AADBEditorManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AADBEditorManager;
  _.getCurrentValueForParam = function(enemy, param) {
    if (enemy.meta[param] != null) {
      return enemy.meta[param];
    } else {
      return AADBEditorManager.getDefaultValueForParam(param);
    }
  };
  _.getDefaultValueForParam = function(param) {
    return AIBehavModel.DEFAULT[param];
  };
  _.convertParam = function(param, typeIndex) {
    switch (typeIndex) {
      case 0:
        return "<" + param + ":X>";
      case 1:
        return "<" + param + ":Z>";
      case 2:
        if (['faceName', 'HPBarStyle'].contains(param)) {
          return "<" + param + ":S>";
        } else {
          return "<" + param + ":X>";
        }
        break;
      default:
        return "<" + param + ":?>";
    }
  };
  _.getParamTypeIndex = function(param) {
    var booleans, numbers, options;
    numbers = ['viewRadius', 'returnRadius', 'reviveTime', 'teamId', 'motionOffset', 'motionADelay', 'motionFrames', 'motionDelay', 'faceIndex', 'level', 'noFightIfLvlBelow', 'runAwayIfLvlBelow', 'barrierHp', 'tVisor', 'teleportDist', 'teleportOut', 'teleportRest', 'teleportRate', 'reviveMaxCount'];
    if (numbers.contains(param)) {
      return 0;
    }
    booleans = ['escapeOnBattle', 'canSearch', 'noFight', 'regen', 'agressive', 'noMove', 'noEmote', 'slow', 'rage', 'ignoreObstacles', 'heavy', 'showHP', 'motion', 'motionX', 'motionWait', 'sChangeModeAllowed', 'canLooting', 'sideVisor'];
    if (booleans.contains(param)) {
      return 1;
    }
    options = ['returnType', 'cEonStart', 'cEonEnd', 'cEonDeath', 'cEinBattle', 'faceName', 'HPBarStyle', 'sBattleMode', 'barrierElemId', 'supportSkillId', 'cEvIfLvlNotSame'];
    if (options.contains(param)) {
      return 2;
    }
    return -1;
  };
  _.getParameterDescription = function(param) {
    switch (param) {
      case 'viewRadius':
        return ["On how many map cells sees enemy around himself", null];
      case 'returnRadius':
        return ["How many cells maximum enemy can escape", "from the last position where he fought"];
      case 'escapeOnBattle':
        return ["Escape from player during a battle when there is", "no available actions or waiting for attack cooldown"];
      case 'canSearch':
        return ["Can enemy hear everything happening around him", "(the reaction to the battle near (in the area of <viewRadius>))"];
      case 'noFight':
        return ["Enemy no fight at all, like Dummy"];
      case 'reviveTime':
        return ["Time (in seconds) to reborn after death", "0 - no revive at all"];
      case 'reviveMaxCount':
        return ["Limit of the revives count on current map"];
      case 'returnType':
        return ["How enemy return to home after chasing"];
      case 'levelRange':
        return ["Random level from Range !(Check Wiki)"];
      case 'regen':
        return ["Out of combat health regeneration"];
      case 'slow':
        return ["Enemy will not accelerating in pursuit"];
      case 'rage':
        return ["Switch the target to the one who caused more damage"];
      case 'ignoreObstacles':
        return ["See through restricted regions", "See plugin parameter: Solid Regions"];
      case 'heavy':
        return ["Ignore <impulse> skill effect"];
      case 'showHP':
        return ["Mini HP Bar always visible", "See plugin parameter: Show mini HP bars"];
      case 'agressive':
        return ["Always approach the player"];
      case 'noMove':
        return ["Enemy can't moving during battle"];
      case 'noEmote':
        return ["No balloon animations above head"];
      case 'cEonStart':
        return ["Common event when this enemy starts fight (engaged in battle)"];
      case 'cEonEnd':
        return ['Common event when this enemy leave battle'];
      case 'cEonDeath':
        return ['Common event when this enemy is died'];
      case 'cEinBattle':
        return ['Common event when enemy in battle', 'Called every second!'];
      case 'motion':
        return ['Enemy using battle motion', 'Motion System'];
      case 'motionOffset':
        return ['Offset for motion image by Y coordinate', "Require <motion> parameter is ON (1)"];
      case 'faceName':
        return ['Image name for Target UI face', 'From img/faces folder'];
      case 'faceIndex':
        return ['Face index on face image', 'Require <faceName> not Empty'];
      case 'HPBarStyle':
        return ['Enemy mini HP bar on map style ID', 'See data/AABS/UIGauges.json'];
      case 'canLooting':
        return ['Can looting enemies', "Only for summoned unit"];
      case 'supportSkillId':
        return ["1. Support skill for summoned unit", "2. Support skill for heal self and other enemies"];
      case 'sBattleMode':
        return ["Standard battle mode", "Only for summoned unit"];
      case 'sChangeModeAllowed':
        return ["Can player change summon unit battle mode in game?"];
      case 'level':
        return ["Enemy level"];
      case 'noFightIfLvlBelow':
        return ["If player level is X more than monster level", "then monster will not attack the player"];
      case 'runAwayIfLvlBelow':
        return ["If player level is X more than monster level", "then monster will run away from player"];
      case 'cEvIfLvlNotSame':
        return ["If player level > the enemy level then start common event"];
      case 'barrierElemId':
        return ["Absorb barrier Element ID", "When your attack is same element, damage will go to the barrier HP"];
      case 'barrierHp':
        return ["Amount of Absorb barrier durability (HP)", "Require <barrierElemId> parameter > 0"];
      case 'teleportDist':
        return ["Teleport max distance to approach target"];
      case 'teleportOut':
        return ["Teleport max distance to escape from target", "Require <escapeOnBattle> parameter is ON (1)"];
      case 'teleportRest':
        return ["Cooldown time between teleports", "Require <teleportDist> or <teleportOut> > 0"];
      case 'teleportRate':
        return ["Chance to apply teleport movement", "Require <teleportDist> or <teleportOut> > 0"];
      case 'tVisor':
        return ["Triangle view mode", "X - triangle base length"];
      case 'sideVisor':
        return ["Extra peripheral vision", "Require <tVisor> parameter > 0"];
      case 'teamId':
        return ["Enemies in same team no fight each others", "0 - enemy will be player ally"];
      case 'motionX':
        return ["Enemy using battle motion", "Motion System 2"];
      case 'motionADelay':
        return ["Delay between frames when attack animation playing"];
      case 'motionDelay':
        return ["Delay between frames when base and in battle animation playing"];
      case 'motionFrames':
        return ["Motion Animation frames count"];
      case 'motionWait':
        return ["Able to move (acting) only after Motion Action is ended"];
      default:
        return ["No description, try search on Wiki Page"];
    }
  };
  _.getParameterWiki = function(param) {
    switch (param) {
      case 'level':
      case 'noFightIfLvlBelow':
      case 'levelRange':
      case 'runAwayIfLvlBelow':
      case 'cEvIfLvlNotSame':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Enemy-Level-System";
      case 'motionX':
      case 'motionADelay':
      case 'motionDelay':
      case 'motionFrames':
      case 'motionOffset':
      case 'motionWait':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Motion-System-2";
      case 'motion':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Motion-System";
      case 'canLooting':
      case 'sBattleMode':
      case 'sChangeModeAllowed':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Summon-System";
      case 'supportSkillID':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Support-Ally-Ability";
      case 'barrierElemId':
      case 'barrierHp':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Absorb-Barriers";
      case 'tVisor':
      case 'sideVisor':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Enemy-Vision";
      case 'teleportDist':
      case 'teleportOut':
      case 'teleportRest':
      case 'teleportRate':
        return "https://github.com/KageDesu/Alpha-ABS/wiki/Teleport-Ability";
      default:
        return null;
    }
  };
  _.getTypeTextForParam = function(param) {
    switch (param) {
      case 'viewRadius':
      case 'returnRadius':
      case 'teleportDist':
      case 'teleportOut':
      case 'tVisor':
        return "map cells";
      case 'reviveTime':
      case 'teleportRest':
        return "seconds";
      case 'cEonStart':
      case 'cEonEnd':
      case 'cEonDeath':
      case 'cEinBattle':
      case 'cEvIfLvlNotSame':
        return 'common event Id';
      case 'teleportRate':
        return "%";
      case 'motionOffset':
        return 'pixels by Y';
      case 'motionFrames':
        return 'frames count';
      case 'teamId':
        return 'team number';
      case 'supportSkillId':
        return 'skill Id';
      case 'barrierElemId':
        return 'element id';
      default:
        return "";
    }
  };
  _.convertOptionValueForParam = function(param, value) {
    switch (param) {
      //when 'supportSkillId'
      //    if value == 0
      //        return "<nothing>"
      //    else
      //        return $dataSkills[value].name
      case 'returnType':
        return ['Instant', 'Walk', 'None'][value];
      case 'sBattleMode':
        return ['All', 'Target', 'Protect'][value];
      case 'barrierElemId':
        if (value === 0) {
          return "0";
        } else {
          return value + " (" + $dataSystem.elements[value] + ")";
        }
        break;
      default:
        return value;
    }
  };
  _.getNotSupportedOrImplementedMessage = function(param) {
    var text;
    text = "";
    switch (param) {
      case "levelRange":
        text = "This parameter can be used only in Event Comment";
        break;
      default:
        text = "This Parameter not implemeted in Editor";
    }
    return text;
  };
  _.checkNewValueForParam = function(value, param) {
    var typeIndex;
    typeIndex = AADBEditorManager.getParamTypeIndex(param);
    switch (typeIndex) {
      case 0:
        if (value < 0) {
          return 0;
        }
        return value;
      case 1:
        value = parseInt(value);
        if (value === 0 || value === 1) {
          return value;
        }
        return 0;
      case 2:
        value = AADBEditorManager.checkOptionValue(value, param);
        if (param === "faceName" && value === 0) {
          value = "";
        }
        return value;
      default:
        return value;
    }
  };
  // * По идеи списки формируются, так что не правильных быть не должно
  _.checkOptionValue = function(value, param) {
    return value;
  };
  _.modifyEnemyDBValue = function(enemy, value, param) {
    var e, enemyData, id;
    try {
      id = enemy.id;
      if ($gameTemp._aaDBmodifiedEnemies == null) {
        $gameTemp._aaDBmodifiedEnemies = [];
      }
      if (!$gameTemp._aaDBmodifiedEnemies.contains(id)) {
        $gameTemp._aaDBmodifiedEnemies.push(id);
      }
      enemyData = $dataEnemies[id];
      value = AADBEditorManager.checkNewValueForParam(value, param);
      AADBEditorManager.writeParamValueToNote(enemyData, param, value);
      return enemyData.meta[param] = value;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.writeParamValueToNote = function(enemyData, param, value) {
    //<faceName:Monster>↵<simple:44>↵<faceIndex:0>↵
    if (this._isParamExistsInNote(enemyData.note, param)) {
      enemyData.note = this._removeParamFromNote(enemyData.note, param);
      return enemyData.note = this._insertParamInNote(enemyData.note, param, value);
    } else {
      return enemyData.note = this._insertParamInNote(enemyData.note, param, value);
    }
  };
  _._isParamExistsInNote = function(note, param) {
    var regex;
    regex = this._getParamRegExp(param);
    return note.match(regex) != null;
  };
  _._getParamRegExp = function(param) {
    return new RegExp("<" + param + ":(.*)>");
  };
  _._removeParamFromNote = function(note, param) {
    var i, l, len, lines, noteX, regex;
    regex = this._getParamRegExp(param);
    note = note.replace(regex, "");
    lines = note.split("\n");
    noteX = "";
    for (i = 0, len = lines.length; i < len; i++) {
      l = lines[i];
      if (l !== "") {
        noteX += l;
        noteX += "\n";
      }
    }
    return noteX;
  };
  _._insertParamInNote = function(note, param, value) {
    var replacer;
    if (param === 'faceName' && value === 0) {
      value = "";
    }
    if (value === this.getDefaultValueForParam(param)) {
      return note;
    }
    replacer = "<" + param + ":" + value + ">";
    note += replacer;
    note += "\n";
    return note;
  };
})();

// ■ END AADBEditorManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Fog Of War.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {  /* * FOGWAR ========================================================== */
  var _;
  _ = AA.FOGWAR;
  _.CACHE = {};
  _.SET = null; //?[PRE]
  _.getFogOpenRadius = function() {
    return AA.Utils.getVar(_.SET.fogOpenRadiusVarId);
  };
  _.isReady = function() {
    return _.ready === true;
  };
  _.drawFogOnMap = function() {
    var i, j, k, l, r, ref, ref1, storedFogData;
    _.SET = AAJsonSettings.getFogOfWarSettings();
    storedFogData = $gamePlayer.getFogForMap();
    _.fogMapData = [];
    _.outerFogMapData = [];
    if (storedFogData == null) {
      for (i = k = 0, ref = $gameMap.width(); (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        for (j = l = 0, ref1 = $gameMap.height(); (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
          r = $gameMap.regionId(i, j);
          if (_.isRegionHasFog(r)) {
            _.drawFogOnRegionIn(r, i, j);
          }
        }
      }
      _.drawFogOutline();
    } else {
      _._createFogFromStore(storedFogData);
    }
    _.ready = true;
  };
  _.isRegionHasFog = function(r) {
    return _.SET.fogRegions.indexOf(r) >= 0;
  };
  _.drawFogOnRegionIn = function(r, x, y) {
    var bitmap, fogData, fx, fy, s;
    fx = _.convertXToScreen(x);
    fy = _.convertYToScreen(y);
    fogData = _.getFogDataForRegion(r);
    bitmap = _.getBitampForColor(fogData.color);
    s = new _.MFSprite(bitmap);
    s.regionId = r;
    s.opacity = fogData.opacity;
    s.move(fx, fy);
    _.addFogOnMap(s);
    return _.fogMapData.push([x, y]);
  };
  _.convertXToScreen = function(x) {
    return x * 48;
  };
  _.convertYToScreen = function(y) {
    return y * 48;
  };
  _.getFogDataForRegion = function(r) {
    return _.SET.fogSettingsA;
  };
  _.getBitampForColor = function(color) {
    var b;
    if (_.CACHE[color] != null) {
      return _.CACHE[color];
    } else {
      b = new Bitmap(48, 48);
      b.fillAll(KDCore.Color.FromHex(color));
      _.CACHE[color] = b;
      return b;
    }
  };
  _.addFogOnMap = function(fogSprite) {
    return SceneManager._scene._spriteset._aafogLayer.addChild(fogSprite);
  };
  _.getSprites = function() {
    return SceneManager._scene._spriteset._aafogLayer.children;
  };
  _.drawFogOutline = function() {
    var i, k, point, ref, results;
    results = [];
    for (i = k = 0, ref = _.fogMapData.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      point = _.fogMapData[i];
      results.push(_.setNeibPoints(point));
    }
    return results;
  };
  _.setNeibPoints = function(point) {
    var newPoint, r, spr;
    spr = _.getFogSpriteByPoint(point);
    r = spr.regionId;
    // * RIGHT
    newPoint = [point[0] + 1, point[1]];
    _.createOuterPoint(newPoint, r);
    // * LEFT
    newPoint = [point[0] - 1, point[1]];
    _.createOuterPoint(newPoint, r);
    // * UP
    newPoint = [point[0], point[1] - 1];
    _.createOuterPoint(newPoint, r);
    // * DOWN
    newPoint = [point[0], point[1] + 1];
    return _.createOuterPoint(newPoint, r);
  };
  _.createOuterPoint = function(newPoint, r) {
    var b, fogData, s;
    if (_.isCanCreateOuterPoint(newPoint)) {
      _.registerOuterPoint(newPoint);
      fogData = _.SET.fogSettingsB;
      b = _.getBitampForColor(fogData.color);
      s = new _.MFSprite(b);
      s.regionId = r;
      s.opacity = fogData.opacity;
      s.setBColor();
      s.move(newPoint[0] * 48, newPoint[1] * 48);
      return _.addFogOnMap(s);
    }
  };
  _.isCanCreateOuterPoint = function(point) {
    if (_.isOutOfMap(point)) {
      return false;
    }
    if (_.isBusyByFog(point)) {
      return false;
    }
    if (_.isHasOuterPoint(point)) {
      return false;
    }
    return true;
  };
  _.isOutOfMap = function(point) {
    return point[0] >= $gameMap.width() || point[1] > $gameMap.height() || point[0] < 0 || point[1] < 0;
  };
  _.isBusyByFog = function(newPoint) {
    var i, k, point, ref;
    for (i = k = 0, ref = _.fogMapData.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      point = _.fogMapData[i];
      if (point[0] === newPoint[0] && point[1] === newPoint[1]) {
        return true;
      }
    }
    return false;
  };
  _.isHasOuterPoint = function(newPoint) {
    var i, k, point, ref;
    for (i = k = 0, ref = _.outerFogMapData.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      point = _.outerFogMapData[i];
      if (point[0] === newPoint[0] && point[1] === newPoint[1]) {
        return true;
      }
    }
    return false;
  };
  _.registerOuterPoint = function(point) {
    return _.outerFogMapData.push(point);
  };
  _.openFogFromPoint = function(x, y) {
    var b;
    b = _.getFogOpenRadius();
    if (b === 0) {
      return;
    }
    _._openFromPointInRaidius(x, y, b, "C");
    return _._openFromPointInRaidius(x, y, b + 1, "B");
  };
  _._openFromPointInRaidius = function(x, y, r, type) {
    var fogS, i, ignored, inRadius, k, point, ref, results;
    inRadius = _.getFogPointsInRadius(x, y, r);
    results = [];
    for (i = k = 0, ref = inRadius.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      point = inRadius[i];
      fogS = _.getFogSpriteByPoint(point);
      if (fogS != null) {
        ignored = _.getIgnoredRegion();
        if (fogS.isProperRegion(ignored)) {
          if (fogS._finalFade !== true) {
            fogS["startFade" + type]();
          }
          if (type === "C") {
            results.push(_.fogMapData.delete(point));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  _.getFogPointsInRadius = function(x, y, r) {
    var cells, i, k, point, ref, result;
    result = [];
    cells = _.fogMapData.concat(_.outerFogMapData);
    for (i = k = 0, ref = cells.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      point = cells[i];
      if ($gameMap.distance(x, y, point[0], point[1]) <= r) {
        result.push(point);
      }
    }
    return result;
  };
  _.getFogSpriteByPoint = function(point) {
    var i, k, px, py, ref, s, spr;
    s = _.getSprites();
    px = point[0] * 48;
    py = point[1] * 48;
    for (i = k = 0, ref = s.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      spr = s[i];
      if (spr.x === px && spr.y === py) {
        return spr;
      }
    }
    return null;
  };
  // * Возвращяет номер региона, на котором сейчас нельзя открывать туман
  _.getIgnoredRegion = function() {
    var pr;
    pr = $gamePlayer.getRegionIdUnder();
    if (_.SET.fogIgnorePairs[pr] != null) {
      return _.SET.fogIgnorePairs[pr];
    } else {
      return null;
    }
  };
  _._createFogFromStore = function(storedFog) {
    var bitmap, color, fx, fy, i, k, len, s;
    _.fogMapData = [];
    _.outerFogMapData = [];
    for (k = 0, len = storedFog.length; k < len; k++) {
      i = storedFog[k];
      _.fogMapData.push(i.point);
      fx = _.convertXToScreen(i.point[0]);
      fy = _.convertYToScreen(i.point[1]);
      color = _.SET.fogSettingsA.color;
      if (i.color === 1) {
        color = _.SET.fogSettingsB.color;
      }
      bitmap = _.getBitampForColor(color);
      s = new _.MFSprite(bitmap);
      if (i.color === 1) {
        s.setBColor();
      }
      s.regionId = i.r;
      s.opacity = i.op;
      s.move(fx, fy);
      _.addFogOnMap(s);
    }
    return _.openFogFromPoint($gamePlayer.x, $gamePlayer.y);
  };
  _.saveFogForMap = function() {
    var cell, fogDataStore, i, k, len, points, s;
    if (_.fogMapData == null) {
      return;
    }
    fogDataStore = [];
    points = _.fogMapData.concat(_.outerFogMapData);
    for (k = 0, len = points.length; k < len; k++) {
      i = points[k];
      s = _.getFogSpriteByPoint(i);
      if (s == null) {
        continue;
      }
      cell = {
        point: i,
        color: s._getColorForSave(),
        op: s.opacity,
        r: s.regionId
      };
      fogDataStore.push(cell);
    }
    return $gamePlayer.saveFogForMap(fogDataStore);
  };
})();

(function() {  /* * MFSPRITE ====================================================== */
  var _;
  _ = AA.FOGWAR.MFSprite.prototype;
  _._onStart = function() {
    this.regionId = 0;
    this._fadeTimer = 0;
    this._fadeTick = 5;
    this._fadeSpeed = 1;
    this._fadeRange = 0;
    this._needFade = false;
    this._finalFade = false;
    return this._colorId = 0;
  };
  
  // * HALF
  _.startFadeA = function() {
    this._needFade = true;
    this._fadeRange = Math.round(this.opacity / 2);
    this._fadeSpeed = 2;
    return this._fadeTick = 6;
  };
  // * 1 / 4
  _.startFadeB = function() {
    this._needFade = true;
    this._fadeRange = Math.round(this.opacity / 2);
    this._fadeSpeed = AA.FOGWAR.SET.fadeSettingsB.fadeSpeed;
    return this._fadeTick = AA.FOGWAR.SET.fadeSettingsB.fadeTick;
  };
  // * FULL
  _.startFadeC = function() {
    this._needFade = true;
    this._fadeRange = 0;
    this._fadeSpeed = AA.FOGWAR.SET.fadeSettingsA.fadeSpeed;
    this._fadeTick = AA.FOGWAR.SET.fadeSettingsA.fadeTick;
    return this._finalFade = true;
  };
  _.testFade = function() {
    return this.bitmap.fillAll(KDCore.Color.RED);
  };
  _.isFading = function() {
    return this._needFade === true;
  };
  _.isProperRegion = function(igroredRegion) {
    if (igroredRegion == null) {
      return true;
    }
    return igroredRegion.indexOf(this.regionId) < 0;
  };
  _.update = function() {
    Sprite.prototype.update.call(this);
    if (this.__destroyed === true) {
      return;
    }
    //@_updatePositionOnMap()
    if (this._needFade === false) {
      return;
    }
    this._fadeTimer++;
    if (this._fadeTimer >= this._fadeTick) {
      this.opacity -= this._fadeSpeed;
      this._fadeTimer = 0;
      if (this.opacity <= this._fadeRange) {
        this._needFade = false;
        if (this._finalFade === true) {
          return this._destroy();
        }
      }
    }
  };
  _.setBColor = function() {
    return this._colorId = 1;
  };
  _._updatePositionOnMap = function() {};
  _._getColorForSave = function() {
    return this._colorId;
  };
  _._destroy = function() {
    var ref;
    this.__destroyed = true;
    this.visible = false;
    return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
  };
})();

// ■ END Fog Of War.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASpellPanelManagerMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AASpellPanelManagerMenu;
  AASpellPanelManagerMenu = class AASpellPanelManagerMenu extends AA.LIBS.AASpelllPanelManager {
    constructor() {
      super();
    }

    _createThread() {} //?EMPTY

    isVisibleWhenEmpty() {
      return true;
    }

    move(x, y) {
      return this._baseSprite.move(x, y);
    }

    refresh() {
      super.refresh();
      return this.newSpellPanelUIElement.applyMenuPosition();
    }

    //$[OVER BASE]
    update() {
      return this.newSpellPanelUIElement.update();
    }

    //@_updateInfo()

      //$[OVER BASE]
    _drawItemInputSymbol(item, index, skill) {
      var sym;
      if (Utils.isMobileDevice()) {
        return;
      }
      sym = this._getKeySymbol(index);
      return item.drawText(sym);
    }

  };
  AA.register(AASpellPanelManagerMenu);
})();

// ■ END AASpellPanelManagerMenu.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASpriteASEI_Cell.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AASpriteASEI_Cell;
  AASpriteASEI_Cell = class AASpriteASEI_Cell extends AA.LIBS.Sprite_MapInvCell {
    constructor(index) {
      super(index);
    }

    
      // * NO ITEMS
    refreshSpecialState() {
      if (this.item == null) {
        return;
      }
      this._checkUsableThread = null;
      return this._refreshEquipmentState();
    }

    _refreshEquipmentState() {
      var equips, i, j;
      // * Фильтр в контроллере, тут не проверям
      //canEquip = $gameTemp._aaStatusWindowEquipInvActor.canEquip(@item)
      //@disableItem() unless canEquip
      this.whoCanEquip = [$gameTemp._aaStatusWindowEquipInvActor.actorId()];
      equips = $gameTemp._aaStatusWindowEquipInvActor.equips();
      for (i in equips) {
        j = equips[i];
        if (j === this.item) {
          this._isEquipedItem = true;
          this._applyEquipmenSpecialState();
        }
      }
    }

    registerClick() {
      var index;
      this._cell._clickHandlers = [];
      index = this.index;
      this._cell.addClickHandler(function() {
        return AA.UI.onStatusInvCellClick(index);
      });
    }

    _getEquipmentActor() {
      return $gameTemp._aaStatusWindowEquipInvActor;
    }

  };
  AA.register(AASpriteASEI_Cell);
})();

// ■ END AASpriteASEI_Cell.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteASEI_Footer;
  AASpriteASEI_Footer = class AASpriteASEI_Footer extends AA.LIBS.Sprite_MapInvFooter {
    constructor() {
      super();
    }

    _loadSettings() {
      super._loadSettings();
      return this.settings2 = AA.JSON.getUIMapStatesWindowSettings().equipmentsInventory;
    }

    _createContent() {
      return this._createButtons();
    }

    _createArrows() {
      super._createArrows();
      this._arrowL.x += this.settings2.pageArrowsMargin[0];
      this._arrowR.x += this.settings2.pageArrowsMargin[0];
      this._arrowL.y += this.settings2.pageArrowsMargin[1];
      this._arrowR.y += this.settings2.pageArrowsMargin[1];
      this._arrowL.clearClickHandlers();
      this._arrowR.clearClickHandlers();
      this._arrowL.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.statusWindowInvShowPrevPage();
      });
      this._arrowR.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.statusWindowInvShowNextPage();
      });
    }

    _createPageText() {
      super._createPageText();
      this._textSpr2.x += this.settings2.pageArrowsMargin[0];
      return this._textSpr2.y += this.settings2.pageArrowsMargin[1];
    }

    _createButtons() {
      this._createOptimazeBtn();
      return this._createClearEquipBtn();
    }

    _createOptimazeBtn() {
      var img0, img1, text, textSpr;
      this.optBtn = new KDCore.Button();
      img0 = ImageManager.loadAA("inventoryChestTakeAllButton_00");
      img1 = ImageManager.loadAA("inventoryChestTakeAllButton_01");
      this.optBtn.setButtonImages(img0, img1, img0, img0);
      this.optBtn.move(AA.Utils.jsonPos(this.settings2.optimizeButtonPosition));
      this.optBtn.addClickHandler(function() {
        SoundManager.playCursor();
        return AA.UI.statusWindowInvOptimize();
      });
      this.add(this.optBtn);
      textSpr = AASprite.FromTextSettings(this.settings2.buttonTextSettings);
      //textSpr.fillAll()
      text = TextManager.optimize;
      textSpr.drawTextWithSettings(text);
      this.optBtn.addChild(textSpr);
    }

    _createClearEquipBtn() {
      var img0, img1, text, textSpr;
      this.clrBtn = new KDCore.Button();
      img0 = ImageManager.loadAA("inventoryChestTakeAllButton_00");
      img1 = ImageManager.loadAA("inventoryChestTakeAllButton_01");
      this.clrBtn.setButtonImages(img0, img1, img0, img0);
      this.clrBtn.move(AA.Utils.jsonPos(this.settings2.clearButtonPosition));
      this.clrBtn.addClickHandler(function() {
        SoundManager.playCursor();
        return AA.UI.statusWindowInvClear();
      });
      this.add(this.clrBtn);
      textSpr = AASprite.FromTextSettings(this.settings2.buttonTextSettings);
      //textSpr.fillAll()
      text = TextManager.clear;
      textSpr.drawTextWithSettings(text);
      this.clrBtn.addChild(textSpr);
    }

  };
  AA.register(AASpriteASEI_Footer);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteASEI_Header;
  AASpriteASEI_Header = class AASpriteASEI_Header extends AA.LIBS.Sprite_MapInvHeader {
    constructor() {
      super();
    }

    _createBackground() {
      this._background = AASprite.FromImg("StatWin_ActorEquipsHeader");
      return this.add(this._background);
    }

    _drawIcon() {}

    _createCloseButton() {}

    _loadSettings() {
      super._loadSettings();
      return this.settings2 = AA.JSON.getUIMapStatesWindowSettings().equipmentsInventory;
    }

    _createContent() {
      var img0, img1, img3;
      this._content = new Sprite();
      this.categoryBtns = [];
      //? this is must be above items! here...
      img0 = ImageManager.loadAA(this.settings.categoryButtonImg);
      img1 = ImageManager.loadAA(this.settings.categoryButtonHoverImg);
      img3 = ImageManager.loadAA(this.settings.categoryButtonSelectedImg);
      this.category1 = new KDCore.Button();
      this.category1.setButtonImages(img0, img1, img0, img3);
      this.category1.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.showStatusActorEquipCategory(0);
      });
      this._content.addChild(this.category1);
      this.categoryBtns.push(this.category1);
      this.category2 = new KDCore.Button();
      this.category2.setButtonImages(img0, img1, img0, img3);
      this.category2.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.showStatusActorEquipCategory(1);
      });
      this._content.addChild(this.category2);
      this.categoryBtns.push(this.category2);
      this.category2.move(this.settings.categoryButtonMarginBetween, 0);
      this._content.move(this.settings2.categoryButtonsMargin);
      this._createCategoryIcons();
      this.add(this._content);
    }

    _createCategoryIcons() {
      var i, icon, j, ref, ref1, results;
      results = [];
      for (i = j = 0, ref = this.categoryBtns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        icon = AASprite.FromImg(this.settings.categoriesIcons[i + 1]);
        results.push((ref1 = this.categoryBtns[i]) != null ? ref1.addChild(icon) : void 0);
      }
      return results;
    }

  };
  AA.register(AASpriteASEI_Header);
})();

// Generated by CoffeeScript 2.5.1
(function() {
  var AASpriteASEI_Items;
  AASpriteASEI_Items = class AASpriteASEI_Items extends AA.LIBS.Sprite_MainInvItems {
    constructor() {
      super();
    }

    _loadSettings() {
      super._loadSettings();
      return this.settings2 = AA.JSON.getUIMapStatesWindowSettings().equipmentsInventory;
    }

    _createContent() {
      super._createContent();
      return this.content.move(this.settings2.invCellStartPosition);
    }

    _createCells() {
      var cell, i, index, j, k, results;
      this._cells = [];
      index = 0;
      results = [];
      for (i = k = 0; k < 4; i = ++k) {
        results.push((function() {
          var l, results1;
          results1 = [];
          for (j = l = 0; l < 5; j = ++l) {
            cell = this._createCell(index++);
            this._cells.push(cell);
            results1.push(this._placeCell(i, j, cell));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    _createItemNameLine() {
      super._createItemNameLine();
      return this._textSpr.move(this.settings2.itemNameTextBoxMargins);
    }

    _createCell(i, j) {
      var cell;
      cell = new AA.LIBS.AASpriteASEI_Cell(i, j);
      this.content.addChild(cell);
      return cell;
    }

  };
  AA.register(AASpriteASEI_Items);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ zAXUI_Sprite_StateIcon_PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  AXUI.Sprite_StateIcon.prototype._loadProperStyleId = function() {
    var styleId;
    styleId = 0;
    if ((this.state != null) && (this.state.meta.uiStyleId != null)) {
      styleId = Number(this.state.meta.uiStyleId);
    }
    return styleId;
  };
})();

// ■ END zAXUI_Sprite_StateIcon_PRO.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BarrierGaugeController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var BarrierGaugeController;
  BarrierGaugeController = class BarrierGaugeController extends AA.LIBS.GaugeController {
    constructor() {
      super(...arguments);
    }

    _readValues() {
      if (this.battler == null) {
        return;
      }
      this._value = this.battler._absParams.barrierHp;
      return this._maxValue = this.battler._absParams.barrierHpMax;
    }

    _needUpdate() {
      if (this._isReady === false) {
        return false;
      }
      if (this.battler == null) {
        return false;
      }
      return true;
    }

    _updateGauge() {
      var percent;
      percent = this._value / this._maxValue;
      return this.gaugeSprite.drawGauge(percent);
    }

  };
  AA.register(BarrierGaugeController);
})();

// ■ END BarrierGaugeController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
ButtonsProManager.loadCustom = function() {
  var customButtons, e;
  if (AlphaABS.jDATA.UIButtons == null) {
    return;
  }
  try {
    customButtons = AlphaABS.Parameters.get_CustomUIButtons();
    return customButtons.forEach(function(item) {
      return ButtonsProManager.createButton(item);
    });
  } catch (error) {
    e = error;
    return AlphaABS.error(e, ' while load Custom UI Buttons');
  }
};

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extra Damage Extension PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ExtraDamagePopUpItem;
  ExtraDamagePopUpItem = class ExtraDamagePopUpItem {
    constructor(battler) {
      this.battler = battler;
      this.setup();
    }

    setup() {
      var result;
      result = this.battler.result();
      if (result.missed || result.evaded) {
        return this.createMiss();
      } else if (result.hpAffected) {
        return this.createHpDamage(result.hpDamage, result.critical);
      } else if (this.battler.isAlive() && result.mpDamage !== 0) {
        return this.createMpDamage(result.mpDamage, result.critical);
      }
    }

    createMiss() {
      return this._createItem(this._getSettings(0), AlphaABS.SYSTEM.STRING_POPUP_MISS);
    }

    _createItem(settings, value) {
      this.item = new AA.LIBS.PopItemText();
      this.item.setSettings(settings);
      this.item.setText(value);
      this.item.create();
      this.item.setAnchors(0.5);
    }

    _getSettings(index) {
      return AAJsonSettings.getDamageExtraPopUpSettings()[index];
    }

    createHpDamage(val, isCrit) {
      var index;
      index = 1;
      if (this.battler.isEnemy()) {
        if (val < 0) {
          index = 10;
          val = this._convertPositiveVal(val);
        } else {
          index = 5;
          if (isCrit === true) {
            index = 6;
          }
        }
      } else {
        if (val < 0) {
          index = 9;
          val = this._convertPositiveVal(val);
        } else {
          if (isCrit === true) {
            index = 2;
          }
        }
      }
      this._createItem(this._getSettings(index), val.toString());
    }

    _convertPositiveVal(val) {
      val = -1 * val;
      val = "+" + val;
      return val;
    }

    createMpDamage(val, isCrit) {
      var index;
      index = 3;
      if (this.battler.isEnemy()) {
        if (val < 0) {
          val = this._convertPositiveVal(val);
          index = 12;
        } else {
          index = 7;
          if (isCrit === true) {
            index = 8;
          }
        }
      } else {
        if (val < 0) {
          val = this._convertPositiveVal(val);
          index = 11;
        } else {

        }
        if (isCrit === true) {
          index = 4;
        }
      }
      return this._createItem(this._getSettings(index), val.toString());
    }

  };
  AA.register(ExtraDamagePopUpItem);
})();

(function() {
  var ALIAS_SCABS_initABS, ALIAS_SCABS_udp, _;
  //@[DEFINES]
  _ = AlphaABS.LIBS.Sprite_CharacterABS.prototype;
  //@[ALIAS]
  ALIAS_SCABS_initABS = _.initABS;
  _.initABS = function() {
    ALIAS_SCABS_initABS.call(this);
    return this._initExtraDamagePopUp();
  };
  _._initExtraDamagePopUp = function() {
    if (AA.Parameters.get_AllowUsingExtraDamagePopUps()) {
      //@_edpuMachine = new AA.LIBS.PopMachine()
      return this._layer = BattleManagerABS.MPS().getAAExtraDmgLayer();
    } else {
      //AAJsonSettings.getDamageExtraPopUpSettings()
      return this._layer = null;
    }
  };
  //@[ALIAS]
  ALIAS_SCABS_udp = _._updateDamagePopup;
  _._updateDamagePopup = function() {
    if (this._layer != null) {
      return this._updateDamagePopupExtra();
    } else {
      return ALIAS_SCABS_udp.call(this);
    }
  };
  _._updateDamagePopupExtra = function() {
    return this._setupDamagePopupExtra();
  };
  //@_edpuMachine.refresh()
  _._setupDamagePopupExtra = function() {
    var b, popUp;
    b = this._character.battler();
    if (b == null) {
      return;
    }
    if (b.isDamagePopupRequested()) {
      popUp = (new AA.LIBS.ExtraDamagePopUpItem(b)).item;
      if (popUp != null) {
        popUp.x = this.x;
        popUp.y = this.y - this.patternHeight() - 12;
        //if @_absParams.damages.length > 0
        popUp.x = popUp.x + Math.randomInt(15) - Math.randomInt(25);
        popUp.y = popUp.y - Math.randomInt(15);
        //popUp.y = this.patternHeight() - 10
        //@_edpuMachine.push popUp
        //@_absParams.damages.push(popUp)
        this._layer.addChild(popUp);
      }
      b.clearDamagePopup();
      b.clearResult();
    }
  };
})();

(function() {
  var _;
  //@[DEFINE]
  _ = Spriteset_Map.prototype;
  _.createAAExtraDmgLayer = function() {
    this._extraDmgLayer = new Sprite();
    return this.getExtraAALayer().addChild(this._extraDmgLayer);
  };
  _.getAAExtraDmgLayer = function() {
    if (this._extraDmgLayer == null) {
      this.createAAExtraDmgLayer();
    }
    return this._extraDmgLayer;
  };
})();

// ■ END Extra Damage Extension PRO.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ExtraDamagePopUpItem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setup, _;
  //@[DEFINES]
  _ = AA.LIBS.ExtraDamagePopUpItem.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    var result;
    ALIAS__setup.call(this);
    result = this.battler.result();
    if (result.barrierAffected === true) {
      return this.createBarrierDamage(result.barrierDamage);
    }
  };
  _.createBarrierDamage = function(value) {
    var elemId, extraColor, ref, ref1, settings;
    settings = (ref = AA.JSON.getAbsorbBarriersSettings()) != null ? ref.barrierDamagePopUp : void 0;
    if (settings == null) {
      return;
    }
    elemId = this.battler.result().barrierDamageId;
    if (elemId > 0) {
      extraColor = (ref1 = AA.JSON.getAbsordBarrierStyle(elemId)) != null ? ref1.barrierHpDamagePopUpColor : void 0;
      if (extraColor != null) {
        settings.text.textColor = extraColor;
      } else {
        settings.text.textColor = settings.text.defaultTextColor;
      }
    } else {
      settings.text.textColor = settings.text.defaultTextColor;
    }
    value = value * -1;
    this._createItem(settings, value.toString());
  };
})();

// ■ END ExtraDamagePopUpItem.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ExtDiagonalMovement.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var get8Dir;
  get8Dir = function(d) {
    switch (d) {
      case 1:
        return [4, 2];
      case 3:
        return [6, 2];
      case 7:
        return [4, 8];
      case 9:
        return [6, 8];
      default:
        return [0, 0];
    }
  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Character.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__moveToPointAA, _;
    
    //@[DEFINES]
    _ = Game_Character.prototype;
    
    //@[ALIAS]
    ALIAS__moveToPointAA = _.moveToPointAA;
    _.moveToPointAA = function(point) {
      var direction, horz, vert;
      if (AA.Parameters.isDiagonalMovement()) {
        direction = this._findDirectionToDiagonal(point.x, point.y);
        if (direction % 2 === 0) {
          return ALIAS__moveToPointAA.call(this, point);
        } else if (Math.abs(direction % 2) === 1) {
          [horz, vert] = get8Dir(direction);
          return this.moveDiagonally(horz, vert);
        }
      } else {
        return ALIAS__moveToPointAA.call(this, point);
      }
    };
  })();
  (function() {    // ■ END Game_Character.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Player.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Game_Player.prototype;
    
    //$[OVER]
    _.canPassDiagonally = function(x, y, horz, vert) {
      var x2, y2;
      if (!AA.Parameters.isDiagonalMovement()) {
        return false;
      }
      x2 = $gameMap.roundXWithDirection(x, horz);
      y2 = $gameMap.roundYWithDirection(y, vert);
      if (this.canPass(x, y, vert) && this.canPass(x, y2, horz) && this.canPass(x, y, horz) && this.canPass(x2, y, vert)) {
        return true;
      }
      return false;
    };
  })();
  (function() {
    var ALIAS__executeMove, _;
    //@[DEFINES]
    _ = Game_Player.prototype;
    //$[OVER]
    _.getInputDirection = function() {
      if (AA.Parameters.isDiagonalMovement()) {
        return Input.dir8;
      } else {
        return Input.dir4;
      }
    };
    //@[ALIAS]
    ALIAS__executeMove = _.executeMove;
    _.executeMove = function(direction) {
      var horz, vert;
      if (direction % 2 === 0) {
        return ALIAS__executeMove.call(this, direction);
      } else if (Math.abs(direction % 2) === 1) {
        [horz, vert] = get8Dir(direction);
        return this.moveDiagonally(horz, vert);
      }
    };
  })();
  (function() {    // ■ END Game_Player.coffee
    //---------------------------------------------------------------------------

    // * Тут было Game_Character, но тогда боты и party тупят
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Player.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__findDirectionTo, _;
    
    //@[DEFINES]
    _ = Game_Player.prototype;
    
    //@[ALIAS]
    ALIAS__findDirectionTo = _.findDirectionTo;
    _.findDirectionTo = function(goalX, goalY) {
      if (!AA.Parameters.isDiagonalMovement()) {
        return ALIAS__findDirectionTo.call(this, goalX, goalY);
      } else {
        return this._findDirectionToDiagonal(goalX, goalY);
      }
    };
  })();
  (function() {    // ■ END Game_Player.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Character.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Game_Character.prototype;
    _._findDirectionToDiagonal = function(goalX, goalY) {
      var best, bestIndex, closedList, current, deltaX1, deltaX2, deltaY1, deltaY2, diag, direction, g1, g2, goaled, horz, i, index2, j, mapWidth, neighbor, node, nodeList, openList, pos1, pos2, searchLimit, start, vert, x1, x2, y1, y2;
      searchLimit = this.searchLimit();
      mapWidth = $gameMap.width();
      nodeList = [];
      openList = [];
      closedList = [];
      start = {};
      best = start;
      if (this.x === goalX && this.y === goalY) {
        return 0;
      }
      start.parent = null;
      start.x = this.x;
      start.y = this.y;
      start.g = 0;
      start.f = $gameMap.distance(start.x, start.y, goalX, goalY);
      nodeList.push(start);
      openList.push(start.y * mapWidth + start.x);
      while (nodeList.length > 0) {
        bestIndex = 0;
        i = 0;
        while (i < nodeList.length) {
          if (nodeList[i].f < nodeList[bestIndex].f) {
            bestIndex = i;
          }
          i++;
        }
        current = nodeList[bestIndex];
        x1 = current.x;
        y1 = current.y;
        pos1 = y1 * mapWidth + x1;
        g1 = current.g;
        nodeList.splice(bestIndex, 1);
        openList.splice(openList.indexOf(pos1), 1);
        closedList.push(pos1);
        if (current.x === goalX && current.y === goalY) {
          best = current;
          goaled = true;
          break;
        }
        if (g1 >= searchLimit) {
          continue;
        }
        j = 0;
        while (j < 9) {
          direction = 1 + j;
          if (direction === 5) {
            j++;
            continue;
          }
          diag = Math.abs(direction % 2) === 1;
          [horz, vert] = get8Dir(direction);
          if (diag && this.canPassDiagonally(x1, y1, horz, vert) && (this.canPass(x1, y1, horz) || this.canPass(x1, y1, vert))) {
            x2 = $gameMap.roundXWithDirection(x1, horz);
            y2 = $gameMap.roundYWithDirection(y1, vert);
          } else if (this.canPass(x1, y1, direction)) {
            x2 = $gameMap.roundXWithDirection(x1, direction);
            y2 = $gameMap.roundYWithDirection(y1, direction);
          } else {
            j++;
            continue;
          }
          pos2 = y2 * mapWidth + x2;
          if (closedList.contains(pos2)) {
            j++;
            continue;
          }
          g2 = g1 + 1;
          index2 = openList.indexOf(pos2);
          if (index2 < 0 || g2 < nodeList[index2].g) {
            if (index2 >= 0) {
              neighbor = nodeList[index2];
            } else {
              neighbor = {};
              nodeList.push(neighbor);
              openList.push(pos2);
            }
            neighbor.parent = current;
            neighbor.x = x2;
            neighbor.y = y2;
            neighbor.g = g2;
            neighbor.f = g2 + $gameMap.distance(x2, y2, goalX, goalY);
            if (!best || neighbor.f - neighbor.g < best.f - best.g) {
              best = neighbor;
            }
          }
          j++;
        }
      }
      node = best;
      while (node.parent && node.parent !== start) {
        node = node.parent;
      }
      deltaX1 = $gameMap.deltaX(node.x, start.x);
      deltaY1 = $gameMap.deltaY(node.y, start.y);
      if (deltaY1 > 0 && deltaX1 > 0) {
        return 3;
      } else if (deltaY1 > 0 && deltaX1 < 0) {
        return 1;
      } else if (deltaY1 < 0 && deltaX1 < 0) {
        return 7;
      } else if (deltaY1 < 0 && deltaX1 > 0) {
        return 9;
      }
      if (deltaY1 > 0) {
        return 2;
      } else if (deltaX1 < 0) {
        return 4;
      } else if (deltaX1 > 0) {
        return 6;
      } else if (deltaY1 < 0) {
        return 8;
      }
      deltaX2 = this.deltaXFrom(goalX);
      deltaY2 = this.deltaYFrom(goalY);
      if (Math.abs(deltaX2) > Math.abs(deltaY2)) {
        if (deltaX2 > 0) {
          return 4;
        } else {
          return 6;
        }
      } else if (deltaY2 !== 0) {
        if (deltaY2 > 0) {
          return 8;
        } else {
          return 2;
        }
      }
      return 0;
    };
  })();
})();

// ■ END ExtDiagonalMovement.coffee
//---------------------------------------------------------------------------
// ■ END Game_Character.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extra.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
AlphaABS.ApplyExtraPluginsSupport = (function () {

    var ELOG = new KDCore.DevLog("Alpha ABS");
    ELOG.on();
    ELOG.setColors(KDCore.Color.GREEN, KDCore.Color.FromHex('#848400'));

    var printSupport = function (plName) {
        ELOG.p(plName + ' finded - supported');
    };

    if(window.mv3d) {
        //TODO: Доделать
        //printSupport('MV3D');
        //?[EMBEDDED SUPPORT]
        
    }


    if(Imported.MOG_Footsteps == true) {
        //@[ALIAS]
        var fsdf432243242fdasfasd = Game_Character.prototype.update;
        Game_Character.prototype.update = function () {
            this.updateFootSteps();
            fsdf432243242fdasfasd.call(this);
        };
    }

    if(Imported.YEP_PartySystem == true) {
        printSupport('YEP_PartySystem');
        //$[OVER]
        Game_Party.prototype.initializeBattleMembers = function() {
            this._battleMembers = [];
            for (var i = 0; i < this.maxBattleMembers(); ++i) {
            if (this._actors[i]) {
                this._battleMembers.push(this._actors[i]);
            } else {
                this._battleMembers.push(0);
            }
            }
            //if ($gamePlayer) $gamePlayer.refresh();
        };
    }

    //HIME_PartyManager support
    if (Imported.TH_PartyManager == 1) {
        printSupport('HIME_PartyManager');
        try {
            var _alias_Party_switch_ABS = Party.switch;
            Party.switch = function (id) {
                var r = _alias_Party_switch_ABS.call(this, id);
                if (AlphaABS.isABS()) {
                    AlphaABS.BattleManagerABS.updateABSSession();
                }
                return r;
            };
        } catch (error) {
            console.error(error);
        }
    }

    if(Imported.FROG_Health == true) {
        printSupport('FROG_Health');
        //$[OVER]
        Game_Action.prototype.evalDamageFormula = function (target) {
            var item = this.item();
            if (item && item.damage && item.damage.formula && (item.damage.formula.charAt(0) === "'" || item.damage.formula.charAt(0) === '"')) return 0;
            return Math.round(FROG.Health.Game_Action_evalDamageFormula.call(this, target));
        };
    }

    if (Imported.Galv_CharacterFrames == true) {
        printSupport('GALV_CharacterFrames');
    
        //$[OVER]
        Sprite_Character.prototype.patternWidth = function () {
            return AA.G_ALIASES._alias_Sprite_Character_patternWidth.call(this);
        };
    }

    if (Imported.Galv_CharacterAnimations == true) {
        printSupport('GALV_CharacterAnimations');

        var alias_GP_updateCharAnims = Game_Player.prototype.updateCharAnims;
        Game_Player.prototype.updateCharAnims = function () {
            if (this.inABSMotion()) {
                return;
            } else {
                alias_GP_updateCharAnims.call(this);
            }
        };
    }

    //HIME_PreTitleEvents support
    if (Imported.PreTitleEvents == 1) {
        printSupport('HIME_PreTitleEvents');
        //?{EMBEDDED SUPPORT}
    }

    if (Imported.YEP_SmartJump == true) {
        printSupport('YEP_SmartJump');
        //?{EMBEDDED SUPPORT}
    }

    if (Imported.YEP_ItemCore == true) {
        printSupport('YEP_ItemCore');
        try {
            var _Game_Party_gainIndependentItem_YEP = Game_Party.prototype.gainIndependentItem;
            Game_Party.prototype.gainIndependentItem = function (item, amount, includeEquip) {
                _Game_Party_gainIndependentItem_YEP.call(this, item, amount, includeEquip);
                if ($gameMap.isABS()) {
                    if (amount > 0 && !this._noNotifyABS) {
                        AudioManager.playSe({
                            name: 'Equip2',
                            pan: 0,
                            pitch: 140,
                            volume: 90
                        });
                        AlphaABS.BattleUI.pushItemOnPanel(item);
                        AlphaABS.BattleUI.refresh();
                    }
                    if (!$gamePlayer.inBattle()) {
                        $gamePlayer.battler().checkAutoReloadFirearm(item);
                    }
                    try {
                        if (AlphaABS.Parameters.isAutoBindItemsToPanel()) {
                            if (item.occasion == 1 && item.meta.ABS)
                                $gamePlayer.battler().setOrRefreshItemOnPanel(item.id, undefined);
                        }
                    } catch (e) {
                        AlphaABS.error(e, ' bind item to panel');
                    }

                    if (DataManager.isWeapon(item)) {
                        AlphaABS.BattleUI.refreshWeaponCircle();
                    }
                }
            };
        } catch (error) {
            AlphaABS.error(error, ' YEP_ItemCore: gain item to party');
        }
    }

    if (Imported.YEP_EquipCore == true) {
        printSupport('YEP_EquipCore');
        try {
            var _Window_EquipSlot_drawItem_YEP = Window_EquipSlot.prototype.drawItem;
            Window_EquipSlot.prototype.drawItem = function (index) {
                _Window_EquipSlot_drawItem_YEP.call(this, index);
                this._drawFavWeapSymbol(index);
            };
        } catch (error) {
            console.error(error);
        }

    }

    if (Imported.YEP_SaveCore == true) {
        printSupport('YEP_SaveCore');
        try {
            var _Scene_File_performActionLoad_YEP = Scene_File.prototype.performActionLoad;
            Scene_File.prototype.performActionLoad = function () {
                if (AlphaABS.LIBS.BattleManagerABS._isABSMap == true) {
                    AlphaABS.LIBS.BattleManagerABS.stopABS();
                }
                _Scene_File_performActionLoad_YEP.call(this);
            };
        } catch (error) {
            console.error(error);
        }
    }

    if (Imported.TerraxLighting) {
        printSupport('TerraxLighting');
        try {
            AlphaABS.SYSTEM.EXTENSIONS.LIGHT = true;

            var _alias_Game_CharacterBase_TerraxL324 = Game_CharacterBase.prototype.setDirection;
            Game_CharacterBase.prototype.setDirection = function (d) {
                if (this._spawnEventId) {
                    if (!this.isDirectionFixed() && d) {
                        this._direction = d;
                    }
                    this.resetStopCount();
                } else
                    _alias_Game_CharacterBase_TerraxL324.call(this, d);

            };

            var _alias_Game_CharacterBase_updateMoveTerrax4325 = Game_CharacterBase.prototype.updateMove;
            Game_CharacterBase.prototype.updateMove = function () {
                if (this._spawnEventId) {
                    try {
                        if (this._x < this._realX) {
                            this._realX = Math.max(this._realX - this.distancePerFrame(), this._x);
                        }
                        if (this._x > this._realX) {
                            this._realX = Math.min(this._realX + this.distancePerFrame(), this._x);
                        }
                        if (this._y < this._realY) {
                            this._realY = Math.max(this._realY - this.distancePerFrame(), this._y);
                        }
                        if (this._y > this._realY) {
                            this._realY = Math.min(this._realY + this.distancePerFrame(), this._y);
                        }
                        if (!this.isMoving()) {
                            this.refreshBushDepth();
                        }
                    } catch (e) {

                    }
                } else
                    _alias_Game_CharacterBase_updateMoveTerrax4325.call(this);
            };

            var xyLightArray = [];

            var _setLightAt = function (tiletype, x, y, radius, color, isOn, bright, isFlicker) {
                if(!bright)
                    bright = 0.0;
                var isValidColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
                if (!isValidColor) {
                    color = '#FFFFFF';
                }

                var tilefound = false;
                for (var i = 0; i < xyLightArray.length; i++) {
                    var tilestr = xyLightArray[i];
                    var tileargs = tilestr.split(";");
                    if (tileargs[0] == tiletype && tileargs[1] == x && tileargs[2] == y) {
                        tilefound = true;
                        if (isOn)
                            xyLightArray[i] = tiletype + ";" + x + ";" + y + ";" + radius + ";" + color + ";" + isOn + ";" + bright + ";" + isFlicker;
                        else
                            xyLightArray.delete(tilestr);
                        break;
                    }
                }

                if (tilefound === false) {
                    var tiletag = tiletype + ";" + x + ";" + y + ";" + radius + ";" + color + ";" + isOn + ";" + bright + ";" + isFlicker;
                    xyLightArray.push(tiletag);
                }

                $gameVariables.setXYArrayABS(xyLightArray);
            };

            var _updateABS = function () {

                var canvas = this._maskBitmap.canvas;
                var ctx = canvas.getContext("2d");
                ctx.globalCompositeOperation = 'lighter';

                var pw = $gameMap.tileWidth();
                var ph = $gameMap.tileHeight();
                var dx = $gameMap.displayX();
                var dy = $gameMap.displayY();

                for (var i = 0; i < xyLightArray.length; i++) {
                    var tilestr = xyLightArray[i];
                    var tileargs = tilestr.split(";");
                    var tile_type = tileargs[0];
                    var x = tileargs[1];
                    var y = tileargs[2];
                    var radius = parseInt(tileargs[3]);
                    var color = tileargs[4];
                    var isOn = (tileargs[5] === 'true');
                    var bright = Number(tileargs[6]);
                    var isFlicker = (tileargs[7] === 'true');

                    if (tile_type == 700 && isOn) {
                        var x1 = (pw / 2) + (x - dx) * pw;
                        var y1 = (ph / 2) + (y - dy) * ph;

                        if ($dataMap.scrollType === 2 || $dataMap.scrollType === 3) {
                            if (dx - 5 > x) {
                                var lxjump = $gameMap.width() - (dx - x);
                                x1 = (pw / 2) + (lxjump * pw);
                            }
                        }
                        if ($dataMap.scrollType === 1 || $dataMap.scrollType === 3) {
                            if (dy - 5 > y) {
                                var lyjump = $gameMap.height() - (dy - y);
                                y1 = (ph / 2) + (lyjump * ph);
                            }
                        }
                        this._maskBitmap.radialgradientFillRect(x1, y1, 0, radius, color, 'black', isFlicker, bright);
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
            };

            var _Spriteset_Map_createLightmask_Terrax = Spriteset_Map.prototype.createLightmask;
            Spriteset_Map.prototype.createLightmask = function () {
                _Spriteset_Map_createLightmask_Terrax.call(this);
                var temp = this._lightmask.__proto__.update;
                this._lightmask.__proto__.update = function () {
                    temp.call(this);
                    try {
                        _updateABS.call(this);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };

            Game_Map.prototype.setLight = function (x, y, radius, color, bright = 0.0, isFlicker = false) {
                try {
                    _setLightAt(700, x, y, radius, color, true, bright, isFlicker);
                } catch (e) {
                    console.error(e);
                }
            };

            Game_Map.prototype.deleteLight = function (x, y) {
                try {
                    _setLightAt(700, x, y, 0, '#FFFFFF', false, 0.0, false);
                } catch (e) {
                    console.error(e);
                }
            };

            Game_Variables.prototype.valueXYArrayABS = function () {
                var default_TA = [];
                return this._xyArrayABS || default_TA;
            };

            Game_Variables.prototype.setXYArrayABS = function (value) {
                this._xyArrayABS = value;
            };

            function SaveLightingVariablesABS() {
                try {
                    xyLightArray = $gameVariables.valueXYArrayABS();
                } catch (e) {
                    console.error(e);
                    xyLightArray = [];
                }
            }

            var _Scene_load_onSavefileOk = Scene_Load.prototype.onSavefileOk;
            Scene_Load.prototype.onSavefileOk = function () {
                _Scene_load_onSavefileOk.call(this);
                if (AlphaABS.SYSTEM.EXTENSIONS.LIGHT) {
                    if (this._loadSuccess) {
                        SaveLightingVariablesABS();
                    }
                }
            };
        } catch (error) {
            console.error(error);
        }
    }

    if (Imported.MOG_LMBS == true) {
        //?[NEW]
        LMBSwindowSkillList.prototype._isAllowedAAPanel = function () {
            return false;
        };

        //?[NEW]
        LMBSwindowSkillEquip.prototype._isAllowedAAPanel = function () {
            return false;
        };

        //?[NEW]
        LMBSWindow_Item.prototype._isAllowedAAPanel = function () {
            return false;
        };
    }

    if (Imported.YEP_BattleEngineCore == true) {

        printSupport('YEP_BattleEngineCore');
        //@[ALIAS]
        var _alias_SceneManager_snapForBackground5435435435 = SceneManager.snapForBackground;
        SceneManager.snapForBackground = function () {
            if(AA.isABS()) {
                return;
            } else
                _alias_SceneManager_snapForBackground5435435435.call(this);        
        };

    }

    if (Imported.YEP_GridFreeDoodads == true) {
        printSupport('YEP_GridFreeDoodads');
        try {
            //@[ALIAS]
            var alias_54354234234 = Spriteset_Map.prototype.createCharacters;
            Spriteset_Map.prototype.createCharacters = function () {
                alias_54354234234.call(this);
                if (this.createDoodads) {
                    this.createDoodads();
                }
            };
        } catch (error) {
            console.error(error);
        }
    }

    if (Imported.Galv_MessageStyles == true) {
        printSupport('GALV_MessageStyles');
        //@[ALIAS]
        var _alias_Window_Message_refreshGraphics = Window_Message.prototype.refreshGraphics;
        Window_Message.prototype.refreshGraphics = function () {
            _alias_Window_Message_refreshGraphics.call(this);
            AA.__CCACHE = {};
        };
    }

    if (Imported["SumRndmDde Character Creator EX"]) {
        printSupport('SumRndmDde Character Creator EX');
        
        AA.isCCEXImproted = true;

        AA.LIBS.SpriteActorPortrait.prototype._drawFaceEx = function() {
            var faceBitmap = Window_Base.prototype.getCustomFace.call(this, this.portrait);
            this._face.bitmap.blt(faceBitmap, 0, 0, Window_Base._faceWidth, Window_Base._faceHeight, 0, 0, this.settings.faceSize, this.settings.faceSize);
        };

    }

    if (Imported.SAN_AnalogMove == true) {
        printSupport('SAN_AnalogMove');
        (function () {
            var Game_CharacterBase_screenX = Game_CharacterBase.prototype.screenX;
            Game_CharacterBase.prototype.screenX = function () {
                var round = Math.round;
                Math.round = Math.floor;
                var val = Game_CharacterBase_screenX.call(this);
                Math.round = round;
                return val;
            };

            var Game_CharacterBase_screenY = Game_CharacterBase.prototype.screenY;
            Game_CharacterBase.prototype.screenY = function () {
                var round = Math.round;
                Math.round = Math.floor;
                var val = Game_CharacterBase_screenY.call(this);
                Math.round = round;
                return val;
            };

            // $[OVER]
            Game_Follower.prototype.isAnalogMoveValid = function () {
                return false;
            };

            var ALIAS_Game_Player_moveByInput = Game_Player.prototype.moveByInput;
            Game_Player.prototype.moveByInput = function () {
                if (this.isAnalogMoveValid()) {
                    if (this.battler() != null) {
                        if (this.battler().canMove()) {
                            return ALIAS_Game_Player_moveByInput.call(this);
                        } else {
                            return false;
                        }
                    } else 
                        return ALIAS_Game_Player_moveByInput.call(this);
                } 
                return ALIAS_Game_Player_moveByInput.call(this);
            };

            var ALIAS_Game_AnalogMove_moveByInput = Game_AnalogMove.prototype.moveByInput;
            Game_AnalogMove.prototype.moveByInput = function (thisCharacter) {
                if (thisCharacter == $gamePlayer) {
                    if ($gameTemp.___AA_CAN_MOVE_ANALOG == false || $gamePlayer._absParams.state == 'targetCircle') {
                        this._distancePerFrame = 0.0;
                        $gameTemp.___AA_CAN_MOVE_ANALOG = true;
                    }
                    else {
                        if (thisCharacter._absParams.targetFollowMode == true) {
                            if (thisCharacter.target()) {
                                this._targRealX = thisCharacter.target().x;
                                this._targRealY = thisCharacter.target().y;
                                thisCharacter.turnTowardCharacter(thisCharacter.target());
                            }
                        }
                        ALIAS_Game_AnalogMove_moveByInput.call(this, thisCharacter);
                        if (this._distancePerFrame != 0) {
                            $gamePlayer.stopFollowMode();
                            $gamePlayer.interruptCast();
                        }
                    }
                } else {
                    ALIAS_Game_AnalogMove_moveByInput.call(this, thisCharacter);
                }
            };

            //@[ALIAS]
            var ALIAS_GAM_CANMOVE_4342 = Sanshiro.Game_AnalogMove.canMove;
            Sanshiro.Game_AnalogMove.canMove = function () {
                if(AA.isMap()) {
                    return ALIAS_GAM_CANMOVE_4342.call(this) && $gamePlayer.battler().canMove();
                } else
                    return ALIAS_GAM_CANMOVE_4342.call(this);
            };

        })();


    }
});

// ■ END Extra.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_AIBot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_AIBot.prototype;
  _.isEnemy = function() {
    return true;
  };
  _.AABattler = function() {
    return this.battler();
  };
  _.AAEntity = function() {
    return this;
  };
})();

// ■ END Game_AIBot.coffee
//---------------------------------------------------------------------------

//==========================================================================================================================================================
// Alpha ABS MAIN
//==========================================================================================================================================================
(function () {

	var LOGW = AlphaABS.SYSTEM.LOGW;
	var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

	ImageManager.loadAA("Circle_segment"); // * PRE LOAD

	//Input
	//------------------------------------------------------------------------------
	Input.loadSchemeABS = function () {
		AlphaABS.LIBS.IKey.loadDefaultKeyConfig();
		//AlphaABS.Parameters.loadBindingScheme();
	};
	//END Input
	//------------------------------------------------------------------------------

	//==========================================================================================================================================================
	//MV GAME OBJECTS
	//==========================================================================================================================================================

	//Game_Screen
	//------------------------------------------------------------------------------
	//OVER
	Game_Screen.prototype.realPictureId = function (pictureId) {
		return pictureId;
	};
	//END Game_Screen
	//------------------------------------------------------------------------------

	//Game_Variables
	//------------------------------------------------------------------------------
	Game_Variables.prototype.setUIParam = function (param, value) {
		if (!this._uiParams) {
			this._uiParams = {};
		}
		this._uiParams[param] = value;
	};

	Game_Variables.prototype.getUIParam = function (param) {
		if (this._uiParams) {
			return this._uiParams[param];
		}
		return null;
	};

	Game_Variables.prototype.setUIPosition = function (id, x, y, vis, extra) {
		if (!this._uiPositions)
			this._uiPositions = {};
		this._uiPositions[id] = [x, y, vis, extra];
	};

	Game_Variables.prototype.getUIPosition = function (id) {
		try {
			if (this._uiPositions) {
				var p = this._uiPositions[id];
				if (p) {
					return {
						x: p[0],
						y: p[1],
						vis: p[2],
						extra: p[3]
					};
				}
			}
		} catch (e) {
			console.error(e);
			return null;
		}
		return null;
	};
	//END Game_Variables
	//------------------------------------------------------------------------------

	//==========================================================================================================================================================
	//MV SCENES
	//==========================================================================================================================================================

	//Scene_Title
	//------------------------------------------------------------------------------
	var _Scene_Title_start = Scene_Title.prototype.start;
	Scene_Title.prototype.start = function () {
		BattleManagerABS.clearABS();
		SlowUpdateManager.clearAll();
		_Scene_Title_start.call(this);
	};
	//END Scene_Title
	//------------------------------------------------------------------------------

	//Scene_Gameover
	//------------------------------------------------------------------------------
	var _Scene_Gameover_create = Scene_Gameover.prototype.create;
	Scene_Gameover.prototype.create = function () {
		$gameMap.stopABS();
		_Scene_Gameover_create.call(this);
	};
	//END Scene_Gameover
	//------------------------------------------------------------------------------

	//Scene_Title
	//------------------------------------------------------------------------------
	var _Scene_Title_create = Scene_Title.prototype.create;
	Scene_Title.prototype.create = function () {
		$gameMap.stopABS();
		_Scene_Title_create.call(this);
	};
	//END Scene_Title
	//------------------------------------------------------------------------------

	//@[ALIAS]
	var _alias_Scene_GameEnd_commandToTitle = Scene_GameEnd.prototype.commandToTitle;
	Scene_GameEnd.prototype.commandToTitle = function () {
		if(AA.isMap())
			BattleManagerABS.stopABS();
		_alias_Scene_GameEnd_commandToTitle.call(this);
	};

	//Scene_Boot
	//------------------------------------------------------------------------------
	var pkd_SceneBoot_start = Scene_Boot.prototype.start;
	Scene_Boot.prototype.start = function () {
        pkd_SceneBoot_start.call(this);
        this.initABSSystem();
    };
    
    Scene_Boot.prototype.initABSSystem = function() {
		AA.__absSystemInited = true;
		if(!AlphaABS.Parameters.isLoaded()) {
			// * Reload again for MZ H build
			AlphaABS.Parameters = new AA.LIBS.ParametersManagerABS();
		}
        ImageManager.loadAA("Circle_segment"); // * PRE LOAD
		ImageManager.loadAA('WindowForHints'); // * PRE LOAD
		var isGamepadSupport = AA.Parameters.get_IsGamepadSupport();
		if (isGamepadSupport == false) {
			Input.refreshGPState = function() {
				Input._isGamePad = false;
			};
		}
		Input.refreshGPState();
		LOGW.p(AlphaABS.getVersionInfo());
		if (!AlphaABS.Parameters.isLoaded()) {
			LOGW.p("Warning! Plugin parameters not finded, used default settings");
		} else {
			AlphaABS.Parameters.loadAllStrings();
		}
		AlphaABS.ApplyPostParamLoad();
		if (AA.Parameters.get_IsAlterMovementMode())
			Input._loadAAAlterMovement();
		if (!AA.Parameters.get_IsUseExtraDashCharacterTilt() && !AA.Parameters.get_IsUseExtraJumpCharacterTilt()) {
			Sprite_Character.prototype._updateDashMotionHolder = function () {};
		}
		if (!AA.Parameters.get_IsMouseMoveMode()) {
			Game_Temp.prototype.setDestination = function() {};
		}
		if(AA.isPro()) {
			AADBEditorManager.init();
		}
		AlphaABS.ApplyExtraPluginsSupport();
		BattleManagerABS.init();
		SlowUpdateManager.init();
		ButtonsProManager.init();
		AA.Parameters.prepareExtraParameters();

    };

	//END Scene_Boot
	//------------------------------------------------------------------------------

	AlphaABS.isABS = function () {
		return AA.isSceneMap() && AA.isMap();
	};

	AA.isMap = function() {
		return $gameMap.isABS();
	};

	AA.isSceneMap = function () {
		return AA.Utils.isSceneMap();
	};

	AlphaABS.error = function (error, message) {
		if (AlphaABS._errorLog == undefined) {
			AlphaABS._errorLog = new KDCore.DevLog('Alpha ABS Error');
			AlphaABS._errorLog.setColors(KDCore.Color.RED, KDCore.Color.BLACK.getLightestColor(225));
			AlphaABS._errorLog.on();
		}
		if (message)
			AlphaABS._errorLog.p(message);
		console.error(error);
	};

	AlphaABS.warning = function (error, message) {
		LOGW.p("Warning! " + message);
		console.warn(error);
	};

	AlphaABS.criticalError = function (error, message) {
		AlphaABS.error(null, message);
		SceneManager.catchException(error);
	};

	//?FROM 1.3
	AlphaABS.isUseFonts = function () {
		return Utils.isNwjs();
	};

	// * Лог для разработки
	AlphaABS.log = function (message, obj) {
		if (!AA.isDEV()) {
			return;
		}
		if (AlphaABS._devLog == undefined) {
			AlphaABS._devLog = new KDCore.DevLog('AA');
			AlphaABS._devLog.setColors(KDCore.Color.BLUE, KDCore.Color.BLACK.getLightestColor(200));
			AlphaABS._devLog.on();
		}
		if (message) {
			if (!obj)
				AlphaABS._devLog.p(message);
			else
				AlphaABS._devLog.p(obj.constructor.name + " : " + message);
		}
	};

	AlphaABS.ApplyPostParamLoad = (function () {
		if (AlphaABS.Parameters.isLoaded()) {
			if (AlphaABS.Parameters.isAStarAllowed()) {
				var _Game_Character_findDirectionTo = Game_Character.prototype.findDirectionTo;
				Game_Character.prototype.findDirectionTo = function (goalX, goalY) {
					if (this._absParams.useAStar == false) {
						return _Game_Character_findDirectionTo.call(this, goalX, goalY);
					} else {
						var t = AlphaABS.LIBS.ABSPathfinding.findPath(this, goalX, goalY);
						if (t == 0) t = _Game_Character_findDirectionTo.call(this, goalX, goalY);
						return t;
					}
				};
			}
		}
		DataManager.loadAISpawnMap();
	});

})();
// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapChestController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MapChestController;
  if (!AA.isPro()) {
    return;
  }
  MapChestController = class MapChestController extends AA.LIBS.MapInvController {
    constructor() {
      super(...arguments);
      this.goldRefreshThread = null;
    }

    _onGoldTick() {} // * EMPTY

    close() {
      super.close();
      return $gameTemp.__visualChestGoldCell = null;
    }

    updateWhenOpen() {
      var ref;
      this.refreshTitle.update();
      this._updateInvDrag();
      this._updateHelp(); //?{PART}
      if (this.isSomeItemFocused()) {
        this.updateClearFocusClick();
      }
      if ((ref = this._autoCloseThread) != null) {
        ref.update();
      }
      if (Input.isTriggered(AA.LIBS.IKey.TALL())) {
        return this.takeAll();
      }
    }

    _onTitleTick() {
      var cellUnderMouse;
      cellUnderMouse = this.content.getHoveredCell();
      if ((cellUnderMouse != null) && (cellUnderMouse.item != null)) {
        return this.content.drawItemName(cellUnderMouse.item.name);
      } else {
        if (AA.UI.isHaveSomeTypeLimit()) {
          return this.content.drawItemName($gameTemp._visualChestRestrictionTypesRaw);
        } else {
          return this.content.drawItemName("");
        }
      }
    }

    _moveToLastPos() {
      if ($gameTemp.__lastVChestDragPos != null) {
        return this.invSprite.move($gameTemp.__lastVChestDragPos);
      }
    }

    _saveLastDragPos() {
      return $gameTemp.__lastVChestDragPos = [this.invSprite.x, this.invSprite.y];
    }

    loadItemsInCategory(catIndex = 4) {
      if (!this.isInventoryActive()) {
        return;
      }
      this._hideHelp();
      this._onNewCategoryWillLoad();
      this._loadedCatIndex = 4; // * 4 - CHEST
      this.content.clearAllItems();
      this.showAllChestItems();
      return this._onNewCategoryLoaded();
    }

    showAllChestItems() {
      this._loadedItems = $gameTemp.__aaItemsForChest;
      this._loadedItems.delete(null);
      this._concatItems();
      this._setPages();
      return this._showItemsGroup(0);
    }

    _concatItems() {
      var i, j, k, l, ref, ref1, ref2;
      if (this._loadedItems.length <= 1) {
        return;
      }
      for (i = k = 0, ref = this._loadedItems.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        for (j = l = ref1 = i, ref2 = this._loadedItems.length; (ref1 <= ref2 ? l < ref2 : l > ref2); j = ref1 <= ref2 ? ++l : --l) {
          if (i === j) {
            continue;
          }
          if (this._loadedItems[i][0] === this._loadedItems[j][0]) {
            this._loadedItems[i][1] += this._loadedItems[j][1];
            this._loadedItems.splice(j, 1);
            this._concatItems();
            return;
          }
        }
      }
    }

    _setItemToCell(cell, item) {
      return cell.setChestItem(item);
    }

    _refreshCategoryButtons() {} // * EMPTY

    clickAt(index) {
      if (this._loadedCatIndex !== 4) {
        return;
      }
      return this._onChestAction(index + (this._currentPage * this.MAX));
    }

    _onChestAction(index) {
      var e, itemData;
      if (this.isSomeItemFocused()) {
        return;
      }
      itemData = this._loadedItems[index];
      if (itemData == null) {
        return;
      }
      try {
        if (AA.UI.isGoldItem(itemData[0])) {
          return this._onGainGoldItem(index);
        } else {
          return this._onGainItem(index, itemData);
        }
      } catch (error) {
        e = error;
        return AA.warning('When try take item from visual chest', e);
      }
    }

    _onGainGoldItem(index) {
      var count;
      count = $gameTemp.__visualChestGoldCount;
      $gameParty.gainGold(count);
      $gameTemp.__aaItemsForChest[index] = null;
      $gameTemp.__visualChestGoldCount = 0;
      this.loadItemsInCategory(this._loadedCatIndex);
      this._checkToAutoClose();
      SoundManager.playCursor();
    }

    _onGainItem(index, itemData, fast = false) {
      var item, realCount, resultCount;
      resultCount = itemData[1];
      item = itemData[0];
      realCount = this._getItemCountToReturn(resultCount, item);
      if (realCount <= 0) {
        SoundManager.playBuzzer();
        return;
      }
      if (realCount === 1 || fast === true || !AA.UI.isUseSlider()) {
        this._onGainItemFinal(index, itemData, realCount);
        if (fast === false) { // * Если множественный, то в другом месте перезагрузка
          this.loadItemsInCategory(this._loadedCatIndex);
          this._checkToAutoClose();
          SoundManager.playCursor();
        }
      } else {
        this._onGainItemWithSlider(index, itemData, realCount);
      }
    }

    _onGainItemWithSlider(index, itemData, realCount) {
      var cell;
      cell = this.content.getCellAt(index);
      this.content.showFocusLayer();
      this.content.showFocusedItem(cell, itemData[1]);
      this.sliderController = new AA.LIBS.SliderController(this.content, 1);
      this._tempSliderIndex = index;
      this._tempSliderItem = itemData;
      this._tempSliderMaxValue = realCount;
      return this.content.refreshSlider(realCount, this._isSliderNewValueIsAllowed(realCount));
    }

    _onGainItemFinal(index, itemData, realCount) {
      $gameParty.gainItem(itemData[0], realCount);
      $gameTemp.__aaItemsForChest[index][1] = itemData[1] - realCount;
      if ($gameTemp.__aaItemsForChest[index][1] <= 0) {
        return $gameTemp.__aaItemsForChest[index] = null;
      }
    }

    //$[OVER BASE]
    onSliderOkClick() {
      if (!this.isSomeItemFocused()) {
        return;
      }
      this.clearFocus();
      this._onGainItemFinal(this._tempSliderIndex, this._tempSliderItem, this.content.getSliderValue());
      this._tempSliderItem = null;
      this._tempSliderIndex = 0;
      this.loadItemsInCategory(this._loadedCatIndex);
      this._checkToAutoClose();
      return SoundManager.playCursor();
    }

    //$[OVER BASE]
    getMaxValueForSlider() {
      return this._tempSliderMaxValue;
    }

    takeAll() {
      var e, index, itemData, k, len, ref;
      try {
        ref = $gameTemp.__aaItemsForChest;
        for (index = k = 0, len = ref.length; k < len; index = ++k) {
          itemData = ref[index];
          if (itemData != null) {
            //$gameParty.gainItem(itemData[0], itemData[1]) if itemData?
            this._onGainItem(index, itemData, true);
          }
        }
        SoundManager.playCursor();
      } catch (error) {
        e = error;
        AA.warning('When try take ALL from visual chest', e);
      }
      //$gameTemp.__aaItemsForChest = []
      this.loadItemsInCategory(this._loadedCatIndex);
      return this._checkToAutoClose();
    }

    _checkToAutoClose() {
      if (this._loadedItems.length === 0) {
        this._autoCloseThread = new AATimedUpdate(20, this.__onAutoCloseTick.bind(this));
        return this._autoCloseThread.once();
      }
    }

    __onAutoCloseTick() {
      return AA.UI.closeChest();
    }

  };
  AA.register(MapChestController);
})();

// ■ END MapChestController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.MapInvController.prototype;
  _._onActionOnGameItem = function(cell) {
    var item;
    item = cell.item;
    // * Если нет цели, если использовать в меню или всегда, то выполнять сразу
    if ((item != null) && item.scope === 0 && (item.occasion === 0 || item.occasion === 1)) {
      this._useInventoryItemDirect($gameParty.leader(), cell.item);
      return;
    }
    if (this._canPartySelect(cell.item)) {
      $gameTemp._tempItemForParty = cell.item;
      return this._onPartySelectItemClick(cell);
    } else {
      return this.useInventoryItem($gameParty.leader(), cell.item);
    }
  };
  _._canPartySelect = function(item) {
    return AA.Parameters.get_MapInventoryAllowPartySelect() && this._isItemScopeIsProper(item);
  };
  _._isItemScopeIsProper = function(item) {
    return [7, 8, 9, 10, 11].contains(item.scope);
  };
  _._onPartySelectItemClick = function(cell) {
    //@invSprite.setFocusedMode(cell)
    this.content.showFocusLayer();
    this.content.showFocusedItem(cell, $gameParty.numItems(cell.item));
    return this.partyController = new AA.LIBS.MapInvPartySelectCntrl(this.content, cell.partyUsecases);
  };
  _.isSomeItemFocused = function() {
    return this.content.isFocused();
  };
  _.clickAtFocusItem = function(index) {
    return this.clearFocus();
  };
  _.clearFocus = function() {
    var ref, ref1;
    if ((ref = this.partyController) != null) {
      ref.close();
    }
    if ((ref1 = this.sliderController) != null) {
      ref1.close();
    }
    this.sliderController = null;
    this.content.clearFocus();
    this.loadItemsInCategory(this._loadedCatIndex);
    return $gameTemp._pkdMICellFocused = false;
  };
  _.updateClearFocusClick = function() {
    if (TouchInput.isTriggered()) {
      if (this.content.isMouseInFocusZone()) {
        return this.clearFocus();
      }
    }
  };
  _.clickAtPartyActor = function(actor) {
    this.partyController.close();
    if (DataManager.isItem($gameTemp._tempItemForParty)) {
      return this.useInventoryItem(actor, $gameTemp._tempItemForParty);
    } else {
      return this._equipInventoryItemOnActor(actor, $gameTemp._tempItemForParty);
    }
  };
  //? CHANGED
  _.useInventoryItem = function(actor, item) {
    var allyABS, e, indexOnPanel;
    if (AA.isMap()) {
      try {
        if (actor === $gameParty.leader()) {
          indexOnPanel = $gameParty.leader().skillIndexOnUI(item.id, true);
          if (indexOnPanel >= 0) {
            return $gamePlayer.touchSkillAt(indexOnPanel + 1);
          } else {
            return $gamePlayer.startABSItemFromInventory(item, $gamePlayer);
          }
        } else {
          allyABS = $gameParty.memberABSByActorId(actor.actorId());
          return allyABS != null ? allyABS.startABSItemFromInventory(item) : void 0;
        }
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    } else {
      return this._useInventoryItemDirect(actor, item);
    }
  };
  _._useInventoryItemDirect = function(actor, item) {
    var actorIndex, e;
    if (item == null) {
      return;
    }
    try {
      actorIndex = AA.UI.partyGroup().indexOf(actor);
      if (actorIndex < 0) {
        return;
      }
      SoundManager.playUseItem();
      actor.useItem(item);
      this.item = function() {
        return item;
      };
      this.user = function() {
        return actor;
      };
      this._actorWindow = {};
      this._actorWindow.index = function() {
        return actorIndex;
      };
      this.itemTargetActors = function() {
        return Scene_Item.prototype.itemTargetActors.call(this);
      };
      Scene_Item.prototype.applyItem.call(this);
      Scene_Item.prototype.checkCommonEvent.call(this);
      Scene_Item.prototype.checkGameover.call(this);
      delete this._actorWindow;
      delete this.item;
      delete this.user;
      delete this.itemTargetActors;
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
})();

// ■ END MapInvController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.MapInvController.prototype;
  _._onActionOnEquipItem = function(cell) {
    var etype;
    etype = cell.item.etypeId;
    if (cell._inSpecialState === false) {
      this.equipInventoryItem(cell);
    } else {
      if (cell.isCanBeUnEquiped()) {
        this._unEquipItem(cell);
      } else {
        SoundManager.playBuzzer();
        return;
      }
    }
    return this.loadItemsInCategory(this._loadedCatIndex);
  };
  _._unEquipItem = function(cell) {
    var actor, etype;
    etype = cell.item.etypeId;
    actor = cell._getEquipmentActor();
    return this._equipFromInv(actor, etype, null);
  };
  _.equipInventoryItem = function(cell) {
    if (AA.UI.isPartyInventoryAllowed()) {
      this._tempItemForParty = cell.item;
      $gameTemp._tempItemForParty = cell.item;
      return this._onPartySelectItemClick(cell);
    } else {
      return this._equipInventoryItemOnActor($gameParty.leader(), cell.item);
    }
  };
  _._equipInventoryItemOnActor = function(actor, item) {
    var etype;
    etype = item.etypeId;
    if (actor.isEquipTypeLocked(etype)) {
      SoundManager.playBuzzer();
    } else {
      this._equipFromInv(actor, etype, item);
      this.loadItemsInCategory(this._loadedCatIndex);
    }
  };
  _._getItemCountToReturn = function(resultCount, item) {
    var c;
    c = this._getItemCountByMaxLimit(resultCount, item);
    if (c > 0 && AA.Parameters.get_IsUseMapInventoryWeightSystem()) {
      c = this._getItemCountByWeight(c, item);
    }
    return c;
  };
  _._getItemCountByMaxLimit = function(resultCount, item) {
    var haveCount, maxCount, newCount;
    haveCount = $gameParty.numItems(item);
    maxCount = $gameParty.maxItems(item);
    if (resultCount <= (maxCount - haveCount)) {
      // * Предметы вмещаются
      return resultCount; // * Предметы не вмещаются
    } else {
      newCount = maxCount - haveCount;
      return newCount;
    }
  };
  _._getItemCountByWeight = function(resultCount, item) {
    var finalW, freeW, w;
    freeW = $gameParty.getMaxWeightCapacity() - $gameParty.getCurrentWeight();
    w = DataManager.getItemWeight(item);
    if (w === 0) {
      return resultCount;
    }
    finalW = resultCount * w;
    if (finalW <= freeW) {
      return resultCount;
    } else {
      if (w > freeW) { // * Даже один нельзя
        this._requestNoWeightNotify();
        return 0;
      } else {
        this._requestNoWeightNotify();
        return Math.floor(freeW / w);
      }
    }
  };
  _._requestNoWeightNotify = function() {
    return AA.UI.requestWeigthNotify();
  };
  _._executeNoWeightNotify = function() {
    return this.invSprite._footer.pulseWeightText();
  };
})();

// ■ END MapInvController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.MapInvController.prototype;
  _.onSliderOkClick = function() {
    if (!this.isSomeItemFocused()) {
      return;
    }
    this.clearFocus();
    this._onStoreItemFinal(this._tempSliderItem, this.content.getSliderValue());
    return this._tempSliderItem = null;
  };
  _.onSliderValueChanged = function(percent) {
    var isAllowed, max, value;
    max = this.getMaxValueForSlider();
    value = Math.round(max * percent / 100);
    if (value <= 0) {
      value = 1;
    }
    if (value >= max) {
      value = max;
    }
    // * Из инвентаря всегда можно убрать
    isAllowed = this._isSliderNewValueIsAllowed(value);
    return this.content.refreshSlider(value, isAllowed);
  };
  // * FOR OVERRIDE
  _.getMaxValueForSlider = function() {
    return $gameParty.numItems(this._tempSliderItem);
  };
  // * FOR OVERRIDE
  _._isSliderNewValueIsAllowed = function(value) {
    return true;
  };
  _._onStoreItemProcess = function(cell) {
    var count, item;
    if (this.isSomeItemFocused()) {
      return;
    }
    item = cell.item;
    if (AA.UI.isHaveSomeTypeLimit()) {
      if (!AA.UI.isProperItemForTypeLimit(item)) {
        SoundManager.playBuzzer();
        return;
      }
    }
    count = $gameParty.numItems(item);
    if (count === 1 || !AA.UI.isUseSlider()) {
      this._onStoreItemFinal(item, count);
    } else {
      this.content.showFocusLayer();
      this.content.showFocusedItem(cell, count);
      this.sliderController = new AA.LIBS.SliderController(this.content, 0);
      this._tempSliderItem = item;
      this.content.refreshSlider(count, true);
    }
  };
  _._onStoreItemFinal = function(item, count) {
    $gameParty.loseItem(item, count, true);
    SoundManager.playCursor();
    this.loadItemsInCategory(this._loadedCatIndex);
    if (AA.UI.isUserChestIsOpen()) {
      $gameTemp._newUserChestCat = this._loadedCatIndex;
      return $gamePlayer.addPutItemToPlayerChest(item, count);
    } else if (AA.UI.isStoredChestIsOpen()) {
      $gameTemp.__aaItemsForChest.push([item, count]);
      return AA.UI.refreshStoredChest();
    }
  };
  _.inSliderMode = function() {
    return (this.sliderController != null) && this.isSomeItemFocused();
  };
})();

// ■ END MapInvController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapInvController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (!AA.isPro()) {
    return;
  }
  //@[DEFINES]
  _ = AA.LIBS.MapInvController.prototype;
  _._updateHelp = function() {
    var hovered;
    if (this._itemDescShowTimer != null) {
      this._itemDescShowTimer.update();
    }
    hovered = this.content.getHoveredCell();
    if ((hovered != null) && (hovered.item != null)) {
      this._showHelp(hovered);
    } else {
      this._hideHelp();
    }
    if (this._itemDescWindow != null) {
      return this._updateEquipStatShow();
    }
  };
  _._updateEquipStatShow = function() {
    if (TouchInput.wheelY >= 20 || TouchInput.wheelY <= -20) {
      this._itemDescWindow.showItemStats();
    }
  };
  _._showHelp = function(cell) {
    if (this.__lastHelpItem === cell) {

    } else {
      this._hideHelp();
      this.__lastHelpItem = cell;
      return this._createHelpWindow();
    }
  };
  _._createHelpWindow = function() {
    this._itemDescWindow = new AA.LIBS.Sprite_MapInvHelp();
    this._waitTime = this._itemDescWindow.delay();
    this._itemDescShowTimer = new AATimedUpdate(1, this._onShowTimeTick.bind(this));
    this._itemDescWindow.opacity = 0;
    this._itemDescWindow.setup(this.__lastHelpItem);
    this._placeDescription();
    return this.layer.addChild(this._itemDescWindow);
  };
  _._onShowTimeTick = function() {
    if (this._waitTime > 0) {
      return this._waitTime--;
    } else {
      if (this._itemDescWindow.opacity < 255) {
        return this._itemDescWindow.opacity += 20;
      } else {
        return this._itemDescShowTimer = null;
      }
    }
  };
  _._placeDescription = function() {
    var e;
    try {
      if (this._itemDescWindow == null) {
        return;
      }
      return this._itemDescWindow.refreshPlacement();
    } catch (error) {
      e = error;
      return AA.warning('_placeDescription', e);
    }
  };
  _._hideHelp = function() {
    if (this.__lastHelpItem == null) {
      return;
    }
    this._itemDescShowTimer = null;
    this._destroyHelpWindow();
    return this.__lastHelpItem = null;
  };
  _._destroyHelpWindow = function() {
    this._itemDescShowTimer = null;
    if (this._itemDescWindow == null) {
      return;
    }
    this.layer.removeChild(this._itemDescWindow);
    this._itemDescWindow.visible = false;
    return this._itemDescWindow = null;
  };
})();

// ■ END MapInvController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MapUserChestController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MapUserChestController;
  if (!AA.isPro()) {
    return;
  }
  MapUserChestController = class MapUserChestController extends AA.LIBS.MapInvController {
    constructor() {
      super(...arguments);
      this.goldRefreshThread = null;
    }

    _onGoldTick() {} // * EMPTY

    _moveToLastPos() {
      if ($gameTemp.__lastUserChestDragPos != null) {
        return this.invSprite.move($gameTemp.__lastUserChestDragPos);
      }
    }

    _saveLastDragPos() {
      return $gameTemp.__lastUserChestDragPos = [this.invSprite.x, this.invSprite.y];
    }

    updateWhenOpen() {
      var ref;
      super.updateWhenOpen();
      if ((ref = this._autoCloseThread) != null) {
        ref.update();
      }
      if (Input.isTriggered(AA.LIBS.IKey.TALL())) {
        return this.takeAll();
      }
    }

    showItems() {
      this._loadedItems = $gamePlayer.aaGetPlayerChestStoredItems().getOnlyItems();
      this._setPages();
      return this._showItemsGroup(0);
    }

    showWeapons() {
      this._loadedItems = $gamePlayer.aaGetPlayerChestStoredItems().getOnlyWeapons();
      this._setPages();
      return this._showItemsGroup(0);
    }

    showArmors() {
      this._loadedItems = $gamePlayer.aaGetPlayerChestStoredItems().getOnlyArmors();
      this._setPages();
      return this._showItemsGroup(0);
    }

    showKeys() {
      this._loadedItems = [];
      this._setPages();
      return this._showItemsGroup(0);
    }

    clickAt(index) {
      var e;
      try {
        this._onReturnItem(index + (this._currentPage * this.MAX));
        if (AA.UI.isInventoryOpened()) {
          return AA.UI.refreshInventory();
        }
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    _onReturnItem(index) {
      var itemData;
      itemData = this._loadedItems[index];
      if (itemData == null) {
        return;
      }
      this._onReturnItemWithCheck(index, itemData);
    }

    _onReturnItemWithCheck(index, itemData, fast = false) {
      var cell, item, realCount, resultCount;
      resultCount = itemData[1];
      item = itemData[0];
      realCount = this._getItemCountToReturn(resultCount, item);
      if (realCount <= 0) {
        SoundManager.playBuzzer();
        return;
      }
      if (realCount === 1 || fast === true || !AA.UI.isUseSlider()) {
        this._onStoreItemFinal(itemData, realCount);
        if (fast === false) { // * Если множественный, то в другом месте перезагрузка
          SoundManager.playCursor();
          this.loadItemsInCategory(this._loadedCatIndex);
        }
      } else {
        //cell = @content.getCellAt(index)
        //@_checkToAutoClose()
        cell = this.content.getCellByItem(itemData[0]);
        this._onReturnItemWithSlider(cell, itemData, realCount);
      }
    }

    //$[OVER BASE]
    onSliderOkClick() {
      if (!this.isSomeItemFocused()) {
        return;
      }
      this.clearFocus();
      this._onStoreItemFinal(this._tempSliderItem, this.content.getSliderValue());
      this._tempSliderItem = null;
      this.loadItemsInCategory(this._loadedCatIndex);
      //@_checkToAutoClose()
      return SoundManager.playCursor();
    }

    _onReturnItemWithSlider(cell, itemData, realCount) {
      this.content.showFocusLayer();
      this.content.showFocusedItem(cell, itemData[1]);
      this.sliderController = new AA.LIBS.SliderController(this.content, 1);
      this._tempSliderItem = itemData;
      this._tempSliderMaxValue = realCount;
      return this.content.refreshSlider(realCount, this._isSliderNewValueIsAllowed(realCount));
    }

    //$[OVER BASE]
    getMaxValueForSlider() {
      return this._tempSliderMaxValue;
    }

    //$[OVER BASE]
    _onStoreItemFinal(itemData, count) {
      var item;
      $gameTemp._newUserChestCat = this._loadedCatIndex;
      item = itemData[0];
      $gamePlayer.removeItemFromChestStorage(item, count);
      //* Прятать всплывающее, если инвентарь открыт
      $gameParty._noNotifyABS = AA.UI.isInventoryOpened();
      $gameParty.gainItem(itemData[0], count);
      $gameParty._noNotifyABS = false;
    }

    _setItemToCell(cell, item) {
      return cell.setChestItem(item);
    }

    takeAll() {
      var e;
      try {
        // * Забирает все вещи с текущей категории
        //"TAKE ALL".p()
        this._returnAllItemsOfCategory();
        if (AA.UI.isInventoryOpened()) {
          //$gamePlayer.removeFullTypeFromChestStorage(@_loadedCatIndex)
          AA.UI.refreshInventory();
        }
        SoundManager.playCursor();
      } catch (error) {
        e = error;
        AA.warning('When try take ALL from User storage chest', e);
      }
      this.loadItemsInCategory(this._loadedCatIndex);
      return this._checkToAutoClose();
    }

    _returnAllItemsOfCategory() {
      var i, itemData, j, l, ref;
      $gameParty._noNotifyABS = AA.UI.isInventoryOpened();
      l = this._loadedItems.length;
      for (i = j = 0, ref = l; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        itemData = this._loadedItems[i];
        if (itemData == null) {
          continue;
        }
        //$gameParty.gainItem(itemData[0], itemData[1])
        this._onReturnItemWithCheck(i, itemData, true);
        if (l !== this._loadedItems.length) {
          this._returnAllItemsOfCategory();
          return;
        }
      }
      $gameParty._noNotifyABS = false;
    }

    // * Если нету вообще ничего (а не только в текущей категории)
    _checkToAutoClose() {
      if ($gamePlayer.aaGetPlayerChestStoredItems().items.length === 0) {
        this._autoCloseThread = new AATimedUpdate(20, this.__onAutoCloseTick.bind(this));
        return this._autoCloseThread.once();
      }
    }

    __onAutoCloseTick() {
      return AA.UI.closeUserChest();
    }

  };
  AA.register(MapUserChestController);
})();

// ■ END MapUserChestController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_AADBEnemiesEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_AADBEnemiesEditor.prototype;
  _._createMainField = function() {
    this.mainField = AASprite.FromBitmap(800, 600);
    this.mainField.fillAll(KDCore.Color.BLACK.reAlpha(150));
    this.addChild(this.mainField);
    this.mainField.x = (Graphics.width / 2) - 400;
    this.mainField.y = (Graphics.height / 2) - 300;
    return this._createEditorTitle();
  };
  _._createEditorTitle = function() {
    this.header = new Sprite(new Bitmap(800, 40));
    this.header.y = 5;
    this.header.x = 0;
    this.header.bitmap.drawTextFull('Alpha ABS Enemies Editor', 'center');
    return this.add(this.header);
  };
  _._createEditWindows = function() {
    this.enemySelectWindow = new Window_AADBEnemiesSelectWindow();
    this.enemySelectWindow.setHandler('ok', this._onEnemySelectedForEdit.bind(this));
    this.addWindow(this.enemySelectWindow);
    this.enemyEditWindow = new Window_AADBEnemyEditABSWindow();
    this.enemyEditWindow.hide();
    this.addWindow(this.enemyEditWindow);
    this.optionSelectWindow = new Window_AADBOptionSelector();
    this.optionSelectWindow.hide();
    this.optionSelectWindow.setHandler('ok', this._onOptionSelected.bind(this));
    return this.addWindow(this.optionSelectWindow);
  };
})();

// ■ END Scene_AADBEnemiesEditor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_AABDEnemiesEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_AADBEnemiesEditor.prototype;
  _.activateSelectEnemyWindow = function() {
    this.isMainSceneActive = true;
    this.enemySelectWindow.show();
    this.enemySelectWindow.refresh();
    this.enemySelectWindow.activate();
    return this.enemySelectWindow.select(0);
  };
  _._onEnemySelectedForEdit = function() {
    SoundManager.playOk();
    "SELECTED".p(this.enemySelectWindow.selectedEnemy().name);
    this._selectedEnemy = this.enemySelectWindow.selectedEnemy();
    return this.activateEnemyEditorABS();
  };
  _.activateEnemyEditorABS = function() {
    this.isMainSceneActive = false;
    this.enemySelectWindow.hide();
    this.enemyEditWindow.setEnemyToEdit(this._selectedEnemy);
    this.enemyEditWindow.show();
    this.enemyEditWindow.activate();
    return this.enemyEditWindow.select(0);
  };
  _.closeEnemyEditorABS = function() {
    this.enemyEditWindow.hide();
    return this.enemyEditWindow.deactivate();
  };
  _.prepareOptionSelectWindow = function(param) {
    //option = {value, name, desc}
    return this._aadbeeOptionList = this.generateOptionsForParam(param);
  };
  _.activateOptionSelectWindow = function(param) {
    this.isSelectorActive = true;
    this.closeEnemyEditorABS();
    this._lastEnemyEditedParam = param;
    this.optionSelectWindow.setOptions(param, this._lastOptionsType, this._aadbeeOptionList);
    this.optionSelectWindow.show();
    this.optionSelectWindow.activate();
    return this.optionSelectWindow.select(0);
  };
  _.onToggleParamValue = function(param) {
    var currentValue;
    "TOGGLE".p(param);
    currentValue = parseInt(AADBEditorManager.getCurrentValueForParam(this._selectedEnemy, param));
    if (currentValue === 1) {
      currentValue = 0;
    } else {
      currentValue = 1;
    }
    this.modifyEnemyDBValue(param, currentValue);
    this.enemyEditWindow.refresh();
  };
  _.onResetParamValue = function(param) {
    var currentValue;
    "RESET".p(param);
    currentValue = AADBEditorManager.getDefaultValueForParam(param);
    this.modifyEnemyDBValue(param, currentValue);
    this.enemyEditWindow.refresh();
  };
  _.onPlusParamValue = function(param) {
    var currentValue;
    "PLUS".p(param);
    currentValue = parseInt(AADBEditorManager.getCurrentValueForParam(this._selectedEnemy, param));
    this.modifyEnemyDBValue(param, currentValue + 1);
    this.enemyEditWindow.refresh();
  };
  _.onMinusParamValue = function(param) {
    var currentValue;
    "MINUS".p(param);
    currentValue = parseInt(AADBEditorManager.getCurrentValueForParam(this._selectedEnemy, param));
    this.modifyEnemyDBValue(param, currentValue - 1);
    this.enemyEditWindow.refresh();
  };
  _.onOptionParamValue = function(param) {
    "OPTION".p(param);
    this._lastSelectedEditorIndex = this.enemyEditWindow.index();
    this.prepareOptionSelectWindow(param);
    return this.activateOptionSelectWindow(param);
  };
  _._onOptionSelected = function() {
    this._lastOption = this.optionSelectWindow.selectedOption();
    if ((this._lastOption != null) && (this._lastOption.value != null)) {
      SoundManager.playOk();
      this.modifyEnemyDBValue(this._lastEnemyEditedParam, this._lastOption.value);
      return this.closeOptionSelectWindow();
    } else {
      SoundManager.playBuzzer();
      return this.optionSelectWindow.activate();
    }
  };
  _.closeOptionSelectWindow = function() {
    this.optionSelectWindow.hide();
    this.optionSelectWindow.deactivate();
    this.isSelectorActive = false;
    this.activateEnemyEditorABS();
    this.enemyEditWindow.select(this._lastSelectedEditorIndex);
    return this.enemyEditWindow.refresh();
  };
  _.modifyEnemyDBValue = function(param, value) {
    var e;
    try {
      return AADBEditorManager.modifyEnemyDBValue(this._selectedEnemy, value, param);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Scene_AABDEnemiesEditor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_AADBEnemiesEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_AADBEnemiesEditor.prototype;
  _.generateOptionsForParam = function(param) {
    var options;
    options = [];
    this._lastOptionsType = null;
    switch (param) {
      case 'cEonStart':
      case 'cEonDeath':
      case 'cEonEnd':
      case 'cEinBattle':
      case 'cEvIfLvlNotSame':
        this._lastOptionsType = 'commonEvent';
        options = this._getCommonEventsOptionsList();
        break;
      case 'supportSkillId':
        this._lastOptionsType = 'skill';
        options = this._getSkillsOptionsList();
        break;
      case 'HPBarStyle':
        this._lastOptionsType = 'hpBar';
        options = this._getHPBarsOptionsList();
        break;
      case 'faceName':
        this._lastOptionsType = 'faces';
        options = this._getFacesOptionsList();
        break;
      case 'returnType':
        this._lastOptionsType = 'returnType';
        options = this._getReturnTypesOptionsList();
        break;
      case 'sBattleMode':
        this._lastOptionsType = 'summonBattleMode';
        options = this._getSummonBattleModesOptionsList();
        break;
      case 'barrierElemId':
        this._lastOptionsType = 'element';
        options = this._getElementsOptionsList();
        break;
    }
    // * NOTHING
    return options;
  };
  _._getCommonEventsOptionsList = function() {
    var items, optionSet;
    items = $dataCommonEvents.filter(function(ev) {
      return (ev != null) && ev.name !== "" && ev.list.length > 1;
    });
    optionSet = items.map(function(i) {
      return {
        value: i.id,
        name: i.name,
        desc: ""
      };
    });
    return optionSet;
  };
  _._getSkillsOptionsList = function() {
    var items, optionSet;
    items = $dataSkills.filter(function(s) {
      return (s != null) && s.name !== "" && (s.meta != null) && (s.meta.ABS != null);
    });
    optionSet = items.map(function(i) {
      return {
        value: i.id,
        name: i.name,
        desc: i.description
      };
    });
    return optionSet;
  };
  _._getHPBarsOptionsList = function() {
    var items, optionSet;
    items = AAJsonSettings.data.UIGauges;
    optionSet = items.map(function(i) {
      return {
        value: i.id,
        name: i.id,
        desc: "From data/AABS/UIGauges.json"
      };
    });
    return optionSet;
  };
  _._getFacesOptionsList = function() {
    var items, optionSet;
    if (!Utils.isNwjs()) {
      return [];
    }
    items = AADBEditorManager.getAllFaceImages().map(function(i) {
      return i.replace(".png", "");
    });
    optionSet = items.map(function(i) {
      return {
        value: i,
        name: i,
        desc: "From img/faces/"
      };
    });
    return optionSet;
  };
  _._getReturnTypesOptionsList = function() {
    var optionSet;
    optionSet = [];
    optionSet.push({
      value: 0,
      name: "Instant",
      desc: "Enemy instantly returns to home poistion"
    });
    optionSet.push({
      value: 1,
      name: "Walk",
      desc: "Enemy slowly (walking) returns to home poistion"
    });
    optionSet.push({
      value: 2,
      name: "None",
      desc: "Enemy stay (not returning at all)"
    });
    return optionSet;
  };
  _._getSummonBattleModesOptionsList = function() {
    var optionSet;
    optionSet = [];
    optionSet.push({
      value: 0,
      name: "Attack All",
      desc: "Attack all enemies in view range"
    });
    optionSet.push({
      value: 1,
      name: "Attack Target",
      desc: "Attack only player target"
    });
    optionSet.push({
      value: 2,
      name: "Protect",
      desc: "Attack only enemy, who attack player"
    });
    return optionSet;
  };
  _._getElementsOptionsList = function() {
    var i, items, j, optionSet, ref;
    items = $dataSystem.elements;
    optionSet = [];
    for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
      optionSet.push({
        value: i,
        name: items[i],
        desc: ""
      });
    }
    return optionSet;
  };
})();

// ■ END Scene_AADBEnemiesEditor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_BarrierGauge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_BarrierGauge, Sprite_BarrierGaugeAlly, Sprite_BarrierGaugePlayer;
  Sprite_BarrierGauge = class Sprite_BarrierGauge extends AA.LIBS.Sprite_ColorGauge {
    // * Заместо settings передаётся ElementID!
    constructor(barrierElementId) {
      super(barrierElementId);
    }

    _loadSettings() {
      this.barrierElementId = this.settings;
      this.settings = this._getBarrierSettings();
      if (this.barrierElementId > 0) {
        this.barrierSettings = AA.JSON.getAbsordBarrierStyle(this.barrierElementId);
        this.settings.fillColor = this.barrierSettings.barrierHpGaugeColor;
      }
      return this.moveByJson(this.settings);
    }

    _getBarrierSettings() {
      return AA.JSON.getAbsorbBarriersSettings().barrierHpGauge;
    }

    _createForeground() {
      super._createForeground();
      if (this.barrierElementId > 0) {
        return this._createIcon();
      }
    }

    _createIcon() {
      var icon, iconPos;
      icon = this.barrierSettings.gaugeIcon;
      if (icon == null) {
        return;
      }
      iconPos = AA.JSON.getAbsorbBarriersSettings().positionOnBarrierHpGauge;
      this.icon = AASprite.FromImg(icon);
      this.icon.move(iconPos);
      return this.add(this.icon);
    }

  };
  Sprite_BarrierGaugePlayer = class Sprite_BarrierGaugePlayer extends Sprite_BarrierGauge {
    constructor() {
      super(...arguments);
    }

    _getBarrierSettings() {
      return AA.JSON.getAbsorbBarriersSettings().barrierPlayerHpGauge;
    }

    _createIcon() {} // * EMPTY

  };
  Sprite_BarrierGaugeAlly = class Sprite_BarrierGaugeAlly extends Sprite_BarrierGauge {
    constructor() {
      super(...arguments);
    }

    _getBarrierSettings() {
      return AA.JSON.getAbsorbBarriersSettings().barrierAllyHpGauge;
    }

    _createIcon() {} // * EMPTY

  };
  AA.register(Sprite_BarrierGauge);
  AA.register(Sprite_BarrierGaugePlayer);
  AA.register(Sprite_BarrierGaugeAlly);
})();

// ■ END Sprite_BarrierGauge.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateOther, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__updateOther = _.updateOther;
  _.updateOther = function() {
    ALIAS__updateOther.call(this);
    return this._updateDashMotionHolder();
  };
  _._updateDashMotionHolder = function() {
    return this.updateDashMotion();
  };
  // * EXTRA DASH ANIMATION ================================
  _.updateDashMotion = function() {
    var chara, isAnimAllowed;
    if (this._character == null) {
      return;
    }
    chara = this._character;
    //isDashing = if chara._memberIndex then $gamePlayer.isDashing() || $gamePlayer.isJumping() else chara.isDashing() || chara.isJumping()
    isAnimAllowed = this._isExtraTiltAnimAllowed();
    if (isAnimAllowed && (chara.isMoving() || this.__lastMoving)) {
      this.y -= chara.pattern() % 2 * 2;
      switch (chara.direction()) {
        case 2:
        case 8:
          this.scale.y = 0.92;
          this.rotation = 0;
          break;
        case 4:
          this.rotation = -0.14;
          break;
        case 6:
          this.rotation = 0.14;
      }
    } else {
      this.rotation = 0;
      this.scale.y = 1;
    }
    this.__lastMoving = chara.isMoving();
  };
  _._isExtraTiltAnimAllowed = function() {
    var isAnimAllowed, isAnimAllowed1, isAnimAllowed2;
    isAnimAllowed = false;
    isAnimAllowed2 = false;
    if (AA.Parameters.get_IsUseExtraDashCharacterTilt()) {
      isAnimAllowed1 = this._character.isDashing();
    }
    if (AA.Parameters.get_IsUseExtraJumpCharacterTilt()) {
      isAnimAllowed2 = this._character.isJumping();
    }
    return isAnimAllowed1 || isAnimAllowed2;
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MainInvItems.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Sprite_MainInvItems.prototype;
  _.showFocusLayer = function() {
    var h, w;
    w = this.settings.invCellMarginX * 5;
    h = this.settings.invCellMarginY * 5;
    this._focusLayer = AASprite.FromBitmap(w, h);
    //@_focusLayer.move -1, -1
    this._focusLayer.bitmap.fillAll(KDCore.Color.BLACK);
    this._focusLayer.opacity = 180;
    this.content.addChild(this._focusLayer);
    return $gameTemp._pkdMICellFocused = true;
  };
  _.showFocusedItem = function(cell, itemCount) {
    this.focusedCell = new AA.LIBS.Sprite_MapInvCell(cell.index);
    this.focusedCell.move(cell.x, cell.y);
    this.focusedCell.setFocusItem(cell.item, itemCount);
    return this._focusLayer.addChild(this.focusedCell);
  };
  _.isFocused = function() {
    return this._focusLayer != null;
  };
  _.clearFocus = function() {
    var ref;
    if (!this.isFocused()) {
      return;
    }
    this.content.removeChild(this._focusLayer);
    this._focusLayer.visible = false;
    this._focusLayer.destroy();
    this._focusLayer = null;
    if ((ref = this.focusedCell) != null) {
      ref.destroy();
    }
    this.focusedCell = null;
    return $gameTemp._pkdMICellFocused = false;
  };
  _.isMouseInFocusZone = function() {
    var pos, rx, ry;
    if (this.focusedCell.isHovered()) {
      return false;
    }
    if (this._isSomePartyActorIsHovered()) {
      return false;
    }
    if (this._isSliderIsHovered()) {
      return false;
    }
    pos = TouchInput.getMousePosition();
    rx = Sprite_Button.prototype.canvasToLocalX.call(this._focusLayer, pos.x);
    ry = Sprite_Button.prototype.canvasToLocalY.call(this._focusLayer, pos.y);
    return rx >= 0 && ry >= 0 && rx <= this._focusLayer.width && ry <= this._focusLayer.height;
  };
  _.createPartyActors = function() {
    var i, j, len, ref, spr;
    this.partyFaces = [];
    this._focusGroup = new Sprite();
    this.content.addChild(this._focusGroup);
    this._focusGroup.move(this.focusedCell.x, this.focusedCell.y);
    ref = AA.UI.partyGroup();
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      spr = new AA.LIBS.Sprite_MapInventoryActorCell();
      spr.setActor(i);
      this.partyFaces.push(spr);
      this._focusGroup.addChild(spr);
    }
    return this.partyFaces;
  };
  _._isSomePartyActorIsHovered = function() {
    var i, j, len, ref;
    if (this.partyFaces == null) {
      return false;
    }
    ref = this.partyFaces;
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      if (i.isHovered()) {
        return true;
      }
    }
    return false;
  };
  _.destroyPartyActors = function() {
    this.partyFaces = null;
    return this._destroyFocusGroup();
  };
  _._destroyFocusGroup = function() {
    var ref;
    this.removeChild(this._focusGroup);
    if ((ref = this._focusGroup) != null) {
      ref.destroy();
    }
    return this._focusGroup = null;
  };
})();

// ■ END Sprite_MainInvItems.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MainInvItems.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Sprite_MainInvItems.prototype;
  _.createSlider = function(methodA, methodB) {
    //"SHOW SLIDER".p()
    this._focusGroup = new Sprite();
    this.content.addChild(this._focusGroup);
    this._focusGroup.move(this.focusedCell.x, this.focusedCell.y);
    this._sliderItem = new AA.LIBS.Sprite_NumberSlider(this._onSliderLoaded.bind(this), methodB);
    this._sliderItem.visible = false;
    this._focusGroup.addChild(this._sliderItem);
    this._sliderOkBtn = this._createSliderOkBtn(methodA);
    this._sliderOkBtn.visible = false;
    this._focusGroup.addChild(this._sliderOkBtn);
    this._createSlidedItemRealCountText();
    this._onSliderLoaded();
  };
  _.refreshSlider = function(value, isAllowed) {
    this._lastSliderValue = value;
    this._slierItemCountText.clear();
    //@_slierItemCountText.bitmap.fillAll KDCore.Color.RED
    if (isAllowed) {
      this._slierItemCountText.bitmap.textColor = KDCore.Color.FromHex(this.settings.cellItemSliderCountText.textColor).CSS;
      this._sliderOkBtn.enable();
    } else {
      this._slierItemCountText.bitmap.textColor = KDCore.Color.FromHex(this.settings.cellItemSliderCountText.textColor2).CSS;
      this._sliderOkBtn.disable();
    }
    return this._slierItemCountText.drawTextFull(value, this.settings.cellItemSliderCountText.position);
  };
  _.getSliderValue = function() {
    return this._lastSliderValue;
  };
  _._createSlidedItemRealCountText = function() {
    this._slierItemCountText = AASprite.FromBitmap(this.settings.cellItemSliderCountText.textBoxWidth, this.settings.cellItemSliderCountText.textBoxHeight);
    this.applyTextSettingsByExtraSettings(this._slierItemCountText, this.settings.cellItemSliderCountText);
    return this._focusGroup.addChild(this._slierItemCountText);
  };
  _._createSliderOkBtn = function(methodA) {
    var btn, btn1, btn2;
    this._sliderOkBtn = new KDCore.Button();
    btn = ImageManager.loadAA('slider_button_ok_00');
    btn1 = ImageManager.loadAA('slider_button_ok_01');
    btn2 = ImageManager.loadAA('slider_button_ok_03');
    this._sliderOkBtn.setButtonImages(btn, btn1, btn, btn2);
    this._sliderOkBtn.x = this.settings.itemSliderSettings.sliderOkButtonMarginX;
    this._sliderOkBtn.y = this.settings.itemSliderSettings.sliderOkButtonMarginY;
    this._sliderOkBtn.addClickHandler(function() {
      return methodA();
    });
    return this._sliderOkBtn;
  };
  _._onSliderLoaded = function() {
    //"AFTER LOAD".p()
    if (this._sliderItem == null) {
      return;
    }
    this._sliderItem.x = this.settings.itemSliderSettings.sliderCellMarginX;
    this._sliderItem.y = this.settings.itemSliderSettings.sliderCellMarginY;
    this._sliderItem.visible = true;
    return this._sliderOkBtn.visible = true;
  };
  _.destroySlider = function() {
    var ref;
    if ((ref = this._sliderItem) != null) {
      ref.terminate();
    }
    this._destroyFocusGroup();
    return this._sliderItem = null;
  };
  _._isSliderIsHovered = function() {
    if (this._sliderItem == null) {
      return false;
    }
    if (this._sliderOkBtn.isMouseInButton()) {
      return true;
    }
    if (this._sliderItem.isInMousePositionAll()) {
      return true;
    }
  };
  _.getCellByItem = function(item) {
    var c, i, len, ref;
    ref = this._cells;
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      if (c.item === item) {
        return c;
      }
    }
    return null;
  };
})();

// ■ END Sprite_MainInvItems.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapChestFooter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapChestFooter;
  Sprite_MapChestFooter = class Sprite_MapChestFooter extends AA.LIBS.Sprite_MapInvFooter {
    constructor() {
      super();
    }

    _createContent() {
      this._createTakeAllBtn();
      return this._createTakeText();
    }

    _createTakeAllBtn() {
      var img0, img1;
      this.takeBtn = new KDCore.Button();
      img0 = ImageManager.loadAA("inventoryChestTakeAllButton_00");
      img1 = ImageManager.loadAA("inventoryChestTakeAllButton_01");
      this.takeBtn.setButtonImages(img0, img1, img0, img0);
      this.takeBtn.move(AA.Utils.jsonPos(this.settings.takeAllButtonPosition));
      this.takeBtn.addClickHandler(function() {
        return AA.UI.takeAllFromChest();
      });
      return this.add(this.takeBtn);
    }

    _createTakeText() {
      var text, textSpr;
      textSpr = AASprite.FromTextSettings(this.settings.takeTextSettings);
      //textSpr.fillAll()
      text = this.settings.takeDefaultText;
      textSpr.drawTextWithSettings(text);
      return this.add(textSpr);
    }

    _createArrows() {
      AA.LIBS.Sprite_MapInvFooter.prototype._createArrows.call(this);
      this._arrowL.clearClickHandlers();
      this._arrowR.clearClickHandlers();
      this._arrowL.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.chestShowPrevPage();
      });
      return this._arrowR.addClickHandler(function() {
        SoundManager.playCursor();
        AA.UI.chestShowNextPage();
      });
    }

    _settingsJSON() {
      return AA.JSON.getUIMapChestSettings();
    }

  };
  AA.register(Sprite_MapChestFooter);
})();

// ■ END Sprite_MapChestFooter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapChestHeader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapChestHeader;
  Sprite_MapChestHeader = class Sprite_MapChestHeader extends AA.LIBS.Sprite_MapInvHeader {
    constructor() {
      super();
    }

    _createContent() {
      var text;
      text = $gameTemp.__aaChestName;
      if (text == null) {
        text = this.settings.defaultChestName;
      }
      this._content = AASprite.FromTextSettings(this.settings.chestName);
      this._content.drawTextWithSettings(text);
      this.add(this._content);
      return $gameTemp.__aaChestName = null;
    }

    _drawIcon() {
      var icon;
      if (this.settings.icon == null) {
        return;
      }
      if ($gameTemp.__aaChestIsLoot === true) {
        icon = AASprite.FromImg("InventoryIconLoot");
        $gameTemp.__aaChestIsLoot = null;
      } else {
        icon = AASprite.FromImg(this.settings.icon);
      }
      icon.move(this.settings.iconMarginX, this.settings.iconMarginY);
      return this.add(icon);
    }

    _settingsJSON() {
      return AA.JSON.getUIMapChestSettings();
    }

    _createCloseButton() {
      super._createCloseButton();
      this.closeBtn.clearClickHandlers();
      return this.closeBtn.addClickHandler(function() {
        return AA.UI.closeChest();
      });
    }

  };
  AA.register(Sprite_MapChestHeader);
})();

// ■ END Sprite_MapChestHeader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ zSprite_MapChestMain_PRO.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapChestMain;
  Sprite_MapChestMain = class Sprite_MapChestMain extends AA.LIBS.Sprite_MapInvMain {
    constructor() {
      super();
    }

    _settingsJSON() {
      return AA.JSON.getUIMapChestSettings();
    }

    _createHeader() {
      this._header = new AA.LIBS.Sprite_MapChestHeader();
      return this._main.addChild(this._header);
    }

    _createFooter() {
      this._footer = new AA.LIBS.Sprite_MapChestFooter();
      return this._main.addChild(this._footer);
    }

    playStartSE() {
      return AA.Utils.playSE(this.settings.openChestSE);
    }

  };
  AA.register(Sprite_MapChestMain);
})();

// ■ END zSprite_MapChestMain_PRO.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_MapInventoryStatText2;
  // * Используется для окна статистики
  Sprite_MapInventoryStatText2 = class Sprite_MapInventoryStatText2 extends AA.LIBS.Sprite_MapInventoryStatText {
    constructor(statId, actor) {
      super(statId, actor);
    }

    _drawValues() {
      // * В cell хранится Actor
      return this._drawStateValue(this.cell[this.statId], 'normal');
    }

  };
  AA.register(Sprite_MapInventoryStatText2);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapUserChestHeader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_MapUserChestHeader;
  Sprite_MapUserChestHeader = class Sprite_MapUserChestHeader extends AA.LIBS.Sprite_MapInvHeader {
    constructor() {
      super();
    }

    _drawIcon() {
      var icon, tempSettings;
      tempSettings = AA.JSON.getUIMapUserChestSettings();
      if (tempSettings.icon == null) {
        return;
      }
      icon = AASprite.FromImg(tempSettings.icon);
      icon.move(tempSettings.iconMarginX, tempSettings.iconMarginY);
      return this.add(icon);
    }

    _settingsJSON() {
      return AA.JSON.getUIMapInventorySettings();
    }

    _createCloseButton() {
      var ref, tempSettings;
      super._createCloseButton();
      this.closeBtn.clearClickHandlers();
      this.closeBtn.addClickHandler(function() {
        return AA.UI.closeUserChest();
      });
      if ((ref = this.category4) != null) {
        ref.visible = false;
      }
      tempSettings = AA.JSON.getUIMapUserChestSettings();
      this._content.move(tempSettings.categoryButtonsMarginX, tempSettings.categoryButtonsMarginY);
      if (this.category1 != null) {
        this.category1.clearClickHandlers();
        this.category1.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.userChestShowCategoryItems();
        });
      }
      if (this.category2 != null) {
        this.category2.clearClickHandlers();
        this.category2.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.userChestShowCategoryWeapons();
        });
      }
      if (this.category3 != null) {
        this.category3.clearClickHandlers();
        this.category3.addClickHandler(function() {
          SoundManager.playCursor();
          AA.UI.userChestShowCategoryArmors();
        });
      }
      if (this.category4 != null) {
        this.category4.clearClickHandlers();
      }
    }

  };
  AA.register(Sprite_MapUserChestHeader);
})();

// ■ END Sprite_MapUserChestHeader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_InterfaceABS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Spriteset_InterfaceABS.prototype;
  _._createPartyUI = function() {
    var e;
    try {
      if ($gameParty.membersABS().length > 0) {
        this.partyUIGroup = new AA.LIBS.PartyUIManager(this);
        if (this._summonUnitCtr != null) {
          return this.partyUIGroup.onActorSummonAny();
        }
      } else {
        return this._updatePartyUI = function() {}; // * EMPTY
      }
    } catch (error) {
      e = error;
      return AA.warning('_createPartyUI', e);
    }
  };
  _._updatePartyUI = function() {
    return this.partyUIGroup.update();
  };
  _._terminatePartyUI = function() {
    var ref;
    return (ref = this.partyUIGroup) != null ? ref.terminate() : void 0;
  };
  // * Дополнительное обновление, когда уже всё прогрузилось
  _._onEndCreate = function() {
    setTimeout((() => {
      var e;
      try {
        this.refresh();
        return this._uiCreated = true;
      } catch (error) {
        e = error;
        return AA.warning('AA Spriteset UI End Create Thread', e);
      }
    }), 100);
  };
  _.commonBehCircle = function() {
    var ref;
    if ((this.partyUIGroup != null) && ((ref = this.partyUIGroup) != null ? ref.isCircleExists() : void 0)) {
      if ($gameParty.selectedAllyByPlayer() != null) {
        return this.partyUIGroup.circle;
      }
    }
    return this.summonUnitCircle();
  };
  _.summonUnitCircle = function() {
    if (this._sumCircle == null) {
      if ($gamePlayer.getSummonUnit() != null) {
        this._createSummonCircle();
      }
    }
    return this._sumCircle;
  };
  _.allyBehCircle = function() {
    var ref;
    return (ref = this.partyUIGroup) != null ? ref.circle : void 0;
  };
  _.redrawVisualOnPartyFaces = function() {
    var ref;
    return (ref = this.partyUIGroup) != null ? ref.redrawVisualEq() : void 0;
  };
})();

// ■ END Spriteset_InterfaceABS.coffee
//---------------------------------------------------------------------------
//@[ALIAS]
//ALIAS__initABS = _.initABS
//_.initABS = ->
//#@_spritesetAA = new SpritesetAA()
//#@addChild @_spritesetAA
//ALIAS__initABS.call(@)

//@[ALIAS]
//ALIAS__update = _.update
// * Старый спрайтсет не обновляет свой Sprite, так что вручную
//_.update = ->
//    ALIAS__update.call(@)
//    @_spritesetAA.update() if @_isABS

//@[ALIAS]
//ALIAS__terminate = _.terminate
//_.terminate = ->
//    ALIAS__terminate.call(@)
//    @_spritesetAA.terminate()

//$[OVER]
//_.showTarget = (target) -> @_spritesetAA.showTargetUI target

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_ExtraUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___initEU, ALIAS__isMouseInInventory, ALIAS__terminate, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_ExtraUI.prototype;
  //@[ALIAS]
  ALIAS___initEU = _._initEU;
  _._initEU = function() {
    ALIAS___initEU.call(this);
    this._skillsSprite = new AA.LIBS.Sprite_MapSkillsMain();
    this.skills = new AA.LIBS.MapSkillController(this._skillsSprite, this);
    this.addChild(this._skillsSprite);
  };
  //@[ALIAS]
  ALIAS__isMouseInInventory = _.isMouseInInventory;
  _.isMouseInInventory = function() {
    var r;
    r = ALIAS__isMouseInInventory.call(this);
    if (r === true) {
      return true;
    } else {
      if (this.isSkillWindowIsOpen()) {
        return this._skillsSprite.isMouseIn();
      }
    }
    return false;
  };
  _.openSkillWindow = function() {
    this.skills.open();
    return this.openSkillCategory($gameTemp._lastSkillsCategory);
  };
  _.closeSkillWindow = function() {
    return this.skills.close();
  };
  _.isSkillWindowIsOpen = function() {
    return this.skills.isInventoryActive();
  };
  _.openSkillCategory = function(catId) {
    if (this.skills.isSomeItemFocused()) {
      return;
    }
    if (catId == null) {
      catId = 0;
    }
    $gameTemp._lastSkillsCategory = catId;
    //"SHOW SKILL CAT".p(catId)
    return this.skills.loadItemsInCategory(catId);
  };
  _.refreshSkillWindow = function() {
    var e;
    try {
      if (this.isSkillWindowIsOpen()) {
        return this.skills.loadItemsInCategory($gameTemp._lastSkillsCategory);
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _.showPrevSkillWPage = function() {
    if (!this.isSkillWindowIsOpen()) {
      return;
    }
    return this.skills.showPrevPage();
  };
  _.showNextSkillWPage = function() {
    if (!this.isSkillWindowIsOpen()) {
      return;
    }
    return this.skills.showNextPage();
  };
  _.clickSkillWItem = function(index) {
    if (!this.isSkillWindowIsOpen()) {
      return;
    }
    return this.skills.clickAt(index);
  };
  _.clickSkillWActor = function(index) {
    var actor;
    if (!this.isSkillWindowIsOpen()) {
      return;
    }
    actor = AA.UI.partyGroup()[index];
    if (actor != null) {
      this.skills.setActiveActor(actor);
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    return this.skills.update();
  };
  
  //@[ALIAS]
  ALIAS__terminate = _.terminate;
  _.terminate = function() {
    var ref;
    ALIAS__terminate.call(this);
    return (ref = this.skills) != null ? ref.terminate() : void 0;
  };
})();

// ■ END Spriteset_ExtraUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_ExtraUI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___initEU, ALIAS__refreshInventory, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_ExtraUI.prototype;
  //@[ALIAS]
  ALIAS___initEU = _._initEU;
  _._initEU = function() {
    ALIAS___initEU.call(this);
    if (!AA.Parameters.isMapStatusWindow()) {
      return;
    }
    return this.fWindow = new AA.LIBS.StatesActorWindow(this);
  };
  _.openStatusWindow = function() {
    if (this.fWindow == null) {
      return;
    }
    this._refreshStatusThread = new KDCore.TimedUpdate(30, this.refreshStatusWindow.bind(this));
    this.fWindow.refreshAllInfo();
    return this.fWindow.open();
  };
  _.closeStatusWindow = function() {
    var ref;
    if ((ref = this.fWindow) != null) {
      ref.close();
    }
    return this._refreshStatusThread = null;
  };
  _.isStatusWindowIsOpen = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.isOpen() : void 0;
  };
  _.nextStatusWindowActor = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.nextActor() : void 0;
  };
  _.prevStatusWindowActor = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.prevActor() : void 0;
  };
  _.showStatusActorEquipCategory = function(index) {
    var ref;
    return (ref = this.fWindow) != null ? ref.setEquipInvCategory(index) : void 0;
  };
  _.onStatusInvCellClick = function(index) {
    var ref;
    return (ref = this.fWindow) != null ? ref.equipsInvCellClicked(index) : void 0;
  };
  _.refreshStatusWindow = function() {
    var e;
    if (this.fWindow == null) {
      return;
    }
    try {
      if (this.isStatusWindowIsOpen()) {
        return this.fWindow.refreshAllInfo();
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  _.statusWindowInvShowPrevPage = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.showPrevPage() : void 0;
  };
  _.statusWindowInvShowNextPage = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.showNextPage() : void 0;
  };
  _.onStatusInvOptimize = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.optimizeEquipments() : void 0;
  };
  _.onStatusInvClear = function() {
    var ref;
    return (ref = this.fWindow) != null ? ref.clearEquipments() : void 0;
  };
  //@[ALIAS]
  ALIAS__refreshInventory = _.refreshInventory;
  _.refreshInventory = function() {
    ALIAS__refreshInventory.call(this);
    return this.refreshStatusWindow();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    var ref;
    ALIAS__update.call(this);
    return (ref = this._refreshStatusThread) != null ? ref.update() : void 0;
  };
})();

// ■ END Spriteset_ExtraUI.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SummonAIBot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_SummonAiBot.prototype;
  //?NEW
  _.slowUpdate = function() {
    var e;
    try {
      if (!AlphaABS.isABS()) {
        return;
      }
      if (!this.inActive()) {
        return;
      }
      return this.checkCollisionWithPlayer();
    } catch (error) {
      e = error;
      return AA.warning('Summon Unit Slow Update', e);
    }
  };
  _.refreshGlobal = function() {
    Game_AIBot.prototype.refreshGlobal.call(this);
    return this._createSlowUpdateThreadForUnit();
  };
  //?NEW
  _._createSlowUpdateThreadForUnit = function() {
    if (this._slowUpdateThreadU != null) {
      AA.clearInterval(this._slowUpdateThreadU);
    }
    return this._slowUpdateThreadU = AA.setInterval(this.slowUpdate.bind(this), 500);
  };
  _.returnSlow = function() {
    if (!this.isMoving()) {
      this.moveTypeTowardPlayer();
    }
    if (this.getHomePosition() == null) {
      return this.onReturnEnd();
    }
  };
  _.getHomePosition = function() {
    if (!this.isNearThePlayerX2()) {
      return $gamePlayer.toPoint();
    } else {
      return null;
    }
  };
  _.isNearThePlayerX2 = function() {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom($gamePlayer.x));
      sy = Math.abs(this.deltaYFrom($gamePlayer.y));
      return (sx + sy) < 3 && (sx + sy) > 1;
    } catch (error) {
      return false;
    }
  };
  _.isNearThePointX = function(point) {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      if (this.inBattle()) {
        return (sx + sy) < 1;
      } else {
        return (sx + sy) < 2;
      }
    } catch (error) {
      return false;
    }
  };
  _._onBattleStart = function() {
    Game_AIBot.prototype._onBattleStart.call(this);
    this.checkCollisionWithPlayer();
    return this.setThrough(false);
  };
  _.checkCollisionWithPlayer = function() {
    if (!this.isMoving()) {
      if (this.isNearThePlayerX()) {
        this.moveFromPoint($gamePlayer);
      }
    }
    return this.checkCollisionWith(this.target());
  };
  _.checkCollisionWith = function(other) {
    var me, pl;
    if (other == null) {
      return;
    }
    me = this.toPoint();
    pl = other.toPoint();
    if (me.x === pl.x && me.y === pl.y) {
      if (!this.isMoving()) {
        return this.moveFromPoint(other);
      }
    }
  };
  _._onBattleEnd = function() {
    return Game_AIBot.prototype._onBattleEnd.call(this);
  };
  //@setThrough true

  //?NEW
  _.changeBehMode = function(mode) {
    // * 0 - Обычный режим (атака всех врагов в области видимости)
    // * 1 - Атака только цели игрока (кого он атакует)
    // * 2 - Атака только тех, кто атакует игрока
    this._bahMode = mode;
    this._stateMachine.refreshBehMode();
    AA.BattleUI.setSummonBehMode(mode);
    this._resetTarget();
    return this.changeStateToFree();
  };
  _.isCanLooting = function() {
    return this.behaviorModel().canLooting > 0;
  };
  _.isCanSupport = function() {
    var b;
    b = this.behaviorModel();
    return b.supportSkillId > 0 && this._supportAction !== null;
  };
  _._makeActions = function() {
    if (this._inSupportPhase === true) {
      return this._makeSupportAction();
    } else {
      return Game_AIBot.prototype._makeActions.call(this);
    }
  };
  _._makeSupportAction = function() {
    var absSkill, actions, canUse;
    //"MAKE HEAL ACTIONS".p()
    if (this.isCasting()) {
      return;
    }
    this.battler()._makeActionsForSupport(this._supportAction);
    actions = this.battler()._actions;
    if (actions.length > 0 && this._isNeedUseSupportOnPlayer()) {
      //"HEAL ACTION CAN BE USED!".p()
      absSkill = this.battler().skillABS_byAction(actions[0]);
      if (absSkill != null) {
        if (absSkill.skill().scope === 7) { // * 1 Ally
          // * Тут логика как в _makeTargets
          canUse = this._checkAndPrepareAbsSkillForTarget(absSkill);
          if (canUse === true) {
            this._setForceAction(actions.first()); // * Выходим из функции
            return;
          }
        } else {
          LOGW.p('Pet try use support skill with wrong scope! ' + absSkill.skill().name);
        }
      }
    }
    // * Переходим в свободный режим
    return this._cancelSupportPhase();
  };
  _._cancelSupportPhase = function() {
    //"CANCEL SUPPORT PHASE".p()
    this.battler()._isSupportFlag = false;
    this._inSupportPhase = false;
    this._stateMachine.switchActionStateToWait();
    return this.changeStateToFree();
  };
  _._isNeedUseSupportOnPlayer = function() {
    if (this._supportAction == null) {
      return false;
    }
    return this._isActionMeetsCondsOnAnother(this._supportAction, $gamePlayer);
  };
  _._getSupportAction = function() {
    return this.battler()._getActionBySkillId(this.behaviorModel().supportSkillId);
  };
  _._isActionMeetsCondsOnAnother = function(action, another) {
    return this.battler()._meetsConditionForAnother(action, another.battler());
  };
  _._isCanUseSupportNow = function() {
    if (this._supportAction == null) {
      return false;
    }
    return this.battler().canUse($dataSkills[this._supportAction.skillId]);
  };
  _._loadSupportAction = function() {
    this._supportAction = this._getSupportAction();
    return this.battler()._supportAction = this._supportAction;
  };
  _._performAction = function() {
    Game_AIBot.prototype._performAction.call(this);
    if (this._inSupportPhase === true) {
      return this._cancelSupportPhase();
    }
  };
  _.activateSupportPhase = function() {
    this.battler()._isSupportFlag = true;
    this._inSupportPhase = true;
    return this.changeStateToBattle($gamePlayer);
  };
  _.inSupportPhase = function() {
    return this._inSupportPhase === true;
  };
  _._returnToHome = function() {
    Game_AIBot.prototype._returnToHome.call(this);
    return AA.BattleUI.setSummonMoveMode(0);
  };
  _._updateABS = function() {
    Game_AIBot.prototype._updateABS.call(this);
    if (!this.inActive()) {
      if (this.__deadPetTimer == null) {
        this.__deadPetTimer = 0;
      }
      this.__deadPetTimer += 1;
      if (this.__deadPetTimer >= 180) {
        $gamePlayer.deleteSummonUnit();
        return this.__deadPetTimer = 0;
      }
    }
  };
  //$[OVER]
  // * Summon имеет свой алгоритм поддержки
  _.isAnyNeedToBeSupported = function() {
    return false;
  };
  //$[OVER]
  _.start = function() {};
})();

// ■ END Game_SummonAIBot.coffee
//---------------------------------------------------------------------------
// * NOTHING

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addNewState, ALIAS__eraseState, ALIAS__gainHpBarrier, ALIAS__initMembers, ALIAS__setupBarrier, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    return this.setupBarrier(0, 0);
  };
  //@[ALIAS]
  ALIAS__addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    //TODO: А что если на NON-ABS карте добавлю состояние?
    // * Нельзя больше одного состояния с барьером
    if (this.isHaveAbBarrier()) {
      this._aaFindAndEraseBarrierState();
    }
    this._aaCheckBarrierState(stateId);
    return ALIAS__addNewState.call(this, stateId);
  };
  _._aaFindAndEraseBarrierState = function() {
    var i, len, ref, s;
    ref = this._states;
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      this._aaEraseBarrierState(s);
    }
  };
  _._aaCheckBarrierState = function(stateId) {
    var bElem, bHp, e, state;
    state = $dataStates[stateId];
    //"CHECK BARRIER STATE".pe()
    bElem = 0;
    bHp = 100;
    try {
      if (state.meta.barrierElemId != null) {
        bElem = Number(state.meta.barrierElemId);
      }
      if (state.meta.barrierHp != null) {
        bHp = Number(state.meta.barrierHp);
      }
    } catch (error) {
      e = error;
      AA.warning(e);
      bElem = 0;
    }
    if (bElem > 0) {
      return this.setupBarrier(bElem, bHp);
    }
  };
  //@[ALIAS]
  ALIAS__eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    if (this.isHaveAbBarrier()) {
      this._aaEraseBarrierState(stateId);
    }
    return ALIAS__eraseState.call(this, stateId);
  };
  _._aaEraseBarrierState = function(stateId) {
    var e, state;
    if (!(stateId > 0)) {
      return;
    }
    try {
      state = $dataStates[stateId];
      if (state.meta.barrierElemId != null) {
        //"ERASED BARRIER STATE".pe()
        this.setupBarrier(0, 100);
        this._states.delete(stateId);
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  //@[ALIAS]
  ALIAS__gainHpBarrier = _.gainHpBarrier;
  _.gainHpBarrier = function(value) {
    ALIAS__gainHpBarrier.call(this, value);
    if (this._absParams.barrierHp <= 0) {
      this._aaFindAndEraseBarrierState();
    }
  };
  //@[ALIAS]
  ALIAS__setupBarrier = _.setupBarrier;
  _.setupBarrier = function(id, hp) {
    ALIAS__setupBarrier.call(this, id, hp);
    if (AA.isABS()) {
      AA.UI.refreshPlayerABGauge();
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
(function() {
  var ActorStatusWindowEquipInvController;
  // * Сильно упрощённая версия
  ActorStatusWindowEquipInvController = class ActorStatusWindowEquipInvController extends AA.LIBS.MapInvController {
    constructor(invSprite) {
      super(invSprite, null);
      this.goldRefreshThread = null;
      this._invStatusActor = $gameParty.leader();
      this.MAX = 20;
      this.open();
    }

    _config() {}

    open() {
      if (this.isInventoryActive()) {
        return;
      }
      this.content = this.invSprite._content;
      this.invSprite.visible = true;
    }

    close() {
      $gameTemp._aaStatusWindowEquipInvActor = null;
    }

    setStatusWindowActor(_invStatusActor) {
      this._invStatusActor = _invStatusActor;
      this.layer = AA.UI.eUI;
      return $gameTemp._aaStatusWindowEquipInvActor = this._invStatusActor;
    }

    _onGoldTick() {}

    _updateInvDrag() {}

    _onAction(cell) {
      return this._onActionItem(cell);
    }

    _onActionItem(cell) {
      if (!cell.isEnabled()) {
        return;
      }
      return this._onActionOnEquipItem(cell);
    }

    equipInventoryItem(cell) {
      return this._equipInventoryItemOnActor(this._invStatusActor, cell.item);
    }

    // * Тут это weapons
    showItems() {
      var e, equipped, equips, i, items, len;
      if (this._invStatusActor == null) {
        return;
      }
      items = $gameParty.weapons().filter(function(w) {
        return $gameTemp._aaStatusWindowEquipInvActor.canEquip(w);
      });
      equips = this._invStatusActor.equips();
      equipped = [];
      for (i = 0, len = equips.length; i < len; i++) {
        e = equips[i];
        if ((e != null) && DataManager.isWeapon(e)) {
          equipped.push(e);
        }
      }
      this._loadedItems = equipped.concat(items);
      this._setPages();
      this._showItemsGroup(0);
    }

    // * Тут это броня
    showWeapons() {
      var e, equipped, equips, i, items, len;
      if (this._invStatusActor == null) {
        return;
      }
      items = $gameParty.armors().filter(function(w) {
        return $gameTemp._aaStatusWindowEquipInvActor.canEquip(w);
      });
      equips = this._invStatusActor.equips();
      equipped = [];
      for (i = 0, len = equips.length; i < len; i++) {
        e = equips[i];
        if ((e != null) && DataManager.isArmor(e)) {
          equipped.push(e);
        }
      }
      this._loadedItems = equipped.concat(items);
      this._setPages();
      this._showItemsGroup(0);
    }

    _getCategoryTitle(index) {
      switch (index) {
        case 0:
          return TextManager.weapon;
        case 1:
          return TextManager.armor;
      }
      return "";
    }

  };
  AA.register(ActorStatusWindowEquipInvController);
})();

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_MapInvCell.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.LIBS.Sprite_MapInvCell.prototype;
  _._refreshEquipmentStateForActor = function(actor) {
    var canEquip, candidates, e, equips, i, j, ref, results;
    try {
      canEquip = actor.canEquip(this.item);
      if (canEquip === true) {
        this.whoCanEquip.push(actor.actorId());
        candidates = this._getUnequipCandidtaes();
        if ((ref = candidates[this.item.id]) != null ? ref.contains(actor.actorId()) : void 0) {
          return;
        }
        equips = actor.equips();
        results = [];
        for (i in equips) {
          j = equips[i];
          if (j === this.item) {
            this._isEquipedItem = true;
            this._applyEquipmenSpecialState();
            this.whoCanUnEquip.push(actor.actorId());
            results.push(this._setCandidateForUnequip(actor.actorId()));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
  // * Имя, кто будет унЭкиперовать
  _._getSpecialStateActorName = function() {
    var actor;
    actor = this._getEquipmentActor();
    if (actor != null) {
      return actor.name();
    }
    return "";
  };
  _._setCandidateForUnequip = function(actorId) {
    var candidates;
    candidates = $gameTemp._equipmentArmrCandidates;
    if (DataManager.isWeapon(this.item)) {
      candidates = $gameTemp._equipmentWeapCandidates;
    }
    if (candidates[this.item.id] != null) {
      return candidates[this.item.id].push(actorId);
    } else {
      return candidates[this.item.id] = [actorId];
    }
  };
  _._getUnequipCandidtaes = function() {
    if (DataManager.isWeapon(this.item)) {
      return $gameTemp._equipmentWeapCandidates;
    } else {
      return $gameTemp._equipmentArmrCandidates;
    }
  };
  _._getEquipmentActor = function() {
    var actor;
    actor = $gameParty.leader();
    if (AA.UI.isPartyInventoryAllowed()) {
      actor = $gameActors.actor(this.whoCanUnEquip[0]);
    }
    return actor;
  };
  _._checkEquipmentsUsable = function() {
    var actor, index, k, len, ref, result;
    if (this._inSpecialState === true) { // * Если экиперовано, то нет смысла
      return;
    }
    this.partyUsecases = [];
    ref = AA.UI.partyGroup();
    for (index = k = 0, len = ref.length; k < len; index = ++k) {
      actor = ref[index];
      result = this.whoCanEquip.contains(actor.actorId());
      this.partyUsecases[index] = result;
    }
  };
})();

// ■ END Sprite_MapInvCell.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_AIBot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _, _SM;
  //@[DEFINES]
  _ = Game_AIBot.prototype;
  _SM = Game_SummonAiBot.prototype;
  _.isCanSupport = function() {
    return _SM.isCanSupport.call(this);
  };
  _._loadSupportAction = function() {
    return _SM._loadSupportAction.call(this);
  };
  _._getSupportAction = function() {
    return _SM._getSupportAction.call(this);
  };
  _.inSupportPhase = function() {
    return _SM.inSupportPhase.call(this);
  };
  _.isAnyNeedToBeSupported = function() {
    var c, candidates, e, goodForIt, i, len;
    this._lastSupportCandidate = null;
    if (this._supportAction == null) {
      return false;
    }
    try {
      candidates = $gameTroop.onlyHostileMembersABSInBattle();
      //console.info candidates
      goodForIt = [];
      for (i = 0, len = candidates.length; i < len; i++) {
        c = candidates[i];
        if (this._isNeedUseSupportActionOnAnother(c)) {
          goodForIt.push(c);
        }
      }
      if (goodForIt.length > 0) {
        //console.info(goodForIt)
        this._lastSupportCandidate = goodForIt.sample();
        return true;
      }
    } catch (error) {
      e = error;
      AA.warning(e);
      this._lastSupportCandidate = null;
    }
    return false;
  };
  _._isNeedUseSupportActionOnAnother = function(another) {
    if (!another.battler().isAlive()) {
      return false;
    }
    if (another === this) {
      return false;
    }
    return this.battler()._meetsConditionForAnother(this._supportAction, another.battler());
  };
  _.getCandidateForSupportSkill = function() {
    return this._lastSupportCandidate;
  };
  _.isCanUseSupportSkillNow = function() {
    var a, absSkill;
    a = _SM._isCanUseSupportNow.call(this);
    if (a === true) {
      absSkill = this.battler().skillABS_byId(this._supportAction.skillId);
      if (this._lastSupportCandidate != null) {
        return this._checkAndPrepareAbsSkillForTarget(absSkill, this._lastSupportCandidate);
      } else {
        return false;
      }
    }
    //return true
    return false;
  };
  _.activateSupportPhase = function() {
    //"SUPPPORT PHASE ACTIVATED".pe()
    this._lastTargetBeforeSupport = this.target();
    // * Или можно в свободный режим переходить
    //console.info(@_lastSupportCandidate)
    this.battler()._isSupportFlag = true;
    this._inSupportPhase = true;
    this.setTarget(this._lastSupportCandidate);
  };
  _._cancelSupportPhase = function() {
    //debugger
    //"CANCEL SUPPORT PHASE".pe()
    this.battler()._isSupportFlag = false;
    this._inSupportPhase = false;
    this._stateMachine.switchActionStateToWait();
    if ((this._lastTargetBeforeSupport != null) && this.inBattle()) {
      this.setTarget(this._lastTargetBeforeSupport);
      //"TARGET RESTORED".pe()
      this._makeBattleActions();
    } else {
      this.changeStateToFree();
    }
  };
  _._makeSupportAction = function() {
    var absSkill, actions, canUse;
    //"MAKE SUPPORT ACTIONS".p()
    if (this.isCasting()) {
      return;
    }
    this.battler()._makeActionsForSupport(this._supportAction);
    actions = this.battler()._actions;
    if (actions.length > 0 && this._isNeedUseSupportActionOnAnother(this._lastSupportCandidate)) {
      //"HEAL ACTION CAN BE USED!".p()
      absSkill = this.battler().skillABS_byAction(actions[0]);
      if (absSkill != null) {
        if (absSkill.skill().scope === 7) { // * 1 Ally
          // * Тут логика как в _makeTargets
          canUse = this._checkAndPrepareAbsSkillForTarget(absSkill);
          if (canUse === true) {
            this._setForceAction(actions.first()); // * Выходим из функции
            return;
          }
        } else {
          LOGW.p('AI try use support skill with wrong scope! ' + absSkill.skill().name);
        }
      }
    }
    // * Переходим в свободный режим
    return this._cancelSupportPhase();
  };
})();

// ■ END Game_AIBot.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.5.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.initECThread = function() {
    $gameTemp._aaAIBotsInBattleGlobalCount = 0;
    return this._aaEnemyCountThread = new AATimedUpdate(120, this._onAAEnemyCountThreadTick.bind(this));
  };
  _._onAAEnemyCountThreadTick = function() {
    $gameTemp._aaAIBotsInBattleGlobalCount = $gameTroop.onlyHostileMembersABSInBattle().length;
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


//Plugin Alpha_ABS automatic build by MVPluginBuilder 1.6.2 29.10.2021
